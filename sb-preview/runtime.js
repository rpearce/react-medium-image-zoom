var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __require = /* @__PURE__ */ ((x2) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x2, {
  get: (a2, b2) => (typeof require !== "undefined" ? require : a2)[b2]
}) : x2)(function(x2) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x2 + '" is not supported');
});
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// ../node_modules/@ngard/tiny-isequal/index.js
var require_tiny_isequal = __commonJS({
  "../node_modules/@ngard/tiny-isequal/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true }), exports.isEqual = /* @__PURE__ */ function() {
      var e2 = Object.prototype.toString, r2 = Object.getPrototypeOf, t2 = Object.getOwnPropertySymbols ? function(e3) {
        return Object.keys(e3).concat(Object.getOwnPropertySymbols(e3));
      } : Object.keys;
      return function(n2, a2) {
        return (/* @__PURE__ */ __name(function n3(a3, c2, u3) {
          var i2, s3, l2, o2 = e2.call(a3), f4 = e2.call(c2);
          if (a3 === c2) return true;
          if (null == a3 || null == c2) return false;
          if (u3.indexOf(a3) > -1 && u3.indexOf(c2) > -1) return true;
          if (u3.push(a3, c2), o2 != f4) return false;
          if (i2 = t2(a3), s3 = t2(c2), i2.length != s3.length || i2.some(function(e3) {
            return !n3(a3[e3], c2[e3], u3);
          })) return false;
          switch (o2.slice(8, -1)) {
            case "Symbol":
              return a3.valueOf() == c2.valueOf();
            case "Date":
            case "Number":
              return +a3 == +c2 || +a3 != +a3 && +c2 != +c2;
            case "RegExp":
            case "Function":
            case "String":
            case "Boolean":
              return "" + a3 == "" + c2;
            case "Set":
            case "Map":
              i2 = a3.entries(), s3 = c2.entries();
              do {
                if (!n3((l2 = i2.next()).value, s3.next().value, u3)) return false;
              } while (!l2.done);
              return true;
            case "ArrayBuffer":
              a3 = new Uint8Array(a3), c2 = new Uint8Array(c2);
            case "DataView":
              a3 = new Uint8Array(a3.buffer), c2 = new Uint8Array(c2.buffer);
            case "Float32Array":
            case "Float64Array":
            case "Int8Array":
            case "Int16Array":
            case "Int32Array":
            case "Uint8Array":
            case "Uint16Array":
            case "Uint32Array":
            case "Uint8ClampedArray":
            case "Arguments":
            case "Array":
              if (a3.length != c2.length) return false;
              for (l2 = 0; l2 < a3.length; l2++) if ((l2 in a3 || l2 in c2) && (l2 in a3 != l2 in c2 || !n3(a3[l2], c2[l2], u3))) return false;
              return true;
            case "Object":
              return n3(r2(a3), r2(c2), u3);
            default:
              return false;
          }
        }, "n"))(n2, a2, []);
      };
    }();
  }
});

// ../node_modules/min-indent/index.js
var require_min_indent = __commonJS({
  "../node_modules/min-indent/index.js"(exports, module2) {
    "use strict";
    module2.exports = (string) => {
      const match = string.match(/^[ \t]*(?=\S)/gm);
      if (!match) {
        return 0;
      }
      return match.reduce((r2, a2) => Math.min(r2, a2.length), Infinity);
    };
  }
});

// ../node_modules/strip-indent/index.js
var require_strip_indent = __commonJS({
  "../node_modules/strip-indent/index.js"(exports, module2) {
    "use strict";
    var minIndent = require_min_indent();
    module2.exports = (string) => {
      const indent2 = minIndent(string);
      if (indent2 === 0) {
        return string;
      }
      const regex = new RegExp(`^[ \\t]{${indent2}}`, "gm");
      return string.replace(regex, "");
    };
  }
});

// ../node_modules/indent-string/index.js
var require_indent_string = __commonJS({
  "../node_modules/indent-string/index.js"(exports, module2) {
    "use strict";
    module2.exports = (string, count2 = 1, options) => {
      options = {
        indent: " ",
        includeEmptyLines: false,
        ...options
      };
      if (typeof string !== "string") {
        throw new TypeError(
          `Expected \`input\` to be a \`string\`, got \`${typeof string}\``
        );
      }
      if (typeof count2 !== "number") {
        throw new TypeError(
          `Expected \`count\` to be a \`number\`, got \`${typeof count2}\``
        );
      }
      if (typeof options.indent !== "string") {
        throw new TypeError(
          `Expected \`options.indent\` to be a \`string\`, got \`${typeof options.indent}\``
        );
      }
      if (count2 === 0) {
        return string;
      }
      const regex = options.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
      return string.replace(regex, options.indent.repeat(count2));
    };
  }
});

// ../node_modules/redent/index.js
var require_redent = __commonJS({
  "../node_modules/redent/index.js"(exports, module2) {
    "use strict";
    var stripIndent = require_strip_indent();
    var indentString = require_indent_string();
    module2.exports = (string, count2 = 0, options) => indentString(stripIndent(string), count2, options);
  }
});

// ../node_modules/aria-query/lib/util/iteratorProxy.js
var require_iteratorProxy = __commonJS({
  "../node_modules/aria-query/lib/util/iteratorProxy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    function iteratorProxy() {
      var values = this;
      var index2 = 0;
      var iter = {
        "@@iterator": /* @__PURE__ */ __name(function iterator() {
          return iter;
        }, "iterator"),
        next: /* @__PURE__ */ __name(function next() {
          if (index2 < values.length) {
            var value = values[index2];
            index2 = index2 + 1;
            return {
              done: false,
              value
            };
          } else {
            return {
              done: true
            };
          }
        }, "next")
      };
      return iter;
    }
    __name(iteratorProxy, "iteratorProxy");
    var _default = exports.default = iteratorProxy;
  }
});

// ../node_modules/aria-query/lib/util/iterationDecorator.js
var require_iterationDecorator = __commonJS({
  "../node_modules/aria-query/lib/util/iterationDecorator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = iterationDecorator;
    var _iteratorProxy = _interopRequireDefault(require_iteratorProxy());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    function _typeof5(o2) {
      "@babel/helpers - typeof";
      return _typeof5 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
        return typeof o3;
      } : function(o3) {
        return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
      }, _typeof5(o2);
    }
    __name(_typeof5, "_typeof");
    function iterationDecorator(collection, entries) {
      if (typeof Symbol === "function" && _typeof5(Symbol.iterator) === "symbol") {
        Object.defineProperty(collection, Symbol.iterator, {
          value: _iteratorProxy.default.bind(entries)
        });
      }
      return collection;
    }
    __name(iterationDecorator, "iterationDecorator");
  }
});

// ../node_modules/aria-query/lib/ariaPropsMap.js
var require_ariaPropsMap = __commonJS({
  "../node_modules/aria-query/lib/ariaPropsMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    function _slicedToArray(r2, e2) {
      return _arrayWithHoles(r2) || _iterableToArrayLimit(r2, e2) || _unsupportedIterableToArray(r2, e2) || _nonIterableRest();
    }
    __name(_slicedToArray, "_slicedToArray");
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    __name(_nonIterableRest, "_nonIterableRest");
    function _unsupportedIterableToArray(r2, a2) {
      if (r2) {
        if ("string" == typeof r2) return _arrayLikeToArray(r2, a2);
        var t2 = {}.toString.call(r2).slice(8, -1);
        return "Object" === t2 && r2.constructor && (t2 = r2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray(r2, a2) : void 0;
      }
    }
    __name(_unsupportedIterableToArray, "_unsupportedIterableToArray");
    function _arrayLikeToArray(r2, a2) {
      (null == a2 || a2 > r2.length) && (a2 = r2.length);
      for (var e2 = 0, n2 = Array(a2); e2 < a2; e2++) n2[e2] = r2[e2];
      return n2;
    }
    __name(_arrayLikeToArray, "_arrayLikeToArray");
    function _iterableToArrayLimit(r2, l2) {
      var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
      if (null != t2) {
        var e2, n2, i2, u3, a2 = [], f4 = true, o2 = false;
        try {
          if (i2 = (t2 = t2.call(r2)).next, 0 === l2) {
            if (Object(t2) !== t2) return;
            f4 = false;
          } else for (; !(f4 = (e2 = i2.call(t2)).done) && (a2.push(e2.value), a2.length !== l2); f4 = true) ;
        } catch (r3) {
          o2 = true, n2 = r3;
        } finally {
          try {
            if (!f4 && null != t2.return && (u3 = t2.return(), Object(u3) !== u3)) return;
          } finally {
            if (o2) throw n2;
          }
        }
        return a2;
      }
    }
    __name(_iterableToArrayLimit, "_iterableToArrayLimit");
    function _arrayWithHoles(r2) {
      if (Array.isArray(r2)) return r2;
    }
    __name(_arrayWithHoles, "_arrayWithHoles");
    var properties = [["aria-activedescendant", {
      "type": "id"
    }], ["aria-atomic", {
      "type": "boolean"
    }], ["aria-autocomplete", {
      "type": "token",
      "values": ["inline", "list", "both", "none"]
    }], ["aria-braillelabel", {
      "type": "string"
    }], ["aria-brailleroledescription", {
      "type": "string"
    }], ["aria-busy", {
      "type": "boolean"
    }], ["aria-checked", {
      "type": "tristate"
    }], ["aria-colcount", {
      type: "integer"
    }], ["aria-colindex", {
      type: "integer"
    }], ["aria-colspan", {
      type: "integer"
    }], ["aria-controls", {
      "type": "idlist"
    }], ["aria-current", {
      type: "token",
      values: ["page", "step", "location", "date", "time", true, false]
    }], ["aria-describedby", {
      "type": "idlist"
    }], ["aria-description", {
      "type": "string"
    }], ["aria-details", {
      "type": "id"
    }], ["aria-disabled", {
      "type": "boolean"
    }], ["aria-dropeffect", {
      "type": "tokenlist",
      "values": ["copy", "execute", "link", "move", "none", "popup"]
    }], ["aria-errormessage", {
      "type": "id"
    }], ["aria-expanded", {
      "type": "boolean",
      "allowundefined": true
    }], ["aria-flowto", {
      "type": "idlist"
    }], ["aria-grabbed", {
      "type": "boolean",
      "allowundefined": true
    }], ["aria-haspopup", {
      "type": "token",
      "values": [false, true, "menu", "listbox", "tree", "grid", "dialog"]
    }], ["aria-hidden", {
      "type": "boolean",
      "allowundefined": true
    }], ["aria-invalid", {
      "type": "token",
      "values": ["grammar", false, "spelling", true]
    }], ["aria-keyshortcuts", {
      type: "string"
    }], ["aria-label", {
      "type": "string"
    }], ["aria-labelledby", {
      "type": "idlist"
    }], ["aria-level", {
      "type": "integer"
    }], ["aria-live", {
      "type": "token",
      "values": ["assertive", "off", "polite"]
    }], ["aria-modal", {
      type: "boolean"
    }], ["aria-multiline", {
      "type": "boolean"
    }], ["aria-multiselectable", {
      "type": "boolean"
    }], ["aria-orientation", {
      "type": "token",
      "values": ["vertical", "undefined", "horizontal"]
    }], ["aria-owns", {
      "type": "idlist"
    }], ["aria-placeholder", {
      type: "string"
    }], ["aria-posinset", {
      "type": "integer"
    }], ["aria-pressed", {
      "type": "tristate"
    }], ["aria-readonly", {
      "type": "boolean"
    }], ["aria-relevant", {
      "type": "tokenlist",
      "values": ["additions", "all", "removals", "text"]
    }], ["aria-required", {
      "type": "boolean"
    }], ["aria-roledescription", {
      type: "string"
    }], ["aria-rowcount", {
      type: "integer"
    }], ["aria-rowindex", {
      type: "integer"
    }], ["aria-rowspan", {
      type: "integer"
    }], ["aria-selected", {
      "type": "boolean",
      "allowundefined": true
    }], ["aria-setsize", {
      "type": "integer"
    }], ["aria-sort", {
      "type": "token",
      "values": ["ascending", "descending", "none", "other"]
    }], ["aria-valuemax", {
      "type": "number"
    }], ["aria-valuemin", {
      "type": "number"
    }], ["aria-valuenow", {
      "type": "number"
    }], ["aria-valuetext", {
      "type": "string"
    }]];
    var ariaPropsMap = {
      entries: /* @__PURE__ */ __name(function entries() {
        return properties;
      }, "entries"),
      forEach: /* @__PURE__ */ __name(function forEach(fn3) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        for (var _i = 0, _properties = properties; _i < _properties.length; _i++) {
          var _properties$_i = _slicedToArray(_properties[_i], 2), key = _properties$_i[0], values = _properties$_i[1];
          fn3.call(thisArg, values, key, properties);
        }
      }, "forEach"),
      get: /* @__PURE__ */ __name(function get3(key) {
        var item = properties.filter(function(tuple) {
          return tuple[0] === key ? true : false;
        })[0];
        return item && item[1];
      }, "get"),
      has: /* @__PURE__ */ __name(function has(key) {
        return !!ariaPropsMap.get(key);
      }, "has"),
      keys: /* @__PURE__ */ __name(function keys2() {
        return properties.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key = _ref2[0];
          return key;
        });
      }, "keys"),
      values: /* @__PURE__ */ __name(function values() {
        return properties.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }, "values")
    };
    var _default = exports.default = (0, _iterationDecorator.default)(ariaPropsMap, ariaPropsMap.entries());
  }
});

// ../node_modules/aria-query/lib/domMap.js
var require_domMap = __commonJS({
  "../node_modules/aria-query/lib/domMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    function _slicedToArray(r2, e2) {
      return _arrayWithHoles(r2) || _iterableToArrayLimit(r2, e2) || _unsupportedIterableToArray(r2, e2) || _nonIterableRest();
    }
    __name(_slicedToArray, "_slicedToArray");
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    __name(_nonIterableRest, "_nonIterableRest");
    function _unsupportedIterableToArray(r2, a2) {
      if (r2) {
        if ("string" == typeof r2) return _arrayLikeToArray(r2, a2);
        var t2 = {}.toString.call(r2).slice(8, -1);
        return "Object" === t2 && r2.constructor && (t2 = r2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray(r2, a2) : void 0;
      }
    }
    __name(_unsupportedIterableToArray, "_unsupportedIterableToArray");
    function _arrayLikeToArray(r2, a2) {
      (null == a2 || a2 > r2.length) && (a2 = r2.length);
      for (var e2 = 0, n2 = Array(a2); e2 < a2; e2++) n2[e2] = r2[e2];
      return n2;
    }
    __name(_arrayLikeToArray, "_arrayLikeToArray");
    function _iterableToArrayLimit(r2, l2) {
      var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
      if (null != t2) {
        var e2, n2, i2, u3, a2 = [], f4 = true, o2 = false;
        try {
          if (i2 = (t2 = t2.call(r2)).next, 0 === l2) {
            if (Object(t2) !== t2) return;
            f4 = false;
          } else for (; !(f4 = (e2 = i2.call(t2)).done) && (a2.push(e2.value), a2.length !== l2); f4 = true) ;
        } catch (r3) {
          o2 = true, n2 = r3;
        } finally {
          try {
            if (!f4 && null != t2.return && (u3 = t2.return(), Object(u3) !== u3)) return;
          } finally {
            if (o2) throw n2;
          }
        }
        return a2;
      }
    }
    __name(_iterableToArrayLimit, "_iterableToArrayLimit");
    function _arrayWithHoles(r2) {
      if (Array.isArray(r2)) return r2;
    }
    __name(_arrayWithHoles, "_arrayWithHoles");
    var dom = [["a", {
      reserved: false
    }], ["abbr", {
      reserved: false
    }], ["acronym", {
      reserved: false
    }], ["address", {
      reserved: false
    }], ["applet", {
      reserved: false
    }], ["area", {
      reserved: false
    }], ["article", {
      reserved: false
    }], ["aside", {
      reserved: false
    }], ["audio", {
      reserved: false
    }], ["b", {
      reserved: false
    }], ["base", {
      reserved: true
    }], ["bdi", {
      reserved: false
    }], ["bdo", {
      reserved: false
    }], ["big", {
      reserved: false
    }], ["blink", {
      reserved: false
    }], ["blockquote", {
      reserved: false
    }], ["body", {
      reserved: false
    }], ["br", {
      reserved: false
    }], ["button", {
      reserved: false
    }], ["canvas", {
      reserved: false
    }], ["caption", {
      reserved: false
    }], ["center", {
      reserved: false
    }], ["cite", {
      reserved: false
    }], ["code", {
      reserved: false
    }], ["col", {
      reserved: true
    }], ["colgroup", {
      reserved: true
    }], ["content", {
      reserved: false
    }], ["data", {
      reserved: false
    }], ["datalist", {
      reserved: false
    }], ["dd", {
      reserved: false
    }], ["del", {
      reserved: false
    }], ["details", {
      reserved: false
    }], ["dfn", {
      reserved: false
    }], ["dialog", {
      reserved: false
    }], ["dir", {
      reserved: false
    }], ["div", {
      reserved: false
    }], ["dl", {
      reserved: false
    }], ["dt", {
      reserved: false
    }], ["em", {
      reserved: false
    }], ["embed", {
      reserved: false
    }], ["fieldset", {
      reserved: false
    }], ["figcaption", {
      reserved: false
    }], ["figure", {
      reserved: false
    }], ["font", {
      reserved: false
    }], ["footer", {
      reserved: false
    }], ["form", {
      reserved: false
    }], ["frame", {
      reserved: false
    }], ["frameset", {
      reserved: false
    }], ["h1", {
      reserved: false
    }], ["h2", {
      reserved: false
    }], ["h3", {
      reserved: false
    }], ["h4", {
      reserved: false
    }], ["h5", {
      reserved: false
    }], ["h6", {
      reserved: false
    }], ["head", {
      reserved: true
    }], ["header", {
      reserved: false
    }], ["hgroup", {
      reserved: false
    }], ["hr", {
      reserved: false
    }], ["html", {
      reserved: true
    }], ["i", {
      reserved: false
    }], ["iframe", {
      reserved: false
    }], ["img", {
      reserved: false
    }], ["input", {
      reserved: false
    }], ["ins", {
      reserved: false
    }], ["kbd", {
      reserved: false
    }], ["keygen", {
      reserved: false
    }], ["label", {
      reserved: false
    }], ["legend", {
      reserved: false
    }], ["li", {
      reserved: false
    }], ["link", {
      reserved: true
    }], ["main", {
      reserved: false
    }], ["map", {
      reserved: false
    }], ["mark", {
      reserved: false
    }], ["marquee", {
      reserved: false
    }], ["menu", {
      reserved: false
    }], ["menuitem", {
      reserved: false
    }], ["meta", {
      reserved: true
    }], ["meter", {
      reserved: false
    }], ["nav", {
      reserved: false
    }], ["noembed", {
      reserved: true
    }], ["noscript", {
      reserved: true
    }], ["object", {
      reserved: false
    }], ["ol", {
      reserved: false
    }], ["optgroup", {
      reserved: false
    }], ["option", {
      reserved: false
    }], ["output", {
      reserved: false
    }], ["p", {
      reserved: false
    }], ["param", {
      reserved: true
    }], ["picture", {
      reserved: true
    }], ["pre", {
      reserved: false
    }], ["progress", {
      reserved: false
    }], ["q", {
      reserved: false
    }], ["rp", {
      reserved: false
    }], ["rt", {
      reserved: false
    }], ["rtc", {
      reserved: false
    }], ["ruby", {
      reserved: false
    }], ["s", {
      reserved: false
    }], ["samp", {
      reserved: false
    }], ["script", {
      reserved: true
    }], ["section", {
      reserved: false
    }], ["select", {
      reserved: false
    }], ["small", {
      reserved: false
    }], ["source", {
      reserved: true
    }], ["spacer", {
      reserved: false
    }], ["span", {
      reserved: false
    }], ["strike", {
      reserved: false
    }], ["strong", {
      reserved: false
    }], ["style", {
      reserved: true
    }], ["sub", {
      reserved: false
    }], ["summary", {
      reserved: false
    }], ["sup", {
      reserved: false
    }], ["table", {
      reserved: false
    }], ["tbody", {
      reserved: false
    }], ["td", {
      reserved: false
    }], ["textarea", {
      reserved: false
    }], ["tfoot", {
      reserved: false
    }], ["th", {
      reserved: false
    }], ["thead", {
      reserved: false
    }], ["time", {
      reserved: false
    }], ["title", {
      reserved: true
    }], ["tr", {
      reserved: false
    }], ["track", {
      reserved: true
    }], ["tt", {
      reserved: false
    }], ["u", {
      reserved: false
    }], ["ul", {
      reserved: false
    }], ["var", {
      reserved: false
    }], ["video", {
      reserved: false
    }], ["wbr", {
      reserved: false
    }], ["xmp", {
      reserved: false
    }]];
    var domMap = {
      entries: /* @__PURE__ */ __name(function entries() {
        return dom;
      }, "entries"),
      forEach: /* @__PURE__ */ __name(function forEach(fn3) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        for (var _i = 0, _dom = dom; _i < _dom.length; _i++) {
          var _dom$_i = _slicedToArray(_dom[_i], 2), key = _dom$_i[0], values = _dom$_i[1];
          fn3.call(thisArg, values, key, dom);
        }
      }, "forEach"),
      get: /* @__PURE__ */ __name(function get3(key) {
        var item = dom.filter(function(tuple) {
          return tuple[0] === key ? true : false;
        })[0];
        return item && item[1];
      }, "get"),
      has: /* @__PURE__ */ __name(function has(key) {
        return !!domMap.get(key);
      }, "has"),
      keys: /* @__PURE__ */ __name(function keys2() {
        return dom.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key = _ref2[0];
          return key;
        });
      }, "keys"),
      values: /* @__PURE__ */ __name(function values() {
        return dom.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }, "values")
    };
    var _default = exports.default = (0, _iterationDecorator.default)(domMap, domMap.entries());
  }
});

// ../node_modules/aria-query/lib/etc/roles/abstract/commandRole.js
var require_commandRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/abstract/commandRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var commandRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget"]]
    };
    var _default = exports.default = commandRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/abstract/compositeRole.js
var require_compositeRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/abstract/compositeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var compositeRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-disabled": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget"]]
    };
    var _default = exports.default = compositeRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/abstract/inputRole.js
var require_inputRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/abstract/inputRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var inputRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null
      },
      relatedConcepts: [{
        concept: {
          name: "input"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget"]]
    };
    var _default = exports.default = inputRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/abstract/landmarkRole.js
var require_landmarkRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/abstract/landmarkRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var landmarkRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = landmarkRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/abstract/rangeRole.js
var require_rangeRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/abstract/rangeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var rangeRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-valuemax": null,
        "aria-valuemin": null,
        "aria-valuenow": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    var _default = exports.default = rangeRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/abstract/roletypeRole.js
var require_roletypeRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/abstract/roletypeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var roletypeRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [],
      prohibitedProps: [],
      props: {
        "aria-atomic": null,
        "aria-busy": null,
        "aria-controls": null,
        "aria-current": null,
        "aria-describedby": null,
        "aria-details": null,
        "aria-dropeffect": null,
        "aria-flowto": null,
        "aria-grabbed": null,
        "aria-hidden": null,
        "aria-keyshortcuts": null,
        "aria-label": null,
        "aria-labelledby": null,
        "aria-live": null,
        "aria-owns": null,
        "aria-relevant": null,
        "aria-roledescription": null
      },
      relatedConcepts: [{
        concept: {
          name: "role"
        },
        module: "XHTML"
      }, {
        concept: {
          name: "type"
        },
        module: "Dublin Core"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: []
    };
    var _default = exports.default = roletypeRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/abstract/sectionRole.js
var require_sectionRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/abstract/sectionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var sectionRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "frontmatter"
        },
        module: "DTB"
      }, {
        concept: {
          name: "level"
        },
        module: "DTB"
      }, {
        concept: {
          name: "level"
        },
        module: "SMIL"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    var _default = exports.default = sectionRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/abstract/sectionheadRole.js
var require_sectionheadRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/abstract/sectionheadRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var sectionheadRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    var _default = exports.default = sectionheadRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/abstract/selectRole.js
var require_selectRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/abstract/selectRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var selectRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-orientation": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite"], ["roletype", "structure", "section", "group"]]
    };
    var _default = exports.default = selectRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/abstract/structureRole.js
var require_structureRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/abstract/structureRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var structureRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype"]]
    };
    var _default = exports.default = structureRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/abstract/widgetRole.js
var require_widgetRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/abstract/widgetRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var widgetRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype"]]
    };
    var _default = exports.default = widgetRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/abstract/windowRole.js
var require_windowRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/abstract/windowRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var windowRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-modal": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype"]]
    };
    var _default = exports.default = windowRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/ariaAbstractRoles.js
var require_ariaAbstractRoles = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/ariaAbstractRoles.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _commandRole = _interopRequireDefault(require_commandRole());
    var _compositeRole = _interopRequireDefault(require_compositeRole());
    var _inputRole = _interopRequireDefault(require_inputRole());
    var _landmarkRole = _interopRequireDefault(require_landmarkRole());
    var _rangeRole = _interopRequireDefault(require_rangeRole());
    var _roletypeRole = _interopRequireDefault(require_roletypeRole());
    var _sectionRole = _interopRequireDefault(require_sectionRole());
    var _sectionheadRole = _interopRequireDefault(require_sectionheadRole());
    var _selectRole = _interopRequireDefault(require_selectRole());
    var _structureRole = _interopRequireDefault(require_structureRole());
    var _widgetRole = _interopRequireDefault(require_widgetRole());
    var _windowRole = _interopRequireDefault(require_windowRole());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var ariaAbstractRoles = [["command", _commandRole.default], ["composite", _compositeRole.default], ["input", _inputRole.default], ["landmark", _landmarkRole.default], ["range", _rangeRole.default], ["roletype", _roletypeRole.default], ["section", _sectionRole.default], ["sectionhead", _sectionheadRole.default], ["select", _selectRole.default], ["structure", _structureRole.default], ["widget", _widgetRole.default], ["window", _windowRole.default]];
    var _default = exports.default = ariaAbstractRoles;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/alertRole.js
var require_alertRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/alertRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var alertRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-atomic": "true",
        "aria-live": "assertive"
      },
      relatedConcepts: [{
        concept: {
          name: "alert"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = alertRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/alertdialogRole.js
var require_alertdialogRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/alertdialogRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var alertdialogRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "alert"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "alert"], ["roletype", "window", "dialog"]]
    };
    var _default = exports.default = alertdialogRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/applicationRole.js
var require_applicationRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/applicationRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var applicationRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "Device Independence Delivery Unit"
        }
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    var _default = exports.default = applicationRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/articleRole.js
var require_articleRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/articleRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var articleRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-posinset": null,
        "aria-setsize": null
      },
      relatedConcepts: [{
        concept: {
          name: "article"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "document"]]
    };
    var _default = exports.default = articleRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/bannerRole.js
var require_bannerRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/bannerRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var bannerRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          constraints: ["scoped to the body element"],
          name: "header"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = bannerRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/blockquoteRole.js
var require_blockquoteRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/blockquoteRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var blockquoteRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "blockquote"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = blockquoteRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/buttonRole.js
var require_buttonRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/buttonRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var buttonRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-pressed": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "type",
            value: "button"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "type",
            value: "image"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "type",
            value: "reset"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "type",
            value: "submit"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          name: "button"
        },
        module: "HTML"
      }, {
        concept: {
          name: "trigger"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command"]]
    };
    var _default = exports.default = buttonRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/captionRole.js
var require_captionRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/captionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var captionRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "caption"
        },
        module: "HTML"
      }],
      requireContextRole: ["figure", "grid", "table"],
      requiredContextRole: ["figure", "grid", "table"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = captionRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/cellRole.js
var require_cellRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/cellRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var cellRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-colindex": null,
        "aria-colspan": null,
        "aria-rowindex": null,
        "aria-rowspan": null
      },
      relatedConcepts: [{
        concept: {
          constraints: ["ancestor table element has table role"],
          name: "td"
        },
        module: "HTML"
      }],
      requireContextRole: ["row"],
      requiredContextRole: ["row"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = cellRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/checkboxRole.js
var require_checkboxRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/checkboxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var checkboxRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-checked": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "type",
            value: "checkbox"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          name: "option"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [["roletype", "widget", "input"]]
    };
    var _default = exports.default = checkboxRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/codeRole.js
var require_codeRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/codeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var codeRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "code"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = codeRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/columnheaderRole.js
var require_columnheaderRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/columnheaderRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var columnheaderRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-sort": null
      },
      relatedConcepts: [{
        concept: {
          name: "th"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "scope",
            value: "col"
          }],
          name: "th"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "scope",
            value: "colgroup"
          }],
          name: "th"
        },
        module: "HTML"
      }],
      requireContextRole: ["row"],
      requiredContextRole: ["row"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "cell"], ["roletype", "structure", "section", "cell", "gridcell"], ["roletype", "widget", "gridcell"], ["roletype", "structure", "sectionhead"]]
    };
    var _default = exports.default = columnheaderRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/comboboxRole.js
var require_comboboxRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/comboboxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var comboboxRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-autocomplete": null,
        "aria-errormessage": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null,
        "aria-expanded": "false",
        "aria-haspopup": "listbox"
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "email"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "search"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "tel"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "text"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "url"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "url"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "multiple"
          }, {
            constraints: ["undefined"],
            name: "size"
          }],
          constraints: ["the multiple attribute is not set and the size attribute does not have a value greater than 1"],
          name: "select"
        },
        module: "HTML"
      }, {
        concept: {
          name: "select"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-controls": null,
        "aria-expanded": "false"
      },
      superClass: [["roletype", "widget", "input"]]
    };
    var _default = exports.default = comboboxRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/complementaryRole.js
var require_complementaryRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/complementaryRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var complementaryRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          constraints: ["scoped to the body element", "scoped to the main element"],
          name: "aside"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-label"
          }],
          constraints: ["scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
          name: "aside"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-labelledby"
          }],
          constraints: ["scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
          name: "aside"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = complementaryRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/contentinfoRole.js
var require_contentinfoRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/contentinfoRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var contentinfoRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          constraints: ["scoped to the body element"],
          name: "footer"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = contentinfoRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/definitionRole.js
var require_definitionRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/definitionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var definitionRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "dd"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = definitionRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/deletionRole.js
var require_deletionRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/deletionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var deletionRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "del"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = deletionRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/dialogRole.js
var require_dialogRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/dialogRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var dialogRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "dialog"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "window"]]
    };
    var _default = exports.default = dialogRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/directoryRole.js
var require_directoryRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/directoryRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var directoryRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        module: "DAISY Guide"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "list"]]
    };
    var _default = exports.default = directoryRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/documentRole.js
var require_documentRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/documentRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var documentRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "Device Independence Delivery Unit"
        }
      }, {
        concept: {
          name: "html"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    var _default = exports.default = documentRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/emphasisRole.js
var require_emphasisRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/emphasisRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var emphasisRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "em"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = emphasisRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/feedRole.js
var require_feedRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/feedRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var feedRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["article"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "list"]]
    };
    var _default = exports.default = feedRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/figureRole.js
var require_figureRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/figureRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var figureRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "figure"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = figureRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/formRole.js
var require_formRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/formRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var formRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-label"
          }],
          name: "form"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-labelledby"
          }],
          name: "form"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "name"
          }],
          name: "form"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = formRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/genericRole.js
var require_genericRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/genericRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var genericRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "a"
        },
        module: "HTML"
      }, {
        concept: {
          name: "area"
        },
        module: "HTML"
      }, {
        concept: {
          name: "aside"
        },
        module: "HTML"
      }, {
        concept: {
          name: "b"
        },
        module: "HTML"
      }, {
        concept: {
          name: "bdo"
        },
        module: "HTML"
      }, {
        concept: {
          name: "body"
        },
        module: "HTML"
      }, {
        concept: {
          name: "data"
        },
        module: "HTML"
      }, {
        concept: {
          name: "div"
        },
        module: "HTML"
      }, {
        concept: {
          constraints: ["scoped to the main element", "scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
          name: "footer"
        },
        module: "HTML"
      }, {
        concept: {
          constraints: ["scoped to the main element", "scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
          name: "header"
        },
        module: "HTML"
      }, {
        concept: {
          name: "hgroup"
        },
        module: "HTML"
      }, {
        concept: {
          name: "i"
        },
        module: "HTML"
      }, {
        concept: {
          name: "pre"
        },
        module: "HTML"
      }, {
        concept: {
          name: "q"
        },
        module: "HTML"
      }, {
        concept: {
          name: "samp"
        },
        module: "HTML"
      }, {
        concept: {
          name: "section"
        },
        module: "HTML"
      }, {
        concept: {
          name: "small"
        },
        module: "HTML"
      }, {
        concept: {
          name: "span"
        },
        module: "HTML"
      }, {
        concept: {
          name: "u"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    var _default = exports.default = genericRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/gridRole.js
var require_gridRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/gridRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var gridRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-multiselectable": null,
        "aria-readonly": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["row"], ["row", "rowgroup"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite"], ["roletype", "structure", "section", "table"]]
    };
    var _default = exports.default = gridRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/gridcellRole.js
var require_gridcellRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/gridcellRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var gridcellRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null,
        "aria-selected": null
      },
      relatedConcepts: [{
        concept: {
          constraints: ["ancestor table element has grid role", "ancestor table element has treegrid role"],
          name: "td"
        },
        module: "HTML"
      }],
      requireContextRole: ["row"],
      requiredContextRole: ["row"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "cell"], ["roletype", "widget"]]
    };
    var _default = exports.default = gridcellRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/groupRole.js
var require_groupRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/groupRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var groupRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-disabled": null
      },
      relatedConcepts: [{
        concept: {
          name: "details"
        },
        module: "HTML"
      }, {
        concept: {
          name: "fieldset"
        },
        module: "HTML"
      }, {
        concept: {
          name: "optgroup"
        },
        module: "HTML"
      }, {
        concept: {
          name: "address"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = groupRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/headingRole.js
var require_headingRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/headingRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var headingRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-level": "2"
      },
      relatedConcepts: [{
        concept: {
          name: "h1"
        },
        module: "HTML"
      }, {
        concept: {
          name: "h2"
        },
        module: "HTML"
      }, {
        concept: {
          name: "h3"
        },
        module: "HTML"
      }, {
        concept: {
          name: "h4"
        },
        module: "HTML"
      }, {
        concept: {
          name: "h5"
        },
        module: "HTML"
      }, {
        concept: {
          name: "h6"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-level": "2"
      },
      superClass: [["roletype", "structure", "sectionhead"]]
    };
    var _default = exports.default = headingRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/imgRole.js
var require_imgRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/imgRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var imgRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "alt"
          }],
          name: "img"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "alt"
          }],
          name: "img"
        },
        module: "HTML"
      }, {
        concept: {
          name: "imggroup"
        },
        module: "DTB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = imgRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/insertionRole.js
var require_insertionRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/insertionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var insertionRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "ins"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = insertionRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/linkRole.js
var require_linkRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/linkRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var linkRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-expanded": null,
        "aria-haspopup": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "href"
          }],
          name: "a"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "href"
          }],
          name: "area"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command"]]
    };
    var _default = exports.default = linkRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/listRole.js
var require_listRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/listRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var listRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "menu"
        },
        module: "HTML"
      }, {
        concept: {
          name: "ol"
        },
        module: "HTML"
      }, {
        concept: {
          name: "ul"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["listitem"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = listRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/listboxRole.js
var require_listboxRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/listboxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var listboxRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-invalid": null,
        "aria-multiselectable": null,
        "aria-readonly": null,
        "aria-required": null,
        "aria-orientation": "vertical"
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: [">1"],
            name: "size"
          }],
          constraints: ["the size attribute value is greater than 1"],
          name: "select"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "multiple"
          }],
          name: "select"
        },
        module: "HTML"
      }, {
        concept: {
          name: "datalist"
        },
        module: "HTML"
      }, {
        concept: {
          name: "list"
        },
        module: "ARIA"
      }, {
        concept: {
          name: "select"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["option", "group"], ["option"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
    };
    var _default = exports.default = listboxRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/listitemRole.js
var require_listitemRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/listitemRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var listitemRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-level": null,
        "aria-posinset": null,
        "aria-setsize": null
      },
      relatedConcepts: [{
        concept: {
          constraints: ["direct descendant of ol", "direct descendant of ul", "direct descendant of menu"],
          name: "li"
        },
        module: "HTML"
      }, {
        concept: {
          name: "item"
        },
        module: "XForms"
      }],
      requireContextRole: ["directory", "list"],
      requiredContextRole: ["directory", "list"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = listitemRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/logRole.js
var require_logRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/logRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var logRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-live": "polite"
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = logRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/mainRole.js
var require_mainRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/mainRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var mainRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "main"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = mainRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/markRole.js
var require_markRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/markRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var markRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: [],
      props: {
        "aria-braillelabel": null,
        "aria-brailleroledescription": null,
        "aria-description": null
      },
      relatedConcepts: [{
        concept: {
          name: "mark"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = markRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/marqueeRole.js
var require_marqueeRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/marqueeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var marqueeRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = marqueeRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/mathRole.js
var require_mathRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/mathRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var mathRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "math"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = mathRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/menuRole.js
var require_menuRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/menuRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var menuRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-orientation": "vertical"
      },
      relatedConcepts: [{
        concept: {
          name: "MENU"
        },
        module: "JAPI"
      }, {
        concept: {
          name: "list"
        },
        module: "ARIA"
      }, {
        concept: {
          name: "select"
        },
        module: "XForms"
      }, {
        concept: {
          name: "sidebar"
        },
        module: "DTB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["menuitem", "group"], ["menuitemradio", "group"], ["menuitemcheckbox", "group"], ["menuitem"], ["menuitemcheckbox"], ["menuitemradio"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
    };
    var _default = exports.default = menuRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/menubarRole.js
var require_menubarRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/menubarRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var menubarRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-orientation": "horizontal"
      },
      relatedConcepts: [{
        concept: {
          name: "toolbar"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["menuitem", "group"], ["menuitemradio", "group"], ["menuitemcheckbox", "group"], ["menuitem"], ["menuitemcheckbox"], ["menuitemradio"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "select", "menu"], ["roletype", "structure", "section", "group", "select", "menu"]]
    };
    var _default = exports.default = menubarRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/menuitemRole.js
var require_menuitemRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/menuitemRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var menuitemRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-posinset": null,
        "aria-setsize": null
      },
      relatedConcepts: [{
        concept: {
          name: "MENU_ITEM"
        },
        module: "JAPI"
      }, {
        concept: {
          name: "listitem"
        },
        module: "ARIA"
      }, {
        concept: {
          name: "option"
        },
        module: "ARIA"
      }],
      requireContextRole: ["group", "menu", "menubar"],
      requiredContextRole: ["group", "menu", "menubar"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command"]]
    };
    var _default = exports.default = menuitemRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/menuitemcheckboxRole.js
var require_menuitemcheckboxRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/menuitemcheckboxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var menuitemcheckboxRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "menuitem"
        },
        module: "ARIA"
      }],
      requireContextRole: ["group", "menu", "menubar"],
      requiredContextRole: ["group", "menu", "menubar"],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [["roletype", "widget", "input", "checkbox"], ["roletype", "widget", "command", "menuitem"]]
    };
    var _default = exports.default = menuitemcheckboxRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/menuitemradioRole.js
var require_menuitemradioRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/menuitemradioRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var menuitemradioRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "menuitem"
        },
        module: "ARIA"
      }],
      requireContextRole: ["group", "menu", "menubar"],
      requiredContextRole: ["group", "menu", "menubar"],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [["roletype", "widget", "input", "checkbox", "menuitemcheckbox"], ["roletype", "widget", "command", "menuitem", "menuitemcheckbox"], ["roletype", "widget", "input", "radio"]]
    };
    var _default = exports.default = menuitemradioRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/meterRole.js
var require_meterRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/meterRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var meterRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-valuetext": null,
        "aria-valuemax": "100",
        "aria-valuemin": "0"
      },
      relatedConcepts: [{
        concept: {
          name: "meter"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-valuenow": null
      },
      superClass: [["roletype", "structure", "range"]]
    };
    var _default = exports.default = meterRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/navigationRole.js
var require_navigationRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/navigationRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var navigationRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "nav"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = navigationRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/noneRole.js
var require_noneRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/noneRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var noneRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: []
    };
    var _default = exports.default = noneRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/noteRole.js
var require_noteRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/noteRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var noteRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = noteRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/optionRole.js
var require_optionRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/optionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var optionRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-checked": null,
        "aria-posinset": null,
        "aria-setsize": null,
        "aria-selected": "false"
      },
      relatedConcepts: [{
        concept: {
          name: "item"
        },
        module: "XForms"
      }, {
        concept: {
          name: "listitem"
        },
        module: "ARIA"
      }, {
        concept: {
          name: "option"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-selected": "false"
      },
      superClass: [["roletype", "widget", "input"]]
    };
    var _default = exports.default = optionRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/paragraphRole.js
var require_paragraphRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/paragraphRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var paragraphRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "p"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = paragraphRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/presentationRole.js
var require_presentationRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/presentationRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var presentationRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "alt",
            value: ""
          }],
          name: "img"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    var _default = exports.default = presentationRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/progressbarRole.js
var require_progressbarRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/progressbarRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var progressbarRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-valuetext": null
      },
      relatedConcepts: [{
        concept: {
          name: "progress"
        },
        module: "HTML"
      }, {
        concept: {
          name: "status"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "range"], ["roletype", "widget"]]
    };
    var _default = exports.default = progressbarRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/radioRole.js
var require_radioRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/radioRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var radioRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-checked": null,
        "aria-posinset": null,
        "aria-setsize": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "type",
            value: "radio"
          }],
          name: "input"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [["roletype", "widget", "input"]]
    };
    var _default = exports.default = radioRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/radiogroupRole.js
var require_radiogroupRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/radiogroupRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var radiogroupRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null
      },
      relatedConcepts: [{
        concept: {
          name: "list"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["radio"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
    };
    var _default = exports.default = radiogroupRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/regionRole.js
var require_regionRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/regionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var regionRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-label"
          }],
          name: "section"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-labelledby"
          }],
          name: "section"
        },
        module: "HTML"
      }, {
        concept: {
          name: "Device Independence Glossart perceivable unit"
        }
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = regionRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/rowRole.js
var require_rowRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/rowRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var rowRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-colindex": null,
        "aria-expanded": null,
        "aria-level": null,
        "aria-posinset": null,
        "aria-rowindex": null,
        "aria-selected": null,
        "aria-setsize": null
      },
      relatedConcepts: [{
        concept: {
          name: "tr"
        },
        module: "HTML"
      }],
      requireContextRole: ["grid", "rowgroup", "table", "treegrid"],
      requiredContextRole: ["grid", "rowgroup", "table", "treegrid"],
      requiredOwnedElements: [["cell"], ["columnheader"], ["gridcell"], ["rowheader"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "group"], ["roletype", "widget"]]
    };
    var _default = exports.default = rowRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/rowgroupRole.js
var require_rowgroupRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/rowgroupRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var rowgroupRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "tbody"
        },
        module: "HTML"
      }, {
        concept: {
          name: "tfoot"
        },
        module: "HTML"
      }, {
        concept: {
          name: "thead"
        },
        module: "HTML"
      }],
      requireContextRole: ["grid", "table", "treegrid"],
      requiredContextRole: ["grid", "table", "treegrid"],
      requiredOwnedElements: [["row"]],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    var _default = exports.default = rowgroupRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/rowheaderRole.js
var require_rowheaderRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/rowheaderRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var rowheaderRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-sort": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "scope",
            value: "row"
          }],
          name: "th"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "scope",
            value: "rowgroup"
          }],
          name: "th"
        },
        module: "HTML"
      }],
      requireContextRole: ["row", "rowgroup"],
      requiredContextRole: ["row", "rowgroup"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "cell"], ["roletype", "structure", "section", "cell", "gridcell"], ["roletype", "widget", "gridcell"], ["roletype", "structure", "sectionhead"]]
    };
    var _default = exports.default = rowheaderRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/scrollbarRole.js
var require_scrollbarRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/scrollbarRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var scrollbarRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-valuetext": null,
        "aria-orientation": "vertical",
        "aria-valuemax": "100",
        "aria-valuemin": "0"
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-controls": null,
        "aria-valuenow": null
      },
      superClass: [["roletype", "structure", "range"], ["roletype", "widget"]]
    };
    var _default = exports.default = scrollbarRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/searchRole.js
var require_searchRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/searchRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var searchRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = searchRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/searchboxRole.js
var require_searchboxRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/searchboxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var searchboxRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "list"
          }, {
            name: "type",
            value: "search"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "input", "textbox"]]
    };
    var _default = exports.default = searchboxRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/separatorRole.js
var require_separatorRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/separatorRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var separatorRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-orientation": "horizontal",
        "aria-valuemax": "100",
        "aria-valuemin": "0",
        "aria-valuenow": null,
        "aria-valuetext": null
      },
      relatedConcepts: [{
        concept: {
          name: "hr"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    var _default = exports.default = separatorRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/sliderRole.js
var require_sliderRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/sliderRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var sliderRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-haspopup": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-valuetext": null,
        "aria-orientation": "horizontal",
        "aria-valuemax": "100",
        "aria-valuemin": "0"
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "type",
            value: "range"
          }],
          name: "input"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-valuenow": null
      },
      superClass: [["roletype", "widget", "input"], ["roletype", "structure", "range"]]
    };
    var _default = exports.default = sliderRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/spinbuttonRole.js
var require_spinbuttonRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/spinbuttonRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var spinbuttonRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null,
        "aria-valuetext": null,
        "aria-valuenow": "0"
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "type",
            value: "number"
          }],
          name: "input"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite"], ["roletype", "widget", "input"], ["roletype", "structure", "range"]]
    };
    var _default = exports.default = spinbuttonRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/statusRole.js
var require_statusRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/statusRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var statusRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-atomic": "true",
        "aria-live": "polite"
      },
      relatedConcepts: [{
        concept: {
          name: "output"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = statusRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/strongRole.js
var require_strongRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/strongRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var strongRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "strong"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = strongRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/subscriptRole.js
var require_subscriptRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/subscriptRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var subscriptRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "sub"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = subscriptRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/superscriptRole.js
var require_superscriptRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/superscriptRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var superscriptRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "sup"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = superscriptRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/switchRole.js
var require_switchRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/switchRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var switchRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "button"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [["roletype", "widget", "input", "checkbox"]]
    };
    var _default = exports.default = switchRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/tabRole.js
var require_tabRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/tabRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var tabRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-posinset": null,
        "aria-setsize": null,
        "aria-selected": "false"
      },
      relatedConcepts: [],
      requireContextRole: ["tablist"],
      requiredContextRole: ["tablist"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "sectionhead"], ["roletype", "widget"]]
    };
    var _default = exports.default = tabRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/tableRole.js
var require_tableRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/tableRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var tableRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-colcount": null,
        "aria-rowcount": null
      },
      relatedConcepts: [{
        concept: {
          name: "table"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["row"], ["row", "rowgroup"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = tableRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/tablistRole.js
var require_tablistRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/tablistRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var tablistRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-level": null,
        "aria-multiselectable": null,
        "aria-orientation": "horizontal"
      },
      relatedConcepts: [{
        module: "DAISY",
        concept: {
          name: "guide"
        }
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["tab"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite"]]
    };
    var _default = exports.default = tablistRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/tabpanelRole.js
var require_tabpanelRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/tabpanelRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var tabpanelRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = tabpanelRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/termRole.js
var require_termRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/termRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var termRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "dfn"
        },
        module: "HTML"
      }, {
        concept: {
          name: "dt"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = termRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/textboxRole.js
var require_textboxRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/textboxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var textboxRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-autocomplete": null,
        "aria-errormessage": null,
        "aria-haspopup": null,
        "aria-invalid": null,
        "aria-multiline": null,
        "aria-placeholder": null,
        "aria-readonly": null,
        "aria-required": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "type"
          }, {
            constraints: ["undefined"],
            name: "list"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "list"
          }, {
            name: "type",
            value: "email"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "list"
          }, {
            name: "type",
            value: "tel"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "list"
          }, {
            name: "type",
            value: "text"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "list"
          }, {
            name: "type",
            value: "url"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          name: "input"
        },
        module: "XForms"
      }, {
        concept: {
          name: "textarea"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "input"]]
    };
    var _default = exports.default = textboxRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/timeRole.js
var require_timeRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/timeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var timeRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "time"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = timeRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/timerRole.js
var require_timerRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/timerRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var timerRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "status"]]
    };
    var _default = exports.default = timerRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/toolbarRole.js
var require_toolbarRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/toolbarRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var toolbarRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-orientation": "horizontal"
      },
      relatedConcepts: [{
        concept: {
          name: "menubar"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "group"]]
    };
    var _default = exports.default = toolbarRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/tooltipRole.js
var require_tooltipRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/tooltipRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var tooltipRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = tooltipRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/treeRole.js
var require_treeRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/treeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var treeRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null,
        "aria-multiselectable": null,
        "aria-required": null,
        "aria-orientation": "vertical"
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["treeitem", "group"], ["treeitem"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
    };
    var _default = exports.default = treeRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/treegridRole.js
var require_treegridRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/treegridRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var treegridRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["row"], ["row", "rowgroup"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "grid"], ["roletype", "structure", "section", "table", "grid"], ["roletype", "widget", "composite", "select", "tree"], ["roletype", "structure", "section", "group", "select", "tree"]]
    };
    var _default = exports.default = treegridRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/treeitemRole.js
var require_treeitemRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/treeitemRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var treeitemRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-expanded": null,
        "aria-haspopup": null
      },
      relatedConcepts: [],
      requireContextRole: ["group", "tree"],
      requiredContextRole: ["group", "tree"],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-selected": null
      },
      superClass: [["roletype", "structure", "section", "listitem"], ["roletype", "widget", "input", "option"]]
    };
    var _default = exports.default = treeitemRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/ariaLiteralRoles.js
var require_ariaLiteralRoles = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/ariaLiteralRoles.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _alertRole = _interopRequireDefault(require_alertRole());
    var _alertdialogRole = _interopRequireDefault(require_alertdialogRole());
    var _applicationRole = _interopRequireDefault(require_applicationRole());
    var _articleRole = _interopRequireDefault(require_articleRole());
    var _bannerRole = _interopRequireDefault(require_bannerRole());
    var _blockquoteRole = _interopRequireDefault(require_blockquoteRole());
    var _buttonRole = _interopRequireDefault(require_buttonRole());
    var _captionRole = _interopRequireDefault(require_captionRole());
    var _cellRole = _interopRequireDefault(require_cellRole());
    var _checkboxRole = _interopRequireDefault(require_checkboxRole());
    var _codeRole = _interopRequireDefault(require_codeRole());
    var _columnheaderRole = _interopRequireDefault(require_columnheaderRole());
    var _comboboxRole = _interopRequireDefault(require_comboboxRole());
    var _complementaryRole = _interopRequireDefault(require_complementaryRole());
    var _contentinfoRole = _interopRequireDefault(require_contentinfoRole());
    var _definitionRole = _interopRequireDefault(require_definitionRole());
    var _deletionRole = _interopRequireDefault(require_deletionRole());
    var _dialogRole = _interopRequireDefault(require_dialogRole());
    var _directoryRole = _interopRequireDefault(require_directoryRole());
    var _documentRole = _interopRequireDefault(require_documentRole());
    var _emphasisRole = _interopRequireDefault(require_emphasisRole());
    var _feedRole = _interopRequireDefault(require_feedRole());
    var _figureRole = _interopRequireDefault(require_figureRole());
    var _formRole = _interopRequireDefault(require_formRole());
    var _genericRole = _interopRequireDefault(require_genericRole());
    var _gridRole = _interopRequireDefault(require_gridRole());
    var _gridcellRole = _interopRequireDefault(require_gridcellRole());
    var _groupRole = _interopRequireDefault(require_groupRole());
    var _headingRole = _interopRequireDefault(require_headingRole());
    var _imgRole = _interopRequireDefault(require_imgRole());
    var _insertionRole = _interopRequireDefault(require_insertionRole());
    var _linkRole = _interopRequireDefault(require_linkRole());
    var _listRole = _interopRequireDefault(require_listRole());
    var _listboxRole = _interopRequireDefault(require_listboxRole());
    var _listitemRole = _interopRequireDefault(require_listitemRole());
    var _logRole = _interopRequireDefault(require_logRole());
    var _mainRole = _interopRequireDefault(require_mainRole());
    var _markRole = _interopRequireDefault(require_markRole());
    var _marqueeRole = _interopRequireDefault(require_marqueeRole());
    var _mathRole = _interopRequireDefault(require_mathRole());
    var _menuRole = _interopRequireDefault(require_menuRole());
    var _menubarRole = _interopRequireDefault(require_menubarRole());
    var _menuitemRole = _interopRequireDefault(require_menuitemRole());
    var _menuitemcheckboxRole = _interopRequireDefault(require_menuitemcheckboxRole());
    var _menuitemradioRole = _interopRequireDefault(require_menuitemradioRole());
    var _meterRole = _interopRequireDefault(require_meterRole());
    var _navigationRole = _interopRequireDefault(require_navigationRole());
    var _noneRole = _interopRequireDefault(require_noneRole());
    var _noteRole = _interopRequireDefault(require_noteRole());
    var _optionRole = _interopRequireDefault(require_optionRole());
    var _paragraphRole = _interopRequireDefault(require_paragraphRole());
    var _presentationRole = _interopRequireDefault(require_presentationRole());
    var _progressbarRole = _interopRequireDefault(require_progressbarRole());
    var _radioRole = _interopRequireDefault(require_radioRole());
    var _radiogroupRole = _interopRequireDefault(require_radiogroupRole());
    var _regionRole = _interopRequireDefault(require_regionRole());
    var _rowRole = _interopRequireDefault(require_rowRole());
    var _rowgroupRole = _interopRequireDefault(require_rowgroupRole());
    var _rowheaderRole = _interopRequireDefault(require_rowheaderRole());
    var _scrollbarRole = _interopRequireDefault(require_scrollbarRole());
    var _searchRole = _interopRequireDefault(require_searchRole());
    var _searchboxRole = _interopRequireDefault(require_searchboxRole());
    var _separatorRole = _interopRequireDefault(require_separatorRole());
    var _sliderRole = _interopRequireDefault(require_sliderRole());
    var _spinbuttonRole = _interopRequireDefault(require_spinbuttonRole());
    var _statusRole = _interopRequireDefault(require_statusRole());
    var _strongRole = _interopRequireDefault(require_strongRole());
    var _subscriptRole = _interopRequireDefault(require_subscriptRole());
    var _superscriptRole = _interopRequireDefault(require_superscriptRole());
    var _switchRole = _interopRequireDefault(require_switchRole());
    var _tabRole = _interopRequireDefault(require_tabRole());
    var _tableRole = _interopRequireDefault(require_tableRole());
    var _tablistRole = _interopRequireDefault(require_tablistRole());
    var _tabpanelRole = _interopRequireDefault(require_tabpanelRole());
    var _termRole = _interopRequireDefault(require_termRole());
    var _textboxRole = _interopRequireDefault(require_textboxRole());
    var _timeRole = _interopRequireDefault(require_timeRole());
    var _timerRole = _interopRequireDefault(require_timerRole());
    var _toolbarRole = _interopRequireDefault(require_toolbarRole());
    var _tooltipRole = _interopRequireDefault(require_tooltipRole());
    var _treeRole = _interopRequireDefault(require_treeRole());
    var _treegridRole = _interopRequireDefault(require_treegridRole());
    var _treeitemRole = _interopRequireDefault(require_treeitemRole());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var ariaLiteralRoles = [["alert", _alertRole.default], ["alertdialog", _alertdialogRole.default], ["application", _applicationRole.default], ["article", _articleRole.default], ["banner", _bannerRole.default], ["blockquote", _blockquoteRole.default], ["button", _buttonRole.default], ["caption", _captionRole.default], ["cell", _cellRole.default], ["checkbox", _checkboxRole.default], ["code", _codeRole.default], ["columnheader", _columnheaderRole.default], ["combobox", _comboboxRole.default], ["complementary", _complementaryRole.default], ["contentinfo", _contentinfoRole.default], ["definition", _definitionRole.default], ["deletion", _deletionRole.default], ["dialog", _dialogRole.default], ["directory", _directoryRole.default], ["document", _documentRole.default], ["emphasis", _emphasisRole.default], ["feed", _feedRole.default], ["figure", _figureRole.default], ["form", _formRole.default], ["generic", _genericRole.default], ["grid", _gridRole.default], ["gridcell", _gridcellRole.default], ["group", _groupRole.default], ["heading", _headingRole.default], ["img", _imgRole.default], ["insertion", _insertionRole.default], ["link", _linkRole.default], ["list", _listRole.default], ["listbox", _listboxRole.default], ["listitem", _listitemRole.default], ["log", _logRole.default], ["main", _mainRole.default], ["mark", _markRole.default], ["marquee", _marqueeRole.default], ["math", _mathRole.default], ["menu", _menuRole.default], ["menubar", _menubarRole.default], ["menuitem", _menuitemRole.default], ["menuitemcheckbox", _menuitemcheckboxRole.default], ["menuitemradio", _menuitemradioRole.default], ["meter", _meterRole.default], ["navigation", _navigationRole.default], ["none", _noneRole.default], ["note", _noteRole.default], ["option", _optionRole.default], ["paragraph", _paragraphRole.default], ["presentation", _presentationRole.default], ["progressbar", _progressbarRole.default], ["radio", _radioRole.default], ["radiogroup", _radiogroupRole.default], ["region", _regionRole.default], ["row", _rowRole.default], ["rowgroup", _rowgroupRole.default], ["rowheader", _rowheaderRole.default], ["scrollbar", _scrollbarRole.default], ["search", _searchRole.default], ["searchbox", _searchboxRole.default], ["separator", _separatorRole.default], ["slider", _sliderRole.default], ["spinbutton", _spinbuttonRole.default], ["status", _statusRole.default], ["strong", _strongRole.default], ["subscript", _subscriptRole.default], ["superscript", _superscriptRole.default], ["switch", _switchRole.default], ["tab", _tabRole.default], ["table", _tableRole.default], ["tablist", _tablistRole.default], ["tabpanel", _tabpanelRole.default], ["term", _termRole.default], ["textbox", _textboxRole.default], ["time", _timeRole.default], ["timer", _timerRole.default], ["toolbar", _toolbarRole.default], ["tooltip", _tooltipRole.default], ["tree", _treeRole.default], ["treegrid", _treegridRole.default], ["treeitem", _treeitemRole.default]];
    var _default = exports.default = ariaLiteralRoles;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docAbstractRole.js
var require_docAbstractRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docAbstractRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docAbstractRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "abstract [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = docAbstractRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docAcknowledgmentsRole.js
var require_docAcknowledgmentsRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docAcknowledgmentsRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docAcknowledgmentsRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "acknowledgments [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docAcknowledgmentsRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docAfterwordRole.js
var require_docAfterwordRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docAfterwordRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docAfterwordRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "afterword [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docAfterwordRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docAppendixRole.js
var require_docAppendixRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docAppendixRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docAppendixRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "appendix [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docAppendixRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docBacklinkRole.js
var require_docBacklinkRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docBacklinkRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docBacklinkRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "referrer [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command", "link"]]
    };
    var _default = exports.default = docBacklinkRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docBiblioentryRole.js
var require_docBiblioentryRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docBiblioentryRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docBiblioentryRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "EPUB biblioentry [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: ["doc-bibliography"],
      requiredContextRole: ["doc-bibliography"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "listitem"]]
    };
    var _default = exports.default = docBiblioentryRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docBibliographyRole.js
var require_docBibliographyRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docBibliographyRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docBibliographyRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "bibliography [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["doc-biblioentry"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docBibliographyRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docBibliorefRole.js
var require_docBibliorefRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docBibliorefRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docBibliorefRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "biblioref [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command", "link"]]
    };
    var _default = exports.default = docBibliorefRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docChapterRole.js
var require_docChapterRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docChapterRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docChapterRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "chapter [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docChapterRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docColophonRole.js
var require_docColophonRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docColophonRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docColophonRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "colophon [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = docColophonRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docConclusionRole.js
var require_docConclusionRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docConclusionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docConclusionRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "conclusion [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docConclusionRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docCoverRole.js
var require_docCoverRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docCoverRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docCoverRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "cover [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "img"]]
    };
    var _default = exports.default = docCoverRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docCreditRole.js
var require_docCreditRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docCreditRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docCreditRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "credit [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = docCreditRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docCreditsRole.js
var require_docCreditsRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docCreditsRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docCreditsRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "credits [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docCreditsRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docDedicationRole.js
var require_docDedicationRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docDedicationRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docDedicationRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "dedication [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = docDedicationRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docEndnoteRole.js
var require_docEndnoteRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docEndnoteRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docEndnoteRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "rearnote [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: ["doc-endnotes"],
      requiredContextRole: ["doc-endnotes"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "listitem"]]
    };
    var _default = exports.default = docEndnoteRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docEndnotesRole.js
var require_docEndnotesRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docEndnotesRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docEndnotesRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "rearnotes [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["doc-endnote"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docEndnotesRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docEpigraphRole.js
var require_docEpigraphRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docEpigraphRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docEpigraphRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "epigraph [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = docEpigraphRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docEpilogueRole.js
var require_docEpilogueRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docEpilogueRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docEpilogueRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "epilogue [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docEpilogueRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docErrataRole.js
var require_docErrataRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docErrataRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docErrataRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "errata [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docErrataRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docExampleRole.js
var require_docExampleRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docExampleRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docExampleRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = docExampleRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docFootnoteRole.js
var require_docFootnoteRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docFootnoteRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docFootnoteRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "footnote [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = docFootnoteRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docForewordRole.js
var require_docForewordRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docForewordRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docForewordRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "foreword [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docForewordRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docGlossaryRole.js
var require_docGlossaryRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docGlossaryRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docGlossaryRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "glossary [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["definition"], ["term"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docGlossaryRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docGlossrefRole.js
var require_docGlossrefRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docGlossrefRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docGlossrefRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "glossref [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command", "link"]]
    };
    var _default = exports.default = docGlossrefRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docIndexRole.js
var require_docIndexRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docIndexRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docIndexRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "index [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark", "navigation"]]
    };
    var _default = exports.default = docIndexRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docIntroductionRole.js
var require_docIntroductionRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docIntroductionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docIntroductionRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "introduction [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docIntroductionRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docNoterefRole.js
var require_docNoterefRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docNoterefRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docNoterefRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "noteref [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command", "link"]]
    };
    var _default = exports.default = docNoterefRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docNoticeRole.js
var require_docNoticeRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docNoticeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docNoticeRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "notice [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "note"]]
    };
    var _default = exports.default = docNoticeRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docPagebreakRole.js
var require_docPagebreakRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docPagebreakRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docPagebreakRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "pagebreak [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "separator"]]
    };
    var _default = exports.default = docPagebreakRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docPagefooterRole.js
var require_docPagefooterRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docPagefooterRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docPagefooterRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: [],
      props: {
        "aria-braillelabel": null,
        "aria-brailleroledescription": null,
        "aria-description": null,
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = docPagefooterRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docPageheaderRole.js
var require_docPageheaderRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docPageheaderRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docPageheaderRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: [],
      props: {
        "aria-braillelabel": null,
        "aria-brailleroledescription": null,
        "aria-description": null,
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = docPageheaderRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docPagelistRole.js
var require_docPagelistRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docPagelistRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docPagelistRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "page-list [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark", "navigation"]]
    };
    var _default = exports.default = docPagelistRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docPartRole.js
var require_docPartRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docPartRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docPartRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "part [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docPartRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docPrefaceRole.js
var require_docPrefaceRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docPrefaceRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docPrefaceRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "preface [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docPrefaceRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docPrologueRole.js
var require_docPrologueRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docPrologueRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docPrologueRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "prologue [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docPrologueRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docPullquoteRole.js
var require_docPullquoteRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docPullquoteRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docPullquoteRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "pullquote [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["none"]]
    };
    var _default = exports.default = docPullquoteRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docQnaRole.js
var require_docQnaRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docQnaRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docQnaRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "qna [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = docQnaRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docSubtitleRole.js
var require_docSubtitleRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docSubtitleRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docSubtitleRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "subtitle [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "sectionhead"]]
    };
    var _default = exports.default = docSubtitleRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docTipRole.js
var require_docTipRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docTipRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docTipRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "help [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "note"]]
    };
    var _default = exports.default = docTipRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docTocRole.js
var require_docTocRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docTocRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docTocRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "toc [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark", "navigation"]]
    };
    var _default = exports.default = docTocRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/ariaDpubRoles.js
var require_ariaDpubRoles = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/ariaDpubRoles.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _docAbstractRole = _interopRequireDefault(require_docAbstractRole());
    var _docAcknowledgmentsRole = _interopRequireDefault(require_docAcknowledgmentsRole());
    var _docAfterwordRole = _interopRequireDefault(require_docAfterwordRole());
    var _docAppendixRole = _interopRequireDefault(require_docAppendixRole());
    var _docBacklinkRole = _interopRequireDefault(require_docBacklinkRole());
    var _docBiblioentryRole = _interopRequireDefault(require_docBiblioentryRole());
    var _docBibliographyRole = _interopRequireDefault(require_docBibliographyRole());
    var _docBibliorefRole = _interopRequireDefault(require_docBibliorefRole());
    var _docChapterRole = _interopRequireDefault(require_docChapterRole());
    var _docColophonRole = _interopRequireDefault(require_docColophonRole());
    var _docConclusionRole = _interopRequireDefault(require_docConclusionRole());
    var _docCoverRole = _interopRequireDefault(require_docCoverRole());
    var _docCreditRole = _interopRequireDefault(require_docCreditRole());
    var _docCreditsRole = _interopRequireDefault(require_docCreditsRole());
    var _docDedicationRole = _interopRequireDefault(require_docDedicationRole());
    var _docEndnoteRole = _interopRequireDefault(require_docEndnoteRole());
    var _docEndnotesRole = _interopRequireDefault(require_docEndnotesRole());
    var _docEpigraphRole = _interopRequireDefault(require_docEpigraphRole());
    var _docEpilogueRole = _interopRequireDefault(require_docEpilogueRole());
    var _docErrataRole = _interopRequireDefault(require_docErrataRole());
    var _docExampleRole = _interopRequireDefault(require_docExampleRole());
    var _docFootnoteRole = _interopRequireDefault(require_docFootnoteRole());
    var _docForewordRole = _interopRequireDefault(require_docForewordRole());
    var _docGlossaryRole = _interopRequireDefault(require_docGlossaryRole());
    var _docGlossrefRole = _interopRequireDefault(require_docGlossrefRole());
    var _docIndexRole = _interopRequireDefault(require_docIndexRole());
    var _docIntroductionRole = _interopRequireDefault(require_docIntroductionRole());
    var _docNoterefRole = _interopRequireDefault(require_docNoterefRole());
    var _docNoticeRole = _interopRequireDefault(require_docNoticeRole());
    var _docPagebreakRole = _interopRequireDefault(require_docPagebreakRole());
    var _docPagefooterRole = _interopRequireDefault(require_docPagefooterRole());
    var _docPageheaderRole = _interopRequireDefault(require_docPageheaderRole());
    var _docPagelistRole = _interopRequireDefault(require_docPagelistRole());
    var _docPartRole = _interopRequireDefault(require_docPartRole());
    var _docPrefaceRole = _interopRequireDefault(require_docPrefaceRole());
    var _docPrologueRole = _interopRequireDefault(require_docPrologueRole());
    var _docPullquoteRole = _interopRequireDefault(require_docPullquoteRole());
    var _docQnaRole = _interopRequireDefault(require_docQnaRole());
    var _docSubtitleRole = _interopRequireDefault(require_docSubtitleRole());
    var _docTipRole = _interopRequireDefault(require_docTipRole());
    var _docTocRole = _interopRequireDefault(require_docTocRole());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var ariaDpubRoles = [["doc-abstract", _docAbstractRole.default], ["doc-acknowledgments", _docAcknowledgmentsRole.default], ["doc-afterword", _docAfterwordRole.default], ["doc-appendix", _docAppendixRole.default], ["doc-backlink", _docBacklinkRole.default], ["doc-biblioentry", _docBiblioentryRole.default], ["doc-bibliography", _docBibliographyRole.default], ["doc-biblioref", _docBibliorefRole.default], ["doc-chapter", _docChapterRole.default], ["doc-colophon", _docColophonRole.default], ["doc-conclusion", _docConclusionRole.default], ["doc-cover", _docCoverRole.default], ["doc-credit", _docCreditRole.default], ["doc-credits", _docCreditsRole.default], ["doc-dedication", _docDedicationRole.default], ["doc-endnote", _docEndnoteRole.default], ["doc-endnotes", _docEndnotesRole.default], ["doc-epigraph", _docEpigraphRole.default], ["doc-epilogue", _docEpilogueRole.default], ["doc-errata", _docErrataRole.default], ["doc-example", _docExampleRole.default], ["doc-footnote", _docFootnoteRole.default], ["doc-foreword", _docForewordRole.default], ["doc-glossary", _docGlossaryRole.default], ["doc-glossref", _docGlossrefRole.default], ["doc-index", _docIndexRole.default], ["doc-introduction", _docIntroductionRole.default], ["doc-noteref", _docNoterefRole.default], ["doc-notice", _docNoticeRole.default], ["doc-pagebreak", _docPagebreakRole.default], ["doc-pagefooter", _docPagefooterRole.default], ["doc-pageheader", _docPageheaderRole.default], ["doc-pagelist", _docPagelistRole.default], ["doc-part", _docPartRole.default], ["doc-preface", _docPrefaceRole.default], ["doc-prologue", _docPrologueRole.default], ["doc-pullquote", _docPullquoteRole.default], ["doc-qna", _docQnaRole.default], ["doc-subtitle", _docSubtitleRole.default], ["doc-tip", _docTipRole.default], ["doc-toc", _docTocRole.default]];
    var _default = exports.default = ariaDpubRoles;
  }
});

// ../node_modules/aria-query/lib/etc/roles/graphics/graphicsDocumentRole.js
var require_graphicsDocumentRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/graphics/graphicsDocumentRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var graphicsDocumentRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        module: "GRAPHICS",
        concept: {
          name: "graphics-object"
        }
      }, {
        module: "ARIA",
        concept: {
          name: "img"
        }
      }, {
        module: "ARIA",
        concept: {
          name: "article"
        }
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "document"]]
    };
    var _default = exports.default = graphicsDocumentRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/graphics/graphicsObjectRole.js
var require_graphicsObjectRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/graphics/graphicsObjectRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var graphicsObjectRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        module: "GRAPHICS",
        concept: {
          name: "graphics-document"
        }
      }, {
        module: "ARIA",
        concept: {
          name: "group"
        }
      }, {
        module: "ARIA",
        concept: {
          name: "img"
        }
      }, {
        module: "GRAPHICS",
        concept: {
          name: "graphics-symbol"
        }
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "group"]]
    };
    var _default = exports.default = graphicsObjectRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/graphics/graphicsSymbolRole.js
var require_graphicsSymbolRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/graphics/graphicsSymbolRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var graphicsSymbolRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "img"]]
    };
    var _default = exports.default = graphicsSymbolRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/ariaGraphicsRoles.js
var require_ariaGraphicsRoles = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/ariaGraphicsRoles.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _graphicsDocumentRole = _interopRequireDefault(require_graphicsDocumentRole());
    var _graphicsObjectRole = _interopRequireDefault(require_graphicsObjectRole());
    var _graphicsSymbolRole = _interopRequireDefault(require_graphicsSymbolRole());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var ariaGraphicsRoles = [["graphics-document", _graphicsDocumentRole.default], ["graphics-object", _graphicsObjectRole.default], ["graphics-symbol", _graphicsSymbolRole.default]];
    var _default = exports.default = ariaGraphicsRoles;
  }
});

// ../node_modules/aria-query/lib/rolesMap.js
var require_rolesMap = __commonJS({
  "../node_modules/aria-query/lib/rolesMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _ariaAbstractRoles = _interopRequireDefault(require_ariaAbstractRoles());
    var _ariaLiteralRoles = _interopRequireDefault(require_ariaLiteralRoles());
    var _ariaDpubRoles = _interopRequireDefault(require_ariaDpubRoles());
    var _ariaGraphicsRoles = _interopRequireDefault(require_ariaGraphicsRoles());
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    function _createForOfIteratorHelper(r2, e2) {
      var t2 = "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
      if (!t2) {
        if (Array.isArray(r2) || (t2 = _unsupportedIterableToArray(r2)) || e2 && r2 && "number" == typeof r2.length) {
          t2 && (r2 = t2);
          var _n = 0, F = /* @__PURE__ */ __name(function F2() {
          }, "F");
          return { s: F, n: /* @__PURE__ */ __name(function n2() {
            return _n >= r2.length ? { done: true } : { done: false, value: r2[_n++] };
          }, "n"), e: /* @__PURE__ */ __name(function e3(r3) {
            throw r3;
          }, "e"), f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var o2, a2 = true, u3 = false;
      return { s: /* @__PURE__ */ __name(function s3() {
        t2 = t2.call(r2);
      }, "s"), n: /* @__PURE__ */ __name(function n2() {
        var r3 = t2.next();
        return a2 = r3.done, r3;
      }, "n"), e: /* @__PURE__ */ __name(function e3(r3) {
        u3 = true, o2 = r3;
      }, "e"), f: /* @__PURE__ */ __name(function f4() {
        try {
          a2 || null == t2.return || t2.return();
        } finally {
          if (u3) throw o2;
        }
      }, "f") };
    }
    __name(_createForOfIteratorHelper, "_createForOfIteratorHelper");
    function _slicedToArray(r2, e2) {
      return _arrayWithHoles(r2) || _iterableToArrayLimit(r2, e2) || _unsupportedIterableToArray(r2, e2) || _nonIterableRest();
    }
    __name(_slicedToArray, "_slicedToArray");
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    __name(_nonIterableRest, "_nonIterableRest");
    function _unsupportedIterableToArray(r2, a2) {
      if (r2) {
        if ("string" == typeof r2) return _arrayLikeToArray(r2, a2);
        var t2 = {}.toString.call(r2).slice(8, -1);
        return "Object" === t2 && r2.constructor && (t2 = r2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray(r2, a2) : void 0;
      }
    }
    __name(_unsupportedIterableToArray, "_unsupportedIterableToArray");
    function _arrayLikeToArray(r2, a2) {
      (null == a2 || a2 > r2.length) && (a2 = r2.length);
      for (var e2 = 0, n2 = Array(a2); e2 < a2; e2++) n2[e2] = r2[e2];
      return n2;
    }
    __name(_arrayLikeToArray, "_arrayLikeToArray");
    function _iterableToArrayLimit(r2, l2) {
      var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
      if (null != t2) {
        var e2, n2, i2, u3, a2 = [], f4 = true, o2 = false;
        try {
          if (i2 = (t2 = t2.call(r2)).next, 0 === l2) {
            if (Object(t2) !== t2) return;
            f4 = false;
          } else for (; !(f4 = (e2 = i2.call(t2)).done) && (a2.push(e2.value), a2.length !== l2); f4 = true) ;
        } catch (r3) {
          o2 = true, n2 = r3;
        } finally {
          try {
            if (!f4 && null != t2.return && (u3 = t2.return(), Object(u3) !== u3)) return;
          } finally {
            if (o2) throw n2;
          }
        }
        return a2;
      }
    }
    __name(_iterableToArrayLimit, "_iterableToArrayLimit");
    function _arrayWithHoles(r2) {
      if (Array.isArray(r2)) return r2;
    }
    __name(_arrayWithHoles, "_arrayWithHoles");
    var roles3 = [].concat(_ariaAbstractRoles.default, _ariaLiteralRoles.default, _ariaDpubRoles.default, _ariaGraphicsRoles.default);
    roles3.forEach(function(_ref) {
      var _ref2 = _slicedToArray(_ref, 2), roleDefinition = _ref2[1];
      var _iterator = _createForOfIteratorHelper(roleDefinition.superClass), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var superClassIter = _step.value;
          var _iterator2 = _createForOfIteratorHelper(superClassIter), _step2;
          try {
            var _loop = /* @__PURE__ */ __name(function _loop2() {
              var superClassName = _step2.value;
              var superClassRoleTuple = roles3.filter(function(_ref3) {
                var _ref4 = _slicedToArray(_ref3, 1), name = _ref4[0];
                return name === superClassName;
              })[0];
              if (superClassRoleTuple) {
                var superClassDefinition = superClassRoleTuple[1];
                for (var _i = 0, _Object$keys = Object.keys(superClassDefinition.props); _i < _Object$keys.length; _i++) {
                  var prop = _Object$keys[_i];
                  if (
                    // $FlowIssue Accessing the hasOwnProperty on the Object prototype is fine.
                    !Object.prototype.hasOwnProperty.call(roleDefinition.props, prop)
                  ) {
                    roleDefinition.props[prop] = superClassDefinition.props[prop];
                  }
                }
              }
            }, "_loop");
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
              _loop();
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    });
    var rolesMap = {
      entries: /* @__PURE__ */ __name(function entries() {
        return roles3;
      }, "entries"),
      forEach: /* @__PURE__ */ __name(function forEach(fn3) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        var _iterator3 = _createForOfIteratorHelper(roles3), _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
            var _step3$value = _slicedToArray(_step3.value, 2), key = _step3$value[0], values = _step3$value[1];
            fn3.call(thisArg, values, key, roles3);
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      }, "forEach"),
      get: /* @__PURE__ */ __name(function get3(key) {
        var item = roles3.filter(function(tuple) {
          return tuple[0] === key ? true : false;
        })[0];
        return item && item[1];
      }, "get"),
      has: /* @__PURE__ */ __name(function has(key) {
        return !!rolesMap.get(key);
      }, "has"),
      keys: /* @__PURE__ */ __name(function keys2() {
        return roles3.map(function(_ref5) {
          var _ref6 = _slicedToArray(_ref5, 1), key = _ref6[0];
          return key;
        });
      }, "keys"),
      values: /* @__PURE__ */ __name(function values() {
        return roles3.map(function(_ref7) {
          var _ref8 = _slicedToArray(_ref7, 2), values2 = _ref8[1];
          return values2;
        });
      }, "values")
    };
    var _default = exports.default = (0, _iterationDecorator.default)(rolesMap, rolesMap.entries());
  }
});

// ../node_modules/aria-query/lib/elementRoleMap.js
var require_elementRoleMap = __commonJS({
  "../node_modules/aria-query/lib/elementRoleMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator());
    var _rolesMap = _interopRequireDefault(require_rolesMap());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    function _slicedToArray(r2, e2) {
      return _arrayWithHoles(r2) || _iterableToArrayLimit(r2, e2) || _unsupportedIterableToArray(r2, e2) || _nonIterableRest();
    }
    __name(_slicedToArray, "_slicedToArray");
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    __name(_nonIterableRest, "_nonIterableRest");
    function _unsupportedIterableToArray(r2, a2) {
      if (r2) {
        if ("string" == typeof r2) return _arrayLikeToArray(r2, a2);
        var t2 = {}.toString.call(r2).slice(8, -1);
        return "Object" === t2 && r2.constructor && (t2 = r2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray(r2, a2) : void 0;
      }
    }
    __name(_unsupportedIterableToArray, "_unsupportedIterableToArray");
    function _arrayLikeToArray(r2, a2) {
      (null == a2 || a2 > r2.length) && (a2 = r2.length);
      for (var e2 = 0, n2 = Array(a2); e2 < a2; e2++) n2[e2] = r2[e2];
      return n2;
    }
    __name(_arrayLikeToArray, "_arrayLikeToArray");
    function _iterableToArrayLimit(r2, l2) {
      var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
      if (null != t2) {
        var e2, n2, i3, u3, a2 = [], f4 = true, o2 = false;
        try {
          if (i3 = (t2 = t2.call(r2)).next, 0 === l2) {
            if (Object(t2) !== t2) return;
            f4 = false;
          } else for (; !(f4 = (e2 = i3.call(t2)).done) && (a2.push(e2.value), a2.length !== l2); f4 = true) ;
        } catch (r3) {
          o2 = true, n2 = r3;
        } finally {
          try {
            if (!f4 && null != t2.return && (u3 = t2.return(), Object(u3) !== u3)) return;
          } finally {
            if (o2) throw n2;
          }
        }
        return a2;
      }
    }
    __name(_iterableToArrayLimit, "_iterableToArrayLimit");
    function _arrayWithHoles(r2) {
      if (Array.isArray(r2)) return r2;
    }
    __name(_arrayWithHoles, "_arrayWithHoles");
    var elementRoles3 = [];
    var keys2 = _rolesMap.default.keys();
    for (i2 = 0; i2 < keys2.length; i2++) {
      key = keys2[i2];
      role = _rolesMap.default.get(key);
      if (role) {
        concepts = [].concat(role.baseConcepts, role.relatedConcepts);
        _loop = /* @__PURE__ */ __name(function _loop2() {
          var relation = concepts[k2];
          if (relation.module === "HTML") {
            var concept = relation.concept;
            if (concept) {
              var elementRoleRelation = elementRoles3.filter(function(relation2) {
                return ariaRoleRelationConceptEquals(relation2[0], concept);
              })[0];
              var roles3;
              if (elementRoleRelation) {
                roles3 = elementRoleRelation[1];
              } else {
                roles3 = [];
              }
              var isUnique = true;
              for (var _i = 0; _i < roles3.length; _i++) {
                if (roles3[_i] === key) {
                  isUnique = false;
                  break;
                }
              }
              if (isUnique) {
                roles3.push(key);
              }
              if (!elementRoleRelation) {
                elementRoles3.push([concept, roles3]);
              }
            }
          }
        }, "_loop");
        for (k2 = 0; k2 < concepts.length; k2++) {
          _loop();
        }
      }
    }
    var key;
    var role;
    var concepts;
    var _loop;
    var k2;
    var i2;
    var elementRoleMap = {
      entries: /* @__PURE__ */ __name(function entries() {
        return elementRoles3;
      }, "entries"),
      forEach: /* @__PURE__ */ __name(function forEach(fn3) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        for (var _i2 = 0, _elementRoles = elementRoles3; _i2 < _elementRoles.length; _i2++) {
          var _elementRoles$_i = _slicedToArray(_elementRoles[_i2], 2), _key = _elementRoles$_i[0], values = _elementRoles$_i[1];
          fn3.call(thisArg, values, _key, elementRoles3);
        }
      }, "forEach"),
      get: /* @__PURE__ */ __name(function get3(key2) {
        var item = elementRoles3.filter(function(tuple) {
          return key2.name === tuple[0].name && ariaRoleRelationConceptAttributeEquals(key2.attributes, tuple[0].attributes);
        })[0];
        return item && item[1];
      }, "get"),
      has: /* @__PURE__ */ __name(function has(key2) {
        return !!elementRoleMap.get(key2);
      }, "has"),
      keys: /* @__PURE__ */ __name(function keys3() {
        return elementRoles3.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key2 = _ref2[0];
          return key2;
        });
      }, "keys"),
      values: /* @__PURE__ */ __name(function values() {
        return elementRoles3.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }, "values")
    };
    function ariaRoleRelationConceptEquals(a2, b2) {
      return a2.name === b2.name && ariaRoleRelationConstraintsEquals(a2.constraints, b2.constraints) && ariaRoleRelationConceptAttributeEquals(a2.attributes, b2.attributes);
    }
    __name(ariaRoleRelationConceptEquals, "ariaRoleRelationConceptEquals");
    function ariaRoleRelationConstraintsEquals(a2, b2) {
      if (a2 === void 0 && b2 !== void 0) {
        return false;
      }
      if (a2 !== void 0 && b2 === void 0) {
        return false;
      }
      if (a2 !== void 0 && b2 !== void 0) {
        if (a2.length !== b2.length) {
          return false;
        }
        for (var _i3 = 0; _i3 < a2.length; _i3++) {
          if (a2[_i3] !== b2[_i3]) {
            return false;
          }
        }
      }
      return true;
    }
    __name(ariaRoleRelationConstraintsEquals, "ariaRoleRelationConstraintsEquals");
    function ariaRoleRelationConceptAttributeEquals(a2, b2) {
      if (a2 === void 0 && b2 !== void 0) {
        return false;
      }
      if (a2 !== void 0 && b2 === void 0) {
        return false;
      }
      if (a2 !== void 0 && b2 !== void 0) {
        if (a2.length !== b2.length) {
          return false;
        }
        for (var _i4 = 0; _i4 < a2.length; _i4++) {
          if (a2[_i4].name !== b2[_i4].name || a2[_i4].value !== b2[_i4].value) {
            return false;
          }
          if (a2[_i4].constraints === void 0 && b2[_i4].constraints !== void 0) {
            return false;
          }
          if (a2[_i4].constraints !== void 0 && b2[_i4].constraints === void 0) {
            return false;
          }
          if (a2[_i4].constraints !== void 0 && b2[_i4].constraints !== void 0) {
            if (a2[_i4].constraints.length !== b2[_i4].constraints.length) {
              return false;
            }
            for (var j2 = 0; j2 < a2[_i4].constraints.length; j2++) {
              if (a2[_i4].constraints[j2] !== b2[_i4].constraints[j2]) {
                return false;
              }
            }
          }
        }
      }
      return true;
    }
    __name(ariaRoleRelationConceptAttributeEquals, "ariaRoleRelationConceptAttributeEquals");
    var _default = exports.default = (0, _iterationDecorator.default)(elementRoleMap, elementRoleMap.entries());
  }
});

// ../node_modules/aria-query/lib/roleElementMap.js
var require_roleElementMap = __commonJS({
  "../node_modules/aria-query/lib/roleElementMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator());
    var _rolesMap = _interopRequireDefault(require_rolesMap());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    function _slicedToArray(r2, e2) {
      return _arrayWithHoles(r2) || _iterableToArrayLimit(r2, e2) || _unsupportedIterableToArray(r2, e2) || _nonIterableRest();
    }
    __name(_slicedToArray, "_slicedToArray");
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    __name(_nonIterableRest, "_nonIterableRest");
    function _unsupportedIterableToArray(r2, a2) {
      if (r2) {
        if ("string" == typeof r2) return _arrayLikeToArray(r2, a2);
        var t2 = {}.toString.call(r2).slice(8, -1);
        return "Object" === t2 && r2.constructor && (t2 = r2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray(r2, a2) : void 0;
      }
    }
    __name(_unsupportedIterableToArray, "_unsupportedIterableToArray");
    function _arrayLikeToArray(r2, a2) {
      (null == a2 || a2 > r2.length) && (a2 = r2.length);
      for (var e2 = 0, n2 = Array(a2); e2 < a2; e2++) n2[e2] = r2[e2];
      return n2;
    }
    __name(_arrayLikeToArray, "_arrayLikeToArray");
    function _iterableToArrayLimit(r2, l2) {
      var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
      if (null != t2) {
        var e2, n2, i3, u3, a2 = [], f4 = true, o2 = false;
        try {
          if (i3 = (t2 = t2.call(r2)).next, 0 === l2) {
            if (Object(t2) !== t2) return;
            f4 = false;
          } else for (; !(f4 = (e2 = i3.call(t2)).done) && (a2.push(e2.value), a2.length !== l2); f4 = true) ;
        } catch (r3) {
          o2 = true, n2 = r3;
        } finally {
          try {
            if (!f4 && null != t2.return && (u3 = t2.return(), Object(u3) !== u3)) return;
          } finally {
            if (o2) throw n2;
          }
        }
        return a2;
      }
    }
    __name(_iterableToArrayLimit, "_iterableToArrayLimit");
    function _arrayWithHoles(r2) {
      if (Array.isArray(r2)) return r2;
    }
    __name(_arrayWithHoles, "_arrayWithHoles");
    var roleElement = [];
    var keys2 = _rolesMap.default.keys();
    for (i2 = 0; i2 < keys2.length; i2++) {
      key = keys2[i2];
      role = _rolesMap.default.get(key);
      relationConcepts = [];
      if (role) {
        concepts = [].concat(role.baseConcepts, role.relatedConcepts);
        for (k2 = 0; k2 < concepts.length; k2++) {
          relation = concepts[k2];
          if (relation.module === "HTML") {
            concept = relation.concept;
            if (concept != null) {
              relationConcepts.push(concept);
            }
          }
        }
        if (relationConcepts.length > 0) {
          roleElement.push([key, relationConcepts]);
        }
      }
    }
    var key;
    var role;
    var relationConcepts;
    var concepts;
    var relation;
    var concept;
    var k2;
    var i2;
    var roleElementMap = {
      entries: /* @__PURE__ */ __name(function entries() {
        return roleElement;
      }, "entries"),
      forEach: /* @__PURE__ */ __name(function forEach(fn3) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        for (var _i = 0, _roleElement = roleElement; _i < _roleElement.length; _i++) {
          var _roleElement$_i = _slicedToArray(_roleElement[_i], 2), _key = _roleElement$_i[0], values = _roleElement$_i[1];
          fn3.call(thisArg, values, _key, roleElement);
        }
      }, "forEach"),
      get: /* @__PURE__ */ __name(function get3(key2) {
        var item = roleElement.filter(function(tuple) {
          return tuple[0] === key2 ? true : false;
        })[0];
        return item && item[1];
      }, "get"),
      has: /* @__PURE__ */ __name(function has(key2) {
        return !!roleElementMap.get(key2);
      }, "has"),
      keys: /* @__PURE__ */ __name(function keys3() {
        return roleElement.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key2 = _ref2[0];
          return key2;
        });
      }, "keys"),
      values: /* @__PURE__ */ __name(function values() {
        return roleElement.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }, "values")
    };
    var _default = exports.default = (0, _iterationDecorator.default)(roleElementMap, roleElementMap.entries());
  }
});

// ../node_modules/aria-query/lib/index.js
var require_lib = __commonJS({
  "../node_modules/aria-query/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.roles = exports.roleElements = exports.elementRoles = exports.dom = exports.aria = void 0;
    var _ariaPropsMap = _interopRequireDefault(require_ariaPropsMap());
    var _domMap = _interopRequireDefault(require_domMap());
    var _rolesMap = _interopRequireDefault(require_rolesMap());
    var _elementRoleMap = _interopRequireDefault(require_elementRoleMap());
    var _roleElementMap = _interopRequireDefault(require_roleElementMap());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var aria = exports.aria = _ariaPropsMap.default;
    var dom = exports.dom = _domMap.default;
    var roles3 = exports.roles = _rolesMap.default;
    var elementRoles3 = exports.elementRoles = _elementRoleMap.default;
    var roleElements2 = exports.roleElements = _roleElementMap.default;
  }
});

// ../node_modules/picocolors/picocolors.browser.js
var require_picocolors_browser = __commonJS({
  "../node_modules/picocolors/picocolors.browser.js"(exports, module2) {
    var x2 = String;
    var create = /* @__PURE__ */ __name(function() {
      return { isColorSupported: false, reset: x2, bold: x2, dim: x2, italic: x2, underline: x2, inverse: x2, hidden: x2, strikethrough: x2, black: x2, red: x2, green: x2, yellow: x2, blue: x2, magenta: x2, cyan: x2, white: x2, gray: x2, bgBlack: x2, bgRed: x2, bgGreen: x2, bgYellow: x2, bgBlue: x2, bgMagenta: x2, bgCyan: x2, bgWhite: x2, blackBright: x2, redBright: x2, greenBright: x2, yellowBright: x2, blueBright: x2, magentaBright: x2, cyanBright: x2, whiteBright: x2, bgBlackBright: x2, bgRedBright: x2, bgGreenBright: x2, bgYellowBright: x2, bgBlueBright: x2, bgMagentaBright: x2, bgCyanBright: x2, bgWhiteBright: x2 };
    }, "create");
    module2.exports = create();
    module2.exports.createColors = create;
  }
});

// ../node_modules/css.escape/css.escape.js
var require_css_escape = __commonJS({
  "../node_modules/css.escape/css.escape.js"(exports, module2) {
    (function(root2, factory) {
      if (typeof exports == "object") {
        module2.exports = factory(root2);
      } else if (typeof define == "function" && define.amd) {
        define([], factory.bind(root2, root2));
      } else {
        factory(root2);
      }
    })(typeof global != "undefined" ? global : exports, function(root2) {
      if (root2.CSS && root2.CSS.escape) {
        return root2.CSS.escape;
      }
      var cssEscape = /* @__PURE__ */ __name(function(value) {
        if (arguments.length == 0) {
          throw new TypeError("`CSS.escape` requires an argument.");
        }
        var string = String(value);
        var length = string.length;
        var index2 = -1;
        var codeUnit;
        var result = "";
        var firstCodeUnit = string.charCodeAt(0);
        while (++index2 < length) {
          codeUnit = string.charCodeAt(index2);
          if (codeUnit == 0) {
            result += "\uFFFD";
            continue;
          }
          if (
            // If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
            // U+007F, []
            codeUnit >= 1 && codeUnit <= 31 || codeUnit == 127 || // If the character is the first character and is in the range [0-9]
            // (U+0030 to U+0039), []
            index2 == 0 && codeUnit >= 48 && codeUnit <= 57 || // If the character is the second character and is in the range [0-9]
            // (U+0030 to U+0039) and the first character is a `-` (U+002D), []
            index2 == 1 && codeUnit >= 48 && codeUnit <= 57 && firstCodeUnit == 45
          ) {
            result += "\\" + codeUnit.toString(16) + " ";
            continue;
          }
          if (
            // If the character is the first character and is a `-` (U+002D), and
            // there is no second character, []
            index2 == 0 && length == 1 && codeUnit == 45
          ) {
            result += "\\" + string.charAt(index2);
            continue;
          }
          if (codeUnit >= 128 || codeUnit == 45 || codeUnit == 95 || codeUnit >= 48 && codeUnit <= 57 || codeUnit >= 65 && codeUnit <= 90 || codeUnit >= 97 && codeUnit <= 122) {
            result += string.charAt(index2);
            continue;
          }
          result += "\\" + string.charAt(index2);
        }
        return result;
      }, "cssEscape");
      if (!root2.CSS) {
        root2.CSS = {};
      }
      root2.CSS.escape = cssEscape;
      return cssEscape;
    });
  }
});

// ../node_modules/pretty-format/node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS({
  "../node_modules/pretty-format/node_modules/ansi-styles/index.js"(exports, module2) {
    "use strict";
    var ANSI_BACKGROUND_OFFSET = 10;
    var wrapAnsi256 = /* @__PURE__ */ __name((offset2 = 0) => (code) => `\x1B[${38 + offset2};5;${code}m`, "wrapAnsi256");
    var wrapAnsi16m = /* @__PURE__ */ __name((offset2 = 0) => (red, green, blue) => `\x1B[${38 + offset2};2;${red};${green};${blue}m`, "wrapAnsi16m");
    function assembleStyles() {
      const codes = /* @__PURE__ */ new Map();
      const styles3 = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          overline: [53, 55],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          // Bright color
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles3.color.gray = styles3.color.blackBright;
      styles3.bgColor.bgGray = styles3.bgColor.bgBlackBright;
      styles3.color.grey = styles3.color.blackBright;
      styles3.bgColor.bgGrey = styles3.bgColor.bgBlackBright;
      for (const [groupName, group] of Object.entries(styles3)) {
        for (const [styleName, style] of Object.entries(group)) {
          styles3[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`
          };
          group[styleName] = styles3[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles3, groupName, {
          value: group,
          enumerable: false
        });
      }
      Object.defineProperty(styles3, "codes", {
        value: codes,
        enumerable: false
      });
      styles3.color.close = "\x1B[39m";
      styles3.bgColor.close = "\x1B[49m";
      styles3.color.ansi256 = wrapAnsi256();
      styles3.color.ansi16m = wrapAnsi16m();
      styles3.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
      styles3.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
      Object.defineProperties(styles3, {
        rgbToAnsi256: {
          value: /* @__PURE__ */ __name((red, green, blue) => {
            if (red === green && green === blue) {
              if (red < 8) {
                return 16;
              }
              if (red > 248) {
                return 231;
              }
              return Math.round((red - 8) / 247 * 24) + 232;
            }
            return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
          }, "value"),
          enumerable: false
        },
        hexToRgb: {
          value: /* @__PURE__ */ __name((hex3) => {
            const matches5 = /(?<colorString>[a-f\d]{6}|[a-f\d]{3})/i.exec(hex3.toString(16));
            if (!matches5) {
              return [0, 0, 0];
            }
            let { colorString } = matches5.groups;
            if (colorString.length === 3) {
              colorString = colorString.split("").map((character) => character + character).join("");
            }
            const integer = Number.parseInt(colorString, 16);
            return [
              integer >> 16 & 255,
              integer >> 8 & 255,
              integer & 255
            ];
          }, "value"),
          enumerable: false
        },
        hexToAnsi256: {
          value: /* @__PURE__ */ __name((hex3) => styles3.rgbToAnsi256(...styles3.hexToRgb(hex3)), "value"),
          enumerable: false
        }
      });
      return styles3;
    }
    __name(assembleStyles, "assembleStyles");
    Object.defineProperty(module2, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// ../node_modules/pretty-format/build/collections.js
var require_collections = __commonJS({
  "../node_modules/pretty-format/build/collections.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.printIteratorEntries = printIteratorEntries2;
    exports.printIteratorValues = printIteratorValues2;
    exports.printListItems = printListItems2;
    exports.printObjectProperties = printObjectProperties2;
    var getKeysOfEnumerableProperties2 = /* @__PURE__ */ __name((object, compareKeys) => {
      const keys2 = Object.keys(object).sort(compareKeys);
      if (Object.getOwnPropertySymbols) {
        Object.getOwnPropertySymbols(object).forEach((symbol) => {
          if (Object.getOwnPropertyDescriptor(object, symbol).enumerable) {
            keys2.push(symbol);
          }
        });
      }
      return keys2;
    }, "getKeysOfEnumerableProperties");
    function printIteratorEntries2(iterator, config4, indentation, depth, refs, printer2, separator = ": ") {
      let result = "";
      let current = iterator.next();
      if (!current.done) {
        result += config4.spacingOuter;
        const indentationNext = indentation + config4.indent;
        while (!current.done) {
          const name = printer2(
            current.value[0],
            config4,
            indentationNext,
            depth,
            refs
          );
          const value = printer2(
            current.value[1],
            config4,
            indentationNext,
            depth,
            refs
          );
          result += indentationNext + name + separator + value;
          current = iterator.next();
          if (!current.done) {
            result += "," + config4.spacingInner;
          } else if (!config4.min) {
            result += ",";
          }
        }
        result += config4.spacingOuter + indentation;
      }
      return result;
    }
    __name(printIteratorEntries2, "printIteratorEntries");
    function printIteratorValues2(iterator, config4, indentation, depth, refs, printer2) {
      let result = "";
      let current = iterator.next();
      if (!current.done) {
        result += config4.spacingOuter;
        const indentationNext = indentation + config4.indent;
        while (!current.done) {
          result += indentationNext + printer2(current.value, config4, indentationNext, depth, refs);
          current = iterator.next();
          if (!current.done) {
            result += "," + config4.spacingInner;
          } else if (!config4.min) {
            result += ",";
          }
        }
        result += config4.spacingOuter + indentation;
      }
      return result;
    }
    __name(printIteratorValues2, "printIteratorValues");
    function printListItems2(list, config4, indentation, depth, refs, printer2) {
      let result = "";
      if (list.length) {
        result += config4.spacingOuter;
        const indentationNext = indentation + config4.indent;
        for (let i2 = 0; i2 < list.length; i2++) {
          result += indentationNext;
          if (i2 in list) {
            result += printer2(list[i2], config4, indentationNext, depth, refs);
          }
          if (i2 < list.length - 1) {
            result += "," + config4.spacingInner;
          } else if (!config4.min) {
            result += ",";
          }
        }
        result += config4.spacingOuter + indentation;
      }
      return result;
    }
    __name(printListItems2, "printListItems");
    function printObjectProperties2(val, config4, indentation, depth, refs, printer2) {
      let result = "";
      const keys2 = getKeysOfEnumerableProperties2(val, config4.compareKeys);
      if (keys2.length) {
        result += config4.spacingOuter;
        const indentationNext = indentation + config4.indent;
        for (let i2 = 0; i2 < keys2.length; i2++) {
          const key = keys2[i2];
          const name = printer2(key, config4, indentationNext, depth, refs);
          const value = printer2(val[key], config4, indentationNext, depth, refs);
          result += indentationNext + name + ": " + value;
          if (i2 < keys2.length - 1) {
            result += "," + config4.spacingInner;
          } else if (!config4.min) {
            result += ",";
          }
        }
        result += config4.spacingOuter + indentation;
      }
      return result;
    }
    __name(printObjectProperties2, "printObjectProperties");
  }
});

// ../node_modules/pretty-format/build/plugins/AsymmetricMatcher.js
var require_AsymmetricMatcher = __commonJS({
  "../node_modules/pretty-format/build/plugins/AsymmetricMatcher.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.test = exports.serialize = exports.default = void 0;
    var _collections = require_collections();
    var global2 = function() {
      if (typeof globalThis !== "undefined") {
        return globalThis;
      } else if (typeof global2 !== "undefined") {
        return global2;
      } else if (typeof self !== "undefined") {
        return self;
      } else if (typeof window !== "undefined") {
        return window;
      } else {
        return Function("return this")();
      }
    }();
    var Symbol3 = global2["jest-symbol-do-not-touch"] || global2.Symbol;
    var asymmetricMatcher2 = typeof Symbol3 === "function" && Symbol3.for ? Symbol3.for("jest.asymmetricMatcher") : 1267621;
    var SPACE2 = " ";
    var serialize2 = /* @__PURE__ */ __name((val, config4, indentation, depth, refs, printer2) => {
      const stringedValue = val.toString();
      if (stringedValue === "ArrayContaining" || stringedValue === "ArrayNotContaining") {
        if (++depth > config4.maxDepth) {
          return "[" + stringedValue + "]";
        }
        return stringedValue + SPACE2 + "[" + (0, _collections.printListItems)(
          val.sample,
          config4,
          indentation,
          depth,
          refs,
          printer2
        ) + "]";
      }
      if (stringedValue === "ObjectContaining" || stringedValue === "ObjectNotContaining") {
        if (++depth > config4.maxDepth) {
          return "[" + stringedValue + "]";
        }
        return stringedValue + SPACE2 + "{" + (0, _collections.printObjectProperties)(
          val.sample,
          config4,
          indentation,
          depth,
          refs,
          printer2
        ) + "}";
      }
      if (stringedValue === "StringMatching" || stringedValue === "StringNotMatching") {
        return stringedValue + SPACE2 + printer2(val.sample, config4, indentation, depth, refs);
      }
      if (stringedValue === "StringContaining" || stringedValue === "StringNotContaining") {
        return stringedValue + SPACE2 + printer2(val.sample, config4, indentation, depth, refs);
      }
      return val.toAsymmetricMatcher();
    }, "serialize");
    exports.serialize = serialize2;
    var test3 = /* @__PURE__ */ __name((val) => val && val.$$typeof === asymmetricMatcher2, "test");
    exports.test = test3;
    var plugin2 = {
      serialize: serialize2,
      test: test3
    };
    var _default = plugin2;
    exports.default = _default;
  }
});

// ../node_modules/pretty-format/node_modules/ansi-regex/index.js
var require_ansi_regex = __commonJS({
  "../node_modules/pretty-format/node_modules/ansi-regex/index.js"(exports, module2) {
    "use strict";
    module2.exports = ({ onlyFirst = false } = {}) => {
      const pattern = [
        "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
        "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
      ].join("|");
      return new RegExp(pattern, onlyFirst ? void 0 : "g");
    };
  }
});

// ../node_modules/pretty-format/build/plugins/ConvertAnsi.js
var require_ConvertAnsi = __commonJS({
  "../node_modules/pretty-format/build/plugins/ConvertAnsi.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.test = exports.serialize = exports.default = void 0;
    var _ansiRegex = _interopRequireDefault(require_ansi_regex());
    var _ansiStyles = _interopRequireDefault(require_ansi_styles());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var toHumanReadableAnsi = /* @__PURE__ */ __name((text) => text.replace((0, _ansiRegex.default)(), (match) => {
      switch (match) {
        case _ansiStyles.default.red.close:
        case _ansiStyles.default.green.close:
        case _ansiStyles.default.cyan.close:
        case _ansiStyles.default.gray.close:
        case _ansiStyles.default.white.close:
        case _ansiStyles.default.yellow.close:
        case _ansiStyles.default.bgRed.close:
        case _ansiStyles.default.bgGreen.close:
        case _ansiStyles.default.bgYellow.close:
        case _ansiStyles.default.inverse.close:
        case _ansiStyles.default.dim.close:
        case _ansiStyles.default.bold.close:
        case _ansiStyles.default.reset.open:
        case _ansiStyles.default.reset.close:
          return "</>";
        case _ansiStyles.default.red.open:
          return "<red>";
        case _ansiStyles.default.green.open:
          return "<green>";
        case _ansiStyles.default.cyan.open:
          return "<cyan>";
        case _ansiStyles.default.gray.open:
          return "<gray>";
        case _ansiStyles.default.white.open:
          return "<white>";
        case _ansiStyles.default.yellow.open:
          return "<yellow>";
        case _ansiStyles.default.bgRed.open:
          return "<bgRed>";
        case _ansiStyles.default.bgGreen.open:
          return "<bgGreen>";
        case _ansiStyles.default.bgYellow.open:
          return "<bgYellow>";
        case _ansiStyles.default.inverse.open:
          return "<inverse>";
        case _ansiStyles.default.dim.open:
          return "<dim>";
        case _ansiStyles.default.bold.open:
          return "<bold>";
        default:
          return "";
      }
    }), "toHumanReadableAnsi");
    var test3 = /* @__PURE__ */ __name((val) => typeof val === "string" && !!val.match((0, _ansiRegex.default)()), "test");
    exports.test = test3;
    var serialize2 = /* @__PURE__ */ __name((val, config4, indentation, depth, refs, printer2) => printer2(toHumanReadableAnsi(val), config4, indentation, depth, refs), "serialize");
    exports.serialize = serialize2;
    var plugin2 = {
      serialize: serialize2,
      test: test3
    };
    var _default = plugin2;
    exports.default = _default;
  }
});

// ../node_modules/pretty-format/build/plugins/DOMCollection.js
var require_DOMCollection = __commonJS({
  "../node_modules/pretty-format/build/plugins/DOMCollection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.test = exports.serialize = exports.default = void 0;
    var _collections = require_collections();
    var SPACE2 = " ";
    var OBJECT_NAMES2 = ["DOMStringMap", "NamedNodeMap"];
    var ARRAY_REGEXP2 = /^(HTML\w*Collection|NodeList)$/;
    var testName2 = /* @__PURE__ */ __name((name) => OBJECT_NAMES2.indexOf(name) !== -1 || ARRAY_REGEXP2.test(name), "testName");
    var test3 = /* @__PURE__ */ __name((val) => val && val.constructor && !!val.constructor.name && testName2(val.constructor.name), "test");
    exports.test = test3;
    var isNamedNodeMap2 = /* @__PURE__ */ __name((collection) => collection.constructor.name === "NamedNodeMap", "isNamedNodeMap");
    var serialize2 = /* @__PURE__ */ __name((collection, config4, indentation, depth, refs, printer2) => {
      const name = collection.constructor.name;
      if (++depth > config4.maxDepth) {
        return "[" + name + "]";
      }
      return (config4.min ? "" : name + SPACE2) + (OBJECT_NAMES2.indexOf(name) !== -1 ? "{" + (0, _collections.printObjectProperties)(
        isNamedNodeMap2(collection) ? Array.from(collection).reduce((props, attribute) => {
          props[attribute.name] = attribute.value;
          return props;
        }, {}) : { ...collection },
        config4,
        indentation,
        depth,
        refs,
        printer2
      ) + "}" : "[" + (0, _collections.printListItems)(
        Array.from(collection),
        config4,
        indentation,
        depth,
        refs,
        printer2
      ) + "]");
    }, "serialize");
    exports.serialize = serialize2;
    var plugin2 = {
      serialize: serialize2,
      test: test3
    };
    var _default = plugin2;
    exports.default = _default;
  }
});

// ../node_modules/pretty-format/build/plugins/lib/escapeHTML.js
var require_escapeHTML = __commonJS({
  "../node_modules/pretty-format/build/plugins/lib/escapeHTML.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = escapeHTML3;
    function escapeHTML3(str2) {
      return str2.replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }
    __name(escapeHTML3, "escapeHTML");
  }
});

// ../node_modules/pretty-format/build/plugins/lib/markup.js
var require_markup = __commonJS({
  "../node_modules/pretty-format/build/plugins/lib/markup.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.printText = exports.printProps = exports.printElementAsLeaf = exports.printElement = exports.printComment = exports.printChildren = void 0;
    var _escapeHTML = _interopRequireDefault(require_escapeHTML());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var printProps3 = /* @__PURE__ */ __name((keys2, props, config4, indentation, depth, refs, printer2) => {
      const indentationNext = indentation + config4.indent;
      const colors3 = config4.colors;
      return keys2.map((key) => {
        const value = props[key];
        let printed = printer2(value, config4, indentationNext, depth, refs);
        if (typeof value !== "string") {
          if (printed.indexOf("\n") !== -1) {
            printed = config4.spacingOuter + indentationNext + printed + config4.spacingOuter + indentation;
          }
          printed = "{" + printed + "}";
        }
        return config4.spacingInner + indentation + colors3.prop.open + key + colors3.prop.close + "=" + colors3.value.open + printed + colors3.value.close;
      }).join("");
    }, "printProps");
    exports.printProps = printProps3;
    var printChildren3 = /* @__PURE__ */ __name((children, config4, indentation, depth, refs, printer2) => children.map(
      (child) => config4.spacingOuter + indentation + (typeof child === "string" ? printText3(child, config4) : printer2(child, config4, indentation, depth, refs))
    ).join(""), "printChildren");
    exports.printChildren = printChildren3;
    var printText3 = /* @__PURE__ */ __name((text, config4) => {
      const contentColor = config4.colors.content;
      return contentColor.open + (0, _escapeHTML.default)(text) + contentColor.close;
    }, "printText");
    exports.printText = printText3;
    var printComment3 = /* @__PURE__ */ __name((comment, config4) => {
      const commentColor = config4.colors.comment;
      return commentColor.open + "<!--" + (0, _escapeHTML.default)(comment) + "-->" + commentColor.close;
    }, "printComment");
    exports.printComment = printComment3;
    var printElement3 = /* @__PURE__ */ __name((type5, printedProps, printedChildren, config4, indentation) => {
      const tagColor = config4.colors.tag;
      return tagColor.open + "<" + type5 + (printedProps && tagColor.close + printedProps + config4.spacingOuter + indentation + tagColor.open) + (printedChildren ? ">" + tagColor.close + printedChildren + config4.spacingOuter + indentation + tagColor.open + "</" + type5 : (printedProps && !config4.min ? "" : " ") + "/") + ">" + tagColor.close;
    }, "printElement");
    exports.printElement = printElement3;
    var printElementAsLeaf3 = /* @__PURE__ */ __name((type5, config4) => {
      const tagColor = config4.colors.tag;
      return tagColor.open + "<" + type5 + tagColor.close + " \u2026" + tagColor.open + " />" + tagColor.close;
    }, "printElementAsLeaf");
    exports.printElementAsLeaf = printElementAsLeaf3;
  }
});

// ../node_modules/pretty-format/build/plugins/DOMElement.js
var require_DOMElement = __commonJS({
  "../node_modules/pretty-format/build/plugins/DOMElement.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.test = exports.serialize = exports.default = void 0;
    var _markup = require_markup();
    var ELEMENT_NODE3 = 1;
    var TEXT_NODE3 = 3;
    var COMMENT_NODE3 = 8;
    var FRAGMENT_NODE3 = 11;
    var ELEMENT_REGEXP3 = /^((HTML|SVG)\w*)?Element$/;
    var testHasAttribute2 = /* @__PURE__ */ __name((val) => {
      try {
        return typeof val.hasAttribute === "function" && val.hasAttribute("is");
      } catch {
        return false;
      }
    }, "testHasAttribute");
    var testNode3 = /* @__PURE__ */ __name((val) => {
      const constructorName = val.constructor.name;
      const { nodeType, tagName } = val;
      const isCustomElement3 = typeof tagName === "string" && tagName.includes("-") || testHasAttribute2(val);
      return nodeType === ELEMENT_NODE3 && (ELEMENT_REGEXP3.test(constructorName) || isCustomElement3) || nodeType === TEXT_NODE3 && constructorName === "Text" || nodeType === COMMENT_NODE3 && constructorName === "Comment" || nodeType === FRAGMENT_NODE3 && constructorName === "DocumentFragment";
    }, "testNode");
    var test3 = /* @__PURE__ */ __name((val) => {
      var _val$constructor;
      return (val === null || val === void 0 ? void 0 : (_val$constructor = val.constructor) === null || _val$constructor === void 0 ? void 0 : _val$constructor.name) && testNode3(val);
    }, "test");
    exports.test = test3;
    function nodeIsText3(node) {
      return node.nodeType === TEXT_NODE3;
    }
    __name(nodeIsText3, "nodeIsText");
    function nodeIsComment3(node) {
      return node.nodeType === COMMENT_NODE3;
    }
    __name(nodeIsComment3, "nodeIsComment");
    function nodeIsFragment3(node) {
      return node.nodeType === FRAGMENT_NODE3;
    }
    __name(nodeIsFragment3, "nodeIsFragment");
    var serialize2 = /* @__PURE__ */ __name((node, config4, indentation, depth, refs, printer2) => {
      if (nodeIsText3(node)) {
        return (0, _markup.printText)(node.data, config4);
      }
      if (nodeIsComment3(node)) {
        return (0, _markup.printComment)(node.data, config4);
      }
      const type5 = nodeIsFragment3(node) ? "DocumentFragment" : node.tagName.toLowerCase();
      if (++depth > config4.maxDepth) {
        return (0, _markup.printElementAsLeaf)(type5, config4);
      }
      return (0, _markup.printElement)(
        type5,
        (0, _markup.printProps)(
          nodeIsFragment3(node) ? [] : Array.from(node.attributes).map((attr) => attr.name).sort(),
          nodeIsFragment3(node) ? {} : Array.from(node.attributes).reduce((props, attribute) => {
            props[attribute.name] = attribute.value;
            return props;
          }, {}),
          config4,
          indentation + config4.indent,
          depth,
          refs,
          printer2
        ),
        (0, _markup.printChildren)(
          Array.prototype.slice.call(node.childNodes || node.children),
          config4,
          indentation + config4.indent,
          depth,
          refs,
          printer2
        ),
        config4,
        indentation
      );
    }, "serialize");
    exports.serialize = serialize2;
    var plugin2 = {
      serialize: serialize2,
      test: test3
    };
    var _default = plugin2;
    exports.default = _default;
  }
});

// ../node_modules/pretty-format/build/plugins/Immutable.js
var require_Immutable = __commonJS({
  "../node_modules/pretty-format/build/plugins/Immutable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.test = exports.serialize = exports.default = void 0;
    var _collections = require_collections();
    var IS_ITERABLE_SENTINEL2 = "@@__IMMUTABLE_ITERABLE__@@";
    var IS_LIST_SENTINEL3 = "@@__IMMUTABLE_LIST__@@";
    var IS_KEYED_SENTINEL3 = "@@__IMMUTABLE_KEYED__@@";
    var IS_MAP_SENTINEL2 = "@@__IMMUTABLE_MAP__@@";
    var IS_ORDERED_SENTINEL3 = "@@__IMMUTABLE_ORDERED__@@";
    var IS_RECORD_SENTINEL2 = "@@__IMMUTABLE_RECORD__@@";
    var IS_SEQ_SENTINEL2 = "@@__IMMUTABLE_SEQ__@@";
    var IS_SET_SENTINEL3 = "@@__IMMUTABLE_SET__@@";
    var IS_STACK_SENTINEL2 = "@@__IMMUTABLE_STACK__@@";
    var getImmutableName2 = /* @__PURE__ */ __name((name) => "Immutable." + name, "getImmutableName");
    var printAsLeaf2 = /* @__PURE__ */ __name((name) => "[" + name + "]", "printAsLeaf");
    var SPACE2 = " ";
    var LAZY2 = "\u2026";
    var printImmutableEntries2 = /* @__PURE__ */ __name((val, config4, indentation, depth, refs, printer2, type5) => ++depth > config4.maxDepth ? printAsLeaf2(getImmutableName2(type5)) : getImmutableName2(type5) + SPACE2 + "{" + (0, _collections.printIteratorEntries)(
      val.entries(),
      config4,
      indentation,
      depth,
      refs,
      printer2
    ) + "}", "printImmutableEntries");
    function getRecordEntries2(val) {
      let i2 = 0;
      return {
        next() {
          if (i2 < val._keys.length) {
            const key = val._keys[i2++];
            return {
              done: false,
              value: [key, val.get(key)]
            };
          }
          return {
            done: true,
            value: void 0
          };
        }
      };
    }
    __name(getRecordEntries2, "getRecordEntries");
    var printImmutableRecord2 = /* @__PURE__ */ __name((val, config4, indentation, depth, refs, printer2) => {
      const name = getImmutableName2(val._name || "Record");
      return ++depth > config4.maxDepth ? printAsLeaf2(name) : name + SPACE2 + "{" + (0, _collections.printIteratorEntries)(
        getRecordEntries2(val),
        config4,
        indentation,
        depth,
        refs,
        printer2
      ) + "}";
    }, "printImmutableRecord");
    var printImmutableSeq2 = /* @__PURE__ */ __name((val, config4, indentation, depth, refs, printer2) => {
      const name = getImmutableName2("Seq");
      if (++depth > config4.maxDepth) {
        return printAsLeaf2(name);
      }
      if (val[IS_KEYED_SENTINEL3]) {
        return name + SPACE2 + "{" + // from Immutable collection of entries or from ECMAScript object
        (val._iter || val._object ? (0, _collections.printIteratorEntries)(
          val.entries(),
          config4,
          indentation,
          depth,
          refs,
          printer2
        ) : LAZY2) + "}";
      }
      return name + SPACE2 + "[" + (val._iter || // from Immutable collection of values
      val._array || // from ECMAScript array
      val._collection || // from ECMAScript collection in immutable v4
      val._iterable ? (0, _collections.printIteratorValues)(
        val.values(),
        config4,
        indentation,
        depth,
        refs,
        printer2
      ) : LAZY2) + "]";
    }, "printImmutableSeq");
    var printImmutableValues2 = /* @__PURE__ */ __name((val, config4, indentation, depth, refs, printer2, type5) => ++depth > config4.maxDepth ? printAsLeaf2(getImmutableName2(type5)) : getImmutableName2(type5) + SPACE2 + "[" + (0, _collections.printIteratorValues)(
      val.values(),
      config4,
      indentation,
      depth,
      refs,
      printer2
    ) + "]", "printImmutableValues");
    var serialize2 = /* @__PURE__ */ __name((val, config4, indentation, depth, refs, printer2) => {
      if (val[IS_MAP_SENTINEL2]) {
        return printImmutableEntries2(
          val,
          config4,
          indentation,
          depth,
          refs,
          printer2,
          val[IS_ORDERED_SENTINEL3] ? "OrderedMap" : "Map"
        );
      }
      if (val[IS_LIST_SENTINEL3]) {
        return printImmutableValues2(
          val,
          config4,
          indentation,
          depth,
          refs,
          printer2,
          "List"
        );
      }
      if (val[IS_SET_SENTINEL3]) {
        return printImmutableValues2(
          val,
          config4,
          indentation,
          depth,
          refs,
          printer2,
          val[IS_ORDERED_SENTINEL3] ? "OrderedSet" : "Set"
        );
      }
      if (val[IS_STACK_SENTINEL2]) {
        return printImmutableValues2(
          val,
          config4,
          indentation,
          depth,
          refs,
          printer2,
          "Stack"
        );
      }
      if (val[IS_SEQ_SENTINEL2]) {
        return printImmutableSeq2(val, config4, indentation, depth, refs, printer2);
      }
      return printImmutableRecord2(val, config4, indentation, depth, refs, printer2);
    }, "serialize");
    exports.serialize = serialize2;
    var test3 = /* @__PURE__ */ __name((val) => val && (val[IS_ITERABLE_SENTINEL2] === true || val[IS_RECORD_SENTINEL2] === true), "test");
    exports.test = test3;
    var plugin2 = {
      serialize: serialize2,
      test: test3
    };
    var _default = plugin2;
    exports.default = _default;
  }
});

// ../node_modules/pretty-format/node_modules/react-is/cjs/react-is.production.min.js
var require_react_is_production_min = __commonJS({
  "../node_modules/pretty-format/node_modules/react-is/cjs/react-is.production.min.js"(exports) {
    "use strict";
    var b2 = 60103;
    var c2 = 60106;
    var d = 60107;
    var e2 = 60108;
    var f4 = 60114;
    var g2 = 60109;
    var h3 = 60110;
    var k2 = 60112;
    var l2 = 60113;
    var m3 = 60120;
    var n2 = 60115;
    var p2 = 60116;
    var q = 60121;
    var r2 = 60122;
    var u3 = 60117;
    var v2 = 60129;
    var w2 = 60131;
    if ("function" === typeof Symbol && Symbol.for) {
      x2 = Symbol.for;
      b2 = x2("react.element");
      c2 = x2("react.portal");
      d = x2("react.fragment");
      e2 = x2("react.strict_mode");
      f4 = x2("react.profiler");
      g2 = x2("react.provider");
      h3 = x2("react.context");
      k2 = x2("react.forward_ref");
      l2 = x2("react.suspense");
      m3 = x2("react.suspense_list");
      n2 = x2("react.memo");
      p2 = x2("react.lazy");
      q = x2("react.block");
      r2 = x2("react.server.block");
      u3 = x2("react.fundamental");
      v2 = x2("react.debug_trace_mode");
      w2 = x2("react.legacy_hidden");
    }
    var x2;
    function y2(a2) {
      if ("object" === typeof a2 && null !== a2) {
        var t2 = a2.$$typeof;
        switch (t2) {
          case b2:
            switch (a2 = a2.type, a2) {
              case d:
              case f4:
              case e2:
              case l2:
              case m3:
                return a2;
              default:
                switch (a2 = a2 && a2.$$typeof, a2) {
                  case h3:
                  case k2:
                  case p2:
                  case n2:
                  case g2:
                    return a2;
                  default:
                    return t2;
                }
            }
          case c2:
            return t2;
        }
      }
    }
    __name(y2, "y");
    var z = g2;
    var A = b2;
    var B2 = k2;
    var C2 = d;
    var D2 = p2;
    var E2 = n2;
    var F = c2;
    var G = f4;
    var H = e2;
    var I = l2;
    exports.ContextConsumer = h3;
    exports.ContextProvider = z;
    exports.Element = A;
    exports.ForwardRef = B2;
    exports.Fragment = C2;
    exports.Lazy = D2;
    exports.Memo = E2;
    exports.Portal = F;
    exports.Profiler = G;
    exports.StrictMode = H;
    exports.Suspense = I;
    exports.isAsyncMode = function() {
      return false;
    };
    exports.isConcurrentMode = function() {
      return false;
    };
    exports.isContextConsumer = function(a2) {
      return y2(a2) === h3;
    };
    exports.isContextProvider = function(a2) {
      return y2(a2) === g2;
    };
    exports.isElement = function(a2) {
      return "object" === typeof a2 && null !== a2 && a2.$$typeof === b2;
    };
    exports.isForwardRef = function(a2) {
      return y2(a2) === k2;
    };
    exports.isFragment = function(a2) {
      return y2(a2) === d;
    };
    exports.isLazy = function(a2) {
      return y2(a2) === p2;
    };
    exports.isMemo = function(a2) {
      return y2(a2) === n2;
    };
    exports.isPortal = function(a2) {
      return y2(a2) === c2;
    };
    exports.isProfiler = function(a2) {
      return y2(a2) === f4;
    };
    exports.isStrictMode = function(a2) {
      return y2(a2) === e2;
    };
    exports.isSuspense = function(a2) {
      return y2(a2) === l2;
    };
    exports.isValidElementType = function(a2) {
      return "string" === typeof a2 || "function" === typeof a2 || a2 === d || a2 === f4 || a2 === v2 || a2 === e2 || a2 === l2 || a2 === m3 || a2 === w2 || "object" === typeof a2 && null !== a2 && (a2.$$typeof === p2 || a2.$$typeof === n2 || a2.$$typeof === g2 || a2.$$typeof === h3 || a2.$$typeof === k2 || a2.$$typeof === u3 || a2.$$typeof === q || a2[0] === r2) ? true : false;
    };
    exports.typeOf = y2;
  }
});

// ../node_modules/pretty-format/node_modules/react-is/index.js
var require_react_is = __commonJS({
  "../node_modules/pretty-format/node_modules/react-is/index.js"(exports, module2) {
    "use strict";
    if (true) {
      module2.exports = require_react_is_production_min();
    } else {
      module2.exports = null;
    }
  }
});

// ../node_modules/pretty-format/build/plugins/ReactElement.js
var require_ReactElement = __commonJS({
  "../node_modules/pretty-format/build/plugins/ReactElement.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.test = exports.serialize = exports.default = void 0;
    var ReactIs2 = _interopRequireWildcard(require_react_is());
    var _markup = require_markup();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function") return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interopRequireWildcard, "_interopRequireWildcard");
    var getChildren2 = /* @__PURE__ */ __name((arg, children = []) => {
      if (Array.isArray(arg)) {
        arg.forEach((item) => {
          getChildren2(item, children);
        });
      } else if (arg != null && arg !== false) {
        children.push(arg);
      }
      return children;
    }, "getChildren");
    var getType4 = /* @__PURE__ */ __name((element) => {
      const type5 = element.type;
      if (typeof type5 === "string") {
        return type5;
      }
      if (typeof type5 === "function") {
        return type5.displayName || type5.name || "Unknown";
      }
      if (ReactIs2.isFragment(element)) {
        return "React.Fragment";
      }
      if (ReactIs2.isSuspense(element)) {
        return "React.Suspense";
      }
      if (typeof type5 === "object" && type5 !== null) {
        if (ReactIs2.isContextProvider(element)) {
          return "Context.Provider";
        }
        if (ReactIs2.isContextConsumer(element)) {
          return "Context.Consumer";
        }
        if (ReactIs2.isForwardRef(element)) {
          if (type5.displayName) {
            return type5.displayName;
          }
          const functionName = type5.render.displayName || type5.render.name || "";
          return functionName !== "" ? "ForwardRef(" + functionName + ")" : "ForwardRef";
        }
        if (ReactIs2.isMemo(element)) {
          const functionName = type5.displayName || type5.type.displayName || type5.type.name || "";
          return functionName !== "" ? "Memo(" + functionName + ")" : "Memo";
        }
      }
      return "UNDEFINED";
    }, "getType");
    var getPropKeys2 = /* @__PURE__ */ __name((element) => {
      const { props } = element;
      return Object.keys(props).filter((key) => key !== "children" && props[key] !== void 0).sort();
    }, "getPropKeys");
    var serialize2 = /* @__PURE__ */ __name((element, config4, indentation, depth, refs, printer2) => ++depth > config4.maxDepth ? (0, _markup.printElementAsLeaf)(getType4(element), config4) : (0, _markup.printElement)(
      getType4(element),
      (0, _markup.printProps)(
        getPropKeys2(element),
        element.props,
        config4,
        indentation + config4.indent,
        depth,
        refs,
        printer2
      ),
      (0, _markup.printChildren)(
        getChildren2(element.props.children),
        config4,
        indentation + config4.indent,
        depth,
        refs,
        printer2
      ),
      config4,
      indentation
    ), "serialize");
    exports.serialize = serialize2;
    var test3 = /* @__PURE__ */ __name((val) => val != null && ReactIs2.isElement(val), "test");
    exports.test = test3;
    var plugin2 = {
      serialize: serialize2,
      test: test3
    };
    var _default = plugin2;
    exports.default = _default;
  }
});

// ../node_modules/pretty-format/build/plugins/ReactTestComponent.js
var require_ReactTestComponent = __commonJS({
  "../node_modules/pretty-format/build/plugins/ReactTestComponent.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.test = exports.serialize = exports.default = void 0;
    var _markup = require_markup();
    var global2 = function() {
      if (typeof globalThis !== "undefined") {
        return globalThis;
      } else if (typeof global2 !== "undefined") {
        return global2;
      } else if (typeof self !== "undefined") {
        return self;
      } else if (typeof window !== "undefined") {
        return window;
      } else {
        return Function("return this")();
      }
    }();
    var Symbol3 = global2["jest-symbol-do-not-touch"] || global2.Symbol;
    var testSymbol2 = typeof Symbol3 === "function" && Symbol3.for ? Symbol3.for("react.test.json") : 245830487;
    var getPropKeys2 = /* @__PURE__ */ __name((object) => {
      const { props } = object;
      return props ? Object.keys(props).filter((key) => props[key] !== void 0).sort() : [];
    }, "getPropKeys");
    var serialize2 = /* @__PURE__ */ __name((object, config4, indentation, depth, refs, printer2) => ++depth > config4.maxDepth ? (0, _markup.printElementAsLeaf)(object.type, config4) : (0, _markup.printElement)(
      object.type,
      object.props ? (0, _markup.printProps)(
        getPropKeys2(object),
        object.props,
        config4,
        indentation + config4.indent,
        depth,
        refs,
        printer2
      ) : "",
      object.children ? (0, _markup.printChildren)(
        object.children,
        config4,
        indentation + config4.indent,
        depth,
        refs,
        printer2
      ) : "",
      config4,
      indentation
    ), "serialize");
    exports.serialize = serialize2;
    var test3 = /* @__PURE__ */ __name((val) => val && val.$$typeof === testSymbol2, "test");
    exports.test = test3;
    var plugin2 = {
      serialize: serialize2,
      test: test3
    };
    var _default = plugin2;
    exports.default = _default;
  }
});

// ../node_modules/pretty-format/build/index.js
var require_build = __commonJS({
  "../node_modules/pretty-format/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = exports.DEFAULT_OPTIONS = void 0;
    exports.format = format4;
    exports.plugins = void 0;
    var _ansiStyles = _interopRequireDefault(require_ansi_styles());
    var _collections = require_collections();
    var _AsymmetricMatcher2 = _interopRequireDefault(
      require_AsymmetricMatcher()
    );
    var _ConvertAnsi = _interopRequireDefault(require_ConvertAnsi());
    var _DOMCollection = _interopRequireDefault(require_DOMCollection());
    var _DOMElement = _interopRequireDefault(require_DOMElement());
    var _Immutable = _interopRequireDefault(require_Immutable());
    var _ReactElement = _interopRequireDefault(require_ReactElement());
    var _ReactTestComponent = _interopRequireDefault(
      require_ReactTestComponent()
    );
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var toString5 = Object.prototype.toString;
    var toISOString2 = Date.prototype.toISOString;
    var errorToString2 = Error.prototype.toString;
    var regExpToString2 = RegExp.prototype.toString;
    var getConstructorName3 = /* @__PURE__ */ __name((val) => typeof val.constructor === "function" && val.constructor.name || "Object", "getConstructorName");
    var isWindow2 = /* @__PURE__ */ __name((val) => typeof window !== "undefined" && val === window, "isWindow");
    var SYMBOL_REGEXP2 = /^Symbol\((.*)\)(.*)$/;
    var NEWLINE_REGEXP2 = /\n/gi;
    var _PrettyFormatPluginError2 = class _PrettyFormatPluginError2 extends Error {
      constructor(message, stack) {
        super(message);
        this.stack = stack;
        this.name = this.constructor.name;
      }
    };
    __name(_PrettyFormatPluginError2, "PrettyFormatPluginError");
    var PrettyFormatPluginError2 = _PrettyFormatPluginError2;
    function isToStringedArrayType2(toStringed) {
      return toStringed === "[object Array]" || toStringed === "[object ArrayBuffer]" || toStringed === "[object DataView]" || toStringed === "[object Float32Array]" || toStringed === "[object Float64Array]" || toStringed === "[object Int8Array]" || toStringed === "[object Int16Array]" || toStringed === "[object Int32Array]" || toStringed === "[object Uint8Array]" || toStringed === "[object Uint8ClampedArray]" || toStringed === "[object Uint16Array]" || toStringed === "[object Uint32Array]";
    }
    __name(isToStringedArrayType2, "isToStringedArrayType");
    function printNumber2(val) {
      return Object.is(val, -0) ? "-0" : String(val);
    }
    __name(printNumber2, "printNumber");
    function printBigInt2(val) {
      return String(`${val}n`);
    }
    __name(printBigInt2, "printBigInt");
    function printFunction2(val, printFunctionName) {
      if (!printFunctionName) {
        return "[Function]";
      }
      return "[Function " + (val.name || "anonymous") + "]";
    }
    __name(printFunction2, "printFunction");
    function printSymbol2(val) {
      return String(val).replace(SYMBOL_REGEXP2, "Symbol($1)");
    }
    __name(printSymbol2, "printSymbol");
    function printError2(val) {
      return "[" + errorToString2.call(val) + "]";
    }
    __name(printError2, "printError");
    function printBasicValue2(val, printFunctionName, escapeRegex, escapeString) {
      if (val === true || val === false) {
        return "" + val;
      }
      if (val === void 0) {
        return "undefined";
      }
      if (val === null) {
        return "null";
      }
      const typeOf = typeof val;
      if (typeOf === "number") {
        return printNumber2(val);
      }
      if (typeOf === "bigint") {
        return printBigInt2(val);
      }
      if (typeOf === "string") {
        if (escapeString) {
          return '"' + val.replace(/"|\\/g, "\\$&") + '"';
        }
        return '"' + val + '"';
      }
      if (typeOf === "function") {
        return printFunction2(val, printFunctionName);
      }
      if (typeOf === "symbol") {
        return printSymbol2(val);
      }
      const toStringed = toString5.call(val);
      if (toStringed === "[object WeakMap]") {
        return "WeakMap {}";
      }
      if (toStringed === "[object WeakSet]") {
        return "WeakSet {}";
      }
      if (toStringed === "[object Function]" || toStringed === "[object GeneratorFunction]") {
        return printFunction2(val, printFunctionName);
      }
      if (toStringed === "[object Symbol]") {
        return printSymbol2(val);
      }
      if (toStringed === "[object Date]") {
        return isNaN(+val) ? "Date { NaN }" : toISOString2.call(val);
      }
      if (toStringed === "[object Error]") {
        return printError2(val);
      }
      if (toStringed === "[object RegExp]") {
        if (escapeRegex) {
          return regExpToString2.call(val).replace(/[\\^$*+?.()|[\]{}]/g, "\\$&");
        }
        return regExpToString2.call(val);
      }
      if (val instanceof Error) {
        return printError2(val);
      }
      return null;
    }
    __name(printBasicValue2, "printBasicValue");
    function printComplexValue2(val, config4, indentation, depth, refs, hasCalledToJSON) {
      if (refs.indexOf(val) !== -1) {
        return "[Circular]";
      }
      refs = refs.slice();
      refs.push(val);
      const hitMaxDepth = ++depth > config4.maxDepth;
      const min = config4.min;
      if (config4.callToJSON && !hitMaxDepth && val.toJSON && typeof val.toJSON === "function" && !hasCalledToJSON) {
        return printer2(val.toJSON(), config4, indentation, depth, refs, true);
      }
      const toStringed = toString5.call(val);
      if (toStringed === "[object Arguments]") {
        return hitMaxDepth ? "[Arguments]" : (min ? "" : "Arguments ") + "[" + (0, _collections.printListItems)(
          val,
          config4,
          indentation,
          depth,
          refs,
          printer2
        ) + "]";
      }
      if (isToStringedArrayType2(toStringed)) {
        return hitMaxDepth ? "[" + val.constructor.name + "]" : (min ? "" : !config4.printBasicPrototype && val.constructor.name === "Array" ? "" : val.constructor.name + " ") + "[" + (0, _collections.printListItems)(
          val,
          config4,
          indentation,
          depth,
          refs,
          printer2
        ) + "]";
      }
      if (toStringed === "[object Map]") {
        return hitMaxDepth ? "[Map]" : "Map {" + (0, _collections.printIteratorEntries)(
          val.entries(),
          config4,
          indentation,
          depth,
          refs,
          printer2,
          " => "
        ) + "}";
      }
      if (toStringed === "[object Set]") {
        return hitMaxDepth ? "[Set]" : "Set {" + (0, _collections.printIteratorValues)(
          val.values(),
          config4,
          indentation,
          depth,
          refs,
          printer2
        ) + "}";
      }
      return hitMaxDepth || isWindow2(val) ? "[" + getConstructorName3(val) + "]" : (min ? "" : !config4.printBasicPrototype && getConstructorName3(val) === "Object" ? "" : getConstructorName3(val) + " ") + "{" + (0, _collections.printObjectProperties)(
        val,
        config4,
        indentation,
        depth,
        refs,
        printer2
      ) + "}";
    }
    __name(printComplexValue2, "printComplexValue");
    function isNewPlugin2(plugin2) {
      return plugin2.serialize != null;
    }
    __name(isNewPlugin2, "isNewPlugin");
    function printPlugin2(plugin2, val, config4, indentation, depth, refs) {
      let printed;
      try {
        printed = isNewPlugin2(plugin2) ? plugin2.serialize(val, config4, indentation, depth, refs, printer2) : plugin2.print(
          val,
          (valChild) => printer2(valChild, config4, indentation, depth, refs),
          (str2) => {
            const indentationNext = indentation + config4.indent;
            return indentationNext + str2.replace(NEWLINE_REGEXP2, "\n" + indentationNext);
          },
          {
            edgeSpacing: config4.spacingOuter,
            min: config4.min,
            spacing: config4.spacingInner
          },
          config4.colors
        );
      } catch (error) {
        throw new PrettyFormatPluginError2(error.message, error.stack);
      }
      if (typeof printed !== "string") {
        throw new Error(
          `pretty-format: Plugin must return type "string" but instead returned "${typeof printed}".`
        );
      }
      return printed;
    }
    __name(printPlugin2, "printPlugin");
    function findPlugin2(plugins4, val) {
      for (let p2 = 0; p2 < plugins4.length; p2++) {
        try {
          if (plugins4[p2].test(val)) {
            return plugins4[p2];
          }
        } catch (error) {
          throw new PrettyFormatPluginError2(error.message, error.stack);
        }
      }
      return null;
    }
    __name(findPlugin2, "findPlugin");
    function printer2(val, config4, indentation, depth, refs, hasCalledToJSON) {
      const plugin2 = findPlugin2(config4.plugins, val);
      if (plugin2 !== null) {
        return printPlugin2(plugin2, val, config4, indentation, depth, refs);
      }
      const basicResult = printBasicValue2(
        val,
        config4.printFunctionName,
        config4.escapeRegex,
        config4.escapeString
      );
      if (basicResult !== null) {
        return basicResult;
      }
      return printComplexValue2(
        val,
        config4,
        indentation,
        depth,
        refs,
        hasCalledToJSON
      );
    }
    __name(printer2, "printer");
    var DEFAULT_THEME2 = {
      comment: "gray",
      content: "reset",
      prop: "yellow",
      tag: "cyan",
      value: "green"
    };
    var DEFAULT_THEME_KEYS2 = Object.keys(DEFAULT_THEME2);
    var DEFAULT_OPTIONS2 = {
      callToJSON: true,
      compareKeys: void 0,
      escapeRegex: false,
      escapeString: true,
      highlight: false,
      indent: 2,
      maxDepth: Infinity,
      min: false,
      plugins: [],
      printBasicPrototype: true,
      printFunctionName: true,
      theme: DEFAULT_THEME2
    };
    exports.DEFAULT_OPTIONS = DEFAULT_OPTIONS2;
    function validateOptions3(options) {
      Object.keys(options).forEach((key) => {
        if (!DEFAULT_OPTIONS2.hasOwnProperty(key)) {
          throw new Error(`pretty-format: Unknown option "${key}".`);
        }
      });
      if (options.min && options.indent !== void 0 && options.indent !== 0) {
        throw new Error(
          'pretty-format: Options "min" and "indent" cannot be used together.'
        );
      }
      if (options.theme !== void 0) {
        if (options.theme === null) {
          throw new Error('pretty-format: Option "theme" must not be null.');
        }
        if (typeof options.theme !== "object") {
          throw new Error(
            `pretty-format: Option "theme" must be of type "object" but instead received "${typeof options.theme}".`
          );
        }
      }
    }
    __name(validateOptions3, "validateOptions");
    var getColorsHighlight2 = /* @__PURE__ */ __name((options) => DEFAULT_THEME_KEYS2.reduce((colors3, key) => {
      const value = options.theme && options.theme[key] !== void 0 ? options.theme[key] : DEFAULT_THEME2[key];
      const color = value && _ansiStyles.default[value];
      if (color && typeof color.close === "string" && typeof color.open === "string") {
        colors3[key] = color;
      } else {
        throw new Error(
          `pretty-format: Option "theme" has a key "${key}" whose value "${value}" is undefined in ansi-styles.`
        );
      }
      return colors3;
    }, /* @__PURE__ */ Object.create(null)), "getColorsHighlight");
    var getColorsEmpty2 = /* @__PURE__ */ __name(() => DEFAULT_THEME_KEYS2.reduce((colors3, key) => {
      colors3[key] = {
        close: "",
        open: ""
      };
      return colors3;
    }, /* @__PURE__ */ Object.create(null)), "getColorsEmpty");
    var getPrintFunctionName2 = /* @__PURE__ */ __name((options) => options && options.printFunctionName !== void 0 ? options.printFunctionName : DEFAULT_OPTIONS2.printFunctionName, "getPrintFunctionName");
    var getEscapeRegex2 = /* @__PURE__ */ __name((options) => options && options.escapeRegex !== void 0 ? options.escapeRegex : DEFAULT_OPTIONS2.escapeRegex, "getEscapeRegex");
    var getEscapeString2 = /* @__PURE__ */ __name((options) => options && options.escapeString !== void 0 ? options.escapeString : DEFAULT_OPTIONS2.escapeString, "getEscapeString");
    var getConfig4 = /* @__PURE__ */ __name((options) => {
      var _options$printBasicPr;
      return {
        callToJSON: options && options.callToJSON !== void 0 ? options.callToJSON : DEFAULT_OPTIONS2.callToJSON,
        colors: options && options.highlight ? getColorsHighlight2(options) : getColorsEmpty2(),
        compareKeys: options && typeof options.compareKeys === "function" ? options.compareKeys : DEFAULT_OPTIONS2.compareKeys,
        escapeRegex: getEscapeRegex2(options),
        escapeString: getEscapeString2(options),
        indent: options && options.min ? "" : createIndent2(
          options && options.indent !== void 0 ? options.indent : DEFAULT_OPTIONS2.indent
        ),
        maxDepth: options && options.maxDepth !== void 0 ? options.maxDepth : DEFAULT_OPTIONS2.maxDepth,
        min: options && options.min !== void 0 ? options.min : DEFAULT_OPTIONS2.min,
        plugins: options && options.plugins !== void 0 ? options.plugins : DEFAULT_OPTIONS2.plugins,
        printBasicPrototype: (_options$printBasicPr = options === null || options === void 0 ? void 0 : options.printBasicPrototype) !== null && _options$printBasicPr !== void 0 ? _options$printBasicPr : true,
        printFunctionName: getPrintFunctionName2(options),
        spacingInner: options && options.min ? " " : "\n",
        spacingOuter: options && options.min ? "" : "\n"
      };
    }, "getConfig");
    function createIndent2(indent2) {
      return new Array(indent2 + 1).join(" ");
    }
    __name(createIndent2, "createIndent");
    function format4(val, options) {
      if (options) {
        validateOptions3(options);
        if (options.plugins) {
          const plugin2 = findPlugin2(options.plugins, val);
          if (plugin2 !== null) {
            return printPlugin2(plugin2, val, getConfig4(options), "", 0, []);
          }
        }
      }
      const basicResult = printBasicValue2(
        val,
        getPrintFunctionName2(options),
        getEscapeRegex2(options),
        getEscapeString2(options)
      );
      if (basicResult !== null) {
        return basicResult;
      }
      return printComplexValue2(val, getConfig4(options), "", 0, []);
    }
    __name(format4, "format");
    var plugins3 = {
      AsymmetricMatcher: _AsymmetricMatcher2.default,
      ConvertAnsi: _ConvertAnsi.default,
      DOMCollection: _DOMCollection.default,
      DOMElement: _DOMElement.default,
      Immutable: _Immutable.default,
      ReactElement: _ReactElement.default,
      ReactTestComponent: _ReactTestComponent.default
    };
    exports.plugins = plugins3;
    var _default = format4;
    exports.default = _default;
  }
});

// ../node_modules/lz-string/libs/lz-string.js
var require_lz_string = __commonJS({
  "../node_modules/lz-string/libs/lz-string.js"(exports, module2) {
    var LZString = function() {
      var f4 = String.fromCharCode;
      var keyStrBase64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      var keyStrUriSafe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$";
      var baseReverseDic = {};
      function getBaseValue(alphabet, character) {
        if (!baseReverseDic[alphabet]) {
          baseReverseDic[alphabet] = {};
          for (var i2 = 0; i2 < alphabet.length; i2++) {
            baseReverseDic[alphabet][alphabet.charAt(i2)] = i2;
          }
        }
        return baseReverseDic[alphabet][character];
      }
      __name(getBaseValue, "getBaseValue");
      var LZString2 = {
        compressToBase64: /* @__PURE__ */ __name(function(input2) {
          if (input2 == null) return "";
          var res = LZString2._compress(input2, 6, function(a2) {
            return keyStrBase64.charAt(a2);
          });
          switch (res.length % 4) {
            // To produce valid Base64
            default:
            // When could this happen ?
            case 0:
              return res;
            case 1:
              return res + "===";
            case 2:
              return res + "==";
            case 3:
              return res + "=";
          }
        }, "compressToBase64"),
        decompressFromBase64: /* @__PURE__ */ __name(function(input2) {
          if (input2 == null) return "";
          if (input2 == "") return null;
          return LZString2._decompress(input2.length, 32, function(index2) {
            return getBaseValue(keyStrBase64, input2.charAt(index2));
          });
        }, "decompressFromBase64"),
        compressToUTF16: /* @__PURE__ */ __name(function(input2) {
          if (input2 == null) return "";
          return LZString2._compress(input2, 15, function(a2) {
            return f4(a2 + 32);
          }) + " ";
        }, "compressToUTF16"),
        decompressFromUTF16: /* @__PURE__ */ __name(function(compressed) {
          if (compressed == null) return "";
          if (compressed == "") return null;
          return LZString2._decompress(compressed.length, 16384, function(index2) {
            return compressed.charCodeAt(index2) - 32;
          });
        }, "decompressFromUTF16"),
        //compress into uint8array (UCS-2 big endian format)
        compressToUint8Array: /* @__PURE__ */ __name(function(uncompressed) {
          var compressed = LZString2.compress(uncompressed);
          var buf = new Uint8Array(compressed.length * 2);
          for (var i2 = 0, TotalLen = compressed.length; i2 < TotalLen; i2++) {
            var current_value = compressed.charCodeAt(i2);
            buf[i2 * 2] = current_value >>> 8;
            buf[i2 * 2 + 1] = current_value % 256;
          }
          return buf;
        }, "compressToUint8Array"),
        //decompress from uint8array (UCS-2 big endian format)
        decompressFromUint8Array: /* @__PURE__ */ __name(function(compressed) {
          if (compressed === null || compressed === void 0) {
            return LZString2.decompress(compressed);
          } else {
            var buf = new Array(compressed.length / 2);
            for (var i2 = 0, TotalLen = buf.length; i2 < TotalLen; i2++) {
              buf[i2] = compressed[i2 * 2] * 256 + compressed[i2 * 2 + 1];
            }
            var result = [];
            buf.forEach(function(c2) {
              result.push(f4(c2));
            });
            return LZString2.decompress(result.join(""));
          }
        }, "decompressFromUint8Array"),
        //compress into a string that is already URI encoded
        compressToEncodedURIComponent: /* @__PURE__ */ __name(function(input2) {
          if (input2 == null) return "";
          return LZString2._compress(input2, 6, function(a2) {
            return keyStrUriSafe.charAt(a2);
          });
        }, "compressToEncodedURIComponent"),
        //decompress from an output of compressToEncodedURIComponent
        decompressFromEncodedURIComponent: /* @__PURE__ */ __name(function(input2) {
          if (input2 == null) return "";
          if (input2 == "") return null;
          input2 = input2.replace(/ /g, "+");
          return LZString2._decompress(input2.length, 32, function(index2) {
            return getBaseValue(keyStrUriSafe, input2.charAt(index2));
          });
        }, "decompressFromEncodedURIComponent"),
        compress: /* @__PURE__ */ __name(function(uncompressed) {
          return LZString2._compress(uncompressed, 16, function(a2) {
            return f4(a2);
          });
        }, "compress"),
        _compress: /* @__PURE__ */ __name(function(uncompressed, bitsPerChar, getCharFromInt) {
          if (uncompressed == null) return "";
          var i2, value, context_dictionary = {}, context_dictionaryToCreate = {}, context_c = "", context_wc = "", context_w = "", context_enlargeIn = 2, context_dictSize = 3, context_numBits = 2, context_data = [], context_data_val = 0, context_data_position = 0, ii;
          for (ii = 0; ii < uncompressed.length; ii += 1) {
            context_c = uncompressed.charAt(ii);
            if (!Object.prototype.hasOwnProperty.call(context_dictionary, context_c)) {
              context_dictionary[context_c] = context_dictSize++;
              context_dictionaryToCreate[context_c] = true;
            }
            context_wc = context_w + context_c;
            if (Object.prototype.hasOwnProperty.call(context_dictionary, context_wc)) {
              context_w = context_wc;
            } else {
              if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
                if (context_w.charCodeAt(0) < 256) {
                  for (i2 = 0; i2 < context_numBits; i2++) {
                    context_data_val = context_data_val << 1;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                  }
                  value = context_w.charCodeAt(0);
                  for (i2 = 0; i2 < 8; i2++) {
                    context_data_val = context_data_val << 1 | value & 1;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                    value = value >> 1;
                  }
                } else {
                  value = 1;
                  for (i2 = 0; i2 < context_numBits; i2++) {
                    context_data_val = context_data_val << 1 | value;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                    value = 0;
                  }
                  value = context_w.charCodeAt(0);
                  for (i2 = 0; i2 < 16; i2++) {
                    context_data_val = context_data_val << 1 | value & 1;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                    value = value >> 1;
                  }
                }
                context_enlargeIn--;
                if (context_enlargeIn == 0) {
                  context_enlargeIn = Math.pow(2, context_numBits);
                  context_numBits++;
                }
                delete context_dictionaryToCreate[context_w];
              } else {
                value = context_dictionary[context_w];
                for (i2 = 0; i2 < context_numBits; i2++) {
                  context_data_val = context_data_val << 1 | value & 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = value >> 1;
                }
              }
              context_enlargeIn--;
              if (context_enlargeIn == 0) {
                context_enlargeIn = Math.pow(2, context_numBits);
                context_numBits++;
              }
              context_dictionary[context_wc] = context_dictSize++;
              context_w = String(context_c);
            }
          }
          if (context_w !== "") {
            if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
              if (context_w.charCodeAt(0) < 256) {
                for (i2 = 0; i2 < context_numBits; i2++) {
                  context_data_val = context_data_val << 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                }
                value = context_w.charCodeAt(0);
                for (i2 = 0; i2 < 8; i2++) {
                  context_data_val = context_data_val << 1 | value & 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = value >> 1;
                }
              } else {
                value = 1;
                for (i2 = 0; i2 < context_numBits; i2++) {
                  context_data_val = context_data_val << 1 | value;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = 0;
                }
                value = context_w.charCodeAt(0);
                for (i2 = 0; i2 < 16; i2++) {
                  context_data_val = context_data_val << 1 | value & 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = value >> 1;
                }
              }
              context_enlargeIn--;
              if (context_enlargeIn == 0) {
                context_enlargeIn = Math.pow(2, context_numBits);
                context_numBits++;
              }
              delete context_dictionaryToCreate[context_w];
            } else {
              value = context_dictionary[context_w];
              for (i2 = 0; i2 < context_numBits; i2++) {
                context_data_val = context_data_val << 1 | value & 1;
                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value = value >> 1;
              }
            }
            context_enlargeIn--;
            if (context_enlargeIn == 0) {
              context_enlargeIn = Math.pow(2, context_numBits);
              context_numBits++;
            }
          }
          value = 2;
          for (i2 = 0; i2 < context_numBits; i2++) {
            context_data_val = context_data_val << 1 | value & 1;
            if (context_data_position == bitsPerChar - 1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = value >> 1;
          }
          while (true) {
            context_data_val = context_data_val << 1;
            if (context_data_position == bitsPerChar - 1) {
              context_data.push(getCharFromInt(context_data_val));
              break;
            } else context_data_position++;
          }
          return context_data.join("");
        }, "_compress"),
        decompress: /* @__PURE__ */ __name(function(compressed) {
          if (compressed == null) return "";
          if (compressed == "") return null;
          return LZString2._decompress(compressed.length, 32768, function(index2) {
            return compressed.charCodeAt(index2);
          });
        }, "decompress"),
        _decompress: /* @__PURE__ */ __name(function(length, resetValue, getNextValue) {
          var dictionary = [], next, enlargeIn = 4, dictSize = 4, numBits = 3, entry = "", result = [], i2, w2, bits, resb, maxpower, power, c2, data = { val: getNextValue(0), position: resetValue, index: 1 };
          for (i2 = 0; i2 < 3; i2 += 1) {
            dictionary[i2] = i2;
          }
          bits = 0;
          maxpower = Math.pow(2, 2);
          power = 1;
          while (power != maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb > 0 ? 1 : 0) * power;
            power <<= 1;
          }
          switch (next = bits) {
            case 0:
              bits = 0;
              maxpower = Math.pow(2, 8);
              power = 1;
              while (power != maxpower) {
                resb = data.val & data.position;
                data.position >>= 1;
                if (data.position == 0) {
                  data.position = resetValue;
                  data.val = getNextValue(data.index++);
                }
                bits |= (resb > 0 ? 1 : 0) * power;
                power <<= 1;
              }
              c2 = f4(bits);
              break;
            case 1:
              bits = 0;
              maxpower = Math.pow(2, 16);
              power = 1;
              while (power != maxpower) {
                resb = data.val & data.position;
                data.position >>= 1;
                if (data.position == 0) {
                  data.position = resetValue;
                  data.val = getNextValue(data.index++);
                }
                bits |= (resb > 0 ? 1 : 0) * power;
                power <<= 1;
              }
              c2 = f4(bits);
              break;
            case 2:
              return "";
          }
          dictionary[3] = c2;
          w2 = c2;
          result.push(c2);
          while (true) {
            if (data.index > length) {
              return "";
            }
            bits = 0;
            maxpower = Math.pow(2, numBits);
            power = 1;
            while (power != maxpower) {
              resb = data.val & data.position;
              data.position >>= 1;
              if (data.position == 0) {
                data.position = resetValue;
                data.val = getNextValue(data.index++);
              }
              bits |= (resb > 0 ? 1 : 0) * power;
              power <<= 1;
            }
            switch (c2 = bits) {
              case 0:
                bits = 0;
                maxpower = Math.pow(2, 8);
                power = 1;
                while (power != maxpower) {
                  resb = data.val & data.position;
                  data.position >>= 1;
                  if (data.position == 0) {
                    data.position = resetValue;
                    data.val = getNextValue(data.index++);
                  }
                  bits |= (resb > 0 ? 1 : 0) * power;
                  power <<= 1;
                }
                dictionary[dictSize++] = f4(bits);
                c2 = dictSize - 1;
                enlargeIn--;
                break;
              case 1:
                bits = 0;
                maxpower = Math.pow(2, 16);
                power = 1;
                while (power != maxpower) {
                  resb = data.val & data.position;
                  data.position >>= 1;
                  if (data.position == 0) {
                    data.position = resetValue;
                    data.val = getNextValue(data.index++);
                  }
                  bits |= (resb > 0 ? 1 : 0) * power;
                  power <<= 1;
                }
                dictionary[dictSize++] = f4(bits);
                c2 = dictSize - 1;
                enlargeIn--;
                break;
              case 2:
                return result.join("");
            }
            if (enlargeIn == 0) {
              enlargeIn = Math.pow(2, numBits);
              numBits++;
            }
            if (dictionary[c2]) {
              entry = dictionary[c2];
            } else {
              if (c2 === dictSize) {
                entry = w2 + w2.charAt(0);
              } else {
                return null;
              }
            }
            result.push(entry);
            dictionary[dictSize++] = w2 + entry.charAt(0);
            enlargeIn--;
            w2 = entry;
            if (enlargeIn == 0) {
              enlargeIn = Math.pow(2, numBits);
              numBits++;
            }
          }
        }, "_decompress")
      };
      return LZString2;
    }();
    if (typeof define === "function" && define.amd) {
      define(function() {
        return LZString;
      });
    } else if (typeof module2 !== "undefined" && module2 != null) {
      module2.exports = LZString;
    } else if (typeof angular !== "undefined" && angular != null) {
      angular.module("LZString", []).factory("LZString", function() {
        return LZString;
      });
    }
  }
});

// ../node_modules/memoizerific/memoizerific.js
var require_memoizerific = __commonJS({
  "../node_modules/memoizerific/memoizerific.js"(exports, module2) {
    (function(f4) {
      if (typeof exports === "object" && typeof module2 !== "undefined") {
        module2.exports = f4();
      } else if (typeof define === "function" && define.amd) {
        define([], f4);
      } else {
        var g2;
        if (typeof window !== "undefined") {
          g2 = window;
        } else if (typeof global !== "undefined") {
          g2 = global;
        } else if (typeof self !== "undefined") {
          g2 = self;
        } else {
          g2 = this;
        }
        g2.memoizerific = f4();
      }
    })(function() {
      var define2, module3, exports2;
      return (/* @__PURE__ */ __name(function e2(t2, n2, r2) {
        function s3(o3, u3) {
          if (!n2[o3]) {
            if (!t2[o3]) {
              var a2 = typeof __require == "function" && __require;
              if (!u3 && a2) return a2(o3, true);
              if (i2) return i2(o3, true);
              var f4 = new Error("Cannot find module '" + o3 + "'");
              throw f4.code = "MODULE_NOT_FOUND", f4;
            }
            var l2 = n2[o3] = { exports: {} };
            t2[o3][0].call(l2.exports, function(e3) {
              var n3 = t2[o3][1][e3];
              return s3(n3 ? n3 : e3);
            }, l2, l2.exports, e2, t2, n2, r2);
          }
          return n2[o3].exports;
        }
        __name(s3, "s");
        var i2 = typeof __require == "function" && __require;
        for (var o2 = 0; o2 < r2.length; o2++) s3(r2[o2]);
        return s3;
      }, "e"))({ 1: [function(_dereq_, module4, exports3) {
        module4.exports = function(forceSimilar) {
          if (typeof Map !== "function" || forceSimilar) {
            var Similar = _dereq_("./similar");
            return new Similar();
          } else {
            return /* @__PURE__ */ new Map();
          }
        };
      }, { "./similar": 2 }], 2: [function(_dereq_, module4, exports3) {
        function Similar() {
          this.list = [];
          this.lastItem = void 0;
          this.size = 0;
          return this;
        }
        __name(Similar, "Similar");
        Similar.prototype.get = function(key) {
          var index2;
          if (this.lastItem && this.isEqual(this.lastItem.key, key)) {
            return this.lastItem.val;
          }
          index2 = this.indexOf(key);
          if (index2 >= 0) {
            this.lastItem = this.list[index2];
            return this.list[index2].val;
          }
          return void 0;
        };
        Similar.prototype.set = function(key, val) {
          var index2;
          if (this.lastItem && this.isEqual(this.lastItem.key, key)) {
            this.lastItem.val = val;
            return this;
          }
          index2 = this.indexOf(key);
          if (index2 >= 0) {
            this.lastItem = this.list[index2];
            this.list[index2].val = val;
            return this;
          }
          this.lastItem = { key, val };
          this.list.push(this.lastItem);
          this.size++;
          return this;
        };
        Similar.prototype.delete = function(key) {
          var index2;
          if (this.lastItem && this.isEqual(this.lastItem.key, key)) {
            this.lastItem = void 0;
          }
          index2 = this.indexOf(key);
          if (index2 >= 0) {
            this.size--;
            return this.list.splice(index2, 1)[0];
          }
          return void 0;
        };
        Similar.prototype.has = function(key) {
          var index2;
          if (this.lastItem && this.isEqual(this.lastItem.key, key)) {
            return true;
          }
          index2 = this.indexOf(key);
          if (index2 >= 0) {
            this.lastItem = this.list[index2];
            return true;
          }
          return false;
        };
        Similar.prototype.forEach = function(callback, thisArg) {
          var i2;
          for (i2 = 0; i2 < this.size; i2++) {
            callback.call(thisArg || this, this.list[i2].val, this.list[i2].key, this);
          }
        };
        Similar.prototype.indexOf = function(key) {
          var i2;
          for (i2 = 0; i2 < this.size; i2++) {
            if (this.isEqual(this.list[i2].key, key)) {
              return i2;
            }
          }
          return -1;
        };
        Similar.prototype.isEqual = function(val1, val2) {
          return val1 === val2 || val1 !== val1 && val2 !== val2;
        };
        module4.exports = Similar;
      }, {}], 3: [function(_dereq_, module4, exports3) {
        var MapOrSimilar = _dereq_("map-or-similar");
        module4.exports = function(limit) {
          var cache = new MapOrSimilar(false), lru = [];
          return function(fn3) {
            var memoizerific = /* @__PURE__ */ __name(function() {
              var currentCache = cache, newMap, fnResult, argsLengthMinusOne = arguments.length - 1, lruPath = Array(argsLengthMinusOne + 1), isMemoized = true, i2;
              if ((memoizerific.numArgs || memoizerific.numArgs === 0) && memoizerific.numArgs !== argsLengthMinusOne + 1) {
                throw new Error("Memoizerific functions should always be called with the same number of arguments");
              }
              for (i2 = 0; i2 < argsLengthMinusOne; i2++) {
                lruPath[i2] = {
                  cacheItem: currentCache,
                  arg: arguments[i2]
                };
                if (currentCache.has(arguments[i2])) {
                  currentCache = currentCache.get(arguments[i2]);
                  continue;
                }
                isMemoized = false;
                newMap = new MapOrSimilar(false);
                currentCache.set(arguments[i2], newMap);
                currentCache = newMap;
              }
              if (isMemoized) {
                if (currentCache.has(arguments[argsLengthMinusOne])) {
                  fnResult = currentCache.get(arguments[argsLengthMinusOne]);
                } else {
                  isMemoized = false;
                }
              }
              if (!isMemoized) {
                fnResult = fn3.apply(null, arguments);
                currentCache.set(arguments[argsLengthMinusOne], fnResult);
              }
              if (limit > 0) {
                lruPath[argsLengthMinusOne] = {
                  cacheItem: currentCache,
                  arg: arguments[argsLengthMinusOne]
                };
                if (isMemoized) {
                  moveToMostRecentLru(lru, lruPath);
                } else {
                  lru.push(lruPath);
                }
                if (lru.length > limit) {
                  removeCachedResult(lru.shift());
                }
              }
              memoizerific.wasMemoized = isMemoized;
              memoizerific.numArgs = argsLengthMinusOne + 1;
              return fnResult;
            }, "memoizerific");
            memoizerific.limit = limit;
            memoizerific.wasMemoized = false;
            memoizerific.cache = cache;
            memoizerific.lru = lru;
            return memoizerific;
          };
        };
        function moveToMostRecentLru(lru, lruPath) {
          var lruLen = lru.length, lruPathLen = lruPath.length, isMatch, i2, ii;
          for (i2 = 0; i2 < lruLen; i2++) {
            isMatch = true;
            for (ii = 0; ii < lruPathLen; ii++) {
              if (!isEqual3(lru[i2][ii].arg, lruPath[ii].arg)) {
                isMatch = false;
                break;
              }
            }
            if (isMatch) {
              break;
            }
          }
          lru.push(lru.splice(i2, 1)[0]);
        }
        __name(moveToMostRecentLru, "moveToMostRecentLru");
        function removeCachedResult(removedLru) {
          var removedLruLen = removedLru.length, currentLru = removedLru[removedLruLen - 1], tmp, i2;
          currentLru.cacheItem.delete(currentLru.arg);
          for (i2 = removedLruLen - 2; i2 >= 0; i2--) {
            currentLru = removedLru[i2];
            tmp = currentLru.cacheItem.get(currentLru.arg);
            if (!tmp || !tmp.size) {
              currentLru.cacheItem.delete(currentLru.arg);
            } else {
              break;
            }
          }
        }
        __name(removeCachedResult, "removeCachedResult");
        function isEqual3(val1, val2) {
          return val1 === val2 || val1 !== val1 && val2 !== val2;
        }
        __name(isEqual3, "isEqual");
      }, { "map-or-similar": 1 }] }, {}, [3])(3);
    });
  }
});

// ../node_modules/picoquery/lib/string-util.js
var require_string_util = __commonJS({
  "../node_modules/picoquery/lib/string-util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeString = encodeString;
    var hexTable = Array.from({ length: 256 }, (_, i2) => "%" + ((i2 < 16 ? "0" : "") + i2.toString(16)).toUpperCase());
    var noEscape = new Int8Array([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      0
    ]);
    function encodeString(str2) {
      const len = str2.length;
      if (len === 0) {
        return "";
      }
      let out = "";
      let lastPos = 0;
      let i2 = 0;
      outer: for (; i2 < len; i2++) {
        let c2 = str2.charCodeAt(i2);
        while (c2 < 128) {
          if (noEscape[c2] !== 1) {
            if (lastPos < i2)
              out += str2.slice(lastPos, i2);
            lastPos = i2 + 1;
            out += hexTable[c2];
          }
          if (++i2 === len)
            break outer;
          c2 = str2.charCodeAt(i2);
        }
        if (lastPos < i2)
          out += str2.slice(lastPos, i2);
        if (c2 < 2048) {
          lastPos = i2 + 1;
          out += hexTable[192 | c2 >> 6] + hexTable[128 | c2 & 63];
          continue;
        }
        if (c2 < 55296 || c2 >= 57344) {
          lastPos = i2 + 1;
          out += hexTable[224 | c2 >> 12] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63];
          continue;
        }
        ++i2;
        if (i2 >= len) {
          throw new Error("URI malformed");
        }
        const c22 = str2.charCodeAt(i2) & 1023;
        lastPos = i2 + 1;
        c2 = 65536 + ((c2 & 1023) << 10 | c22);
        out += hexTable[240 | c2 >> 18] + hexTable[128 | c2 >> 12 & 63] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63];
      }
      if (lastPos === 0)
        return str2;
      if (lastPos < len)
        return out + str2.slice(lastPos);
      return out;
    }
    __name(encodeString, "encodeString");
  }
});

// ../node_modules/picoquery/lib/shared.js
var require_shared = __commonJS({
  "../node_modules/picoquery/lib/shared.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaultOptions = exports.defaultShouldSerializeObject = exports.defaultValueSerializer = void 0;
    var string_util_js_1 = require_string_util();
    var defaultValueSerializer = /* @__PURE__ */ __name((value) => {
      switch (typeof value) {
        case "string":
          return (0, string_util_js_1.encodeString)(value);
        case "bigint":
        case "boolean":
          return "" + value;
        case "number":
          if (Number.isFinite(value)) {
            return value < 1e21 ? "" + value : (0, string_util_js_1.encodeString)("" + value);
          }
          break;
      }
      if (value instanceof Date) {
        return (0, string_util_js_1.encodeString)(value.toISOString());
      }
      return "";
    }, "defaultValueSerializer");
    exports.defaultValueSerializer = defaultValueSerializer;
    var defaultShouldSerializeObject = /* @__PURE__ */ __name((val) => {
      return val instanceof Date;
    }, "defaultShouldSerializeObject");
    exports.defaultShouldSerializeObject = defaultShouldSerializeObject;
    var identityFunc = /* @__PURE__ */ __name((v2) => v2, "identityFunc");
    exports.defaultOptions = {
      nesting: true,
      nestingSyntax: "dot",
      arrayRepeat: false,
      arrayRepeatSyntax: "repeat",
      delimiter: 38,
      valueDeserializer: identityFunc,
      valueSerializer: exports.defaultValueSerializer,
      keyDeserializer: identityFunc,
      shouldSerializeObject: exports.defaultShouldSerializeObject
    };
  }
});

// ../node_modules/picoquery/lib/object-util.js
var require_object_util = __commonJS({
  "../node_modules/picoquery/lib/object-util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getDeepObject = getDeepObject;
    exports.stringifyObject = stringifyObject;
    var shared_js_1 = require_shared();
    var string_util_js_1 = require_string_util();
    function isPrototypeKey(value) {
      return value === "__proto__" || value === "constructor" || value === "prototype";
    }
    __name(isPrototypeKey, "isPrototypeKey");
    function getDeepObject(obj, key, nextKey, forceObject, forceArray) {
      if (isPrototypeKey(key))
        return obj;
      const currObj = obj[key];
      if (typeof currObj === "object" && currObj !== null) {
        return currObj;
      }
      if (!forceObject && (forceArray || typeof nextKey === "number" || typeof nextKey === "string" && nextKey * 0 === 0 && nextKey.indexOf(".") === -1)) {
        return obj[key] = [];
      }
      return obj[key] = {};
    }
    __name(getDeepObject, "getDeepObject");
    var MAX_DEPTH = 20;
    var strBracketPair = "[]";
    var strBracketLeft = "[";
    var strBracketRight = "]";
    var strDot = ".";
    function stringifyObject(obj, options, depth = 0, parentKey, isProbableArray) {
      const { nestingSyntax = shared_js_1.defaultOptions.nestingSyntax, arrayRepeat = shared_js_1.defaultOptions.arrayRepeat, arrayRepeatSyntax = shared_js_1.defaultOptions.arrayRepeatSyntax, nesting = shared_js_1.defaultOptions.nesting, delimiter = shared_js_1.defaultOptions.delimiter, valueSerializer = shared_js_1.defaultOptions.valueSerializer, shouldSerializeObject = shared_js_1.defaultOptions.shouldSerializeObject } = options;
      const strDelimiter = typeof delimiter === "number" ? String.fromCharCode(delimiter) : delimiter;
      const useArrayRepeatKey = isProbableArray === true && arrayRepeat;
      const shouldUseDot = nestingSyntax === "dot" || nestingSyntax === "js" && !isProbableArray;
      if (depth > MAX_DEPTH) {
        return "";
      }
      let result = "";
      let firstKey = true;
      let valueIsProbableArray = false;
      for (const key in obj) {
        const value = obj[key];
        if (value === void 0) {
          continue;
        }
        let path;
        if (parentKey) {
          path = parentKey;
          if (useArrayRepeatKey) {
            if (arrayRepeatSyntax === "bracket") {
              path += strBracketPair;
            }
          } else if (shouldUseDot) {
            path += strDot;
            path += key;
          } else {
            path += strBracketLeft;
            path += key;
            path += strBracketRight;
          }
        } else {
          path = key;
        }
        if (!firstKey) {
          result += strDelimiter;
        }
        if (typeof value === "object" && value !== null && !shouldSerializeObject(value)) {
          valueIsProbableArray = value.pop !== void 0;
          if (nesting || arrayRepeat && valueIsProbableArray) {
            result += stringifyObject(value, options, depth + 1, path, valueIsProbableArray);
          }
        } else {
          result += (0, string_util_js_1.encodeString)(path);
          result += "=";
          result += valueSerializer(value, key);
        }
        if (firstKey) {
          firstKey = false;
        }
      }
      return result;
    }
    __name(stringifyObject, "stringifyObject");
  }
});

// ../node_modules/picoquery/lib/decode-uri-component.js
var require_decode_uri_component = __commonJS({
  "../node_modules/picoquery/lib/decode-uri-component.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeURIComponent = decodeURIComponent2;
    var UTF8_ACCEPT = 12;
    var UTF8_REJECT = 0;
    var UTF8_DATA = [
      // The first part of the table maps bytes to character to a transition.
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      4,
      4,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      6,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      8,
      7,
      7,
      10,
      9,
      9,
      9,
      11,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      // The second part of the table maps a state to a new state when adding a
      // transition.
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      12,
      0,
      0,
      0,
      0,
      24,
      36,
      48,
      60,
      72,
      84,
      96,
      0,
      12,
      12,
      12,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      24,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      24,
      24,
      24,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      24,
      24,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      48,
      48,
      48,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      48,
      48,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      48,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // The third part maps the current transition to a mask that needs to apply
      // to the byte.
      127,
      63,
      63,
      63,
      0,
      31,
      15,
      15,
      15,
      7,
      7,
      7
    ];
    function decodeURIComponent2(uri) {
      let percentPosition = uri.indexOf("%");
      if (percentPosition === -1) {
        return uri;
      }
      const length = uri.length;
      let decoded = "";
      let last = 0;
      let codepoint = 0;
      let startOfOctets = percentPosition;
      let state3 = UTF8_ACCEPT;
      while (percentPosition > -1 && percentPosition < length) {
        const high = hexCodeToInt(uri[percentPosition + 1], 4);
        const low = hexCodeToInt(uri[percentPosition + 2], 0);
        const byte = high | low;
        const type5 = UTF8_DATA[byte];
        state3 = UTF8_DATA[256 + state3 + type5];
        codepoint = codepoint << 6 | byte & UTF8_DATA[364 + type5];
        if (state3 === UTF8_ACCEPT) {
          decoded += uri.slice(last, startOfOctets);
          decoded += codepoint <= 65535 ? String.fromCharCode(codepoint) : String.fromCharCode(55232 + (codepoint >> 10), 56320 + (codepoint & 1023));
          codepoint = 0;
          last = percentPosition + 3;
          percentPosition = startOfOctets = uri.indexOf("%", last);
        } else if (state3 === UTF8_REJECT) {
          return null;
        } else {
          percentPosition += 3;
          if (percentPosition < length && uri.charCodeAt(percentPosition) === 37)
            continue;
          return null;
        }
      }
      return decoded + uri.slice(last);
    }
    __name(decodeURIComponent2, "decodeURIComponent");
    var HEX = {
      "0": 0,
      "1": 1,
      "2": 2,
      "3": 3,
      "4": 4,
      "5": 5,
      "6": 6,
      "7": 7,
      "8": 8,
      "9": 9,
      a: 10,
      A: 10,
      b: 11,
      B: 11,
      c: 12,
      C: 12,
      d: 13,
      D: 13,
      e: 14,
      E: 14,
      f: 15,
      F: 15
    };
    function hexCodeToInt(c2, shift) {
      const i2 = HEX[c2];
      return i2 === void 0 ? 255 : i2 << shift;
    }
    __name(hexCodeToInt, "hexCodeToInt");
  }
});

// ../node_modules/picoquery/lib/parse.js
var require_parse = __commonJS({
  "../node_modules/picoquery/lib/parse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.numberValueDeserializer = exports.numberKeyDeserializer = void 0;
    exports.parse = parse6;
    var object_util_js_1 = require_object_util();
    var shared_js_1 = require_shared();
    var decode_uri_component_js_1 = require_decode_uri_component();
    var numberKeyDeserializer = /* @__PURE__ */ __name((key) => {
      const asNumber = Number(key);
      if (!Number.isNaN(asNumber)) {
        return asNumber;
      }
      return key;
    }, "numberKeyDeserializer");
    exports.numberKeyDeserializer = numberKeyDeserializer;
    var numberValueDeserializer = /* @__PURE__ */ __name((value) => {
      const asNumber = Number(value);
      if (!Number.isNaN(asNumber)) {
        return asNumber;
      }
      return value;
    }, "numberValueDeserializer");
    exports.numberValueDeserializer = numberValueDeserializer;
    var regexPlus = /\+/g;
    var Empty = /* @__PURE__ */ __name(function() {
    }, "Empty");
    Empty.prototype = /* @__PURE__ */ Object.create(null);
    function computeKeySlice(input2, startIndex, endIndex, keyHasPlus, shouldDecodeKey) {
      let chunk = input2.substring(startIndex, endIndex);
      if (keyHasPlus) {
        chunk = chunk.replace(regexPlus, " ");
      }
      if (shouldDecodeKey) {
        chunk = (0, decode_uri_component_js_1.decodeURIComponent)(chunk) || chunk;
      }
      return chunk;
    }
    __name(computeKeySlice, "computeKeySlice");
    function parse6(input2, options) {
      const { valueDeserializer = shared_js_1.defaultOptions.valueDeserializer, keyDeserializer = shared_js_1.defaultOptions.keyDeserializer, arrayRepeatSyntax = shared_js_1.defaultOptions.arrayRepeatSyntax, nesting = shared_js_1.defaultOptions.nesting, arrayRepeat = shared_js_1.defaultOptions.arrayRepeat, nestingSyntax = shared_js_1.defaultOptions.nestingSyntax, delimiter = shared_js_1.defaultOptions.delimiter } = options ?? {};
      const charDelimiter = typeof delimiter === "string" ? delimiter.charCodeAt(0) : delimiter;
      const isJsNestingSyntax = nestingSyntax === "js";
      const result = new Empty();
      if (typeof input2 !== "string") {
        return result;
      }
      const inputLength = input2.length;
      let value = "";
      let startingIndex = -1;
      let equalityIndex = -1;
      let keySeparatorIndex = -1;
      let currentObj = result;
      let lastKey = void 0;
      let currentKey = "";
      let keyChunk = "";
      let shouldDecodeKey = false;
      let shouldDecodeValue = false;
      let keyHasPlus = false;
      let valueHasPlus = false;
      let keyIsDot = false;
      let hasBothKeyValuePair = false;
      let c2 = 0;
      let arrayRepeatBracketIndex = -1;
      let prevIndex = -1;
      let prevChar = -1;
      for (let i2 = 0; i2 < inputLength + 1; i2++) {
        c2 = i2 !== inputLength ? input2.charCodeAt(i2) : charDelimiter;
        if (c2 === charDelimiter) {
          hasBothKeyValuePair = equalityIndex > startingIndex;
          if (!hasBothKeyValuePair) {
            equalityIndex = i2;
          }
          if (keySeparatorIndex !== equalityIndex - 1) {
            keyChunk = computeKeySlice(input2, keySeparatorIndex + 1, arrayRepeatBracketIndex > -1 ? arrayRepeatBracketIndex : equalityIndex, keyHasPlus, shouldDecodeKey);
            currentKey = keyDeserializer(keyChunk);
            if (lastKey !== void 0) {
              currentObj = (0, object_util_js_1.getDeepObject)(currentObj, lastKey, currentKey, isJsNestingSyntax && keyIsDot, void 0);
            }
          }
          if (hasBothKeyValuePair || currentKey !== "") {
            if (hasBothKeyValuePair) {
              value = input2.slice(equalityIndex + 1, i2);
              if (valueHasPlus) {
                value = value.replace(regexPlus, " ");
              }
              if (shouldDecodeValue) {
                value = (0, decode_uri_component_js_1.decodeURIComponent)(value) || value;
              }
            }
            const newValue = valueDeserializer(value, currentKey);
            if (arrayRepeat) {
              const currentValue = currentObj[currentKey];
              if (currentValue === void 0) {
                if (arrayRepeatBracketIndex > -1) {
                  currentObj[currentKey] = [newValue];
                } else {
                  currentObj[currentKey] = newValue;
                }
              } else if (currentValue.pop) {
                currentValue.push(newValue);
              } else {
                currentObj[currentKey] = [currentValue, newValue];
              }
            } else
              currentObj[currentKey] = newValue;
          }
          value = "";
          startingIndex = i2;
          equalityIndex = i2;
          shouldDecodeKey = false;
          shouldDecodeValue = false;
          keyHasPlus = false;
          valueHasPlus = false;
          keyIsDot = false;
          arrayRepeatBracketIndex = -1;
          keySeparatorIndex = i2;
          currentObj = result;
          lastKey = void 0;
          currentKey = "";
        } else if (c2 === 93) {
          if (arrayRepeat && arrayRepeatSyntax === "bracket") {
            if (prevChar === 91) {
              arrayRepeatBracketIndex = prevIndex;
            }
          }
          if (nesting && (nestingSyntax === "index" || isJsNestingSyntax) && equalityIndex <= startingIndex) {
            if (keySeparatorIndex !== prevIndex) {
              keyChunk = computeKeySlice(input2, keySeparatorIndex + 1, i2, keyHasPlus, shouldDecodeKey);
              currentKey = keyDeserializer(keyChunk);
              if (lastKey !== void 0) {
                currentObj = (0, object_util_js_1.getDeepObject)(currentObj, lastKey, currentKey, void 0, void 0);
              }
              lastKey = currentKey;
              keyHasPlus = false;
              shouldDecodeKey = false;
            }
            keySeparatorIndex = i2;
            keyIsDot = false;
          }
        } else if (c2 === 46) {
          if (nesting && (nestingSyntax === "dot" || isJsNestingSyntax) && equalityIndex <= startingIndex) {
            if (keySeparatorIndex !== prevIndex) {
              keyChunk = computeKeySlice(input2, keySeparatorIndex + 1, i2, keyHasPlus, shouldDecodeKey);
              currentKey = keyDeserializer(keyChunk);
              if (lastKey !== void 0) {
                currentObj = (0, object_util_js_1.getDeepObject)(currentObj, lastKey, currentKey, isJsNestingSyntax);
              }
              lastKey = currentKey;
              keyHasPlus = false;
              shouldDecodeKey = false;
            }
            keyIsDot = true;
            keySeparatorIndex = i2;
          }
        } else if (c2 === 91) {
          if (nesting && (nestingSyntax === "index" || isJsNestingSyntax) && equalityIndex <= startingIndex) {
            if (keySeparatorIndex !== prevIndex) {
              keyChunk = computeKeySlice(input2, keySeparatorIndex + 1, i2, keyHasPlus, shouldDecodeKey);
              currentKey = keyDeserializer(keyChunk);
              if (isJsNestingSyntax && lastKey !== void 0) {
                currentObj = (0, object_util_js_1.getDeepObject)(currentObj, lastKey, currentKey, isJsNestingSyntax);
              }
              lastKey = currentKey;
              keyHasPlus = false;
              shouldDecodeKey = false;
              keyIsDot = false;
            }
            keySeparatorIndex = i2;
          }
        } else if (c2 === 61) {
          if (equalityIndex <= startingIndex) {
            equalityIndex = i2;
          } else {
            shouldDecodeValue = true;
          }
        } else if (c2 === 43) {
          if (equalityIndex > startingIndex) {
            valueHasPlus = true;
          } else {
            keyHasPlus = true;
          }
        } else if (c2 === 37) {
          if (equalityIndex > startingIndex) {
            shouldDecodeValue = true;
          } else {
            shouldDecodeKey = true;
          }
        }
        prevIndex = i2;
        prevChar = c2;
      }
      return result;
    }
    __name(parse6, "parse");
  }
});

// ../node_modules/picoquery/lib/stringify.js
var require_stringify = __commonJS({
  "../node_modules/picoquery/lib/stringify.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stringify = stringify5;
    var object_util_js_1 = require_object_util();
    function stringify5(input2, options) {
      if (input2 === null || typeof input2 !== "object") {
        return "";
      }
      const optionsObj = options ?? {};
      return (0, object_util_js_1.stringifyObject)(input2, optionsObj);
    }
    __name(stringify5, "stringify");
  }
});

// ../node_modules/picoquery/lib/main.js
var require_main = __commonJS({
  "../node_modules/picoquery/lib/main.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m3, k2);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m3[k2];
        }, "get") };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m3, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m3[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
      for (var p2 in m3) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2)) __createBinding(exports2, m3, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stringify = exports.parse = void 0;
    var parse_js_1 = require_parse();
    Object.defineProperty(exports, "parse", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return parse_js_1.parse;
    }, "get") });
    var stringify_js_1 = require_stringify();
    Object.defineProperty(exports, "stringify", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return stringify_js_1.stringify;
    }, "get") });
    __exportStar(require_shared(), exports);
  }
});

// ../node_modules/entities/lib/maps/entities.json
var require_entities = __commonJS({
  "../node_modules/entities/lib/maps/entities.json"(exports, module2) {
    module2.exports = { Aacute: "\xC1", aacute: "\xE1", Abreve: "\u0102", abreve: "\u0103", ac: "\u223E", acd: "\u223F", acE: "\u223E\u0333", Acirc: "\xC2", acirc: "\xE2", acute: "\xB4", Acy: "\u0410", acy: "\u0430", AElig: "\xC6", aelig: "\xE6", af: "\u2061", Afr: "\u{1D504}", afr: "\u{1D51E}", Agrave: "\xC0", agrave: "\xE0", alefsym: "\u2135", aleph: "\u2135", Alpha: "\u0391", alpha: "\u03B1", Amacr: "\u0100", amacr: "\u0101", amalg: "\u2A3F", amp: "&", AMP: "&", andand: "\u2A55", And: "\u2A53", and: "\u2227", andd: "\u2A5C", andslope: "\u2A58", andv: "\u2A5A", ang: "\u2220", ange: "\u29A4", angle: "\u2220", angmsdaa: "\u29A8", angmsdab: "\u29A9", angmsdac: "\u29AA", angmsdad: "\u29AB", angmsdae: "\u29AC", angmsdaf: "\u29AD", angmsdag: "\u29AE", angmsdah: "\u29AF", angmsd: "\u2221", angrt: "\u221F", angrtvb: "\u22BE", angrtvbd: "\u299D", angsph: "\u2222", angst: "\xC5", angzarr: "\u237C", Aogon: "\u0104", aogon: "\u0105", Aopf: "\u{1D538}", aopf: "\u{1D552}", apacir: "\u2A6F", ap: "\u2248", apE: "\u2A70", ape: "\u224A", apid: "\u224B", apos: "'", ApplyFunction: "\u2061", approx: "\u2248", approxeq: "\u224A", Aring: "\xC5", aring: "\xE5", Ascr: "\u{1D49C}", ascr: "\u{1D4B6}", Assign: "\u2254", ast: "*", asymp: "\u2248", asympeq: "\u224D", Atilde: "\xC3", atilde: "\xE3", Auml: "\xC4", auml: "\xE4", awconint: "\u2233", awint: "\u2A11", backcong: "\u224C", backepsilon: "\u03F6", backprime: "\u2035", backsim: "\u223D", backsimeq: "\u22CD", Backslash: "\u2216", Barv: "\u2AE7", barvee: "\u22BD", barwed: "\u2305", Barwed: "\u2306", barwedge: "\u2305", bbrk: "\u23B5", bbrktbrk: "\u23B6", bcong: "\u224C", Bcy: "\u0411", bcy: "\u0431", bdquo: "\u201E", becaus: "\u2235", because: "\u2235", Because: "\u2235", bemptyv: "\u29B0", bepsi: "\u03F6", bernou: "\u212C", Bernoullis: "\u212C", Beta: "\u0392", beta: "\u03B2", beth: "\u2136", between: "\u226C", Bfr: "\u{1D505}", bfr: "\u{1D51F}", bigcap: "\u22C2", bigcirc: "\u25EF", bigcup: "\u22C3", bigodot: "\u2A00", bigoplus: "\u2A01", bigotimes: "\u2A02", bigsqcup: "\u2A06", bigstar: "\u2605", bigtriangledown: "\u25BD", bigtriangleup: "\u25B3", biguplus: "\u2A04", bigvee: "\u22C1", bigwedge: "\u22C0", bkarow: "\u290D", blacklozenge: "\u29EB", blacksquare: "\u25AA", blacktriangle: "\u25B4", blacktriangledown: "\u25BE", blacktriangleleft: "\u25C2", blacktriangleright: "\u25B8", blank: "\u2423", blk12: "\u2592", blk14: "\u2591", blk34: "\u2593", block: "\u2588", bne: "=\u20E5", bnequiv: "\u2261\u20E5", bNot: "\u2AED", bnot: "\u2310", Bopf: "\u{1D539}", bopf: "\u{1D553}", bot: "\u22A5", bottom: "\u22A5", bowtie: "\u22C8", boxbox: "\u29C9", boxdl: "\u2510", boxdL: "\u2555", boxDl: "\u2556", boxDL: "\u2557", boxdr: "\u250C", boxdR: "\u2552", boxDr: "\u2553", boxDR: "\u2554", boxh: "\u2500", boxH: "\u2550", boxhd: "\u252C", boxHd: "\u2564", boxhD: "\u2565", boxHD: "\u2566", boxhu: "\u2534", boxHu: "\u2567", boxhU: "\u2568", boxHU: "\u2569", boxminus: "\u229F", boxplus: "\u229E", boxtimes: "\u22A0", boxul: "\u2518", boxuL: "\u255B", boxUl: "\u255C", boxUL: "\u255D", boxur: "\u2514", boxuR: "\u2558", boxUr: "\u2559", boxUR: "\u255A", boxv: "\u2502", boxV: "\u2551", boxvh: "\u253C", boxvH: "\u256A", boxVh: "\u256B", boxVH: "\u256C", boxvl: "\u2524", boxvL: "\u2561", boxVl: "\u2562", boxVL: "\u2563", boxvr: "\u251C", boxvR: "\u255E", boxVr: "\u255F", boxVR: "\u2560", bprime: "\u2035", breve: "\u02D8", Breve: "\u02D8", brvbar: "\xA6", bscr: "\u{1D4B7}", Bscr: "\u212C", bsemi: "\u204F", bsim: "\u223D", bsime: "\u22CD", bsolb: "\u29C5", bsol: "\\", bsolhsub: "\u27C8", bull: "\u2022", bullet: "\u2022", bump: "\u224E", bumpE: "\u2AAE", bumpe: "\u224F", Bumpeq: "\u224E", bumpeq: "\u224F", Cacute: "\u0106", cacute: "\u0107", capand: "\u2A44", capbrcup: "\u2A49", capcap: "\u2A4B", cap: "\u2229", Cap: "\u22D2", capcup: "\u2A47", capdot: "\u2A40", CapitalDifferentialD: "\u2145", caps: "\u2229\uFE00", caret: "\u2041", caron: "\u02C7", Cayleys: "\u212D", ccaps: "\u2A4D", Ccaron: "\u010C", ccaron: "\u010D", Ccedil: "\xC7", ccedil: "\xE7", Ccirc: "\u0108", ccirc: "\u0109", Cconint: "\u2230", ccups: "\u2A4C", ccupssm: "\u2A50", Cdot: "\u010A", cdot: "\u010B", cedil: "\xB8", Cedilla: "\xB8", cemptyv: "\u29B2", cent: "\xA2", centerdot: "\xB7", CenterDot: "\xB7", cfr: "\u{1D520}", Cfr: "\u212D", CHcy: "\u0427", chcy: "\u0447", check: "\u2713", checkmark: "\u2713", Chi: "\u03A7", chi: "\u03C7", circ: "\u02C6", circeq: "\u2257", circlearrowleft: "\u21BA", circlearrowright: "\u21BB", circledast: "\u229B", circledcirc: "\u229A", circleddash: "\u229D", CircleDot: "\u2299", circledR: "\xAE", circledS: "\u24C8", CircleMinus: "\u2296", CirclePlus: "\u2295", CircleTimes: "\u2297", cir: "\u25CB", cirE: "\u29C3", cire: "\u2257", cirfnint: "\u2A10", cirmid: "\u2AEF", cirscir: "\u29C2", ClockwiseContourIntegral: "\u2232", CloseCurlyDoubleQuote: "\u201D", CloseCurlyQuote: "\u2019", clubs: "\u2663", clubsuit: "\u2663", colon: ":", Colon: "\u2237", Colone: "\u2A74", colone: "\u2254", coloneq: "\u2254", comma: ",", commat: "@", comp: "\u2201", compfn: "\u2218", complement: "\u2201", complexes: "\u2102", cong: "\u2245", congdot: "\u2A6D", Congruent: "\u2261", conint: "\u222E", Conint: "\u222F", ContourIntegral: "\u222E", copf: "\u{1D554}", Copf: "\u2102", coprod: "\u2210", Coproduct: "\u2210", copy: "\xA9", COPY: "\xA9", copysr: "\u2117", CounterClockwiseContourIntegral: "\u2233", crarr: "\u21B5", cross: "\u2717", Cross: "\u2A2F", Cscr: "\u{1D49E}", cscr: "\u{1D4B8}", csub: "\u2ACF", csube: "\u2AD1", csup: "\u2AD0", csupe: "\u2AD2", ctdot: "\u22EF", cudarrl: "\u2938", cudarrr: "\u2935", cuepr: "\u22DE", cuesc: "\u22DF", cularr: "\u21B6", cularrp: "\u293D", cupbrcap: "\u2A48", cupcap: "\u2A46", CupCap: "\u224D", cup: "\u222A", Cup: "\u22D3", cupcup: "\u2A4A", cupdot: "\u228D", cupor: "\u2A45", cups: "\u222A\uFE00", curarr: "\u21B7", curarrm: "\u293C", curlyeqprec: "\u22DE", curlyeqsucc: "\u22DF", curlyvee: "\u22CE", curlywedge: "\u22CF", curren: "\xA4", curvearrowleft: "\u21B6", curvearrowright: "\u21B7", cuvee: "\u22CE", cuwed: "\u22CF", cwconint: "\u2232", cwint: "\u2231", cylcty: "\u232D", dagger: "\u2020", Dagger: "\u2021", daleth: "\u2138", darr: "\u2193", Darr: "\u21A1", dArr: "\u21D3", dash: "\u2010", Dashv: "\u2AE4", dashv: "\u22A3", dbkarow: "\u290F", dblac: "\u02DD", Dcaron: "\u010E", dcaron: "\u010F", Dcy: "\u0414", dcy: "\u0434", ddagger: "\u2021", ddarr: "\u21CA", DD: "\u2145", dd: "\u2146", DDotrahd: "\u2911", ddotseq: "\u2A77", deg: "\xB0", Del: "\u2207", Delta: "\u0394", delta: "\u03B4", demptyv: "\u29B1", dfisht: "\u297F", Dfr: "\u{1D507}", dfr: "\u{1D521}", dHar: "\u2965", dharl: "\u21C3", dharr: "\u21C2", DiacriticalAcute: "\xB4", DiacriticalDot: "\u02D9", DiacriticalDoubleAcute: "\u02DD", DiacriticalGrave: "`", DiacriticalTilde: "\u02DC", diam: "\u22C4", diamond: "\u22C4", Diamond: "\u22C4", diamondsuit: "\u2666", diams: "\u2666", die: "\xA8", DifferentialD: "\u2146", digamma: "\u03DD", disin: "\u22F2", div: "\xF7", divide: "\xF7", divideontimes: "\u22C7", divonx: "\u22C7", DJcy: "\u0402", djcy: "\u0452", dlcorn: "\u231E", dlcrop: "\u230D", dollar: "$", Dopf: "\u{1D53B}", dopf: "\u{1D555}", Dot: "\xA8", dot: "\u02D9", DotDot: "\u20DC", doteq: "\u2250", doteqdot: "\u2251", DotEqual: "\u2250", dotminus: "\u2238", dotplus: "\u2214", dotsquare: "\u22A1", doublebarwedge: "\u2306", DoubleContourIntegral: "\u222F", DoubleDot: "\xA8", DoubleDownArrow: "\u21D3", DoubleLeftArrow: "\u21D0", DoubleLeftRightArrow: "\u21D4", DoubleLeftTee: "\u2AE4", DoubleLongLeftArrow: "\u27F8", DoubleLongLeftRightArrow: "\u27FA", DoubleLongRightArrow: "\u27F9", DoubleRightArrow: "\u21D2", DoubleRightTee: "\u22A8", DoubleUpArrow: "\u21D1", DoubleUpDownArrow: "\u21D5", DoubleVerticalBar: "\u2225", DownArrowBar: "\u2913", downarrow: "\u2193", DownArrow: "\u2193", Downarrow: "\u21D3", DownArrowUpArrow: "\u21F5", DownBreve: "\u0311", downdownarrows: "\u21CA", downharpoonleft: "\u21C3", downharpoonright: "\u21C2", DownLeftRightVector: "\u2950", DownLeftTeeVector: "\u295E", DownLeftVectorBar: "\u2956", DownLeftVector: "\u21BD", DownRightTeeVector: "\u295F", DownRightVectorBar: "\u2957", DownRightVector: "\u21C1", DownTeeArrow: "\u21A7", DownTee: "\u22A4", drbkarow: "\u2910", drcorn: "\u231F", drcrop: "\u230C", Dscr: "\u{1D49F}", dscr: "\u{1D4B9}", DScy: "\u0405", dscy: "\u0455", dsol: "\u29F6", Dstrok: "\u0110", dstrok: "\u0111", dtdot: "\u22F1", dtri: "\u25BF", dtrif: "\u25BE", duarr: "\u21F5", duhar: "\u296F", dwangle: "\u29A6", DZcy: "\u040F", dzcy: "\u045F", dzigrarr: "\u27FF", Eacute: "\xC9", eacute: "\xE9", easter: "\u2A6E", Ecaron: "\u011A", ecaron: "\u011B", Ecirc: "\xCA", ecirc: "\xEA", ecir: "\u2256", ecolon: "\u2255", Ecy: "\u042D", ecy: "\u044D", eDDot: "\u2A77", Edot: "\u0116", edot: "\u0117", eDot: "\u2251", ee: "\u2147", efDot: "\u2252", Efr: "\u{1D508}", efr: "\u{1D522}", eg: "\u2A9A", Egrave: "\xC8", egrave: "\xE8", egs: "\u2A96", egsdot: "\u2A98", el: "\u2A99", Element: "\u2208", elinters: "\u23E7", ell: "\u2113", els: "\u2A95", elsdot: "\u2A97", Emacr: "\u0112", emacr: "\u0113", empty: "\u2205", emptyset: "\u2205", EmptySmallSquare: "\u25FB", emptyv: "\u2205", EmptyVerySmallSquare: "\u25AB", emsp13: "\u2004", emsp14: "\u2005", emsp: "\u2003", ENG: "\u014A", eng: "\u014B", ensp: "\u2002", Eogon: "\u0118", eogon: "\u0119", Eopf: "\u{1D53C}", eopf: "\u{1D556}", epar: "\u22D5", eparsl: "\u29E3", eplus: "\u2A71", epsi: "\u03B5", Epsilon: "\u0395", epsilon: "\u03B5", epsiv: "\u03F5", eqcirc: "\u2256", eqcolon: "\u2255", eqsim: "\u2242", eqslantgtr: "\u2A96", eqslantless: "\u2A95", Equal: "\u2A75", equals: "=", EqualTilde: "\u2242", equest: "\u225F", Equilibrium: "\u21CC", equiv: "\u2261", equivDD: "\u2A78", eqvparsl: "\u29E5", erarr: "\u2971", erDot: "\u2253", escr: "\u212F", Escr: "\u2130", esdot: "\u2250", Esim: "\u2A73", esim: "\u2242", Eta: "\u0397", eta: "\u03B7", ETH: "\xD0", eth: "\xF0", Euml: "\xCB", euml: "\xEB", euro: "\u20AC", excl: "!", exist: "\u2203", Exists: "\u2203", expectation: "\u2130", exponentiale: "\u2147", ExponentialE: "\u2147", fallingdotseq: "\u2252", Fcy: "\u0424", fcy: "\u0444", female: "\u2640", ffilig: "\uFB03", fflig: "\uFB00", ffllig: "\uFB04", Ffr: "\u{1D509}", ffr: "\u{1D523}", filig: "\uFB01", FilledSmallSquare: "\u25FC", FilledVerySmallSquare: "\u25AA", fjlig: "fj", flat: "\u266D", fllig: "\uFB02", fltns: "\u25B1", fnof: "\u0192", Fopf: "\u{1D53D}", fopf: "\u{1D557}", forall: "\u2200", ForAll: "\u2200", fork: "\u22D4", forkv: "\u2AD9", Fouriertrf: "\u2131", fpartint: "\u2A0D", frac12: "\xBD", frac13: "\u2153", frac14: "\xBC", frac15: "\u2155", frac16: "\u2159", frac18: "\u215B", frac23: "\u2154", frac25: "\u2156", frac34: "\xBE", frac35: "\u2157", frac38: "\u215C", frac45: "\u2158", frac56: "\u215A", frac58: "\u215D", frac78: "\u215E", frasl: "\u2044", frown: "\u2322", fscr: "\u{1D4BB}", Fscr: "\u2131", gacute: "\u01F5", Gamma: "\u0393", gamma: "\u03B3", Gammad: "\u03DC", gammad: "\u03DD", gap: "\u2A86", Gbreve: "\u011E", gbreve: "\u011F", Gcedil: "\u0122", Gcirc: "\u011C", gcirc: "\u011D", Gcy: "\u0413", gcy: "\u0433", Gdot: "\u0120", gdot: "\u0121", ge: "\u2265", gE: "\u2267", gEl: "\u2A8C", gel: "\u22DB", geq: "\u2265", geqq: "\u2267", geqslant: "\u2A7E", gescc: "\u2AA9", ges: "\u2A7E", gesdot: "\u2A80", gesdoto: "\u2A82", gesdotol: "\u2A84", gesl: "\u22DB\uFE00", gesles: "\u2A94", Gfr: "\u{1D50A}", gfr: "\u{1D524}", gg: "\u226B", Gg: "\u22D9", ggg: "\u22D9", gimel: "\u2137", GJcy: "\u0403", gjcy: "\u0453", gla: "\u2AA5", gl: "\u2277", glE: "\u2A92", glj: "\u2AA4", gnap: "\u2A8A", gnapprox: "\u2A8A", gne: "\u2A88", gnE: "\u2269", gneq: "\u2A88", gneqq: "\u2269", gnsim: "\u22E7", Gopf: "\u{1D53E}", gopf: "\u{1D558}", grave: "`", GreaterEqual: "\u2265", GreaterEqualLess: "\u22DB", GreaterFullEqual: "\u2267", GreaterGreater: "\u2AA2", GreaterLess: "\u2277", GreaterSlantEqual: "\u2A7E", GreaterTilde: "\u2273", Gscr: "\u{1D4A2}", gscr: "\u210A", gsim: "\u2273", gsime: "\u2A8E", gsiml: "\u2A90", gtcc: "\u2AA7", gtcir: "\u2A7A", gt: ">", GT: ">", Gt: "\u226B", gtdot: "\u22D7", gtlPar: "\u2995", gtquest: "\u2A7C", gtrapprox: "\u2A86", gtrarr: "\u2978", gtrdot: "\u22D7", gtreqless: "\u22DB", gtreqqless: "\u2A8C", gtrless: "\u2277", gtrsim: "\u2273", gvertneqq: "\u2269\uFE00", gvnE: "\u2269\uFE00", Hacek: "\u02C7", hairsp: "\u200A", half: "\xBD", hamilt: "\u210B", HARDcy: "\u042A", hardcy: "\u044A", harrcir: "\u2948", harr: "\u2194", hArr: "\u21D4", harrw: "\u21AD", Hat: "^", hbar: "\u210F", Hcirc: "\u0124", hcirc: "\u0125", hearts: "\u2665", heartsuit: "\u2665", hellip: "\u2026", hercon: "\u22B9", hfr: "\u{1D525}", Hfr: "\u210C", HilbertSpace: "\u210B", hksearow: "\u2925", hkswarow: "\u2926", hoarr: "\u21FF", homtht: "\u223B", hookleftarrow: "\u21A9", hookrightarrow: "\u21AA", hopf: "\u{1D559}", Hopf: "\u210D", horbar: "\u2015", HorizontalLine: "\u2500", hscr: "\u{1D4BD}", Hscr: "\u210B", hslash: "\u210F", Hstrok: "\u0126", hstrok: "\u0127", HumpDownHump: "\u224E", HumpEqual: "\u224F", hybull: "\u2043", hyphen: "\u2010", Iacute: "\xCD", iacute: "\xED", ic: "\u2063", Icirc: "\xCE", icirc: "\xEE", Icy: "\u0418", icy: "\u0438", Idot: "\u0130", IEcy: "\u0415", iecy: "\u0435", iexcl: "\xA1", iff: "\u21D4", ifr: "\u{1D526}", Ifr: "\u2111", Igrave: "\xCC", igrave: "\xEC", ii: "\u2148", iiiint: "\u2A0C", iiint: "\u222D", iinfin: "\u29DC", iiota: "\u2129", IJlig: "\u0132", ijlig: "\u0133", Imacr: "\u012A", imacr: "\u012B", image: "\u2111", ImaginaryI: "\u2148", imagline: "\u2110", imagpart: "\u2111", imath: "\u0131", Im: "\u2111", imof: "\u22B7", imped: "\u01B5", Implies: "\u21D2", incare: "\u2105", in: "\u2208", infin: "\u221E", infintie: "\u29DD", inodot: "\u0131", intcal: "\u22BA", int: "\u222B", Int: "\u222C", integers: "\u2124", Integral: "\u222B", intercal: "\u22BA", Intersection: "\u22C2", intlarhk: "\u2A17", intprod: "\u2A3C", InvisibleComma: "\u2063", InvisibleTimes: "\u2062", IOcy: "\u0401", iocy: "\u0451", Iogon: "\u012E", iogon: "\u012F", Iopf: "\u{1D540}", iopf: "\u{1D55A}", Iota: "\u0399", iota: "\u03B9", iprod: "\u2A3C", iquest: "\xBF", iscr: "\u{1D4BE}", Iscr: "\u2110", isin: "\u2208", isindot: "\u22F5", isinE: "\u22F9", isins: "\u22F4", isinsv: "\u22F3", isinv: "\u2208", it: "\u2062", Itilde: "\u0128", itilde: "\u0129", Iukcy: "\u0406", iukcy: "\u0456", Iuml: "\xCF", iuml: "\xEF", Jcirc: "\u0134", jcirc: "\u0135", Jcy: "\u0419", jcy: "\u0439", Jfr: "\u{1D50D}", jfr: "\u{1D527}", jmath: "\u0237", Jopf: "\u{1D541}", jopf: "\u{1D55B}", Jscr: "\u{1D4A5}", jscr: "\u{1D4BF}", Jsercy: "\u0408", jsercy: "\u0458", Jukcy: "\u0404", jukcy: "\u0454", Kappa: "\u039A", kappa: "\u03BA", kappav: "\u03F0", Kcedil: "\u0136", kcedil: "\u0137", Kcy: "\u041A", kcy: "\u043A", Kfr: "\u{1D50E}", kfr: "\u{1D528}", kgreen: "\u0138", KHcy: "\u0425", khcy: "\u0445", KJcy: "\u040C", kjcy: "\u045C", Kopf: "\u{1D542}", kopf: "\u{1D55C}", Kscr: "\u{1D4A6}", kscr: "\u{1D4C0}", lAarr: "\u21DA", Lacute: "\u0139", lacute: "\u013A", laemptyv: "\u29B4", lagran: "\u2112", Lambda: "\u039B", lambda: "\u03BB", lang: "\u27E8", Lang: "\u27EA", langd: "\u2991", langle: "\u27E8", lap: "\u2A85", Laplacetrf: "\u2112", laquo: "\xAB", larrb: "\u21E4", larrbfs: "\u291F", larr: "\u2190", Larr: "\u219E", lArr: "\u21D0", larrfs: "\u291D", larrhk: "\u21A9", larrlp: "\u21AB", larrpl: "\u2939", larrsim: "\u2973", larrtl: "\u21A2", latail: "\u2919", lAtail: "\u291B", lat: "\u2AAB", late: "\u2AAD", lates: "\u2AAD\uFE00", lbarr: "\u290C", lBarr: "\u290E", lbbrk: "\u2772", lbrace: "{", lbrack: "[", lbrke: "\u298B", lbrksld: "\u298F", lbrkslu: "\u298D", Lcaron: "\u013D", lcaron: "\u013E", Lcedil: "\u013B", lcedil: "\u013C", lceil: "\u2308", lcub: "{", Lcy: "\u041B", lcy: "\u043B", ldca: "\u2936", ldquo: "\u201C", ldquor: "\u201E", ldrdhar: "\u2967", ldrushar: "\u294B", ldsh: "\u21B2", le: "\u2264", lE: "\u2266", LeftAngleBracket: "\u27E8", LeftArrowBar: "\u21E4", leftarrow: "\u2190", LeftArrow: "\u2190", Leftarrow: "\u21D0", LeftArrowRightArrow: "\u21C6", leftarrowtail: "\u21A2", LeftCeiling: "\u2308", LeftDoubleBracket: "\u27E6", LeftDownTeeVector: "\u2961", LeftDownVectorBar: "\u2959", LeftDownVector: "\u21C3", LeftFloor: "\u230A", leftharpoondown: "\u21BD", leftharpoonup: "\u21BC", leftleftarrows: "\u21C7", leftrightarrow: "\u2194", LeftRightArrow: "\u2194", Leftrightarrow: "\u21D4", leftrightarrows: "\u21C6", leftrightharpoons: "\u21CB", leftrightsquigarrow: "\u21AD", LeftRightVector: "\u294E", LeftTeeArrow: "\u21A4", LeftTee: "\u22A3", LeftTeeVector: "\u295A", leftthreetimes: "\u22CB", LeftTriangleBar: "\u29CF", LeftTriangle: "\u22B2", LeftTriangleEqual: "\u22B4", LeftUpDownVector: "\u2951", LeftUpTeeVector: "\u2960", LeftUpVectorBar: "\u2958", LeftUpVector: "\u21BF", LeftVectorBar: "\u2952", LeftVector: "\u21BC", lEg: "\u2A8B", leg: "\u22DA", leq: "\u2264", leqq: "\u2266", leqslant: "\u2A7D", lescc: "\u2AA8", les: "\u2A7D", lesdot: "\u2A7F", lesdoto: "\u2A81", lesdotor: "\u2A83", lesg: "\u22DA\uFE00", lesges: "\u2A93", lessapprox: "\u2A85", lessdot: "\u22D6", lesseqgtr: "\u22DA", lesseqqgtr: "\u2A8B", LessEqualGreater: "\u22DA", LessFullEqual: "\u2266", LessGreater: "\u2276", lessgtr: "\u2276", LessLess: "\u2AA1", lesssim: "\u2272", LessSlantEqual: "\u2A7D", LessTilde: "\u2272", lfisht: "\u297C", lfloor: "\u230A", Lfr: "\u{1D50F}", lfr: "\u{1D529}", lg: "\u2276", lgE: "\u2A91", lHar: "\u2962", lhard: "\u21BD", lharu: "\u21BC", lharul: "\u296A", lhblk: "\u2584", LJcy: "\u0409", ljcy: "\u0459", llarr: "\u21C7", ll: "\u226A", Ll: "\u22D8", llcorner: "\u231E", Lleftarrow: "\u21DA", llhard: "\u296B", lltri: "\u25FA", Lmidot: "\u013F", lmidot: "\u0140", lmoustache: "\u23B0", lmoust: "\u23B0", lnap: "\u2A89", lnapprox: "\u2A89", lne: "\u2A87", lnE: "\u2268", lneq: "\u2A87", lneqq: "\u2268", lnsim: "\u22E6", loang: "\u27EC", loarr: "\u21FD", lobrk: "\u27E6", longleftarrow: "\u27F5", LongLeftArrow: "\u27F5", Longleftarrow: "\u27F8", longleftrightarrow: "\u27F7", LongLeftRightArrow: "\u27F7", Longleftrightarrow: "\u27FA", longmapsto: "\u27FC", longrightarrow: "\u27F6", LongRightArrow: "\u27F6", Longrightarrow: "\u27F9", looparrowleft: "\u21AB", looparrowright: "\u21AC", lopar: "\u2985", Lopf: "\u{1D543}", lopf: "\u{1D55D}", loplus: "\u2A2D", lotimes: "\u2A34", lowast: "\u2217", lowbar: "_", LowerLeftArrow: "\u2199", LowerRightArrow: "\u2198", loz: "\u25CA", lozenge: "\u25CA", lozf: "\u29EB", lpar: "(", lparlt: "\u2993", lrarr: "\u21C6", lrcorner: "\u231F", lrhar: "\u21CB", lrhard: "\u296D", lrm: "\u200E", lrtri: "\u22BF", lsaquo: "\u2039", lscr: "\u{1D4C1}", Lscr: "\u2112", lsh: "\u21B0", Lsh: "\u21B0", lsim: "\u2272", lsime: "\u2A8D", lsimg: "\u2A8F", lsqb: "[", lsquo: "\u2018", lsquor: "\u201A", Lstrok: "\u0141", lstrok: "\u0142", ltcc: "\u2AA6", ltcir: "\u2A79", lt: "<", LT: "<", Lt: "\u226A", ltdot: "\u22D6", lthree: "\u22CB", ltimes: "\u22C9", ltlarr: "\u2976", ltquest: "\u2A7B", ltri: "\u25C3", ltrie: "\u22B4", ltrif: "\u25C2", ltrPar: "\u2996", lurdshar: "\u294A", luruhar: "\u2966", lvertneqq: "\u2268\uFE00", lvnE: "\u2268\uFE00", macr: "\xAF", male: "\u2642", malt: "\u2720", maltese: "\u2720", Map: "\u2905", map: "\u21A6", mapsto: "\u21A6", mapstodown: "\u21A7", mapstoleft: "\u21A4", mapstoup: "\u21A5", marker: "\u25AE", mcomma: "\u2A29", Mcy: "\u041C", mcy: "\u043C", mdash: "\u2014", mDDot: "\u223A", measuredangle: "\u2221", MediumSpace: "\u205F", Mellintrf: "\u2133", Mfr: "\u{1D510}", mfr: "\u{1D52A}", mho: "\u2127", micro: "\xB5", midast: "*", midcir: "\u2AF0", mid: "\u2223", middot: "\xB7", minusb: "\u229F", minus: "\u2212", minusd: "\u2238", minusdu: "\u2A2A", MinusPlus: "\u2213", mlcp: "\u2ADB", mldr: "\u2026", mnplus: "\u2213", models: "\u22A7", Mopf: "\u{1D544}", mopf: "\u{1D55E}", mp: "\u2213", mscr: "\u{1D4C2}", Mscr: "\u2133", mstpos: "\u223E", Mu: "\u039C", mu: "\u03BC", multimap: "\u22B8", mumap: "\u22B8", nabla: "\u2207", Nacute: "\u0143", nacute: "\u0144", nang: "\u2220\u20D2", nap: "\u2249", napE: "\u2A70\u0338", napid: "\u224B\u0338", napos: "\u0149", napprox: "\u2249", natural: "\u266E", naturals: "\u2115", natur: "\u266E", nbsp: "\xA0", nbump: "\u224E\u0338", nbumpe: "\u224F\u0338", ncap: "\u2A43", Ncaron: "\u0147", ncaron: "\u0148", Ncedil: "\u0145", ncedil: "\u0146", ncong: "\u2247", ncongdot: "\u2A6D\u0338", ncup: "\u2A42", Ncy: "\u041D", ncy: "\u043D", ndash: "\u2013", nearhk: "\u2924", nearr: "\u2197", neArr: "\u21D7", nearrow: "\u2197", ne: "\u2260", nedot: "\u2250\u0338", NegativeMediumSpace: "\u200B", NegativeThickSpace: "\u200B", NegativeThinSpace: "\u200B", NegativeVeryThinSpace: "\u200B", nequiv: "\u2262", nesear: "\u2928", nesim: "\u2242\u0338", NestedGreaterGreater: "\u226B", NestedLessLess: "\u226A", NewLine: "\n", nexist: "\u2204", nexists: "\u2204", Nfr: "\u{1D511}", nfr: "\u{1D52B}", ngE: "\u2267\u0338", nge: "\u2271", ngeq: "\u2271", ngeqq: "\u2267\u0338", ngeqslant: "\u2A7E\u0338", nges: "\u2A7E\u0338", nGg: "\u22D9\u0338", ngsim: "\u2275", nGt: "\u226B\u20D2", ngt: "\u226F", ngtr: "\u226F", nGtv: "\u226B\u0338", nharr: "\u21AE", nhArr: "\u21CE", nhpar: "\u2AF2", ni: "\u220B", nis: "\u22FC", nisd: "\u22FA", niv: "\u220B", NJcy: "\u040A", njcy: "\u045A", nlarr: "\u219A", nlArr: "\u21CD", nldr: "\u2025", nlE: "\u2266\u0338", nle: "\u2270", nleftarrow: "\u219A", nLeftarrow: "\u21CD", nleftrightarrow: "\u21AE", nLeftrightarrow: "\u21CE", nleq: "\u2270", nleqq: "\u2266\u0338", nleqslant: "\u2A7D\u0338", nles: "\u2A7D\u0338", nless: "\u226E", nLl: "\u22D8\u0338", nlsim: "\u2274", nLt: "\u226A\u20D2", nlt: "\u226E", nltri: "\u22EA", nltrie: "\u22EC", nLtv: "\u226A\u0338", nmid: "\u2224", NoBreak: "\u2060", NonBreakingSpace: "\xA0", nopf: "\u{1D55F}", Nopf: "\u2115", Not: "\u2AEC", not: "\xAC", NotCongruent: "\u2262", NotCupCap: "\u226D", NotDoubleVerticalBar: "\u2226", NotElement: "\u2209", NotEqual: "\u2260", NotEqualTilde: "\u2242\u0338", NotExists: "\u2204", NotGreater: "\u226F", NotGreaterEqual: "\u2271", NotGreaterFullEqual: "\u2267\u0338", NotGreaterGreater: "\u226B\u0338", NotGreaterLess: "\u2279", NotGreaterSlantEqual: "\u2A7E\u0338", NotGreaterTilde: "\u2275", NotHumpDownHump: "\u224E\u0338", NotHumpEqual: "\u224F\u0338", notin: "\u2209", notindot: "\u22F5\u0338", notinE: "\u22F9\u0338", notinva: "\u2209", notinvb: "\u22F7", notinvc: "\u22F6", NotLeftTriangleBar: "\u29CF\u0338", NotLeftTriangle: "\u22EA", NotLeftTriangleEqual: "\u22EC", NotLess: "\u226E", NotLessEqual: "\u2270", NotLessGreater: "\u2278", NotLessLess: "\u226A\u0338", NotLessSlantEqual: "\u2A7D\u0338", NotLessTilde: "\u2274", NotNestedGreaterGreater: "\u2AA2\u0338", NotNestedLessLess: "\u2AA1\u0338", notni: "\u220C", notniva: "\u220C", notnivb: "\u22FE", notnivc: "\u22FD", NotPrecedes: "\u2280", NotPrecedesEqual: "\u2AAF\u0338", NotPrecedesSlantEqual: "\u22E0", NotReverseElement: "\u220C", NotRightTriangleBar: "\u29D0\u0338", NotRightTriangle: "\u22EB", NotRightTriangleEqual: "\u22ED", NotSquareSubset: "\u228F\u0338", NotSquareSubsetEqual: "\u22E2", NotSquareSuperset: "\u2290\u0338", NotSquareSupersetEqual: "\u22E3", NotSubset: "\u2282\u20D2", NotSubsetEqual: "\u2288", NotSucceeds: "\u2281", NotSucceedsEqual: "\u2AB0\u0338", NotSucceedsSlantEqual: "\u22E1", NotSucceedsTilde: "\u227F\u0338", NotSuperset: "\u2283\u20D2", NotSupersetEqual: "\u2289", NotTilde: "\u2241", NotTildeEqual: "\u2244", NotTildeFullEqual: "\u2247", NotTildeTilde: "\u2249", NotVerticalBar: "\u2224", nparallel: "\u2226", npar: "\u2226", nparsl: "\u2AFD\u20E5", npart: "\u2202\u0338", npolint: "\u2A14", npr: "\u2280", nprcue: "\u22E0", nprec: "\u2280", npreceq: "\u2AAF\u0338", npre: "\u2AAF\u0338", nrarrc: "\u2933\u0338", nrarr: "\u219B", nrArr: "\u21CF", nrarrw: "\u219D\u0338", nrightarrow: "\u219B", nRightarrow: "\u21CF", nrtri: "\u22EB", nrtrie: "\u22ED", nsc: "\u2281", nsccue: "\u22E1", nsce: "\u2AB0\u0338", Nscr: "\u{1D4A9}", nscr: "\u{1D4C3}", nshortmid: "\u2224", nshortparallel: "\u2226", nsim: "\u2241", nsime: "\u2244", nsimeq: "\u2244", nsmid: "\u2224", nspar: "\u2226", nsqsube: "\u22E2", nsqsupe: "\u22E3", nsub: "\u2284", nsubE: "\u2AC5\u0338", nsube: "\u2288", nsubset: "\u2282\u20D2", nsubseteq: "\u2288", nsubseteqq: "\u2AC5\u0338", nsucc: "\u2281", nsucceq: "\u2AB0\u0338", nsup: "\u2285", nsupE: "\u2AC6\u0338", nsupe: "\u2289", nsupset: "\u2283\u20D2", nsupseteq: "\u2289", nsupseteqq: "\u2AC6\u0338", ntgl: "\u2279", Ntilde: "\xD1", ntilde: "\xF1", ntlg: "\u2278", ntriangleleft: "\u22EA", ntrianglelefteq: "\u22EC", ntriangleright: "\u22EB", ntrianglerighteq: "\u22ED", Nu: "\u039D", nu: "\u03BD", num: "#", numero: "\u2116", numsp: "\u2007", nvap: "\u224D\u20D2", nvdash: "\u22AC", nvDash: "\u22AD", nVdash: "\u22AE", nVDash: "\u22AF", nvge: "\u2265\u20D2", nvgt: ">\u20D2", nvHarr: "\u2904", nvinfin: "\u29DE", nvlArr: "\u2902", nvle: "\u2264\u20D2", nvlt: "<\u20D2", nvltrie: "\u22B4\u20D2", nvrArr: "\u2903", nvrtrie: "\u22B5\u20D2", nvsim: "\u223C\u20D2", nwarhk: "\u2923", nwarr: "\u2196", nwArr: "\u21D6", nwarrow: "\u2196", nwnear: "\u2927", Oacute: "\xD3", oacute: "\xF3", oast: "\u229B", Ocirc: "\xD4", ocirc: "\xF4", ocir: "\u229A", Ocy: "\u041E", ocy: "\u043E", odash: "\u229D", Odblac: "\u0150", odblac: "\u0151", odiv: "\u2A38", odot: "\u2299", odsold: "\u29BC", OElig: "\u0152", oelig: "\u0153", ofcir: "\u29BF", Ofr: "\u{1D512}", ofr: "\u{1D52C}", ogon: "\u02DB", Ograve: "\xD2", ograve: "\xF2", ogt: "\u29C1", ohbar: "\u29B5", ohm: "\u03A9", oint: "\u222E", olarr: "\u21BA", olcir: "\u29BE", olcross: "\u29BB", oline: "\u203E", olt: "\u29C0", Omacr: "\u014C", omacr: "\u014D", Omega: "\u03A9", omega: "\u03C9", Omicron: "\u039F", omicron: "\u03BF", omid: "\u29B6", ominus: "\u2296", Oopf: "\u{1D546}", oopf: "\u{1D560}", opar: "\u29B7", OpenCurlyDoubleQuote: "\u201C", OpenCurlyQuote: "\u2018", operp: "\u29B9", oplus: "\u2295", orarr: "\u21BB", Or: "\u2A54", or: "\u2228", ord: "\u2A5D", order: "\u2134", orderof: "\u2134", ordf: "\xAA", ordm: "\xBA", origof: "\u22B6", oror: "\u2A56", orslope: "\u2A57", orv: "\u2A5B", oS: "\u24C8", Oscr: "\u{1D4AA}", oscr: "\u2134", Oslash: "\xD8", oslash: "\xF8", osol: "\u2298", Otilde: "\xD5", otilde: "\xF5", otimesas: "\u2A36", Otimes: "\u2A37", otimes: "\u2297", Ouml: "\xD6", ouml: "\xF6", ovbar: "\u233D", OverBar: "\u203E", OverBrace: "\u23DE", OverBracket: "\u23B4", OverParenthesis: "\u23DC", para: "\xB6", parallel: "\u2225", par: "\u2225", parsim: "\u2AF3", parsl: "\u2AFD", part: "\u2202", PartialD: "\u2202", Pcy: "\u041F", pcy: "\u043F", percnt: "%", period: ".", permil: "\u2030", perp: "\u22A5", pertenk: "\u2031", Pfr: "\u{1D513}", pfr: "\u{1D52D}", Phi: "\u03A6", phi: "\u03C6", phiv: "\u03D5", phmmat: "\u2133", phone: "\u260E", Pi: "\u03A0", pi: "\u03C0", pitchfork: "\u22D4", piv: "\u03D6", planck: "\u210F", planckh: "\u210E", plankv: "\u210F", plusacir: "\u2A23", plusb: "\u229E", pluscir: "\u2A22", plus: "+", plusdo: "\u2214", plusdu: "\u2A25", pluse: "\u2A72", PlusMinus: "\xB1", plusmn: "\xB1", plussim: "\u2A26", plustwo: "\u2A27", pm: "\xB1", Poincareplane: "\u210C", pointint: "\u2A15", popf: "\u{1D561}", Popf: "\u2119", pound: "\xA3", prap: "\u2AB7", Pr: "\u2ABB", pr: "\u227A", prcue: "\u227C", precapprox: "\u2AB7", prec: "\u227A", preccurlyeq: "\u227C", Precedes: "\u227A", PrecedesEqual: "\u2AAF", PrecedesSlantEqual: "\u227C", PrecedesTilde: "\u227E", preceq: "\u2AAF", precnapprox: "\u2AB9", precneqq: "\u2AB5", precnsim: "\u22E8", pre: "\u2AAF", prE: "\u2AB3", precsim: "\u227E", prime: "\u2032", Prime: "\u2033", primes: "\u2119", prnap: "\u2AB9", prnE: "\u2AB5", prnsim: "\u22E8", prod: "\u220F", Product: "\u220F", profalar: "\u232E", profline: "\u2312", profsurf: "\u2313", prop: "\u221D", Proportional: "\u221D", Proportion: "\u2237", propto: "\u221D", prsim: "\u227E", prurel: "\u22B0", Pscr: "\u{1D4AB}", pscr: "\u{1D4C5}", Psi: "\u03A8", psi: "\u03C8", puncsp: "\u2008", Qfr: "\u{1D514}", qfr: "\u{1D52E}", qint: "\u2A0C", qopf: "\u{1D562}", Qopf: "\u211A", qprime: "\u2057", Qscr: "\u{1D4AC}", qscr: "\u{1D4C6}", quaternions: "\u210D", quatint: "\u2A16", quest: "?", questeq: "\u225F", quot: '"', QUOT: '"', rAarr: "\u21DB", race: "\u223D\u0331", Racute: "\u0154", racute: "\u0155", radic: "\u221A", raemptyv: "\u29B3", rang: "\u27E9", Rang: "\u27EB", rangd: "\u2992", range: "\u29A5", rangle: "\u27E9", raquo: "\xBB", rarrap: "\u2975", rarrb: "\u21E5", rarrbfs: "\u2920", rarrc: "\u2933", rarr: "\u2192", Rarr: "\u21A0", rArr: "\u21D2", rarrfs: "\u291E", rarrhk: "\u21AA", rarrlp: "\u21AC", rarrpl: "\u2945", rarrsim: "\u2974", Rarrtl: "\u2916", rarrtl: "\u21A3", rarrw: "\u219D", ratail: "\u291A", rAtail: "\u291C", ratio: "\u2236", rationals: "\u211A", rbarr: "\u290D", rBarr: "\u290F", RBarr: "\u2910", rbbrk: "\u2773", rbrace: "}", rbrack: "]", rbrke: "\u298C", rbrksld: "\u298E", rbrkslu: "\u2990", Rcaron: "\u0158", rcaron: "\u0159", Rcedil: "\u0156", rcedil: "\u0157", rceil: "\u2309", rcub: "}", Rcy: "\u0420", rcy: "\u0440", rdca: "\u2937", rdldhar: "\u2969", rdquo: "\u201D", rdquor: "\u201D", rdsh: "\u21B3", real: "\u211C", realine: "\u211B", realpart: "\u211C", reals: "\u211D", Re: "\u211C", rect: "\u25AD", reg: "\xAE", REG: "\xAE", ReverseElement: "\u220B", ReverseEquilibrium: "\u21CB", ReverseUpEquilibrium: "\u296F", rfisht: "\u297D", rfloor: "\u230B", rfr: "\u{1D52F}", Rfr: "\u211C", rHar: "\u2964", rhard: "\u21C1", rharu: "\u21C0", rharul: "\u296C", Rho: "\u03A1", rho: "\u03C1", rhov: "\u03F1", RightAngleBracket: "\u27E9", RightArrowBar: "\u21E5", rightarrow: "\u2192", RightArrow: "\u2192", Rightarrow: "\u21D2", RightArrowLeftArrow: "\u21C4", rightarrowtail: "\u21A3", RightCeiling: "\u2309", RightDoubleBracket: "\u27E7", RightDownTeeVector: "\u295D", RightDownVectorBar: "\u2955", RightDownVector: "\u21C2", RightFloor: "\u230B", rightharpoondown: "\u21C1", rightharpoonup: "\u21C0", rightleftarrows: "\u21C4", rightleftharpoons: "\u21CC", rightrightarrows: "\u21C9", rightsquigarrow: "\u219D", RightTeeArrow: "\u21A6", RightTee: "\u22A2", RightTeeVector: "\u295B", rightthreetimes: "\u22CC", RightTriangleBar: "\u29D0", RightTriangle: "\u22B3", RightTriangleEqual: "\u22B5", RightUpDownVector: "\u294F", RightUpTeeVector: "\u295C", RightUpVectorBar: "\u2954", RightUpVector: "\u21BE", RightVectorBar: "\u2953", RightVector: "\u21C0", ring: "\u02DA", risingdotseq: "\u2253", rlarr: "\u21C4", rlhar: "\u21CC", rlm: "\u200F", rmoustache: "\u23B1", rmoust: "\u23B1", rnmid: "\u2AEE", roang: "\u27ED", roarr: "\u21FE", robrk: "\u27E7", ropar: "\u2986", ropf: "\u{1D563}", Ropf: "\u211D", roplus: "\u2A2E", rotimes: "\u2A35", RoundImplies: "\u2970", rpar: ")", rpargt: "\u2994", rppolint: "\u2A12", rrarr: "\u21C9", Rrightarrow: "\u21DB", rsaquo: "\u203A", rscr: "\u{1D4C7}", Rscr: "\u211B", rsh: "\u21B1", Rsh: "\u21B1", rsqb: "]", rsquo: "\u2019", rsquor: "\u2019", rthree: "\u22CC", rtimes: "\u22CA", rtri: "\u25B9", rtrie: "\u22B5", rtrif: "\u25B8", rtriltri: "\u29CE", RuleDelayed: "\u29F4", ruluhar: "\u2968", rx: "\u211E", Sacute: "\u015A", sacute: "\u015B", sbquo: "\u201A", scap: "\u2AB8", Scaron: "\u0160", scaron: "\u0161", Sc: "\u2ABC", sc: "\u227B", sccue: "\u227D", sce: "\u2AB0", scE: "\u2AB4", Scedil: "\u015E", scedil: "\u015F", Scirc: "\u015C", scirc: "\u015D", scnap: "\u2ABA", scnE: "\u2AB6", scnsim: "\u22E9", scpolint: "\u2A13", scsim: "\u227F", Scy: "\u0421", scy: "\u0441", sdotb: "\u22A1", sdot: "\u22C5", sdote: "\u2A66", searhk: "\u2925", searr: "\u2198", seArr: "\u21D8", searrow: "\u2198", sect: "\xA7", semi: ";", seswar: "\u2929", setminus: "\u2216", setmn: "\u2216", sext: "\u2736", Sfr: "\u{1D516}", sfr: "\u{1D530}", sfrown: "\u2322", sharp: "\u266F", SHCHcy: "\u0429", shchcy: "\u0449", SHcy: "\u0428", shcy: "\u0448", ShortDownArrow: "\u2193", ShortLeftArrow: "\u2190", shortmid: "\u2223", shortparallel: "\u2225", ShortRightArrow: "\u2192", ShortUpArrow: "\u2191", shy: "\xAD", Sigma: "\u03A3", sigma: "\u03C3", sigmaf: "\u03C2", sigmav: "\u03C2", sim: "\u223C", simdot: "\u2A6A", sime: "\u2243", simeq: "\u2243", simg: "\u2A9E", simgE: "\u2AA0", siml: "\u2A9D", simlE: "\u2A9F", simne: "\u2246", simplus: "\u2A24", simrarr: "\u2972", slarr: "\u2190", SmallCircle: "\u2218", smallsetminus: "\u2216", smashp: "\u2A33", smeparsl: "\u29E4", smid: "\u2223", smile: "\u2323", smt: "\u2AAA", smte: "\u2AAC", smtes: "\u2AAC\uFE00", SOFTcy: "\u042C", softcy: "\u044C", solbar: "\u233F", solb: "\u29C4", sol: "/", Sopf: "\u{1D54A}", sopf: "\u{1D564}", spades: "\u2660", spadesuit: "\u2660", spar: "\u2225", sqcap: "\u2293", sqcaps: "\u2293\uFE00", sqcup: "\u2294", sqcups: "\u2294\uFE00", Sqrt: "\u221A", sqsub: "\u228F", sqsube: "\u2291", sqsubset: "\u228F", sqsubseteq: "\u2291", sqsup: "\u2290", sqsupe: "\u2292", sqsupset: "\u2290", sqsupseteq: "\u2292", square: "\u25A1", Square: "\u25A1", SquareIntersection: "\u2293", SquareSubset: "\u228F", SquareSubsetEqual: "\u2291", SquareSuperset: "\u2290", SquareSupersetEqual: "\u2292", SquareUnion: "\u2294", squarf: "\u25AA", squ: "\u25A1", squf: "\u25AA", srarr: "\u2192", Sscr: "\u{1D4AE}", sscr: "\u{1D4C8}", ssetmn: "\u2216", ssmile: "\u2323", sstarf: "\u22C6", Star: "\u22C6", star: "\u2606", starf: "\u2605", straightepsilon: "\u03F5", straightphi: "\u03D5", strns: "\xAF", sub: "\u2282", Sub: "\u22D0", subdot: "\u2ABD", subE: "\u2AC5", sube: "\u2286", subedot: "\u2AC3", submult: "\u2AC1", subnE: "\u2ACB", subne: "\u228A", subplus: "\u2ABF", subrarr: "\u2979", subset: "\u2282", Subset: "\u22D0", subseteq: "\u2286", subseteqq: "\u2AC5", SubsetEqual: "\u2286", subsetneq: "\u228A", subsetneqq: "\u2ACB", subsim: "\u2AC7", subsub: "\u2AD5", subsup: "\u2AD3", succapprox: "\u2AB8", succ: "\u227B", succcurlyeq: "\u227D", Succeeds: "\u227B", SucceedsEqual: "\u2AB0", SucceedsSlantEqual: "\u227D", SucceedsTilde: "\u227F", succeq: "\u2AB0", succnapprox: "\u2ABA", succneqq: "\u2AB6", succnsim: "\u22E9", succsim: "\u227F", SuchThat: "\u220B", sum: "\u2211", Sum: "\u2211", sung: "\u266A", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", sup: "\u2283", Sup: "\u22D1", supdot: "\u2ABE", supdsub: "\u2AD8", supE: "\u2AC6", supe: "\u2287", supedot: "\u2AC4", Superset: "\u2283", SupersetEqual: "\u2287", suphsol: "\u27C9", suphsub: "\u2AD7", suplarr: "\u297B", supmult: "\u2AC2", supnE: "\u2ACC", supne: "\u228B", supplus: "\u2AC0", supset: "\u2283", Supset: "\u22D1", supseteq: "\u2287", supseteqq: "\u2AC6", supsetneq: "\u228B", supsetneqq: "\u2ACC", supsim: "\u2AC8", supsub: "\u2AD4", supsup: "\u2AD6", swarhk: "\u2926", swarr: "\u2199", swArr: "\u21D9", swarrow: "\u2199", swnwar: "\u292A", szlig: "\xDF", Tab: "	", target: "\u2316", Tau: "\u03A4", tau: "\u03C4", tbrk: "\u23B4", Tcaron: "\u0164", tcaron: "\u0165", Tcedil: "\u0162", tcedil: "\u0163", Tcy: "\u0422", tcy: "\u0442", tdot: "\u20DB", telrec: "\u2315", Tfr: "\u{1D517}", tfr: "\u{1D531}", there4: "\u2234", therefore: "\u2234", Therefore: "\u2234", Theta: "\u0398", theta: "\u03B8", thetasym: "\u03D1", thetav: "\u03D1", thickapprox: "\u2248", thicksim: "\u223C", ThickSpace: "\u205F\u200A", ThinSpace: "\u2009", thinsp: "\u2009", thkap: "\u2248", thksim: "\u223C", THORN: "\xDE", thorn: "\xFE", tilde: "\u02DC", Tilde: "\u223C", TildeEqual: "\u2243", TildeFullEqual: "\u2245", TildeTilde: "\u2248", timesbar: "\u2A31", timesb: "\u22A0", times: "\xD7", timesd: "\u2A30", tint: "\u222D", toea: "\u2928", topbot: "\u2336", topcir: "\u2AF1", top: "\u22A4", Topf: "\u{1D54B}", topf: "\u{1D565}", topfork: "\u2ADA", tosa: "\u2929", tprime: "\u2034", trade: "\u2122", TRADE: "\u2122", triangle: "\u25B5", triangledown: "\u25BF", triangleleft: "\u25C3", trianglelefteq: "\u22B4", triangleq: "\u225C", triangleright: "\u25B9", trianglerighteq: "\u22B5", tridot: "\u25EC", trie: "\u225C", triminus: "\u2A3A", TripleDot: "\u20DB", triplus: "\u2A39", trisb: "\u29CD", tritime: "\u2A3B", trpezium: "\u23E2", Tscr: "\u{1D4AF}", tscr: "\u{1D4C9}", TScy: "\u0426", tscy: "\u0446", TSHcy: "\u040B", tshcy: "\u045B", Tstrok: "\u0166", tstrok: "\u0167", twixt: "\u226C", twoheadleftarrow: "\u219E", twoheadrightarrow: "\u21A0", Uacute: "\xDA", uacute: "\xFA", uarr: "\u2191", Uarr: "\u219F", uArr: "\u21D1", Uarrocir: "\u2949", Ubrcy: "\u040E", ubrcy: "\u045E", Ubreve: "\u016C", ubreve: "\u016D", Ucirc: "\xDB", ucirc: "\xFB", Ucy: "\u0423", ucy: "\u0443", udarr: "\u21C5", Udblac: "\u0170", udblac: "\u0171", udhar: "\u296E", ufisht: "\u297E", Ufr: "\u{1D518}", ufr: "\u{1D532}", Ugrave: "\xD9", ugrave: "\xF9", uHar: "\u2963", uharl: "\u21BF", uharr: "\u21BE", uhblk: "\u2580", ulcorn: "\u231C", ulcorner: "\u231C", ulcrop: "\u230F", ultri: "\u25F8", Umacr: "\u016A", umacr: "\u016B", uml: "\xA8", UnderBar: "_", UnderBrace: "\u23DF", UnderBracket: "\u23B5", UnderParenthesis: "\u23DD", Union: "\u22C3", UnionPlus: "\u228E", Uogon: "\u0172", uogon: "\u0173", Uopf: "\u{1D54C}", uopf: "\u{1D566}", UpArrowBar: "\u2912", uparrow: "\u2191", UpArrow: "\u2191", Uparrow: "\u21D1", UpArrowDownArrow: "\u21C5", updownarrow: "\u2195", UpDownArrow: "\u2195", Updownarrow: "\u21D5", UpEquilibrium: "\u296E", upharpoonleft: "\u21BF", upharpoonright: "\u21BE", uplus: "\u228E", UpperLeftArrow: "\u2196", UpperRightArrow: "\u2197", upsi: "\u03C5", Upsi: "\u03D2", upsih: "\u03D2", Upsilon: "\u03A5", upsilon: "\u03C5", UpTeeArrow: "\u21A5", UpTee: "\u22A5", upuparrows: "\u21C8", urcorn: "\u231D", urcorner: "\u231D", urcrop: "\u230E", Uring: "\u016E", uring: "\u016F", urtri: "\u25F9", Uscr: "\u{1D4B0}", uscr: "\u{1D4CA}", utdot: "\u22F0", Utilde: "\u0168", utilde: "\u0169", utri: "\u25B5", utrif: "\u25B4", uuarr: "\u21C8", Uuml: "\xDC", uuml: "\xFC", uwangle: "\u29A7", vangrt: "\u299C", varepsilon: "\u03F5", varkappa: "\u03F0", varnothing: "\u2205", varphi: "\u03D5", varpi: "\u03D6", varpropto: "\u221D", varr: "\u2195", vArr: "\u21D5", varrho: "\u03F1", varsigma: "\u03C2", varsubsetneq: "\u228A\uFE00", varsubsetneqq: "\u2ACB\uFE00", varsupsetneq: "\u228B\uFE00", varsupsetneqq: "\u2ACC\uFE00", vartheta: "\u03D1", vartriangleleft: "\u22B2", vartriangleright: "\u22B3", vBar: "\u2AE8", Vbar: "\u2AEB", vBarv: "\u2AE9", Vcy: "\u0412", vcy: "\u0432", vdash: "\u22A2", vDash: "\u22A8", Vdash: "\u22A9", VDash: "\u22AB", Vdashl: "\u2AE6", veebar: "\u22BB", vee: "\u2228", Vee: "\u22C1", veeeq: "\u225A", vellip: "\u22EE", verbar: "|", Verbar: "\u2016", vert: "|", Vert: "\u2016", VerticalBar: "\u2223", VerticalLine: "|", VerticalSeparator: "\u2758", VerticalTilde: "\u2240", VeryThinSpace: "\u200A", Vfr: "\u{1D519}", vfr: "\u{1D533}", vltri: "\u22B2", vnsub: "\u2282\u20D2", vnsup: "\u2283\u20D2", Vopf: "\u{1D54D}", vopf: "\u{1D567}", vprop: "\u221D", vrtri: "\u22B3", Vscr: "\u{1D4B1}", vscr: "\u{1D4CB}", vsubnE: "\u2ACB\uFE00", vsubne: "\u228A\uFE00", vsupnE: "\u2ACC\uFE00", vsupne: "\u228B\uFE00", Vvdash: "\u22AA", vzigzag: "\u299A", Wcirc: "\u0174", wcirc: "\u0175", wedbar: "\u2A5F", wedge: "\u2227", Wedge: "\u22C0", wedgeq: "\u2259", weierp: "\u2118", Wfr: "\u{1D51A}", wfr: "\u{1D534}", Wopf: "\u{1D54E}", wopf: "\u{1D568}", wp: "\u2118", wr: "\u2240", wreath: "\u2240", Wscr: "\u{1D4B2}", wscr: "\u{1D4CC}", xcap: "\u22C2", xcirc: "\u25EF", xcup: "\u22C3", xdtri: "\u25BD", Xfr: "\u{1D51B}", xfr: "\u{1D535}", xharr: "\u27F7", xhArr: "\u27FA", Xi: "\u039E", xi: "\u03BE", xlarr: "\u27F5", xlArr: "\u27F8", xmap: "\u27FC", xnis: "\u22FB", xodot: "\u2A00", Xopf: "\u{1D54F}", xopf: "\u{1D569}", xoplus: "\u2A01", xotime: "\u2A02", xrarr: "\u27F6", xrArr: "\u27F9", Xscr: "\u{1D4B3}", xscr: "\u{1D4CD}", xsqcup: "\u2A06", xuplus: "\u2A04", xutri: "\u25B3", xvee: "\u22C1", xwedge: "\u22C0", Yacute: "\xDD", yacute: "\xFD", YAcy: "\u042F", yacy: "\u044F", Ycirc: "\u0176", ycirc: "\u0177", Ycy: "\u042B", ycy: "\u044B", yen: "\xA5", Yfr: "\u{1D51C}", yfr: "\u{1D536}", YIcy: "\u0407", yicy: "\u0457", Yopf: "\u{1D550}", yopf: "\u{1D56A}", Yscr: "\u{1D4B4}", yscr: "\u{1D4CE}", YUcy: "\u042E", yucy: "\u044E", yuml: "\xFF", Yuml: "\u0178", Zacute: "\u0179", zacute: "\u017A", Zcaron: "\u017D", zcaron: "\u017E", Zcy: "\u0417", zcy: "\u0437", Zdot: "\u017B", zdot: "\u017C", zeetrf: "\u2128", ZeroWidthSpace: "\u200B", Zeta: "\u0396", zeta: "\u03B6", zfr: "\u{1D537}", Zfr: "\u2128", ZHcy: "\u0416", zhcy: "\u0436", zigrarr: "\u21DD", zopf: "\u{1D56B}", Zopf: "\u2124", Zscr: "\u{1D4B5}", zscr: "\u{1D4CF}", zwj: "\u200D", zwnj: "\u200C" };
  }
});

// ../node_modules/entities/lib/maps/legacy.json
var require_legacy = __commonJS({
  "../node_modules/entities/lib/maps/legacy.json"(exports, module2) {
    module2.exports = { Aacute: "\xC1", aacute: "\xE1", Acirc: "\xC2", acirc: "\xE2", acute: "\xB4", AElig: "\xC6", aelig: "\xE6", Agrave: "\xC0", agrave: "\xE0", amp: "&", AMP: "&", Aring: "\xC5", aring: "\xE5", Atilde: "\xC3", atilde: "\xE3", Auml: "\xC4", auml: "\xE4", brvbar: "\xA6", Ccedil: "\xC7", ccedil: "\xE7", cedil: "\xB8", cent: "\xA2", copy: "\xA9", COPY: "\xA9", curren: "\xA4", deg: "\xB0", divide: "\xF7", Eacute: "\xC9", eacute: "\xE9", Ecirc: "\xCA", ecirc: "\xEA", Egrave: "\xC8", egrave: "\xE8", ETH: "\xD0", eth: "\xF0", Euml: "\xCB", euml: "\xEB", frac12: "\xBD", frac14: "\xBC", frac34: "\xBE", gt: ">", GT: ">", Iacute: "\xCD", iacute: "\xED", Icirc: "\xCE", icirc: "\xEE", iexcl: "\xA1", Igrave: "\xCC", igrave: "\xEC", iquest: "\xBF", Iuml: "\xCF", iuml: "\xEF", laquo: "\xAB", lt: "<", LT: "<", macr: "\xAF", micro: "\xB5", middot: "\xB7", nbsp: "\xA0", not: "\xAC", Ntilde: "\xD1", ntilde: "\xF1", Oacute: "\xD3", oacute: "\xF3", Ocirc: "\xD4", ocirc: "\xF4", Ograve: "\xD2", ograve: "\xF2", ordf: "\xAA", ordm: "\xBA", Oslash: "\xD8", oslash: "\xF8", Otilde: "\xD5", otilde: "\xF5", Ouml: "\xD6", ouml: "\xF6", para: "\xB6", plusmn: "\xB1", pound: "\xA3", quot: '"', QUOT: '"', raquo: "\xBB", reg: "\xAE", REG: "\xAE", sect: "\xA7", shy: "\xAD", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", szlig: "\xDF", THORN: "\xDE", thorn: "\xFE", times: "\xD7", Uacute: "\xDA", uacute: "\xFA", Ucirc: "\xDB", ucirc: "\xFB", Ugrave: "\xD9", ugrave: "\xF9", uml: "\xA8", Uuml: "\xDC", uuml: "\xFC", Yacute: "\xDD", yacute: "\xFD", yen: "\xA5", yuml: "\xFF" };
  }
});

// ../node_modules/entities/lib/maps/xml.json
var require_xml = __commonJS({
  "../node_modules/entities/lib/maps/xml.json"(exports, module2) {
    module2.exports = { amp: "&", apos: "'", gt: ">", lt: "<", quot: '"' };
  }
});

// ../node_modules/entities/lib/maps/decode.json
var require_decode = __commonJS({
  "../node_modules/entities/lib/maps/decode.json"(exports, module2) {
    module2.exports = { "0": 65533, "128": 8364, "130": 8218, "131": 402, "132": 8222, "133": 8230, "134": 8224, "135": 8225, "136": 710, "137": 8240, "138": 352, "139": 8249, "140": 338, "142": 381, "145": 8216, "146": 8217, "147": 8220, "148": 8221, "149": 8226, "150": 8211, "151": 8212, "152": 732, "153": 8482, "154": 353, "155": 8250, "156": 339, "158": 382, "159": 376 };
  }
});

// ../node_modules/entities/lib/decode_codepoint.js
var require_decode_codepoint = __commonJS({
  "../node_modules/entities/lib/decode_codepoint.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var decode_json_1 = __importDefault(require_decode());
    var fromCodePoint = (
      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      String.fromCodePoint || function(codePoint) {
        var output = "";
        if (codePoint > 65535) {
          codePoint -= 65536;
          output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        output += String.fromCharCode(codePoint);
        return output;
      }
    );
    function decodeCodePoint(codePoint) {
      if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
        return "\uFFFD";
      }
      if (codePoint in decode_json_1.default) {
        codePoint = decode_json_1.default[codePoint];
      }
      return fromCodePoint(codePoint);
    }
    __name(decodeCodePoint, "decodeCodePoint");
    exports.default = decodeCodePoint;
  }
});

// ../node_modules/entities/lib/decode.js
var require_decode2 = __commonJS({
  "../node_modules/entities/lib/decode.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeHTML = exports.decodeHTMLStrict = exports.decodeXML = void 0;
    var entities_json_1 = __importDefault(require_entities());
    var legacy_json_1 = __importDefault(require_legacy());
    var xml_json_1 = __importDefault(require_xml());
    var decode_codepoint_1 = __importDefault(require_decode_codepoint());
    var strictEntityRe = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
    exports.decodeXML = getStrictDecoder(xml_json_1.default);
    exports.decodeHTMLStrict = getStrictDecoder(entities_json_1.default);
    function getStrictDecoder(map2) {
      var replace = getReplacer(map2);
      return function(str2) {
        return String(str2).replace(strictEntityRe, replace);
      };
    }
    __name(getStrictDecoder, "getStrictDecoder");
    var sorter = /* @__PURE__ */ __name(function(a2, b2) {
      return a2 < b2 ? 1 : -1;
    }, "sorter");
    exports.decodeHTML = function() {
      var legacy = Object.keys(legacy_json_1.default).sort(sorter);
      var keys2 = Object.keys(entities_json_1.default).sort(sorter);
      for (var i2 = 0, j2 = 0; i2 < keys2.length; i2++) {
        if (legacy[j2] === keys2[i2]) {
          keys2[i2] += ";?";
          j2++;
        } else {
          keys2[i2] += ";";
        }
      }
      var re = new RegExp("&(?:" + keys2.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g");
      var replace = getReplacer(entities_json_1.default);
      function replacer3(str2) {
        if (str2.substr(-1) !== ";")
          str2 += ";";
        return replace(str2);
      }
      __name(replacer3, "replacer");
      return function(str2) {
        return String(str2).replace(re, replacer3);
      };
    }();
    function getReplacer(map2) {
      return /* @__PURE__ */ __name(function replace(str2) {
        if (str2.charAt(1) === "#") {
          var secondChar = str2.charAt(2);
          if (secondChar === "X" || secondChar === "x") {
            return decode_codepoint_1.default(parseInt(str2.substr(3), 16));
          }
          return decode_codepoint_1.default(parseInt(str2.substr(2), 10));
        }
        return map2[str2.slice(1, -1)] || str2;
      }, "replace");
    }
    __name(getReplacer, "getReplacer");
  }
});

// ../node_modules/entities/lib/encode.js
var require_encode = __commonJS({
  "../node_modules/entities/lib/encode.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = void 0;
    var xml_json_1 = __importDefault(require_xml());
    var inverseXML = getInverseObj(xml_json_1.default);
    var xmlReplacer = getInverseReplacer(inverseXML);
    exports.encodeXML = getASCIIEncoder(inverseXML);
    var entities_json_1 = __importDefault(require_entities());
    var inverseHTML = getInverseObj(entities_json_1.default);
    var htmlReplacer = getInverseReplacer(inverseHTML);
    exports.encodeHTML = getInverse(inverseHTML, htmlReplacer);
    exports.encodeNonAsciiHTML = getASCIIEncoder(inverseHTML);
    function getInverseObj(obj) {
      return Object.keys(obj).sort().reduce(function(inverse, name) {
        inverse[obj[name]] = "&" + name + ";";
        return inverse;
      }, {});
    }
    __name(getInverseObj, "getInverseObj");
    function getInverseReplacer(inverse) {
      var single = [];
      var multiple = [];
      for (var _i = 0, _a3 = Object.keys(inverse); _i < _a3.length; _i++) {
        var k2 = _a3[_i];
        if (k2.length === 1) {
          single.push("\\" + k2);
        } else {
          multiple.push(k2);
        }
      }
      single.sort();
      for (var start = 0; start < single.length - 1; start++) {
        var end = start;
        while (end < single.length - 1 && single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1)) {
          end += 1;
        }
        var count2 = 1 + end - start;
        if (count2 < 3)
          continue;
        single.splice(start, count2, single[start] + "-" + single[end]);
      }
      multiple.unshift("[" + single.join("") + "]");
      return new RegExp(multiple.join("|"), "g");
    }
    __name(getInverseReplacer, "getInverseReplacer");
    var reNonASCII = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g;
    var getCodePoint = (
      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      String.prototype.codePointAt != null ? (
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        function(str2) {
          return str2.codePointAt(0);
        }
      ) : (
        // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
        function(c2) {
          return (c2.charCodeAt(0) - 55296) * 1024 + c2.charCodeAt(1) - 56320 + 65536;
        }
      )
    );
    function singleCharReplacer(c2) {
      return "&#x" + (c2.length > 1 ? getCodePoint(c2) : c2.charCodeAt(0)).toString(16).toUpperCase() + ";";
    }
    __name(singleCharReplacer, "singleCharReplacer");
    function getInverse(inverse, re) {
      return function(data) {
        return data.replace(re, function(name) {
          return inverse[name];
        }).replace(reNonASCII, singleCharReplacer);
      };
    }
    __name(getInverse, "getInverse");
    var reEscapeChars = new RegExp(xmlReplacer.source + "|" + reNonASCII.source, "g");
    function escape4(data) {
      return data.replace(reEscapeChars, singleCharReplacer);
    }
    __name(escape4, "escape");
    exports.escape = escape4;
    function escapeUTF8(data) {
      return data.replace(xmlReplacer, singleCharReplacer);
    }
    __name(escapeUTF8, "escapeUTF8");
    exports.escapeUTF8 = escapeUTF8;
    function getASCIIEncoder(obj) {
      return function(data) {
        return data.replace(reEscapeChars, function(c2) {
          return obj[c2] || singleCharReplacer(c2);
        });
      };
    }
    __name(getASCIIEncoder, "getASCIIEncoder");
  }
});

// ../node_modules/entities/lib/index.js
var require_lib2 = __commonJS({
  "../node_modules/entities/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.encodeHTML5 = exports.encodeHTML4 = exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = void 0;
    var decode_1 = require_decode2();
    var encode_1 = require_encode();
    function decode(data, level) {
      return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML)(data);
    }
    __name(decode, "decode");
    exports.decode = decode;
    function decodeStrict(data, level) {
      return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict)(data);
    }
    __name(decodeStrict, "decodeStrict");
    exports.decodeStrict = decodeStrict;
    function encode2(data, level) {
      return (!level || level <= 0 ? encode_1.encodeXML : encode_1.encodeHTML)(data);
    }
    __name(encode2, "encode");
    exports.encode = encode2;
    var encode_2 = require_encode();
    Object.defineProperty(exports, "encodeXML", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return encode_2.encodeXML;
    }, "get") });
    Object.defineProperty(exports, "encodeHTML", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return encode_2.encodeHTML;
    }, "get") });
    Object.defineProperty(exports, "encodeNonAsciiHTML", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return encode_2.encodeNonAsciiHTML;
    }, "get") });
    Object.defineProperty(exports, "escape", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return encode_2.escape;
    }, "get") });
    Object.defineProperty(exports, "escapeUTF8", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return encode_2.escapeUTF8;
    }, "get") });
    Object.defineProperty(exports, "encodeHTML4", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return encode_2.encodeHTML;
    }, "get") });
    Object.defineProperty(exports, "encodeHTML5", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return encode_2.encodeHTML;
    }, "get") });
    var decode_2 = require_decode2();
    Object.defineProperty(exports, "decodeXML", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return decode_2.decodeXML;
    }, "get") });
    Object.defineProperty(exports, "decodeHTML", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return decode_2.decodeHTML;
    }, "get") });
    Object.defineProperty(exports, "decodeHTMLStrict", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return decode_2.decodeHTMLStrict;
    }, "get") });
    Object.defineProperty(exports, "decodeHTML4", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return decode_2.decodeHTML;
    }, "get") });
    Object.defineProperty(exports, "decodeHTML5", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return decode_2.decodeHTML;
    }, "get") });
    Object.defineProperty(exports, "decodeHTML4Strict", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return decode_2.decodeHTMLStrict;
    }, "get") });
    Object.defineProperty(exports, "decodeHTML5Strict", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return decode_2.decodeHTMLStrict;
    }, "get") });
    Object.defineProperty(exports, "decodeXMLStrict", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return decode_2.decodeXML;
    }, "get") });
  }
});

// ../node_modules/ansi-to-html/lib/ansi_to_html.js
var require_ansi_to_html = __commonJS({
  "../node_modules/ansi-to-html/lib/ansi_to_html.js"(exports, module2) {
    "use strict";
    function _classCallCheck3(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    __name(_classCallCheck3, "_classCallCheck");
    function _defineProperties3(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    __name(_defineProperties3, "_defineProperties");
    function _createClass3(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties3(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties3(Constructor, staticProps);
      return Constructor;
    }
    __name(_createClass3, "_createClass");
    function _createForOfIteratorHelper(o2, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o2[Symbol.iterator] || o2["@@iterator"];
      if (!it) {
        if (Array.isArray(o2) || (it = _unsupportedIterableToArray(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
          if (it) o2 = it;
          var i2 = 0;
          var F = /* @__PURE__ */ __name(function F2() {
          }, "F");
          return { s: F, n: /* @__PURE__ */ __name(function n2() {
            if (i2 >= o2.length) return { done: true };
            return { done: false, value: o2[i2++] };
          }, "n"), e: /* @__PURE__ */ __name(function e2(_e2) {
            throw _e2;
          }, "e"), f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: /* @__PURE__ */ __name(function s3() {
        it = it.call(o2);
      }, "s"), n: /* @__PURE__ */ __name(function n2() {
        var step2 = it.next();
        normalCompletion = step2.done;
        return step2;
      }, "n"), e: /* @__PURE__ */ __name(function e2(_e2) {
        didErr = true;
        err = _e2;
      }, "e"), f: /* @__PURE__ */ __name(function f4() {
        try {
          if (!normalCompletion && it["return"] != null) it["return"]();
        } finally {
          if (didErr) throw err;
        }
      }, "f") };
    }
    __name(_createForOfIteratorHelper, "_createForOfIteratorHelper");
    function _unsupportedIterableToArray(o2, minLen) {
      if (!o2) return;
      if (typeof o2 === "string") return _arrayLikeToArray(o2, minLen);
      var n2 = Object.prototype.toString.call(o2).slice(8, -1);
      if (n2 === "Object" && o2.constructor) n2 = o2.constructor.name;
      if (n2 === "Map" || n2 === "Set") return Array.from(o2);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray(o2, minLen);
    }
    __name(_unsupportedIterableToArray, "_unsupportedIterableToArray");
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
        arr2[i2] = arr[i2];
      }
      return arr2;
    }
    __name(_arrayLikeToArray, "_arrayLikeToArray");
    var entities = require_lib2();
    var defaults = {
      fg: "#FFF",
      bg: "#000",
      newline: false,
      escapeXML: false,
      stream: false,
      colors: getDefaultColors()
    };
    function getDefaultColors() {
      var colors3 = {
        0: "#000",
        1: "#A00",
        2: "#0A0",
        3: "#A50",
        4: "#00A",
        5: "#A0A",
        6: "#0AA",
        7: "#AAA",
        8: "#555",
        9: "#F55",
        10: "#5F5",
        11: "#FF5",
        12: "#55F",
        13: "#F5F",
        14: "#5FF",
        15: "#FFF"
      };
      range(0, 5).forEach(function(red) {
        range(0, 5).forEach(function(green) {
          range(0, 5).forEach(function(blue) {
            return setStyleColor(red, green, blue, colors3);
          });
        });
      });
      range(0, 23).forEach(function(gray) {
        var c2 = gray + 232;
        var l2 = toHexString(gray * 10 + 8);
        colors3[c2] = "#" + l2 + l2 + l2;
      });
      return colors3;
    }
    __name(getDefaultColors, "getDefaultColors");
    function setStyleColor(red, green, blue, colors3) {
      var c2 = 16 + red * 36 + green * 6 + blue;
      var r2 = red > 0 ? red * 40 + 55 : 0;
      var g2 = green > 0 ? green * 40 + 55 : 0;
      var b2 = blue > 0 ? blue * 40 + 55 : 0;
      colors3[c2] = toColorHexString([r2, g2, b2]);
    }
    __name(setStyleColor, "setStyleColor");
    function toHexString(num) {
      var str2 = num.toString(16);
      while (str2.length < 2) {
        str2 = "0" + str2;
      }
      return str2;
    }
    __name(toHexString, "toHexString");
    function toColorHexString(ref) {
      var results = [];
      var _iterator = _createForOfIteratorHelper(ref), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var r2 = _step.value;
          results.push(toHexString(r2));
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return "#" + results.join("");
    }
    __name(toColorHexString, "toColorHexString");
    function generateOutput(stack, token, data, options) {
      var result;
      if (token === "text") {
        result = pushText(data, options);
      } else if (token === "display") {
        result = handleDisplay(stack, data, options);
      } else if (token === "xterm256Foreground") {
        result = pushForegroundColor(stack, options.colors[data]);
      } else if (token === "xterm256Background") {
        result = pushBackgroundColor(stack, options.colors[data]);
      } else if (token === "rgb") {
        result = handleRgb(stack, data);
      }
      return result;
    }
    __name(generateOutput, "generateOutput");
    function handleRgb(stack, data) {
      data = data.substring(2).slice(0, -1);
      var operation = +data.substr(0, 2);
      var color = data.substring(5).split(";");
      var rgb = color.map(function(value) {
        return ("0" + Number(value).toString(16)).substr(-2);
      }).join("");
      return pushStyle(stack, (operation === 38 ? "color:#" : "background-color:#") + rgb);
    }
    __name(handleRgb, "handleRgb");
    function handleDisplay(stack, code, options) {
      code = parseInt(code, 10);
      var codeMap = {
        "-1": /* @__PURE__ */ __name(function _() {
          return "<br/>";
        }, "_"),
        0: /* @__PURE__ */ __name(function _() {
          return stack.length && resetStyles(stack);
        }, "_"),
        1: /* @__PURE__ */ __name(function _() {
          return pushTag(stack, "b");
        }, "_"),
        3: /* @__PURE__ */ __name(function _() {
          return pushTag(stack, "i");
        }, "_"),
        4: /* @__PURE__ */ __name(function _() {
          return pushTag(stack, "u");
        }, "_"),
        8: /* @__PURE__ */ __name(function _() {
          return pushStyle(stack, "display:none");
        }, "_"),
        9: /* @__PURE__ */ __name(function _() {
          return pushTag(stack, "strike");
        }, "_"),
        22: /* @__PURE__ */ __name(function _() {
          return pushStyle(stack, "font-weight:normal;text-decoration:none;font-style:normal");
        }, "_"),
        23: /* @__PURE__ */ __name(function _() {
          return closeTag(stack, "i");
        }, "_"),
        24: /* @__PURE__ */ __name(function _() {
          return closeTag(stack, "u");
        }, "_"),
        39: /* @__PURE__ */ __name(function _() {
          return pushForegroundColor(stack, options.fg);
        }, "_"),
        49: /* @__PURE__ */ __name(function _() {
          return pushBackgroundColor(stack, options.bg);
        }, "_"),
        53: /* @__PURE__ */ __name(function _() {
          return pushStyle(stack, "text-decoration:overline");
        }, "_")
      };
      var result;
      if (codeMap[code]) {
        result = codeMap[code]();
      } else if (4 < code && code < 7) {
        result = pushTag(stack, "blink");
      } else if (29 < code && code < 38) {
        result = pushForegroundColor(stack, options.colors[code - 30]);
      } else if (39 < code && code < 48) {
        result = pushBackgroundColor(stack, options.colors[code - 40]);
      } else if (89 < code && code < 98) {
        result = pushForegroundColor(stack, options.colors[8 + (code - 90)]);
      } else if (99 < code && code < 108) {
        result = pushBackgroundColor(stack, options.colors[8 + (code - 100)]);
      }
      return result;
    }
    __name(handleDisplay, "handleDisplay");
    function resetStyles(stack) {
      var stackClone = stack.slice(0);
      stack.length = 0;
      return stackClone.reverse().map(function(tag) {
        return "</" + tag + ">";
      }).join("");
    }
    __name(resetStyles, "resetStyles");
    function range(low, high) {
      var results = [];
      for (var j2 = low; j2 <= high; j2++) {
        results.push(j2);
      }
      return results;
    }
    __name(range, "range");
    function notCategory(category) {
      return function(e2) {
        return (category === null || e2.category !== category) && category !== "all";
      };
    }
    __name(notCategory, "notCategory");
    function categoryForCode(code) {
      code = parseInt(code, 10);
      var result = null;
      if (code === 0) {
        result = "all";
      } else if (code === 1) {
        result = "bold";
      } else if (2 < code && code < 5) {
        result = "underline";
      } else if (4 < code && code < 7) {
        result = "blink";
      } else if (code === 8) {
        result = "hide";
      } else if (code === 9) {
        result = "strike";
      } else if (29 < code && code < 38 || code === 39 || 89 < code && code < 98) {
        result = "foreground-color";
      } else if (39 < code && code < 48 || code === 49 || 99 < code && code < 108) {
        result = "background-color";
      }
      return result;
    }
    __name(categoryForCode, "categoryForCode");
    function pushText(text, options) {
      if (options.escapeXML) {
        return entities.encodeXML(text);
      }
      return text;
    }
    __name(pushText, "pushText");
    function pushTag(stack, tag, style) {
      if (!style) {
        style = "";
      }
      stack.push(tag);
      return "<".concat(tag).concat(style ? ' style="'.concat(style, '"') : "", ">");
    }
    __name(pushTag, "pushTag");
    function pushStyle(stack, style) {
      return pushTag(stack, "span", style);
    }
    __name(pushStyle, "pushStyle");
    function pushForegroundColor(stack, color) {
      return pushTag(stack, "span", "color:" + color);
    }
    __name(pushForegroundColor, "pushForegroundColor");
    function pushBackgroundColor(stack, color) {
      return pushTag(stack, "span", "background-color:" + color);
    }
    __name(pushBackgroundColor, "pushBackgroundColor");
    function closeTag(stack, style) {
      var last;
      if (stack.slice(-1)[0] === style) {
        last = stack.pop();
      }
      if (last) {
        return "</" + style + ">";
      }
    }
    __name(closeTag, "closeTag");
    function tokenize(text, options, callback) {
      var ansiMatch = false;
      var ansiHandler = 3;
      function remove() {
        return "";
      }
      __name(remove, "remove");
      function removeXterm256Foreground(m3, g1) {
        callback("xterm256Foreground", g1);
        return "";
      }
      __name(removeXterm256Foreground, "removeXterm256Foreground");
      function removeXterm256Background(m3, g1) {
        callback("xterm256Background", g1);
        return "";
      }
      __name(removeXterm256Background, "removeXterm256Background");
      function newline(m3) {
        if (options.newline) {
          callback("display", -1);
        } else {
          callback("text", m3);
        }
        return "";
      }
      __name(newline, "newline");
      function ansiMess(m3, g1) {
        ansiMatch = true;
        if (g1.trim().length === 0) {
          g1 = "0";
        }
        g1 = g1.trimRight(";").split(";");
        var _iterator2 = _createForOfIteratorHelper(g1), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var g2 = _step2.value;
            callback("display", g2);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        return "";
      }
      __name(ansiMess, "ansiMess");
      function realText(m3) {
        callback("text", m3);
        return "";
      }
      __name(realText, "realText");
      function rgb(m3) {
        callback("rgb", m3);
        return "";
      }
      __name(rgb, "rgb");
      var tokens = [{
        pattern: /^\x08+/,
        sub: remove
      }, {
        pattern: /^\x1b\[[012]?K/,
        sub: remove
      }, {
        pattern: /^\x1b\[\(B/,
        sub: remove
      }, {
        pattern: /^\x1b\[[34]8;2;\d+;\d+;\d+m/,
        sub: rgb
      }, {
        pattern: /^\x1b\[38;5;(\d+)m/,
        sub: removeXterm256Foreground
      }, {
        pattern: /^\x1b\[48;5;(\d+)m/,
        sub: removeXterm256Background
      }, {
        pattern: /^\n/,
        sub: newline
      }, {
        pattern: /^\r+\n/,
        sub: newline
      }, {
        pattern: /^\r/,
        sub: newline
      }, {
        pattern: /^\x1b\[((?:\d{1,3};?)+|)m/,
        sub: ansiMess
      }, {
        // CSI n J
        // ED - Erase in Display Clears part of the screen.
        // If n is 0 (or missing), clear from cursor to end of screen.
        // If n is 1, clear from cursor to beginning of the screen.
        // If n is 2, clear entire screen (and moves cursor to upper left on DOS ANSI.SYS).
        // If n is 3, clear entire screen and delete all lines saved in the scrollback buffer
        //   (this feature was added for xterm and is supported by other terminal applications).
        pattern: /^\x1b\[\d?J/,
        sub: remove
      }, {
        // CSI n ; m f
        // HVP - Horizontal Vertical Position Same as CUP
        pattern: /^\x1b\[\d{0,3};\d{0,3}f/,
        sub: remove
      }, {
        // catch-all for CSI sequences?
        pattern: /^\x1b\[?[\d;]{0,3}/,
        sub: remove
      }, {
        /**
         * extracts real text - not containing:
         * - `\x1b' - ESC - escape (Ascii 27)
         * - '\x08' - BS - backspace (Ascii 8)
         * - `\n` - Newline - linefeed (LF) (ascii 10)
         * - `\r` - Windows Carriage Return (CR)
         */
        pattern: /^(([^\x1b\x08\r\n])+)/,
        sub: realText
      }];
      function process2(handler2, i3) {
        if (i3 > ansiHandler && ansiMatch) {
          return;
        }
        ansiMatch = false;
        text = text.replace(handler2.pattern, handler2.sub);
      }
      __name(process2, "process");
      var results1 = [];
      var _text = text, length = _text.length;
      outer: while (length > 0) {
        for (var i2 = 0, o2 = 0, len = tokens.length; o2 < len; i2 = ++o2) {
          var handler = tokens[i2];
          process2(handler, i2);
          if (text.length !== length) {
            length = text.length;
            continue outer;
          }
        }
        if (text.length === length) {
          break;
        }
        results1.push(0);
        length = text.length;
      }
      return results1;
    }
    __name(tokenize, "tokenize");
    function updateStickyStack(stickyStack, token, data) {
      if (token !== "text") {
        stickyStack = stickyStack.filter(notCategory(categoryForCode(data)));
        stickyStack.push({
          token,
          data,
          category: categoryForCode(data)
        });
      }
      return stickyStack;
    }
    __name(updateStickyStack, "updateStickyStack");
    var Filter = function() {
      function Filter2(options) {
        _classCallCheck3(this, Filter2);
        options = options || {};
        if (options.colors) {
          options.colors = Object.assign({}, defaults.colors, options.colors);
        }
        this.options = Object.assign({}, defaults, options);
        this.stack = [];
        this.stickyStack = [];
      }
      __name(Filter2, "Filter");
      _createClass3(Filter2, [{
        key: "toHtml",
        value: /* @__PURE__ */ __name(function toHtml(input2) {
          var _this = this;
          input2 = typeof input2 === "string" ? [input2] : input2;
          var stack = this.stack, options = this.options;
          var buf = [];
          this.stickyStack.forEach(function(element) {
            var output = generateOutput(stack, element.token, element.data, options);
            if (output) {
              buf.push(output);
            }
          });
          tokenize(input2.join(""), options, function(token, data) {
            var output = generateOutput(stack, token, data, options);
            if (output) {
              buf.push(output);
            }
            if (options.stream) {
              _this.stickyStack = updateStickyStack(_this.stickyStack, token, data);
            }
          });
          if (stack.length) {
            buf.push(resetStyles(stack));
          }
          return buf.join("");
        }, "toHtml")
      }]);
      return Filter2;
    }();
    module2.exports = Filter;
  }
});

// ../node_modules/jsdoc-type-pratt-parser/dist/index.js
var require_dist = __commonJS({
  "../node_modules/jsdoc-type-pratt-parser/dist/index.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.jtpp = {}));
    })(exports, function(exports2) {
      "use strict";
      function tokenToString(token) {
        if (token.text !== void 0 && token.text !== "") {
          return `'${token.type}' with value '${token.text}'`;
        } else {
          return `'${token.type}'`;
        }
      }
      __name(tokenToString, "tokenToString");
      const _NoParsletFoundError = class _NoParsletFoundError extends Error {
        constructor(token) {
          super(`No parslet found for token: ${tokenToString(token)}`);
          this.token = token;
          Object.setPrototypeOf(this, _NoParsletFoundError.prototype);
        }
        getToken() {
          return this.token;
        }
      };
      __name(_NoParsletFoundError, "NoParsletFoundError");
      let NoParsletFoundError = _NoParsletFoundError;
      const _EarlyEndOfParseError = class _EarlyEndOfParseError extends Error {
        constructor(token) {
          super(`The parsing ended early. The next token was: ${tokenToString(token)}`);
          this.token = token;
          Object.setPrototypeOf(this, _EarlyEndOfParseError.prototype);
        }
        getToken() {
          return this.token;
        }
      };
      __name(_EarlyEndOfParseError, "EarlyEndOfParseError");
      let EarlyEndOfParseError = _EarlyEndOfParseError;
      const _UnexpectedTypeError = class _UnexpectedTypeError extends Error {
        constructor(result, message) {
          let error = `Unexpected type: '${result.type}'.`;
          if (message !== void 0) {
            error += ` Message: ${message}`;
          }
          super(error);
          Object.setPrototypeOf(this, _UnexpectedTypeError.prototype);
        }
      };
      __name(_UnexpectedTypeError, "UnexpectedTypeError");
      let UnexpectedTypeError = _UnexpectedTypeError;
      function makePunctuationRule(type5) {
        return (text) => {
          if (text.startsWith(type5)) {
            return { type: type5, text: type5 };
          } else {
            return null;
          }
        };
      }
      __name(makePunctuationRule, "makePunctuationRule");
      function getQuoted(text) {
        let position = 0;
        let char;
        const mark = text[0];
        let escaped = false;
        if (mark !== "'" && mark !== '"') {
          return null;
        }
        while (position < text.length) {
          position++;
          char = text[position];
          if (!escaped && char === mark) {
            position++;
            break;
          }
          escaped = !escaped && char === "\\";
        }
        if (char !== mark) {
          throw new Error("Unterminated String");
        }
        return text.slice(0, position);
      }
      __name(getQuoted, "getQuoted");
      const identifierStartRegex = new RegExp("[$_\\p{ID_Start}]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}", "u");
      const identifierContinueRegex = new RegExp("[$\\-\\p{ID_Continue}\\u200C\\u200D]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}", "u");
      function getIdentifier(text) {
        let char = text[0];
        if (!identifierStartRegex.test(char)) {
          return null;
        }
        let position = 1;
        do {
          char = text[position];
          if (!identifierContinueRegex.test(char)) {
            break;
          }
          position++;
        } while (position < text.length);
        return text.slice(0, position);
      }
      __name(getIdentifier, "getIdentifier");
      const numberRegex = /^(NaN|-?((\d*\.\d+|\d+)([Ee][+-]?\d+)?|Infinity))/;
      function getNumber(text) {
        var _a3, _b;
        return (_b = (_a3 = numberRegex.exec(text)) === null || _a3 === void 0 ? void 0 : _a3[0]) !== null && _b !== void 0 ? _b : null;
      }
      __name(getNumber, "getNumber");
      const identifierRule = /* @__PURE__ */ __name((text) => {
        const value = getIdentifier(text);
        if (value == null) {
          return null;
        }
        return {
          type: "Identifier",
          text: value
        };
      }, "identifierRule");
      function makeKeyWordRule(type5) {
        return (text) => {
          if (!text.startsWith(type5)) {
            return null;
          }
          const prepends = text[type5.length];
          if (prepends !== void 0 && identifierContinueRegex.test(prepends)) {
            return null;
          }
          return {
            type: type5,
            text: type5
          };
        };
      }
      __name(makeKeyWordRule, "makeKeyWordRule");
      const stringValueRule = /* @__PURE__ */ __name((text) => {
        const value = getQuoted(text);
        if (value == null) {
          return null;
        }
        return {
          type: "StringValue",
          text: value
        };
      }, "stringValueRule");
      const eofRule = /* @__PURE__ */ __name((text) => {
        if (text.length > 0) {
          return null;
        }
        return {
          type: "EOF",
          text: ""
        };
      }, "eofRule");
      const numberRule = /* @__PURE__ */ __name((text) => {
        const value = getNumber(text);
        if (value === null) {
          return null;
        }
        return {
          type: "Number",
          text: value
        };
      }, "numberRule");
      const rules = [
        eofRule,
        makePunctuationRule("=>"),
        makePunctuationRule("("),
        makePunctuationRule(")"),
        makePunctuationRule("{"),
        makePunctuationRule("}"),
        makePunctuationRule("["),
        makePunctuationRule("]"),
        makePunctuationRule("|"),
        makePunctuationRule("&"),
        makePunctuationRule("<"),
        makePunctuationRule(">"),
        makePunctuationRule(","),
        makePunctuationRule(";"),
        makePunctuationRule("*"),
        makePunctuationRule("?"),
        makePunctuationRule("!"),
        makePunctuationRule("="),
        makePunctuationRule(":"),
        makePunctuationRule("..."),
        makePunctuationRule("."),
        makePunctuationRule("#"),
        makePunctuationRule("~"),
        makePunctuationRule("/"),
        makePunctuationRule("@"),
        makeKeyWordRule("undefined"),
        makeKeyWordRule("null"),
        makeKeyWordRule("function"),
        makeKeyWordRule("this"),
        makeKeyWordRule("new"),
        makeKeyWordRule("module"),
        makeKeyWordRule("event"),
        makeKeyWordRule("extends"),
        makeKeyWordRule("external"),
        makeKeyWordRule("infer"),
        makeKeyWordRule("typeof"),
        makeKeyWordRule("keyof"),
        makeKeyWordRule("readonly"),
        makeKeyWordRule("import"),
        makeKeyWordRule("is"),
        makeKeyWordRule("in"),
        makeKeyWordRule("asserts"),
        numberRule,
        identifierRule,
        stringValueRule
      ];
      const breakingWhitespaceRegex = /^\s*\n\s*/;
      const _Lexer = class _Lexer {
        static create(text) {
          const current = this.read(text);
          text = current.text;
          const next = this.read(text);
          text = next.text;
          return new _Lexer(text, void 0, current.token, next.token);
        }
        constructor(text, previous, current, next) {
          this.text = "";
          this.text = text;
          this.previous = previous;
          this.current = current;
          this.next = next;
        }
        static read(text, startOfLine = false) {
          startOfLine = startOfLine || breakingWhitespaceRegex.test(text);
          text = text.trim();
          for (const rule of rules) {
            const partial = rule(text);
            if (partial !== null) {
              const token = Object.assign(Object.assign({}, partial), { startOfLine });
              text = text.slice(token.text.length);
              return { text, token };
            }
          }
          throw new Error("Unexpected Token " + text);
        }
        advance() {
          const next = _Lexer.read(this.text);
          return new _Lexer(next.text, this.current, this.next, next.token);
        }
      };
      __name(_Lexer, "Lexer");
      let Lexer = _Lexer;
      function assertRootResult(result) {
        if (result === void 0) {
          throw new Error("Unexpected undefined");
        }
        if (result.type === "JsdocTypeKeyValue" || result.type === "JsdocTypeParameterList" || result.type === "JsdocTypeProperty" || result.type === "JsdocTypeReadonlyProperty" || result.type === "JsdocTypeObjectField" || result.type === "JsdocTypeJsdocObjectField" || result.type === "JsdocTypeIndexSignature" || result.type === "JsdocTypeMappedType" || result.type === "JsdocTypeTypeParameter") {
          throw new UnexpectedTypeError(result);
        }
        return result;
      }
      __name(assertRootResult, "assertRootResult");
      function assertPlainKeyValueOrRootResult(result) {
        if (result.type === "JsdocTypeKeyValue") {
          return assertPlainKeyValueResult(result);
        }
        return assertRootResult(result);
      }
      __name(assertPlainKeyValueOrRootResult, "assertPlainKeyValueOrRootResult");
      function assertPlainKeyValueOrNameResult(result) {
        if (result.type === "JsdocTypeName") {
          return result;
        }
        return assertPlainKeyValueResult(result);
      }
      __name(assertPlainKeyValueOrNameResult, "assertPlainKeyValueOrNameResult");
      function assertPlainKeyValueResult(result) {
        if (result.type !== "JsdocTypeKeyValue") {
          throw new UnexpectedTypeError(result);
        }
        return result;
      }
      __name(assertPlainKeyValueResult, "assertPlainKeyValueResult");
      function assertNumberOrVariadicNameResult(result) {
        var _a3;
        if (result.type === "JsdocTypeVariadic") {
          if (((_a3 = result.element) === null || _a3 === void 0 ? void 0 : _a3.type) === "JsdocTypeName") {
            return result;
          }
          throw new UnexpectedTypeError(result);
        }
        if (result.type !== "JsdocTypeNumber" && result.type !== "JsdocTypeName") {
          throw new UnexpectedTypeError(result);
        }
        return result;
      }
      __name(assertNumberOrVariadicNameResult, "assertNumberOrVariadicNameResult");
      function assertArrayOrTupleResult(result) {
        if (result.type === "JsdocTypeTuple") {
          return result;
        }
        if (result.type === "JsdocTypeGeneric" && result.meta.brackets === "square") {
          return result;
        }
        throw new UnexpectedTypeError(result);
      }
      __name(assertArrayOrTupleResult, "assertArrayOrTupleResult");
      function isSquaredProperty(result) {
        return result.type === "JsdocTypeIndexSignature" || result.type === "JsdocTypeMappedType";
      }
      __name(isSquaredProperty, "isSquaredProperty");
      var Precedence;
      (function(Precedence2) {
        Precedence2[Precedence2["ALL"] = 0] = "ALL";
        Precedence2[Precedence2["PARAMETER_LIST"] = 1] = "PARAMETER_LIST";
        Precedence2[Precedence2["OBJECT"] = 2] = "OBJECT";
        Precedence2[Precedence2["KEY_VALUE"] = 3] = "KEY_VALUE";
        Precedence2[Precedence2["INDEX_BRACKETS"] = 4] = "INDEX_BRACKETS";
        Precedence2[Precedence2["UNION"] = 5] = "UNION";
        Precedence2[Precedence2["INTERSECTION"] = 6] = "INTERSECTION";
        Precedence2[Precedence2["PREFIX"] = 7] = "PREFIX";
        Precedence2[Precedence2["INFIX"] = 8] = "INFIX";
        Precedence2[Precedence2["TUPLE"] = 9] = "TUPLE";
        Precedence2[Precedence2["SYMBOL"] = 10] = "SYMBOL";
        Precedence2[Precedence2["OPTIONAL"] = 11] = "OPTIONAL";
        Precedence2[Precedence2["NULLABLE"] = 12] = "NULLABLE";
        Precedence2[Precedence2["KEY_OF_TYPE_OF"] = 13] = "KEY_OF_TYPE_OF";
        Precedence2[Precedence2["FUNCTION"] = 14] = "FUNCTION";
        Precedence2[Precedence2["ARROW"] = 15] = "ARROW";
        Precedence2[Precedence2["ARRAY_BRACKETS"] = 16] = "ARRAY_BRACKETS";
        Precedence2[Precedence2["GENERIC"] = 17] = "GENERIC";
        Precedence2[Precedence2["NAME_PATH"] = 18] = "NAME_PATH";
        Precedence2[Precedence2["PARENTHESIS"] = 19] = "PARENTHESIS";
        Precedence2[Precedence2["SPECIAL_TYPES"] = 20] = "SPECIAL_TYPES";
      })(Precedence || (Precedence = {}));
      const _Parser = class _Parser {
        constructor(grammar, textOrLexer, baseParser) {
          this.grammar = grammar;
          if (typeof textOrLexer === "string") {
            this._lexer = Lexer.create(textOrLexer);
          } else {
            this._lexer = textOrLexer;
          }
          this.baseParser = baseParser;
        }
        get lexer() {
          return this._lexer;
        }
        /**
         * Parses a given string and throws an error if the parse ended before the end of the string.
         */
        parse() {
          const result = this.parseType(Precedence.ALL);
          if (this.lexer.current.type !== "EOF") {
            throw new EarlyEndOfParseError(this.lexer.current);
          }
          return result;
        }
        /**
         * Parses with the current lexer and asserts that the result is a {@link RootResult}.
         */
        parseType(precedence) {
          return assertRootResult(this.parseIntermediateType(precedence));
        }
        /**
         * The main parsing function. First it tries to parse the current state in the prefix step, and then it continues
         * to parse the state in the infix step.
         */
        parseIntermediateType(precedence) {
          const result = this.tryParslets(null, precedence);
          if (result === null) {
            throw new NoParsletFoundError(this.lexer.current);
          }
          return this.parseInfixIntermediateType(result, precedence);
        }
        /**
         * In the infix parsing step the parser continues to parse the current state with all parslets until none returns
         * a result.
         */
        parseInfixIntermediateType(left, precedence) {
          let result = this.tryParslets(left, precedence);
          while (result !== null) {
            left = result;
            result = this.tryParslets(left, precedence);
          }
          return left;
        }
        /**
         * Tries to parse the current state with all parslets in the grammar and returns the first non null result.
         */
        tryParslets(left, precedence) {
          for (const parslet of this.grammar) {
            const result = parslet(this, precedence, left);
            if (result !== null) {
              return result;
            }
          }
          return null;
        }
        /**
         * If the given type equals the current type of the {@link Lexer} advance the lexer. Return true if the lexer was
         * advanced.
         */
        consume(types) {
          if (!Array.isArray(types)) {
            types = [types];
          }
          if (types.includes(this.lexer.current.type)) {
            this._lexer = this.lexer.advance();
            return true;
          } else {
            return false;
          }
        }
        acceptLexerState(parser) {
          this._lexer = parser.lexer;
        }
      };
      __name(_Parser, "Parser");
      let Parser = _Parser;
      function isQuestionMarkUnknownType(next) {
        return next === "}" || next === "EOF" || next === "|" || next === "," || next === ")" || next === ">";
      }
      __name(isQuestionMarkUnknownType, "isQuestionMarkUnknownType");
      const nullableParslet = /* @__PURE__ */ __name((parser, precedence, left) => {
        const type5 = parser.lexer.current.type;
        const next = parser.lexer.next.type;
        const accept = left == null && type5 === "?" && !isQuestionMarkUnknownType(next) || left != null && type5 === "?";
        if (!accept) {
          return null;
        }
        parser.consume("?");
        if (left == null) {
          return {
            type: "JsdocTypeNullable",
            element: parser.parseType(Precedence.NULLABLE),
            meta: {
              position: "prefix"
            }
          };
        } else {
          return {
            type: "JsdocTypeNullable",
            element: assertRootResult(left),
            meta: {
              position: "suffix"
            }
          };
        }
      }, "nullableParslet");
      function composeParslet(options) {
        const parslet = /* @__PURE__ */ __name((parser, curPrecedence, left) => {
          const type5 = parser.lexer.current.type;
          const next = parser.lexer.next.type;
          if (left === null) {
            if ("parsePrefix" in options) {
              if (options.accept(type5, next)) {
                return options.parsePrefix(parser);
              }
            }
          } else {
            if ("parseInfix" in options) {
              if (options.precedence > curPrecedence && options.accept(type5, next)) {
                return options.parseInfix(parser, left);
              }
            }
          }
          return null;
        }, "parslet");
        Object.defineProperty(parslet, "name", {
          value: options.name
        });
        return parslet;
      }
      __name(composeParslet, "composeParslet");
      const optionalParslet = composeParslet({
        name: "optionalParslet",
        accept: /* @__PURE__ */ __name((type5) => type5 === "=", "accept"),
        precedence: Precedence.OPTIONAL,
        parsePrefix: /* @__PURE__ */ __name((parser) => {
          parser.consume("=");
          return {
            type: "JsdocTypeOptional",
            element: parser.parseType(Precedence.OPTIONAL),
            meta: {
              position: "prefix"
            }
          };
        }, "parsePrefix"),
        parseInfix: /* @__PURE__ */ __name((parser, left) => {
          parser.consume("=");
          return {
            type: "JsdocTypeOptional",
            element: assertRootResult(left),
            meta: {
              position: "suffix"
            }
          };
        }, "parseInfix")
      });
      const numberParslet = composeParslet({
        name: "numberParslet",
        accept: /* @__PURE__ */ __name((type5) => type5 === "Number", "accept"),
        parsePrefix: /* @__PURE__ */ __name((parser) => {
          const value = parseFloat(parser.lexer.current.text);
          parser.consume("Number");
          return {
            type: "JsdocTypeNumber",
            value
          };
        }, "parsePrefix")
      });
      const parenthesisParslet = composeParslet({
        name: "parenthesisParslet",
        accept: /* @__PURE__ */ __name((type5) => type5 === "(", "accept"),
        parsePrefix: /* @__PURE__ */ __name((parser) => {
          parser.consume("(");
          if (parser.consume(")")) {
            return {
              type: "JsdocTypeParameterList",
              elements: []
            };
          }
          const result = parser.parseIntermediateType(Precedence.ALL);
          if (!parser.consume(")")) {
            throw new Error("Unterminated parenthesis");
          }
          if (result.type === "JsdocTypeParameterList") {
            return result;
          } else if (result.type === "JsdocTypeKeyValue") {
            return {
              type: "JsdocTypeParameterList",
              elements: [result]
            };
          }
          return {
            type: "JsdocTypeParenthesis",
            element: assertRootResult(result)
          };
        }, "parsePrefix")
      });
      const specialTypesParslet = composeParslet({
        name: "specialTypesParslet",
        accept: /* @__PURE__ */ __name((type5, next) => type5 === "?" && isQuestionMarkUnknownType(next) || type5 === "null" || type5 === "undefined" || type5 === "*", "accept"),
        parsePrefix: /* @__PURE__ */ __name((parser) => {
          if (parser.consume("null")) {
            return {
              type: "JsdocTypeNull"
            };
          }
          if (parser.consume("undefined")) {
            return {
              type: "JsdocTypeUndefined"
            };
          }
          if (parser.consume("*")) {
            return {
              type: "JsdocTypeAny"
            };
          }
          if (parser.consume("?")) {
            return {
              type: "JsdocTypeUnknown"
            };
          }
          throw new Error("Unacceptable token: " + parser.lexer.current.text);
        }, "parsePrefix")
      });
      const notNullableParslet = composeParslet({
        name: "notNullableParslet",
        accept: /* @__PURE__ */ __name((type5) => type5 === "!", "accept"),
        precedence: Precedence.NULLABLE,
        parsePrefix: /* @__PURE__ */ __name((parser) => {
          parser.consume("!");
          return {
            type: "JsdocTypeNotNullable",
            element: parser.parseType(Precedence.NULLABLE),
            meta: {
              position: "prefix"
            }
          };
        }, "parsePrefix"),
        parseInfix: /* @__PURE__ */ __name((parser, left) => {
          parser.consume("!");
          return {
            type: "JsdocTypeNotNullable",
            element: assertRootResult(left),
            meta: {
              position: "suffix"
            }
          };
        }, "parseInfix")
      });
      function createParameterListParslet({ allowTrailingComma }) {
        return composeParslet({
          name: "parameterListParslet",
          accept: /* @__PURE__ */ __name((type5) => type5 === ",", "accept"),
          precedence: Precedence.PARAMETER_LIST,
          parseInfix: /* @__PURE__ */ __name((parser, left) => {
            const elements = [
              assertPlainKeyValueOrRootResult(left)
            ];
            parser.consume(",");
            do {
              try {
                const next = parser.parseIntermediateType(Precedence.PARAMETER_LIST);
                elements.push(assertPlainKeyValueOrRootResult(next));
              } catch (e2) {
                if (e2 instanceof NoParsletFoundError) {
                  break;
                } else {
                  throw e2;
                }
              }
            } while (parser.consume(","));
            if (elements.length > 0 && elements.slice(0, -1).some((e2) => e2.type === "JsdocTypeVariadic")) {
              throw new Error("Only the last parameter may be a rest parameter");
            }
            return {
              type: "JsdocTypeParameterList",
              elements
            };
          }, "parseInfix")
        });
      }
      __name(createParameterListParslet, "createParameterListParslet");
      const genericParslet = composeParslet({
        name: "genericParslet",
        accept: /* @__PURE__ */ __name((type5, next) => type5 === "<" || type5 === "." && next === "<", "accept"),
        precedence: Precedence.GENERIC,
        parseInfix: /* @__PURE__ */ __name((parser, left) => {
          const dot = parser.consume(".");
          parser.consume("<");
          const objects = [];
          let infer = false;
          if (parser.consume("infer")) {
            infer = true;
            const left2 = parser.parseIntermediateType(Precedence.SYMBOL);
            if (left2.type !== "JsdocTypeName") {
              throw new UnexpectedTypeError(left2, "A typescript asserts always has to have a name on the left side.");
            }
            objects.push(left2);
          } else {
            do {
              objects.push(parser.parseType(Precedence.PARAMETER_LIST));
            } while (parser.consume(","));
          }
          if (!parser.consume(">")) {
            throw new Error("Unterminated generic parameter list");
          }
          return Object.assign(Object.assign({ type: "JsdocTypeGeneric", left: assertRootResult(left), elements: objects }, infer ? { infer: true } : {}), { meta: {
            brackets: "angle",
            dot
          } });
        }, "parseInfix")
      });
      const unionParslet = composeParslet({
        name: "unionParslet",
        accept: /* @__PURE__ */ __name((type5) => type5 === "|", "accept"),
        precedence: Precedence.UNION,
        parseInfix: /* @__PURE__ */ __name((parser, left) => {
          parser.consume("|");
          const elements = [];
          do {
            elements.push(parser.parseType(Precedence.UNION));
          } while (parser.consume("|"));
          return {
            type: "JsdocTypeUnion",
            elements: [assertRootResult(left), ...elements]
          };
        }, "parseInfix")
      });
      const baseGrammar = [
        nullableParslet,
        optionalParslet,
        numberParslet,
        parenthesisParslet,
        specialTypesParslet,
        notNullableParslet,
        createParameterListParslet({
          allowTrailingComma: true
        }),
        genericParslet,
        unionParslet,
        optionalParslet
      ];
      function createNamePathParslet({ allowSquareBracketsOnAnyType, allowJsdocNamePaths, pathGrammar: pathGrammar2 }) {
        return /* @__PURE__ */ __name(function namePathParslet(parser, precedence, left) {
          if (left == null || precedence >= Precedence.NAME_PATH) {
            return null;
          }
          const type5 = parser.lexer.current.type;
          const next = parser.lexer.next.type;
          const accept = type5 === "." && next !== "<" || type5 === "[" && (allowSquareBracketsOnAnyType || left.type === "JsdocTypeName") || allowJsdocNamePaths && (type5 === "~" || type5 === "#");
          if (!accept) {
            return null;
          }
          let pathType;
          let brackets = false;
          if (parser.consume(".")) {
            pathType = "property";
          } else if (parser.consume("[")) {
            pathType = "property-brackets";
            brackets = true;
          } else if (parser.consume("~")) {
            pathType = "inner";
          } else {
            parser.consume("#");
            pathType = "instance";
          }
          const pathParser = pathGrammar2 !== null ? new Parser(pathGrammar2, parser.lexer, parser) : parser;
          const parsed = pathParser.parseIntermediateType(Precedence.NAME_PATH);
          parser.acceptLexerState(pathParser);
          let right;
          switch (parsed.type) {
            case "JsdocTypeName":
              right = {
                type: "JsdocTypeProperty",
                value: parsed.value,
                meta: {
                  quote: void 0
                }
              };
              break;
            case "JsdocTypeNumber":
              right = {
                type: "JsdocTypeProperty",
                value: parsed.value.toString(10),
                meta: {
                  quote: void 0
                }
              };
              break;
            case "JsdocTypeStringValue":
              right = {
                type: "JsdocTypeProperty",
                value: parsed.value,
                meta: {
                  quote: parsed.meta.quote
                }
              };
              break;
            case "JsdocTypeSpecialNamePath":
              if (parsed.specialType === "event") {
                right = parsed;
              } else {
                throw new UnexpectedTypeError(parsed, "Type 'JsdocTypeSpecialNamePath' is only allowed with specialType 'event'");
              }
              break;
            default:
              throw new UnexpectedTypeError(parsed, "Expecting 'JsdocTypeName', 'JsdocTypeNumber', 'JsdocStringValue' or 'JsdocTypeSpecialNamePath'");
          }
          if (brackets && !parser.consume("]")) {
            const token = parser.lexer.current;
            throw new Error(`Unterminated square brackets. Next token is '${token.type}' with text '${token.text}'`);
          }
          return {
            type: "JsdocTypeNamePath",
            left: assertRootResult(left),
            right,
            pathType
          };
        }, "namePathParslet");
      }
      __name(createNamePathParslet, "createNamePathParslet");
      function createNameParslet({ allowedAdditionalTokens }) {
        return composeParslet({
          name: "nameParslet",
          accept: /* @__PURE__ */ __name((type5) => type5 === "Identifier" || type5 === "this" || type5 === "new" || allowedAdditionalTokens.includes(type5), "accept"),
          parsePrefix: /* @__PURE__ */ __name((parser) => {
            const { type: type5, text } = parser.lexer.current;
            parser.consume(type5);
            return {
              type: "JsdocTypeName",
              value: text
            };
          }, "parsePrefix")
        });
      }
      __name(createNameParslet, "createNameParslet");
      const stringValueParslet = composeParslet({
        name: "stringValueParslet",
        accept: /* @__PURE__ */ __name((type5) => type5 === "StringValue", "accept"),
        parsePrefix: /* @__PURE__ */ __name((parser) => {
          const text = parser.lexer.current.text;
          parser.consume("StringValue");
          return {
            type: "JsdocTypeStringValue",
            value: text.slice(1, -1),
            meta: {
              quote: text[0] === "'" ? "single" : "double"
            }
          };
        }, "parsePrefix")
      });
      function createSpecialNamePathParslet({ pathGrammar: pathGrammar2, allowedTypes }) {
        return composeParslet({
          name: "specialNamePathParslet",
          accept: /* @__PURE__ */ __name((type5) => allowedTypes.includes(type5), "accept"),
          parsePrefix: /* @__PURE__ */ __name((parser) => {
            const type5 = parser.lexer.current.type;
            parser.consume(type5);
            if (!parser.consume(":")) {
              return {
                type: "JsdocTypeName",
                value: type5
              };
            }
            let result;
            let token = parser.lexer.current;
            if (parser.consume("StringValue")) {
              result = {
                type: "JsdocTypeSpecialNamePath",
                value: token.text.slice(1, -1),
                specialType: type5,
                meta: {
                  quote: token.text[0] === "'" ? "single" : "double"
                }
              };
            } else {
              let value = "";
              const allowed = ["Identifier", "@", "/"];
              while (allowed.some((type6) => parser.consume(type6))) {
                value += token.text;
                token = parser.lexer.current;
              }
              result = {
                type: "JsdocTypeSpecialNamePath",
                value,
                specialType: type5,
                meta: {
                  quote: void 0
                }
              };
            }
            const moduleParser = new Parser(pathGrammar2, parser.lexer, parser);
            const moduleResult = moduleParser.parseInfixIntermediateType(result, Precedence.ALL);
            parser.acceptLexerState(moduleParser);
            return assertRootResult(moduleResult);
          }, "parsePrefix")
        });
      }
      __name(createSpecialNamePathParslet, "createSpecialNamePathParslet");
      const basePathGrammar = [
        createNameParslet({
          allowedAdditionalTokens: ["external", "module"]
        }),
        stringValueParslet,
        numberParslet,
        createNamePathParslet({
          allowSquareBracketsOnAnyType: false,
          allowJsdocNamePaths: true,
          pathGrammar: null
        })
      ];
      const pathGrammar = [
        ...basePathGrammar,
        createSpecialNamePathParslet({
          allowedTypes: ["event"],
          pathGrammar: basePathGrammar
        })
      ];
      function getParameters(value) {
        let parameters2;
        if (value.type === "JsdocTypeParameterList") {
          parameters2 = value.elements;
        } else if (value.type === "JsdocTypeParenthesis") {
          parameters2 = [value.element];
        } else {
          throw new UnexpectedTypeError(value);
        }
        return parameters2.map((p2) => assertPlainKeyValueOrRootResult(p2));
      }
      __name(getParameters, "getParameters");
      function getUnnamedParameters(value) {
        const parameters2 = getParameters(value);
        if (parameters2.some((p2) => p2.type === "JsdocTypeKeyValue")) {
          throw new Error("No parameter should be named");
        }
        return parameters2;
      }
      __name(getUnnamedParameters, "getUnnamedParameters");
      function createFunctionParslet({ allowNamedParameters, allowNoReturnType, allowWithoutParenthesis, allowNewAsFunctionKeyword }) {
        return composeParslet({
          name: "functionParslet",
          accept: /* @__PURE__ */ __name((type5, next) => type5 === "function" || allowNewAsFunctionKeyword && type5 === "new" && next === "(", "accept"),
          parsePrefix: /* @__PURE__ */ __name((parser) => {
            const newKeyword = parser.consume("new");
            parser.consume("function");
            const hasParenthesis = parser.lexer.current.type === "(";
            if (!hasParenthesis) {
              if (!allowWithoutParenthesis) {
                throw new Error("function is missing parameter list");
              }
              return {
                type: "JsdocTypeName",
                value: "function"
              };
            }
            let result = {
              type: "JsdocTypeFunction",
              parameters: [],
              arrow: false,
              constructor: newKeyword,
              parenthesis: hasParenthesis
            };
            const value = parser.parseIntermediateType(Precedence.FUNCTION);
            if (allowNamedParameters === void 0) {
              result.parameters = getUnnamedParameters(value);
            } else if (newKeyword && value.type === "JsdocTypeFunction" && value.arrow) {
              result = value;
              result.constructor = true;
              return result;
            } else {
              result.parameters = getParameters(value);
              for (const p2 of result.parameters) {
                if (p2.type === "JsdocTypeKeyValue" && !allowNamedParameters.includes(p2.key)) {
                  throw new Error(`only allowed named parameters are ${allowNamedParameters.join(", ")} but got ${p2.type}`);
                }
              }
            }
            if (parser.consume(":")) {
              result.returnType = parser.parseType(Precedence.PREFIX);
            } else {
              if (!allowNoReturnType) {
                throw new Error("function is missing return type");
              }
            }
            return result;
          }, "parsePrefix")
        });
      }
      __name(createFunctionParslet, "createFunctionParslet");
      function createVariadicParslet({ allowPostfix, allowEnclosingBrackets }) {
        return composeParslet({
          name: "variadicParslet",
          accept: /* @__PURE__ */ __name((type5) => type5 === "...", "accept"),
          precedence: Precedence.PREFIX,
          parsePrefix: /* @__PURE__ */ __name((parser) => {
            parser.consume("...");
            const brackets = allowEnclosingBrackets && parser.consume("[");
            try {
              const element = parser.parseType(Precedence.PREFIX);
              if (brackets && !parser.consume("]")) {
                throw new Error("Unterminated variadic type. Missing ']'");
              }
              return {
                type: "JsdocTypeVariadic",
                element: assertRootResult(element),
                meta: {
                  position: "prefix",
                  squareBrackets: brackets
                }
              };
            } catch (e2) {
              if (e2 instanceof NoParsletFoundError) {
                if (brackets) {
                  throw new Error("Empty square brackets for variadic are not allowed.");
                }
                return {
                  type: "JsdocTypeVariadic",
                  meta: {
                    position: void 0,
                    squareBrackets: false
                  }
                };
              } else {
                throw e2;
              }
            }
          }, "parsePrefix"),
          parseInfix: allowPostfix ? (parser, left) => {
            parser.consume("...");
            return {
              type: "JsdocTypeVariadic",
              element: assertRootResult(left),
              meta: {
                position: "suffix",
                squareBrackets: false
              }
            };
          } : void 0
        });
      }
      __name(createVariadicParslet, "createVariadicParslet");
      const symbolParslet = composeParslet({
        name: "symbolParslet",
        accept: /* @__PURE__ */ __name((type5) => type5 === "(", "accept"),
        precedence: Precedence.SYMBOL,
        parseInfix: /* @__PURE__ */ __name((parser, left) => {
          if (left.type !== "JsdocTypeName") {
            throw new Error("Symbol expects a name on the left side. (Reacting on '(')");
          }
          parser.consume("(");
          const result = {
            type: "JsdocTypeSymbol",
            value: left.value
          };
          if (!parser.consume(")")) {
            const next = parser.parseIntermediateType(Precedence.SYMBOL);
            result.element = assertNumberOrVariadicNameResult(next);
            if (!parser.consume(")")) {
              throw new Error("Symbol does not end after value");
            }
          }
          return result;
        }, "parseInfix")
      });
      const arrayBracketsParslet = composeParslet({
        name: "arrayBracketsParslet",
        precedence: Precedence.ARRAY_BRACKETS,
        accept: /* @__PURE__ */ __name((type5, next) => type5 === "[" && next === "]", "accept"),
        parseInfix: /* @__PURE__ */ __name((parser, left) => {
          parser.consume("[");
          parser.consume("]");
          return {
            type: "JsdocTypeGeneric",
            left: {
              type: "JsdocTypeName",
              value: "Array"
            },
            elements: [
              assertRootResult(left)
            ],
            meta: {
              brackets: "square",
              dot: false
            }
          };
        }, "parseInfix")
      });
      function createObjectParslet({ objectFieldGrammar: objectFieldGrammar2, allowKeyTypes }) {
        return composeParslet({
          name: "objectParslet",
          accept: /* @__PURE__ */ __name((type5) => type5 === "{", "accept"),
          parsePrefix: /* @__PURE__ */ __name((parser) => {
            parser.consume("{");
            const result = {
              type: "JsdocTypeObject",
              meta: {
                separator: "comma"
              },
              elements: []
            };
            if (!parser.consume("}")) {
              let separator;
              const fieldParser = new Parser(objectFieldGrammar2, parser.lexer, parser);
              while (true) {
                fieldParser.acceptLexerState(parser);
                let field = fieldParser.parseIntermediateType(Precedence.OBJECT);
                parser.acceptLexerState(fieldParser);
                if (field === void 0 && allowKeyTypes) {
                  field = parser.parseIntermediateType(Precedence.OBJECT);
                }
                let optional = false;
                if (field.type === "JsdocTypeNullable") {
                  optional = true;
                  field = field.element;
                }
                if (field.type === "JsdocTypeNumber" || field.type === "JsdocTypeName" || field.type === "JsdocTypeStringValue") {
                  let quote2;
                  if (field.type === "JsdocTypeStringValue") {
                    quote2 = field.meta.quote;
                  }
                  result.elements.push({
                    type: "JsdocTypeObjectField",
                    key: field.value.toString(),
                    right: void 0,
                    optional,
                    readonly: false,
                    meta: {
                      quote: quote2
                    }
                  });
                } else if (field.type === "JsdocTypeObjectField" || field.type === "JsdocTypeJsdocObjectField") {
                  result.elements.push(field);
                } else {
                  throw new UnexpectedTypeError(field);
                }
                if (parser.lexer.current.startOfLine) {
                  separator = "linebreak";
                  parser.consume(",") || parser.consume(";");
                } else if (parser.consume(",")) {
                  separator = "comma";
                } else if (parser.consume(";")) {
                  separator = "semicolon";
                } else {
                  break;
                }
                const type5 = parser.lexer.current.type;
                if (type5 === "}") {
                  break;
                }
              }
              result.meta.separator = separator !== null && separator !== void 0 ? separator : "comma";
              if (separator === "linebreak") {
                result.meta.propertyIndent = "  ";
              }
              if (!parser.consume("}")) {
                throw new Error("Unterminated record type. Missing '}'");
              }
            }
            return result;
          }, "parsePrefix")
        });
      }
      __name(createObjectParslet, "createObjectParslet");
      function createObjectFieldParslet({ allowSquaredProperties, allowKeyTypes, allowReadonly, allowOptional }) {
        return composeParslet({
          name: "objectFieldParslet",
          precedence: Precedence.KEY_VALUE,
          accept: /* @__PURE__ */ __name((type5) => type5 === ":", "accept"),
          parseInfix: /* @__PURE__ */ __name((parser, left) => {
            var _a3;
            let optional = false;
            let readonlyProperty = false;
            if (allowOptional && left.type === "JsdocTypeNullable") {
              optional = true;
              left = left.element;
            }
            if (allowReadonly && left.type === "JsdocTypeReadonlyProperty") {
              readonlyProperty = true;
              left = left.element;
            }
            const parentParser = (_a3 = parser.baseParser) !== null && _a3 !== void 0 ? _a3 : parser;
            parentParser.acceptLexerState(parser);
            if (left.type === "JsdocTypeNumber" || left.type === "JsdocTypeName" || left.type === "JsdocTypeStringValue" || isSquaredProperty(left)) {
              if (isSquaredProperty(left) && !allowSquaredProperties) {
                throw new UnexpectedTypeError(left);
              }
              parentParser.consume(":");
              let quote2;
              if (left.type === "JsdocTypeStringValue") {
                quote2 = left.meta.quote;
              }
              const right = parentParser.parseType(Precedence.KEY_VALUE);
              parser.acceptLexerState(parentParser);
              return {
                type: "JsdocTypeObjectField",
                key: isSquaredProperty(left) ? left : left.value.toString(),
                right,
                optional,
                readonly: readonlyProperty,
                meta: {
                  quote: quote2
                }
              };
            } else {
              if (!allowKeyTypes) {
                throw new UnexpectedTypeError(left);
              }
              parentParser.consume(":");
              const right = parentParser.parseType(Precedence.KEY_VALUE);
              parser.acceptLexerState(parentParser);
              return {
                type: "JsdocTypeJsdocObjectField",
                left: assertRootResult(left),
                right
              };
            }
          }, "parseInfix")
        });
      }
      __name(createObjectFieldParslet, "createObjectFieldParslet");
      function createKeyValueParslet({ allowOptional, allowVariadic }) {
        return composeParslet({
          name: "keyValueParslet",
          precedence: Precedence.KEY_VALUE,
          accept: /* @__PURE__ */ __name((type5) => type5 === ":", "accept"),
          parseInfix: /* @__PURE__ */ __name((parser, left) => {
            let optional = false;
            let variadic = false;
            if (allowOptional && left.type === "JsdocTypeNullable") {
              optional = true;
              left = left.element;
            }
            if (allowVariadic && left.type === "JsdocTypeVariadic" && left.element !== void 0) {
              variadic = true;
              left = left.element;
            }
            if (left.type !== "JsdocTypeName") {
              throw new UnexpectedTypeError(left);
            }
            parser.consume(":");
            const right = parser.parseType(Precedence.KEY_VALUE);
            return {
              type: "JsdocTypeKeyValue",
              key: left.value,
              right,
              optional,
              variadic
            };
          }, "parseInfix")
        });
      }
      __name(createKeyValueParslet, "createKeyValueParslet");
      const jsdocBaseGrammar = [
        ...baseGrammar,
        createFunctionParslet({
          allowWithoutParenthesis: true,
          allowNamedParameters: ["this", "new"],
          allowNoReturnType: true,
          allowNewAsFunctionKeyword: false
        }),
        stringValueParslet,
        createSpecialNamePathParslet({
          allowedTypes: ["module", "external", "event"],
          pathGrammar
        }),
        createVariadicParslet({
          allowEnclosingBrackets: true,
          allowPostfix: true
        }),
        createNameParslet({
          allowedAdditionalTokens: ["keyof"]
        }),
        symbolParslet,
        arrayBracketsParslet,
        createNamePathParslet({
          allowSquareBracketsOnAnyType: false,
          allowJsdocNamePaths: true,
          pathGrammar
        })
      ];
      const jsdocGrammar = [
        ...jsdocBaseGrammar,
        createObjectParslet({
          // jsdoc syntax allows full types as keys, so we need to pull in the full grammar here
          // we leave out the object type deliberately
          objectFieldGrammar: [
            createNameParslet({
              allowedAdditionalTokens: ["typeof", "module", "in"]
            }),
            createObjectFieldParslet({
              allowSquaredProperties: false,
              allowKeyTypes: true,
              allowOptional: false,
              allowReadonly: false
            }),
            ...jsdocBaseGrammar
          ],
          allowKeyTypes: true
        }),
        createKeyValueParslet({
          allowOptional: true,
          allowVariadic: true
        })
      ];
      const typeOfParslet = composeParslet({
        name: "typeOfParslet",
        accept: /* @__PURE__ */ __name((type5) => type5 === "typeof", "accept"),
        parsePrefix: /* @__PURE__ */ __name((parser) => {
          parser.consume("typeof");
          return {
            type: "JsdocTypeTypeof",
            element: parser.parseType(Precedence.KEY_OF_TYPE_OF)
          };
        }, "parsePrefix")
      });
      const objectFieldGrammar$1 = [
        createNameParslet({
          allowedAdditionalTokens: ["typeof", "module", "keyof", "event", "external", "in"]
        }),
        nullableParslet,
        optionalParslet,
        stringValueParslet,
        numberParslet,
        createObjectFieldParslet({
          allowSquaredProperties: false,
          allowKeyTypes: false,
          allowOptional: false,
          allowReadonly: false
        })
      ];
      const closureGrammar = [
        ...baseGrammar,
        createObjectParslet({
          allowKeyTypes: false,
          objectFieldGrammar: objectFieldGrammar$1
        }),
        createNameParslet({
          allowedAdditionalTokens: ["event", "external", "in"]
        }),
        typeOfParslet,
        createFunctionParslet({
          allowWithoutParenthesis: false,
          allowNamedParameters: ["this", "new"],
          allowNoReturnType: true,
          allowNewAsFunctionKeyword: false
        }),
        createVariadicParslet({
          allowEnclosingBrackets: false,
          allowPostfix: false
        }),
        // additional name parslet is needed for some special cases
        createNameParslet({
          allowedAdditionalTokens: ["keyof"]
        }),
        createSpecialNamePathParslet({
          allowedTypes: ["module"],
          pathGrammar
        }),
        createNamePathParslet({
          allowSquareBracketsOnAnyType: false,
          allowJsdocNamePaths: true,
          pathGrammar
        }),
        createKeyValueParslet({
          allowOptional: false,
          allowVariadic: false
        }),
        symbolParslet
      ];
      const assertsParslet = composeParslet({
        name: "assertsParslet",
        accept: /* @__PURE__ */ __name((type5) => type5 === "asserts", "accept"),
        parsePrefix: /* @__PURE__ */ __name((parser) => {
          parser.consume("asserts");
          const left = parser.parseIntermediateType(Precedence.SYMBOL);
          if (left.type !== "JsdocTypeName") {
            throw new UnexpectedTypeError(left, "A typescript asserts always has to have a name on the left side.");
          }
          if (!parser.consume("is")) {
            return {
              type: "JsdocTypeAssertsPlain",
              element: left
            };
          }
          return {
            type: "JsdocTypeAsserts",
            left,
            right: assertRootResult(parser.parseIntermediateType(Precedence.INFIX))
          };
        }, "parsePrefix")
      });
      function createTupleParslet({ allowQuestionMark }) {
        return composeParslet({
          name: "tupleParslet",
          accept: /* @__PURE__ */ __name((type5) => type5 === "[", "accept"),
          parsePrefix: /* @__PURE__ */ __name((parser) => {
            parser.consume("[");
            const result = {
              type: "JsdocTypeTuple",
              elements: []
            };
            if (parser.consume("]")) {
              return result;
            }
            const typeList = parser.parseIntermediateType(Precedence.ALL);
            if (typeList.type === "JsdocTypeParameterList") {
              if (typeList.elements[0].type === "JsdocTypeKeyValue") {
                result.elements = typeList.elements.map(assertPlainKeyValueResult);
              } else {
                result.elements = typeList.elements.map(assertRootResult);
              }
            } else {
              if (typeList.type === "JsdocTypeKeyValue") {
                result.elements = [assertPlainKeyValueResult(typeList)];
              } else {
                result.elements = [assertRootResult(typeList)];
              }
            }
            if (!parser.consume("]")) {
              throw new Error("Unterminated '['");
            }
            if (result.elements.some((e2) => e2.type === "JsdocTypeUnknown")) {
              throw new Error("Question mark in tuple not allowed");
            }
            return result;
          }, "parsePrefix")
        });
      }
      __name(createTupleParslet, "createTupleParslet");
      const keyOfParslet = composeParslet({
        name: "keyOfParslet",
        accept: /* @__PURE__ */ __name((type5) => type5 === "keyof", "accept"),
        parsePrefix: /* @__PURE__ */ __name((parser) => {
          parser.consume("keyof");
          return {
            type: "JsdocTypeKeyof",
            element: assertRootResult(parser.parseType(Precedence.KEY_OF_TYPE_OF))
          };
        }, "parsePrefix")
      });
      const importParslet = composeParslet({
        name: "importParslet",
        accept: /* @__PURE__ */ __name((type5) => type5 === "import", "accept"),
        parsePrefix: /* @__PURE__ */ __name((parser) => {
          parser.consume("import");
          if (!parser.consume("(")) {
            throw new Error("Missing parenthesis after import keyword");
          }
          const path = parser.parseType(Precedence.PREFIX);
          if (path.type !== "JsdocTypeStringValue") {
            throw new Error("Only string values are allowed as paths for imports");
          }
          if (!parser.consume(")")) {
            throw new Error("Missing closing parenthesis after import keyword");
          }
          return {
            type: "JsdocTypeImport",
            element: path
          };
        }, "parsePrefix")
      });
      const readonlyPropertyParslet = composeParslet({
        name: "readonlyPropertyParslet",
        accept: /* @__PURE__ */ __name((type5) => type5 === "readonly", "accept"),
        parsePrefix: /* @__PURE__ */ __name((parser) => {
          parser.consume("readonly");
          return {
            type: "JsdocTypeReadonlyProperty",
            element: parser.parseIntermediateType(Precedence.KEY_VALUE)
          };
        }, "parsePrefix")
      });
      const arrowFunctionParslet = composeParslet({
        name: "arrowFunctionParslet",
        precedence: Precedence.ARROW,
        accept: /* @__PURE__ */ __name((type5) => type5 === "=>", "accept"),
        parseInfix: /* @__PURE__ */ __name((parser, left) => {
          parser.consume("=>");
          return {
            type: "JsdocTypeFunction",
            parameters: getParameters(left).map(assertPlainKeyValueOrNameResult),
            arrow: true,
            constructor: false,
            parenthesis: true,
            returnType: parser.parseType(Precedence.OBJECT)
          };
        }, "parseInfix")
      });
      const genericArrowFunctionParslet = composeParslet({
        name: "genericArrowFunctionParslet",
        accept: /* @__PURE__ */ __name((type5) => type5 === "<", "accept"),
        parsePrefix: /* @__PURE__ */ __name((parser) => {
          const typeParameters = [];
          parser.consume("<");
          do {
            let defaultValue;
            let name = parser.parseIntermediateType(Precedence.SYMBOL);
            if (name.type === "JsdocTypeOptional") {
              name = name.element;
              defaultValue = parser.parseType(Precedence.SYMBOL);
            }
            if (name.type !== "JsdocTypeName") {
              throw new UnexpectedTypeError(name);
            }
            let constraint;
            if (parser.consume("extends")) {
              constraint = parser.parseType(Precedence.SYMBOL);
              if (constraint.type === "JsdocTypeOptional") {
                constraint = constraint.element;
                defaultValue = parser.parseType(Precedence.SYMBOL);
              }
            }
            const typeParameter = {
              type: "JsdocTypeTypeParameter",
              name
            };
            if (constraint !== void 0) {
              typeParameter.constraint = constraint;
            }
            if (defaultValue !== void 0) {
              typeParameter.defaultValue = defaultValue;
            }
            typeParameters.push(typeParameter);
            if (parser.consume(">")) {
              break;
            }
          } while (parser.consume(","));
          const functionBase = parser.parseIntermediateType(Precedence.SYMBOL);
          functionBase.typeParameters = typeParameters;
          return functionBase;
        }, "parsePrefix")
      });
      const intersectionParslet = composeParslet({
        name: "intersectionParslet",
        accept: /* @__PURE__ */ __name((type5) => type5 === "&", "accept"),
        precedence: Precedence.INTERSECTION,
        parseInfix: /* @__PURE__ */ __name((parser, left) => {
          parser.consume("&");
          const elements = [];
          do {
            elements.push(parser.parseType(Precedence.INTERSECTION));
          } while (parser.consume("&"));
          return {
            type: "JsdocTypeIntersection",
            elements: [assertRootResult(left), ...elements]
          };
        }, "parseInfix")
      });
      const predicateParslet = composeParslet({
        name: "predicateParslet",
        precedence: Precedence.INFIX,
        accept: /* @__PURE__ */ __name((type5) => type5 === "is", "accept"),
        parseInfix: /* @__PURE__ */ __name((parser, left) => {
          if (left.type !== "JsdocTypeName") {
            throw new UnexpectedTypeError(left, "A typescript predicate always has to have a name on the left side.");
          }
          parser.consume("is");
          return {
            type: "JsdocTypePredicate",
            left,
            right: assertRootResult(parser.parseIntermediateType(Precedence.INFIX))
          };
        }, "parseInfix")
      });
      const objectSquaredPropertyParslet = composeParslet({
        name: "objectSquareBracketPropertyParslet",
        accept: /* @__PURE__ */ __name((type5) => type5 === "[", "accept"),
        parsePrefix: /* @__PURE__ */ __name((parser) => {
          if (parser.baseParser === void 0) {
            throw new Error("Only allowed inside object grammar");
          }
          parser.consume("[");
          const key = parser.lexer.current.text;
          parser.consume("Identifier");
          let result;
          if (parser.consume(":")) {
            const parentParser = parser.baseParser;
            parentParser.acceptLexerState(parser);
            result = {
              type: "JsdocTypeIndexSignature",
              key,
              right: parentParser.parseType(Precedence.INDEX_BRACKETS)
            };
            parser.acceptLexerState(parentParser);
          } else if (parser.consume("in")) {
            const parentParser = parser.baseParser;
            parentParser.acceptLexerState(parser);
            result = {
              type: "JsdocTypeMappedType",
              key,
              right: parentParser.parseType(Precedence.ARRAY_BRACKETS)
            };
            parser.acceptLexerState(parentParser);
          } else {
            throw new Error("Missing ':' or 'in' inside square bracketed property.");
          }
          if (!parser.consume("]")) {
            throw new Error("Unterminated square brackets");
          }
          return result;
        }, "parsePrefix")
      });
      const readonlyArrayParslet = composeParslet({
        name: "readonlyArrayParslet",
        accept: /* @__PURE__ */ __name((type5) => type5 === "readonly", "accept"),
        parsePrefix: /* @__PURE__ */ __name((parser) => {
          parser.consume("readonly");
          return {
            type: "JsdocTypeReadonlyArray",
            element: assertArrayOrTupleResult(parser.parseIntermediateType(Precedence.ALL))
          };
        }, "parsePrefix")
      });
      const conditionalParslet = composeParslet({
        name: "conditionalParslet",
        precedence: Precedence.INFIX,
        accept: /* @__PURE__ */ __name((type5) => type5 === "extends", "accept"),
        parseInfix: /* @__PURE__ */ __name((parser, left) => {
          parser.consume("extends");
          const extendsType = parser.parseType(Precedence.KEY_OF_TYPE_OF).element;
          const trueType = parser.parseType(Precedence.INFIX);
          parser.consume(":");
          return {
            type: "JsdocTypeConditional",
            checksType: assertRootResult(left),
            extendsType,
            trueType,
            falseType: parser.parseType(Precedence.INFIX)
          };
        }, "parseInfix")
      });
      const objectFieldGrammar = [
        readonlyPropertyParslet,
        createNameParslet({
          allowedAdditionalTokens: ["typeof", "module", "keyof", "event", "external", "in"]
        }),
        nullableParslet,
        optionalParslet,
        stringValueParslet,
        numberParslet,
        createObjectFieldParslet({
          allowSquaredProperties: true,
          allowKeyTypes: false,
          allowOptional: true,
          allowReadonly: true
        }),
        objectSquaredPropertyParslet
      ];
      const typescriptGrammar = [
        ...baseGrammar,
        createObjectParslet({
          allowKeyTypes: false,
          objectFieldGrammar
        }),
        readonlyArrayParslet,
        typeOfParslet,
        keyOfParslet,
        importParslet,
        stringValueParslet,
        createFunctionParslet({
          allowWithoutParenthesis: true,
          allowNoReturnType: false,
          allowNamedParameters: ["this", "new", "args"],
          allowNewAsFunctionKeyword: true
        }),
        createTupleParslet({
          allowQuestionMark: false
        }),
        createVariadicParslet({
          allowEnclosingBrackets: false,
          allowPostfix: false
        }),
        assertsParslet,
        conditionalParslet,
        createNameParslet({
          allowedAdditionalTokens: ["event", "external", "in"]
        }),
        createSpecialNamePathParslet({
          allowedTypes: ["module"],
          pathGrammar
        }),
        arrayBracketsParslet,
        arrowFunctionParslet,
        genericArrowFunctionParslet,
        createNamePathParslet({
          allowSquareBracketsOnAnyType: true,
          allowJsdocNamePaths: false,
          pathGrammar
        }),
        intersectionParslet,
        predicateParslet,
        createKeyValueParslet({
          allowVariadic: true,
          allowOptional: true
        })
      ];
      function parse6(expression, mode) {
        switch (mode) {
          case "closure":
            return new Parser(closureGrammar, expression).parse();
          case "jsdoc":
            return new Parser(jsdocGrammar, expression).parse();
          case "typescript":
            return new Parser(typescriptGrammar, expression).parse();
        }
      }
      __name(parse6, "parse");
      function tryParse(expression, modes = ["typescript", "closure", "jsdoc"]) {
        let error;
        for (const mode of modes) {
          try {
            return parse6(expression, mode);
          } catch (e2) {
            error = e2;
          }
        }
        throw error;
      }
      __name(tryParse, "tryParse");
      function transform(rules2, parseResult) {
        const rule = rules2[parseResult.type];
        if (rule === void 0) {
          throw new Error(`In this set of transform rules exists no rule for type ${parseResult.type}.`);
        }
        return rule(parseResult, (aParseResult) => transform(rules2, aParseResult));
      }
      __name(transform, "transform");
      function notAvailableTransform(parseResult) {
        throw new Error("This transform is not available. Are you trying the correct parsing mode?");
      }
      __name(notAvailableTransform, "notAvailableTransform");
      function extractSpecialParams(source) {
        const result = {
          params: []
        };
        for (const param of source.parameters) {
          if (param.type === "JsdocTypeKeyValue") {
            if (param.key === "this") {
              result.this = param.right;
            } else if (param.key === "new") {
              result.new = param.right;
            } else {
              result.params.push(param);
            }
          } else {
            result.params.push(param);
          }
        }
        return result;
      }
      __name(extractSpecialParams, "extractSpecialParams");
      function applyPosition(position, target, value) {
        return position === "prefix" ? value + target : target + value;
      }
      __name(applyPosition, "applyPosition");
      function quote(value, quote2) {
        switch (quote2) {
          case "double":
            return `"${value}"`;
          case "single":
            return `'${value}'`;
          case void 0:
            return value;
        }
      }
      __name(quote, "quote");
      function stringifyRules2() {
        return {
          JsdocTypeParenthesis: /* @__PURE__ */ __name((result, transform2) => `(${result.element !== void 0 ? transform2(result.element) : ""})`, "JsdocTypeParenthesis"),
          JsdocTypeKeyof: /* @__PURE__ */ __name((result, transform2) => `keyof ${transform2(result.element)}`, "JsdocTypeKeyof"),
          JsdocTypeFunction: /* @__PURE__ */ __name((result, transform2) => {
            var _a3;
            if (!result.arrow) {
              let stringified = result.constructor ? "new" : "function";
              if (!result.parenthesis) {
                return stringified;
              }
              stringified += `(${result.parameters.map(transform2).join(", ")})`;
              if (result.returnType !== void 0) {
                stringified += `: ${transform2(result.returnType)}`;
              }
              return stringified;
            } else {
              if (result.returnType === void 0) {
                throw new Error("Arrow function needs a return type.");
              }
              let stringified = `${result.typeParameters !== void 0 ? `<${(_a3 = result.typeParameters.map(transform2).join(", ")) !== null && _a3 !== void 0 ? _a3 : ""}>` : ""}(${result.parameters.map(transform2).join(", ")}) => ${transform2(result.returnType)}`;
              if (result.constructor) {
                stringified = "new " + stringified;
              }
              return stringified;
            }
          }, "JsdocTypeFunction"),
          JsdocTypeName: /* @__PURE__ */ __name((result) => result.value, "JsdocTypeName"),
          JsdocTypeTuple: /* @__PURE__ */ __name((result, transform2) => `[${result.elements.map(transform2).join(", ")}]`, "JsdocTypeTuple"),
          JsdocTypeVariadic: /* @__PURE__ */ __name((result, transform2) => result.meta.position === void 0 ? "..." : applyPosition(result.meta.position, transform2(result.element), "..."), "JsdocTypeVariadic"),
          JsdocTypeNamePath: /* @__PURE__ */ __name((result, transform2) => {
            const left = transform2(result.left);
            const right = transform2(result.right);
            switch (result.pathType) {
              case "inner":
                return `${left}~${right}`;
              case "instance":
                return `${left}#${right}`;
              case "property":
                return `${left}.${right}`;
              case "property-brackets":
                return `${left}[${right}]`;
            }
          }, "JsdocTypeNamePath"),
          JsdocTypeStringValue: /* @__PURE__ */ __name((result) => quote(result.value, result.meta.quote), "JsdocTypeStringValue"),
          JsdocTypeAny: /* @__PURE__ */ __name(() => "*", "JsdocTypeAny"),
          JsdocTypeGeneric: /* @__PURE__ */ __name((result, transform2) => {
            if (result.meta.brackets === "square") {
              const element = result.elements[0];
              const transformed = transform2(element);
              if (element.type === "JsdocTypeUnion" || element.type === "JsdocTypeIntersection") {
                return `(${transformed})[]`;
              } else {
                return `${transformed}[]`;
              }
            } else {
              return `${transform2(result.left)}${result.meta.dot ? "." : ""}<${result.infer === true ? "infer " : ""}${result.elements.map(transform2).join(", ")}>`;
            }
          }, "JsdocTypeGeneric"),
          JsdocTypeImport: /* @__PURE__ */ __name((result, transform2) => `import(${transform2(result.element)})`, "JsdocTypeImport"),
          JsdocTypeObjectField: /* @__PURE__ */ __name((result, transform2) => {
            let text = "";
            if (result.readonly) {
              text += "readonly ";
            }
            if (typeof result.key === "string") {
              text += quote(result.key, result.meta.quote);
            } else {
              text += transform2(result.key);
            }
            if (result.optional) {
              text += "?";
            }
            if (result.right === void 0) {
              return text;
            } else {
              return text + `: ${transform2(result.right)}`;
            }
          }, "JsdocTypeObjectField"),
          JsdocTypeJsdocObjectField: /* @__PURE__ */ __name((result, transform2) => {
            return `${transform2(result.left)}: ${transform2(result.right)}`;
          }, "JsdocTypeJsdocObjectField"),
          JsdocTypeKeyValue: /* @__PURE__ */ __name((result, transform2) => {
            let text = result.key;
            if (result.optional) {
              text += "?";
            }
            if (result.variadic) {
              text = "..." + text;
            }
            if (result.right === void 0) {
              return text;
            } else {
              return text + `: ${transform2(result.right)}`;
            }
          }, "JsdocTypeKeyValue"),
          JsdocTypeSpecialNamePath: /* @__PURE__ */ __name((result) => `${result.specialType}:${quote(result.value, result.meta.quote)}`, "JsdocTypeSpecialNamePath"),
          JsdocTypeNotNullable: /* @__PURE__ */ __name((result, transform2) => applyPosition(result.meta.position, transform2(result.element), "!"), "JsdocTypeNotNullable"),
          JsdocTypeNull: /* @__PURE__ */ __name(() => "null", "JsdocTypeNull"),
          JsdocTypeNullable: /* @__PURE__ */ __name((result, transform2) => applyPosition(result.meta.position, transform2(result.element), "?"), "JsdocTypeNullable"),
          JsdocTypeNumber: /* @__PURE__ */ __name((result) => result.value.toString(), "JsdocTypeNumber"),
          JsdocTypeObject: /* @__PURE__ */ __name((result, transform2) => {
            var _a3, _b;
            return `{${(result.meta.separator === "linebreak" && result.elements.length > 1 ? "\n" + ((_a3 = result.meta.propertyIndent) !== null && _a3 !== void 0 ? _a3 : "") : "") + result.elements.map(transform2).join(result.meta.separator === "comma" ? ", " : result.meta.separator === "linebreak" ? "\n" + ((_b = result.meta.propertyIndent) !== null && _b !== void 0 ? _b : "") : "; ") + (result.meta.separator === "linebreak" && result.elements.length > 1 ? "\n" : "")}}`;
          }, "JsdocTypeObject"),
          JsdocTypeOptional: /* @__PURE__ */ __name((result, transform2) => applyPosition(result.meta.position, transform2(result.element), "="), "JsdocTypeOptional"),
          JsdocTypeSymbol: /* @__PURE__ */ __name((result, transform2) => `${result.value}(${result.element !== void 0 ? transform2(result.element) : ""})`, "JsdocTypeSymbol"),
          JsdocTypeTypeof: /* @__PURE__ */ __name((result, transform2) => `typeof ${transform2(result.element)}`, "JsdocTypeTypeof"),
          JsdocTypeUndefined: /* @__PURE__ */ __name(() => "undefined", "JsdocTypeUndefined"),
          JsdocTypeUnion: /* @__PURE__ */ __name((result, transform2) => result.elements.map(transform2).join(" | "), "JsdocTypeUnion"),
          JsdocTypeUnknown: /* @__PURE__ */ __name(() => "?", "JsdocTypeUnknown"),
          JsdocTypeIntersection: /* @__PURE__ */ __name((result, transform2) => result.elements.map(transform2).join(" & "), "JsdocTypeIntersection"),
          JsdocTypeProperty: /* @__PURE__ */ __name((result) => quote(result.value, result.meta.quote), "JsdocTypeProperty"),
          JsdocTypePredicate: /* @__PURE__ */ __name((result, transform2) => `${transform2(result.left)} is ${transform2(result.right)}`, "JsdocTypePredicate"),
          JsdocTypeIndexSignature: /* @__PURE__ */ __name((result, transform2) => `[${result.key}: ${transform2(result.right)}]`, "JsdocTypeIndexSignature"),
          JsdocTypeMappedType: /* @__PURE__ */ __name((result, transform2) => `[${result.key} in ${transform2(result.right)}]`, "JsdocTypeMappedType"),
          JsdocTypeAsserts: /* @__PURE__ */ __name((result, transform2) => `asserts ${transform2(result.left)} is ${transform2(result.right)}`, "JsdocTypeAsserts"),
          JsdocTypeReadonlyArray: /* @__PURE__ */ __name((result, transform2) => `readonly ${transform2(result.element)}`, "JsdocTypeReadonlyArray"),
          JsdocTypeAssertsPlain: /* @__PURE__ */ __name((result, transform2) => `asserts ${transform2(result.element)}`, "JsdocTypeAssertsPlain"),
          JsdocTypeConditional: /* @__PURE__ */ __name((result, transform2) => `${transform2(result.checksType)} extends ${transform2(result.extendsType)} ? ${transform2(result.trueType)} : ${transform2(result.falseType)}`, "JsdocTypeConditional"),
          JsdocTypeTypeParameter: /* @__PURE__ */ __name((result, transform2) => `${transform2(result.name)}${result.constraint !== void 0 ? ` extends ${transform2(result.constraint)}` : ""}${result.defaultValue !== void 0 ? ` = ${transform2(result.defaultValue)}` : ""}`, "JsdocTypeTypeParameter")
        };
      }
      __name(stringifyRules2, "stringifyRules");
      const storedStringifyRules = stringifyRules2();
      function stringify5(result) {
        return transform(storedStringifyRules, result);
      }
      __name(stringify5, "stringify");
      const reservedWords2 = [
        "null",
        "true",
        "false",
        "break",
        "case",
        "catch",
        "class",
        "const",
        "continue",
        "debugger",
        "default",
        "delete",
        "do",
        "else",
        "export",
        "extends",
        "finally",
        "for",
        "function",
        "if",
        "import",
        "in",
        "instanceof",
        "new",
        "return",
        "super",
        "switch",
        "this",
        "throw",
        "try",
        "typeof",
        "var",
        "void",
        "while",
        "with",
        "yield"
      ];
      function makeName(value) {
        const result = {
          type: "NameExpression",
          name: value
        };
        if (reservedWords2.includes(value)) {
          result.reservedWord = true;
        }
        return result;
      }
      __name(makeName, "makeName");
      const catharsisTransformRules = {
        JsdocTypeOptional: /* @__PURE__ */ __name((result, transform2) => {
          const transformed = transform2(result.element);
          transformed.optional = true;
          return transformed;
        }, "JsdocTypeOptional"),
        JsdocTypeNullable: /* @__PURE__ */ __name((result, transform2) => {
          const transformed = transform2(result.element);
          transformed.nullable = true;
          return transformed;
        }, "JsdocTypeNullable"),
        JsdocTypeNotNullable: /* @__PURE__ */ __name((result, transform2) => {
          const transformed = transform2(result.element);
          transformed.nullable = false;
          return transformed;
        }, "JsdocTypeNotNullable"),
        JsdocTypeVariadic: /* @__PURE__ */ __name((result, transform2) => {
          if (result.element === void 0) {
            throw new Error("dots without value are not allowed in catharsis mode");
          }
          const transformed = transform2(result.element);
          transformed.repeatable = true;
          return transformed;
        }, "JsdocTypeVariadic"),
        JsdocTypeAny: /* @__PURE__ */ __name(() => ({
          type: "AllLiteral"
        }), "JsdocTypeAny"),
        JsdocTypeNull: /* @__PURE__ */ __name(() => ({
          type: "NullLiteral"
        }), "JsdocTypeNull"),
        JsdocTypeStringValue: /* @__PURE__ */ __name((result) => makeName(quote(result.value, result.meta.quote)), "JsdocTypeStringValue"),
        JsdocTypeUndefined: /* @__PURE__ */ __name(() => ({
          type: "UndefinedLiteral"
        }), "JsdocTypeUndefined"),
        JsdocTypeUnknown: /* @__PURE__ */ __name(() => ({
          type: "UnknownLiteral"
        }), "JsdocTypeUnknown"),
        JsdocTypeFunction: /* @__PURE__ */ __name((result, transform2) => {
          const params = extractSpecialParams(result);
          const transformed = {
            type: "FunctionType",
            params: params.params.map(transform2)
          };
          if (params.this !== void 0) {
            transformed.this = transform2(params.this);
          }
          if (params.new !== void 0) {
            transformed.new = transform2(params.new);
          }
          if (result.returnType !== void 0) {
            transformed.result = transform2(result.returnType);
          }
          return transformed;
        }, "JsdocTypeFunction"),
        JsdocTypeGeneric: /* @__PURE__ */ __name((result, transform2) => ({
          type: "TypeApplication",
          applications: result.elements.map((o2) => transform2(o2)),
          expression: transform2(result.left)
        }), "JsdocTypeGeneric"),
        JsdocTypeSpecialNamePath: /* @__PURE__ */ __name((result) => makeName(result.specialType + ":" + quote(result.value, result.meta.quote)), "JsdocTypeSpecialNamePath"),
        JsdocTypeName: /* @__PURE__ */ __name((result) => {
          if (result.value !== "function") {
            return makeName(result.value);
          } else {
            return {
              type: "FunctionType",
              params: []
            };
          }
        }, "JsdocTypeName"),
        JsdocTypeNumber: /* @__PURE__ */ __name((result) => makeName(result.value.toString()), "JsdocTypeNumber"),
        JsdocTypeObject: /* @__PURE__ */ __name((result, transform2) => {
          const transformed = {
            type: "RecordType",
            fields: []
          };
          for (const field of result.elements) {
            if (field.type !== "JsdocTypeObjectField" && field.type !== "JsdocTypeJsdocObjectField") {
              transformed.fields.push({
                type: "FieldType",
                key: transform2(field),
                value: void 0
              });
            } else {
              transformed.fields.push(transform2(field));
            }
          }
          return transformed;
        }, "JsdocTypeObject"),
        JsdocTypeObjectField: /* @__PURE__ */ __name((result, transform2) => {
          if (typeof result.key !== "string") {
            throw new Error("Index signatures and mapped types are not supported");
          }
          return {
            type: "FieldType",
            key: makeName(quote(result.key, result.meta.quote)),
            value: result.right === void 0 ? void 0 : transform2(result.right)
          };
        }, "JsdocTypeObjectField"),
        JsdocTypeJsdocObjectField: /* @__PURE__ */ __name((result, transform2) => ({
          type: "FieldType",
          key: transform2(result.left),
          value: transform2(result.right)
        }), "JsdocTypeJsdocObjectField"),
        JsdocTypeUnion: /* @__PURE__ */ __name((result, transform2) => ({
          type: "TypeUnion",
          elements: result.elements.map((e2) => transform2(e2))
        }), "JsdocTypeUnion"),
        JsdocTypeKeyValue: /* @__PURE__ */ __name((result, transform2) => {
          return {
            type: "FieldType",
            key: makeName(result.key),
            value: result.right === void 0 ? void 0 : transform2(result.right)
          };
        }, "JsdocTypeKeyValue"),
        JsdocTypeNamePath: /* @__PURE__ */ __name((result, transform2) => {
          const leftResult = transform2(result.left);
          let rightValue;
          if (result.right.type === "JsdocTypeSpecialNamePath") {
            rightValue = transform2(result.right).name;
          } else {
            rightValue = quote(result.right.value, result.right.meta.quote);
          }
          const joiner = result.pathType === "inner" ? "~" : result.pathType === "instance" ? "#" : ".";
          return makeName(`${leftResult.name}${joiner}${rightValue}`);
        }, "JsdocTypeNamePath"),
        JsdocTypeSymbol: /* @__PURE__ */ __name((result) => {
          let value = "";
          let element = result.element;
          let trailingDots = false;
          if ((element === null || element === void 0 ? void 0 : element.type) === "JsdocTypeVariadic") {
            if (element.meta.position === "prefix") {
              value = "...";
            } else {
              trailingDots = true;
            }
            element = element.element;
          }
          if ((element === null || element === void 0 ? void 0 : element.type) === "JsdocTypeName") {
            value += element.value;
          } else if ((element === null || element === void 0 ? void 0 : element.type) === "JsdocTypeNumber") {
            value += element.value.toString();
          }
          if (trailingDots) {
            value += "...";
          }
          return makeName(`${result.value}(${value})`);
        }, "JsdocTypeSymbol"),
        JsdocTypeParenthesis: /* @__PURE__ */ __name((result, transform2) => transform2(assertRootResult(result.element)), "JsdocTypeParenthesis"),
        JsdocTypeMappedType: notAvailableTransform,
        JsdocTypeIndexSignature: notAvailableTransform,
        JsdocTypeImport: notAvailableTransform,
        JsdocTypeKeyof: notAvailableTransform,
        JsdocTypeTuple: notAvailableTransform,
        JsdocTypeTypeof: notAvailableTransform,
        JsdocTypeIntersection: notAvailableTransform,
        JsdocTypeProperty: notAvailableTransform,
        JsdocTypePredicate: notAvailableTransform,
        JsdocTypeAsserts: notAvailableTransform,
        JsdocTypeReadonlyArray: notAvailableTransform,
        JsdocTypeAssertsPlain: notAvailableTransform,
        JsdocTypeConditional: notAvailableTransform,
        JsdocTypeTypeParameter: notAvailableTransform
      };
      function catharsisTransform(result) {
        return transform(catharsisTransformRules, result);
      }
      __name(catharsisTransform, "catharsisTransform");
      function getQuoteStyle(quote2) {
        switch (quote2) {
          case void 0:
            return "none";
          case "single":
            return "single";
          case "double":
            return "double";
        }
      }
      __name(getQuoteStyle, "getQuoteStyle");
      function getMemberType(type5) {
        switch (type5) {
          case "inner":
            return "INNER_MEMBER";
          case "instance":
            return "INSTANCE_MEMBER";
          case "property":
            return "MEMBER";
          case "property-brackets":
            return "MEMBER";
        }
      }
      __name(getMemberType, "getMemberType");
      function nestResults(type5, results) {
        if (results.length === 2) {
          return {
            type: type5,
            left: results[0],
            right: results[1]
          };
        } else {
          return {
            type: type5,
            left: results[0],
            right: nestResults(type5, results.slice(1))
          };
        }
      }
      __name(nestResults, "nestResults");
      const jtpRules = {
        JsdocTypeOptional: /* @__PURE__ */ __name((result, transform2) => ({
          type: "OPTIONAL",
          value: transform2(result.element),
          meta: {
            syntax: result.meta.position === "prefix" ? "PREFIX_EQUAL_SIGN" : "SUFFIX_EQUALS_SIGN"
          }
        }), "JsdocTypeOptional"),
        JsdocTypeNullable: /* @__PURE__ */ __name((result, transform2) => ({
          type: "NULLABLE",
          value: transform2(result.element),
          meta: {
            syntax: result.meta.position === "prefix" ? "PREFIX_QUESTION_MARK" : "SUFFIX_QUESTION_MARK"
          }
        }), "JsdocTypeNullable"),
        JsdocTypeNotNullable: /* @__PURE__ */ __name((result, transform2) => ({
          type: "NOT_NULLABLE",
          value: transform2(result.element),
          meta: {
            syntax: result.meta.position === "prefix" ? "PREFIX_BANG" : "SUFFIX_BANG"
          }
        }), "JsdocTypeNotNullable"),
        JsdocTypeVariadic: /* @__PURE__ */ __name((result, transform2) => {
          const transformed = {
            type: "VARIADIC",
            meta: {
              syntax: result.meta.position === "prefix" ? "PREFIX_DOTS" : result.meta.position === "suffix" ? "SUFFIX_DOTS" : "ONLY_DOTS"
            }
          };
          if (result.element !== void 0) {
            transformed.value = transform2(result.element);
          }
          return transformed;
        }, "JsdocTypeVariadic"),
        JsdocTypeName: /* @__PURE__ */ __name((result) => ({
          type: "NAME",
          name: result.value
        }), "JsdocTypeName"),
        JsdocTypeTypeof: /* @__PURE__ */ __name((result, transform2) => ({
          type: "TYPE_QUERY",
          name: transform2(result.element)
        }), "JsdocTypeTypeof"),
        JsdocTypeTuple: /* @__PURE__ */ __name((result, transform2) => ({
          type: "TUPLE",
          entries: result.elements.map(transform2)
        }), "JsdocTypeTuple"),
        JsdocTypeKeyof: /* @__PURE__ */ __name((result, transform2) => ({
          type: "KEY_QUERY",
          value: transform2(result.element)
        }), "JsdocTypeKeyof"),
        JsdocTypeImport: /* @__PURE__ */ __name((result) => ({
          type: "IMPORT",
          path: {
            type: "STRING_VALUE",
            quoteStyle: getQuoteStyle(result.element.meta.quote),
            string: result.element.value
          }
        }), "JsdocTypeImport"),
        JsdocTypeUndefined: /* @__PURE__ */ __name(() => ({
          type: "NAME",
          name: "undefined"
        }), "JsdocTypeUndefined"),
        JsdocTypeAny: /* @__PURE__ */ __name(() => ({
          type: "ANY"
        }), "JsdocTypeAny"),
        JsdocTypeFunction: /* @__PURE__ */ __name((result, transform2) => {
          const specialParams = extractSpecialParams(result);
          const transformed = {
            type: result.arrow ? "ARROW" : "FUNCTION",
            params: specialParams.params.map((param) => {
              if (param.type === "JsdocTypeKeyValue") {
                if (param.right === void 0) {
                  throw new Error("Function parameter without ':' is not expected to be 'KEY_VALUE'");
                }
                return {
                  type: "NAMED_PARAMETER",
                  name: param.key,
                  typeName: transform2(param.right)
                };
              } else {
                return transform2(param);
              }
            }),
            new: null,
            returns: null
          };
          if (specialParams.this !== void 0) {
            transformed.this = transform2(specialParams.this);
          } else if (!result.arrow) {
            transformed.this = null;
          }
          if (specialParams.new !== void 0) {
            transformed.new = transform2(specialParams.new);
          }
          if (result.returnType !== void 0) {
            transformed.returns = transform2(result.returnType);
          }
          return transformed;
        }, "JsdocTypeFunction"),
        JsdocTypeGeneric: /* @__PURE__ */ __name((result, transform2) => {
          const transformed = {
            type: "GENERIC",
            subject: transform2(result.left),
            objects: result.elements.map(transform2),
            meta: {
              syntax: result.meta.brackets === "square" ? "SQUARE_BRACKET" : result.meta.dot ? "ANGLE_BRACKET_WITH_DOT" : "ANGLE_BRACKET"
            }
          };
          if (result.meta.brackets === "square" && result.elements[0].type === "JsdocTypeFunction" && !result.elements[0].parenthesis) {
            transformed.objects[0] = {
              type: "NAME",
              name: "function"
            };
          }
          return transformed;
        }, "JsdocTypeGeneric"),
        JsdocTypeObjectField: /* @__PURE__ */ __name((result, transform2) => {
          if (typeof result.key !== "string") {
            throw new Error("Index signatures and mapped types are not supported");
          }
          if (result.right === void 0) {
            return {
              type: "RECORD_ENTRY",
              key: result.key,
              quoteStyle: getQuoteStyle(result.meta.quote),
              value: null,
              readonly: false
            };
          }
          let right = transform2(result.right);
          if (result.optional) {
            right = {
              type: "OPTIONAL",
              value: right,
              meta: {
                syntax: "SUFFIX_KEY_QUESTION_MARK"
              }
            };
          }
          return {
            type: "RECORD_ENTRY",
            key: result.key.toString(),
            quoteStyle: getQuoteStyle(result.meta.quote),
            value: right,
            readonly: false
          };
        }, "JsdocTypeObjectField"),
        JsdocTypeJsdocObjectField: /* @__PURE__ */ __name(() => {
          throw new Error("Keys may not be typed in jsdoctypeparser.");
        }, "JsdocTypeJsdocObjectField"),
        JsdocTypeKeyValue: /* @__PURE__ */ __name((result, transform2) => {
          if (result.right === void 0) {
            return {
              type: "RECORD_ENTRY",
              key: result.key,
              quoteStyle: "none",
              value: null,
              readonly: false
            };
          }
          let right = transform2(result.right);
          if (result.optional) {
            right = {
              type: "OPTIONAL",
              value: right,
              meta: {
                syntax: "SUFFIX_KEY_QUESTION_MARK"
              }
            };
          }
          return {
            type: "RECORD_ENTRY",
            key: result.key,
            quoteStyle: "none",
            value: right,
            readonly: false
          };
        }, "JsdocTypeKeyValue"),
        JsdocTypeObject: /* @__PURE__ */ __name((result, transform2) => {
          const entries = [];
          for (const field of result.elements) {
            if (field.type === "JsdocTypeObjectField" || field.type === "JsdocTypeJsdocObjectField") {
              entries.push(transform2(field));
            }
          }
          return {
            type: "RECORD",
            entries
          };
        }, "JsdocTypeObject"),
        JsdocTypeSpecialNamePath: /* @__PURE__ */ __name((result) => {
          if (result.specialType !== "module") {
            throw new Error(`jsdoctypeparser does not support type ${result.specialType} at this point.`);
          }
          return {
            type: "MODULE",
            value: {
              type: "FILE_PATH",
              quoteStyle: getQuoteStyle(result.meta.quote),
              path: result.value
            }
          };
        }, "JsdocTypeSpecialNamePath"),
        JsdocTypeNamePath: /* @__PURE__ */ __name((result, transform2) => {
          let hasEventPrefix = false;
          let name;
          let quoteStyle;
          if (result.right.type === "JsdocTypeSpecialNamePath" && result.right.specialType === "event") {
            hasEventPrefix = true;
            name = result.right.value;
            quoteStyle = getQuoteStyle(result.right.meta.quote);
          } else {
            name = result.right.value;
            quoteStyle = getQuoteStyle(result.right.meta.quote);
          }
          const transformed = {
            type: getMemberType(result.pathType),
            owner: transform2(result.left),
            name,
            quoteStyle,
            hasEventPrefix
          };
          if (transformed.owner.type === "MODULE") {
            const tModule = transformed.owner;
            transformed.owner = transformed.owner.value;
            tModule.value = transformed;
            return tModule;
          } else {
            return transformed;
          }
        }, "JsdocTypeNamePath"),
        JsdocTypeUnion: /* @__PURE__ */ __name((result, transform2) => nestResults("UNION", result.elements.map(transform2)), "JsdocTypeUnion"),
        JsdocTypeParenthesis: /* @__PURE__ */ __name((result, transform2) => ({
          type: "PARENTHESIS",
          value: transform2(assertRootResult(result.element))
        }), "JsdocTypeParenthesis"),
        JsdocTypeNull: /* @__PURE__ */ __name(() => ({
          type: "NAME",
          name: "null"
        }), "JsdocTypeNull"),
        JsdocTypeUnknown: /* @__PURE__ */ __name(() => ({
          type: "UNKNOWN"
        }), "JsdocTypeUnknown"),
        JsdocTypeStringValue: /* @__PURE__ */ __name((result) => ({
          type: "STRING_VALUE",
          quoteStyle: getQuoteStyle(result.meta.quote),
          string: result.value
        }), "JsdocTypeStringValue"),
        JsdocTypeIntersection: /* @__PURE__ */ __name((result, transform2) => nestResults("INTERSECTION", result.elements.map(transform2)), "JsdocTypeIntersection"),
        JsdocTypeNumber: /* @__PURE__ */ __name((result) => ({
          type: "NUMBER_VALUE",
          number: result.value.toString()
        }), "JsdocTypeNumber"),
        JsdocTypeSymbol: notAvailableTransform,
        JsdocTypeProperty: notAvailableTransform,
        JsdocTypePredicate: notAvailableTransform,
        JsdocTypeMappedType: notAvailableTransform,
        JsdocTypeIndexSignature: notAvailableTransform,
        JsdocTypeAsserts: notAvailableTransform,
        JsdocTypeReadonlyArray: notAvailableTransform,
        JsdocTypeAssertsPlain: notAvailableTransform,
        JsdocTypeConditional: notAvailableTransform,
        JsdocTypeTypeParameter: notAvailableTransform
      };
      function jtpTransform(result) {
        return transform(jtpRules, result);
      }
      __name(jtpTransform, "jtpTransform");
      function identityTransformRules() {
        return {
          JsdocTypeIntersection: /* @__PURE__ */ __name((result, transform2) => ({
            type: "JsdocTypeIntersection",
            elements: result.elements.map(transform2)
          }), "JsdocTypeIntersection"),
          JsdocTypeGeneric: /* @__PURE__ */ __name((result, transform2) => ({
            type: "JsdocTypeGeneric",
            left: transform2(result.left),
            elements: result.elements.map(transform2),
            meta: {
              dot: result.meta.dot,
              brackets: result.meta.brackets
            }
          }), "JsdocTypeGeneric"),
          JsdocTypeNullable: /* @__PURE__ */ __name((result) => result, "JsdocTypeNullable"),
          JsdocTypeUnion: /* @__PURE__ */ __name((result, transform2) => ({
            type: "JsdocTypeUnion",
            elements: result.elements.map(transform2)
          }), "JsdocTypeUnion"),
          JsdocTypeUnknown: /* @__PURE__ */ __name((result) => result, "JsdocTypeUnknown"),
          JsdocTypeUndefined: /* @__PURE__ */ __name((result) => result, "JsdocTypeUndefined"),
          JsdocTypeTypeof: /* @__PURE__ */ __name((result, transform2) => ({
            type: "JsdocTypeTypeof",
            element: transform2(result.element)
          }), "JsdocTypeTypeof"),
          JsdocTypeSymbol: /* @__PURE__ */ __name((result, transform2) => {
            const transformed = {
              type: "JsdocTypeSymbol",
              value: result.value
            };
            if (result.element !== void 0) {
              transformed.element = transform2(result.element);
            }
            return transformed;
          }, "JsdocTypeSymbol"),
          JsdocTypeOptional: /* @__PURE__ */ __name((result, transform2) => ({
            type: "JsdocTypeOptional",
            element: transform2(result.element),
            meta: {
              position: result.meta.position
            }
          }), "JsdocTypeOptional"),
          JsdocTypeObject: /* @__PURE__ */ __name((result, transform2) => ({
            type: "JsdocTypeObject",
            meta: {
              separator: "comma"
            },
            elements: result.elements.map(transform2)
          }), "JsdocTypeObject"),
          JsdocTypeNumber: /* @__PURE__ */ __name((result) => result, "JsdocTypeNumber"),
          JsdocTypeNull: /* @__PURE__ */ __name((result) => result, "JsdocTypeNull"),
          JsdocTypeNotNullable: /* @__PURE__ */ __name((result, transform2) => ({
            type: "JsdocTypeNotNullable",
            element: transform2(result.element),
            meta: {
              position: result.meta.position
            }
          }), "JsdocTypeNotNullable"),
          JsdocTypeSpecialNamePath: /* @__PURE__ */ __name((result) => result, "JsdocTypeSpecialNamePath"),
          JsdocTypeObjectField: /* @__PURE__ */ __name((result, transform2) => ({
            type: "JsdocTypeObjectField",
            key: result.key,
            right: result.right === void 0 ? void 0 : transform2(result.right),
            optional: result.optional,
            readonly: result.readonly,
            meta: result.meta
          }), "JsdocTypeObjectField"),
          JsdocTypeJsdocObjectField: /* @__PURE__ */ __name((result, transform2) => ({
            type: "JsdocTypeJsdocObjectField",
            left: transform2(result.left),
            right: transform2(result.right)
          }), "JsdocTypeJsdocObjectField"),
          JsdocTypeKeyValue: /* @__PURE__ */ __name((result, transform2) => {
            return {
              type: "JsdocTypeKeyValue",
              key: result.key,
              right: result.right === void 0 ? void 0 : transform2(result.right),
              optional: result.optional,
              variadic: result.variadic
            };
          }, "JsdocTypeKeyValue"),
          JsdocTypeImport: /* @__PURE__ */ __name((result, transform2) => ({
            type: "JsdocTypeImport",
            element: transform2(result.element)
          }), "JsdocTypeImport"),
          JsdocTypeAny: /* @__PURE__ */ __name((result) => result, "JsdocTypeAny"),
          JsdocTypeStringValue: /* @__PURE__ */ __name((result) => result, "JsdocTypeStringValue"),
          JsdocTypeNamePath: /* @__PURE__ */ __name((result) => result, "JsdocTypeNamePath"),
          JsdocTypeVariadic: /* @__PURE__ */ __name((result, transform2) => {
            const transformed = {
              type: "JsdocTypeVariadic",
              meta: {
                position: result.meta.position,
                squareBrackets: result.meta.squareBrackets
              }
            };
            if (result.element !== void 0) {
              transformed.element = transform2(result.element);
            }
            return transformed;
          }, "JsdocTypeVariadic"),
          JsdocTypeTuple: /* @__PURE__ */ __name((result, transform2) => ({
            type: "JsdocTypeTuple",
            elements: result.elements.map(transform2)
          }), "JsdocTypeTuple"),
          JsdocTypeName: /* @__PURE__ */ __name((result) => result, "JsdocTypeName"),
          JsdocTypeFunction: /* @__PURE__ */ __name((result, transform2) => {
            const transformed = {
              type: "JsdocTypeFunction",
              arrow: result.arrow,
              parameters: result.parameters.map(transform2),
              constructor: result.constructor,
              parenthesis: result.parenthesis
            };
            if (result.returnType !== void 0) {
              transformed.returnType = transform2(result.returnType);
            }
            return transformed;
          }, "JsdocTypeFunction"),
          JsdocTypeKeyof: /* @__PURE__ */ __name((result, transform2) => ({
            type: "JsdocTypeKeyof",
            element: transform2(result.element)
          }), "JsdocTypeKeyof"),
          JsdocTypeParenthesis: /* @__PURE__ */ __name((result, transform2) => ({
            type: "JsdocTypeParenthesis",
            element: transform2(result.element)
          }), "JsdocTypeParenthesis"),
          JsdocTypeProperty: /* @__PURE__ */ __name((result) => result, "JsdocTypeProperty"),
          JsdocTypePredicate: /* @__PURE__ */ __name((result, transform2) => ({
            type: "JsdocTypePredicate",
            left: transform2(result.left),
            right: transform2(result.right)
          }), "JsdocTypePredicate"),
          JsdocTypeIndexSignature: /* @__PURE__ */ __name((result, transform2) => ({
            type: "JsdocTypeIndexSignature",
            key: result.key,
            right: transform2(result.right)
          }), "JsdocTypeIndexSignature"),
          JsdocTypeMappedType: /* @__PURE__ */ __name((result, transform2) => ({
            type: "JsdocTypeMappedType",
            key: result.key,
            right: transform2(result.right)
          }), "JsdocTypeMappedType"),
          JsdocTypeAsserts: /* @__PURE__ */ __name((result, transform2) => ({
            type: "JsdocTypeAsserts",
            left: transform2(result.left),
            right: transform2(result.right)
          }), "JsdocTypeAsserts"),
          JsdocTypeReadonlyArray: /* @__PURE__ */ __name((result, transform2) => ({
            type: "JsdocTypeReadonlyArray",
            element: transform2(result.element)
          }), "JsdocTypeReadonlyArray"),
          JsdocTypeAssertsPlain: /* @__PURE__ */ __name((result, transform2) => ({
            type: "JsdocTypeAssertsPlain",
            element: transform2(result.element)
          }), "JsdocTypeAssertsPlain"),
          JsdocTypeConditional: /* @__PURE__ */ __name((result, transform2) => ({
            type: "JsdocTypeConditional",
            checksType: transform2(result.checksType),
            extendsType: transform2(result.extendsType),
            trueType: transform2(result.trueType),
            falseType: transform2(result.falseType)
          }), "JsdocTypeConditional"),
          JsdocTypeTypeParameter: /* @__PURE__ */ __name((result, transform2) => ({
            type: "JsdocTypeTypeParameter",
            name: transform2(result.name),
            constraint: result.constraint !== void 0 ? transform2(result.constraint) : void 0,
            defaultValue: result.defaultValue !== void 0 ? transform2(result.defaultValue) : void 0
          }), "JsdocTypeTypeParameter")
        };
      }
      __name(identityTransformRules, "identityTransformRules");
      const visitorKeys = {
        JsdocTypeAny: [],
        JsdocTypeFunction: ["parameters", "returnType"],
        JsdocTypeGeneric: ["left", "elements"],
        JsdocTypeImport: [],
        JsdocTypeIndexSignature: ["right"],
        JsdocTypeIntersection: ["elements"],
        JsdocTypeKeyof: ["element"],
        JsdocTypeKeyValue: ["right"],
        JsdocTypeMappedType: ["right"],
        JsdocTypeName: [],
        JsdocTypeNamePath: ["left", "right"],
        JsdocTypeNotNullable: ["element"],
        JsdocTypeNull: [],
        JsdocTypeNullable: ["element"],
        JsdocTypeNumber: [],
        JsdocTypeObject: ["elements"],
        JsdocTypeObjectField: ["right"],
        JsdocTypeJsdocObjectField: ["left", "right"],
        JsdocTypeOptional: ["element"],
        JsdocTypeParenthesis: ["element"],
        JsdocTypeSpecialNamePath: [],
        JsdocTypeStringValue: [],
        JsdocTypeSymbol: ["element"],
        JsdocTypeTuple: ["elements"],
        JsdocTypeTypeof: ["element"],
        JsdocTypeUndefined: [],
        JsdocTypeUnion: ["elements"],
        JsdocTypeUnknown: [],
        JsdocTypeVariadic: ["element"],
        JsdocTypeProperty: [],
        JsdocTypePredicate: ["left", "right"],
        JsdocTypeAsserts: ["left", "right"],
        JsdocTypeReadonlyArray: ["element"],
        JsdocTypeAssertsPlain: ["element"],
        JsdocTypeConditional: ["checksType", "extendsType", "trueType", "falseType"],
        JsdocTypeTypeParameter: ["name", "constraint", "defaultValue"]
      };
      function _traverse(node, parentNode, property, onEnter, onLeave) {
        onEnter === null || onEnter === void 0 ? void 0 : onEnter(node, parentNode, property);
        const keysToVisit = visitorKeys[node.type];
        for (const key of keysToVisit) {
          const value = node[key];
          if (value !== void 0) {
            if (Array.isArray(value)) {
              for (const element of value) {
                _traverse(element, node, key, onEnter, onLeave);
              }
            } else {
              _traverse(value, node, key, onEnter, onLeave);
            }
          }
        }
        onLeave === null || onLeave === void 0 ? void 0 : onLeave(node, parentNode, property);
      }
      __name(_traverse, "_traverse");
      function traverse(node, onEnter, onLeave) {
        _traverse(node, void 0, void 0, onEnter, onLeave);
      }
      __name(traverse, "traverse");
      exports2.catharsisTransform = catharsisTransform;
      exports2.identityTransformRules = identityTransformRules;
      exports2.jtpTransform = jtpTransform;
      exports2.parse = parse6;
      exports2.stringify = stringify5;
      exports2.stringifyRules = stringifyRules2;
      exports2.transform = transform;
      exports2.traverse = traverse;
      exports2.tryParse = tryParse;
      exports2.visitorKeys = visitorKeys;
    });
  }
});

// ../node_modules/browser-dtector/browser-dtector.umd.min.js
var require_browser_dtector_umd_min = __commonJS({
  "../node_modules/browser-dtector/browser-dtector.umd.min.js"(exports, module2) {
    !function(e2, o2) {
      "object" == typeof exports && "undefined" != typeof module2 ? module2.exports = o2() : "function" == typeof define && define.amd ? define(o2) : (e2 = "undefined" != typeof globalThis ? globalThis : e2 || self).BrowserDetector = o2();
    }(exports, function() {
      "use strict";
      function e2(e3, o3) {
        for (var r3 = 0; r3 < o3.length; r3++) {
          var n3 = o3[r3];
          n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e3, (i3 = n3.key, t3 = void 0, "symbol" == typeof (t3 = function(e4, o4) {
            if ("object" != typeof e4 || null === e4) return e4;
            var r4 = e4[Symbol.toPrimitive];
            if (void 0 !== r4) {
              var n4 = r4.call(e4, o4 || "default");
              if ("object" != typeof n4) return n4;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === o4 ? String : Number)(e4);
          }(i3, "string")) ? t3 : String(t3)), n3);
        }
        var i3, t3;
      }
      __name(e2, "e");
      var o2 = { chrome: "Google Chrome", brave: "Brave", crios: "Google Chrome", edge: "Microsoft Edge", edg: "Microsoft Edge", edgios: "Microsoft Edge", fennec: "Mozilla Firefox", jsdom: "JsDOM", mozilla: "Mozilla Firefox", fxios: "Mozilla Firefox", msie: "Microsoft Internet Explorer", opera: "Opera", opios: "Opera", opr: "Opera", opt: "Opera", rv: "Microsoft Internet Explorer", safari: "Safari", samsungbrowser: "Samsung Browser", electron: "Electron" }, r2 = { android: "Android", androidTablet: "Android Tablet", cros: "Chrome OS", fennec: "Android Tablet", ipad: "IPad", iphone: "IPhone", jsdom: "JsDOM", linux: "Linux", mac: "Macintosh", tablet: "Android Tablet", win: "Windows", "windows phone": "Windows Phone", xbox: "Microsoft Xbox" }, n2 = /* @__PURE__ */ __name(function(e3) {
        var o3 = new RegExp("^-?\\d+(?:.\\d{0,".concat(arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : -1, "})?")), r3 = Number(e3).toString().match(o3);
        return r3 ? r3[0] : null;
      }, "n"), i2 = /* @__PURE__ */ __name(function() {
        return "undefined" != typeof window ? window.navigator : null;
      }, "i"), t2 = function() {
        function t3(e3) {
          var o3;
          !function(e4, o4) {
            if (!(e4 instanceof o4)) throw new TypeError("Cannot call a class as a function");
          }(this, t3), this.userAgent = e3 || (null === (o3 = i2()) || void 0 === o3 ? void 0 : o3.userAgent) || null;
        }
        __name(t3, "t");
        var a2, l2, s3;
        return a2 = t3, l2 = [{ key: "parseUserAgent", value: /* @__PURE__ */ __name(function(e3) {
          var t4, a3, l3, s4 = {}, c2 = e3 || this.userAgent || "", d = c2.toLowerCase().replace(/\s\s+/g, " "), u3 = /(edge)\/([\w.]+)/.exec(d) || /(edg)[/]([\w.]+)/.exec(d) || /(opr)[/]([\w.]+)/.exec(d) || /(opt)[/]([\w.]+)/.exec(d) || /(fxios)[/]([\w.]+)/.exec(d) || /(edgios)[/]([\w.]+)/.exec(d) || /(jsdom)[/]([\w.]+)/.exec(d) || /(samsungbrowser)[/]([\w.]+)/.exec(d) || /(electron)[/]([\w.]+)/.exec(d) || /(chrome)[/]([\w.]+)/.exec(d) || /(crios)[/]([\w.]+)/.exec(d) || /(opios)[/]([\w.]+)/.exec(d) || /(version)(applewebkit)[/]([\w.]+).*(safari)[/]([\w.]+)/.exec(d) || /(webkit)[/]([\w.]+).*(version)[/]([\w.]+).*(safari)[/]([\w.]+)/.exec(d) || /(applewebkit)[/]([\w.]+).*(safari)[/]([\w.]+)/.exec(d) || /(webkit)[/]([\w.]+)/.exec(d) || /(opera)(?:.*version|)[/]([\w.]+)/.exec(d) || /(msie) ([\w.]+)/.exec(d) || /(fennec)[/]([\w.]+)/.exec(d) || d.indexOf("trident") >= 0 && /(rv)(?::| )([\w.]+)/.exec(d) || d.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(d) || [], f4 = /(ipad)/.exec(d) || /(ipod)/.exec(d) || /(iphone)/.exec(d) || /(jsdom)/.exec(d) || /(windows phone)/.exec(d) || /(xbox)/.exec(d) || /(win)/.exec(d) || /(tablet)/.exec(d) || /(android)/.test(d) && false === /(mobile)/.test(d) && ["androidTablet"] || /(android)/.exec(d) || /(mac)/.exec(d) || /(linux)/.exec(d) || /(cros)/.exec(d) || [], p2 = u3[5] || u3[3] || u3[1] || null, w2 = f4[0] || null, x2 = u3[4] || u3[2] || null, b2 = i2();
          "chrome" === p2 && "function" == typeof (null == b2 || null === (t4 = b2.brave) || void 0 === t4 ? void 0 : t4.isBrave) && (p2 = "brave"), p2 && (s4[p2] = true), w2 && (s4[w2] = true);
          var v2 = Boolean(s4.tablet || s4.android || s4.androidTablet), m3 = Boolean(s4.ipad || s4.tablet || s4.androidTablet), g2 = Boolean(s4.android || s4.androidTablet || s4.tablet || s4.ipad || s4.ipod || s4.iphone || s4["windows phone"]), h3 = Boolean(s4.cros || s4.mac || s4.linux || s4.win), y2 = Boolean(s4.brave || s4.chrome || s4.crios || s4.opr || s4.safari || s4.edg || s4.electron), A = Boolean(s4.msie || s4.rv);
          return { name: null !== (a3 = o2[p2]) && void 0 !== a3 ? a3 : null, platform: null !== (l3 = r2[w2]) && void 0 !== l3 ? l3 : null, userAgent: c2, version: x2, shortVersion: x2 ? n2(parseFloat(x2), 2) : null, isAndroid: v2, isTablet: m3, isMobile: g2, isDesktop: h3, isWebkit: y2, isIE: A };
        }, "value") }, { key: "getBrowserInfo", value: /* @__PURE__ */ __name(function() {
          var e3 = this.parseUserAgent();
          return { name: e3.name, platform: e3.platform, userAgent: e3.userAgent, version: e3.version, shortVersion: e3.shortVersion };
        }, "value") }], s3 = [{ key: "VERSION", get: /* @__PURE__ */ __name(function() {
          return "3.4.0";
        }, "get") }], l2 && e2(a2.prototype, l2), s3 && e2(a2, s3), Object.defineProperty(a2, "prototype", { writable: false }), t3;
      }();
      return t2;
    });
  }
});

// src/core-events/index.ts
var core_events_exports = {};
__export(core_events_exports, {
  ARGTYPES_INFO_REQUEST: () => ARGTYPES_INFO_REQUEST,
  ARGTYPES_INFO_RESPONSE: () => ARGTYPES_INFO_RESPONSE,
  CHANNEL_CREATED: () => CHANNEL_CREATED,
  CHANNEL_WS_DISCONNECT: () => CHANNEL_WS_DISCONNECT,
  CONFIG_ERROR: () => CONFIG_ERROR,
  CREATE_NEW_STORYFILE_REQUEST: () => CREATE_NEW_STORYFILE_REQUEST,
  CREATE_NEW_STORYFILE_RESPONSE: () => CREATE_NEW_STORYFILE_RESPONSE,
  CURRENT_STORY_WAS_SET: () => CURRENT_STORY_WAS_SET,
  DOCS_PREPARED: () => DOCS_PREPARED,
  DOCS_RENDERED: () => DOCS_RENDERED,
  FILE_COMPONENT_SEARCH_REQUEST: () => FILE_COMPONENT_SEARCH_REQUEST,
  FILE_COMPONENT_SEARCH_RESPONSE: () => FILE_COMPONENT_SEARCH_RESPONSE,
  FORCE_REMOUNT: () => FORCE_REMOUNT,
  FORCE_RE_RENDER: () => FORCE_RE_RENDER,
  GLOBALS_UPDATED: () => GLOBALS_UPDATED,
  NAVIGATE_URL: () => NAVIGATE_URL,
  OPEN_IN_EDITOR_REQUEST: () => OPEN_IN_EDITOR_REQUEST,
  OPEN_IN_EDITOR_RESPONSE: () => OPEN_IN_EDITOR_RESPONSE,
  PLAY_FUNCTION_THREW_EXCEPTION: () => PLAY_FUNCTION_THREW_EXCEPTION,
  PRELOAD_ENTRIES: () => PRELOAD_ENTRIES,
  PREVIEW_BUILDER_PROGRESS: () => PREVIEW_BUILDER_PROGRESS,
  PREVIEW_INITIALIZED: () => PREVIEW_INITIALIZED,
  PREVIEW_KEYDOWN: () => PREVIEW_KEYDOWN,
  REGISTER_SUBSCRIPTION: () => REGISTER_SUBSCRIPTION,
  REQUEST_WHATS_NEW_DATA: () => REQUEST_WHATS_NEW_DATA,
  RESET_STORY_ARGS: () => RESET_STORY_ARGS,
  RESULT_WHATS_NEW_DATA: () => RESULT_WHATS_NEW_DATA,
  SAVE_STORY_REQUEST: () => SAVE_STORY_REQUEST,
  SAVE_STORY_RESPONSE: () => SAVE_STORY_RESPONSE,
  SELECT_STORY: () => SELECT_STORY,
  SET_CONFIG: () => SET_CONFIG,
  SET_CURRENT_STORY: () => SET_CURRENT_STORY,
  SET_FILTER: () => SET_FILTER,
  SET_GLOBALS: () => SET_GLOBALS,
  SET_INDEX: () => SET_INDEX,
  SET_STORIES: () => SET_STORIES,
  SET_WHATS_NEW_CACHE: () => SET_WHATS_NEW_CACHE,
  SHARED_STATE_CHANGED: () => SHARED_STATE_CHANGED,
  SHARED_STATE_SET: () => SHARED_STATE_SET,
  STORIES_COLLAPSE_ALL: () => STORIES_COLLAPSE_ALL,
  STORIES_EXPAND_ALL: () => STORIES_EXPAND_ALL,
  STORY_ARGS_UPDATED: () => STORY_ARGS_UPDATED,
  STORY_CHANGED: () => STORY_CHANGED,
  STORY_ERRORED: () => STORY_ERRORED,
  STORY_FINISHED: () => STORY_FINISHED,
  STORY_HOT_UPDATED: () => STORY_HOT_UPDATED,
  STORY_INDEX_INVALIDATED: () => STORY_INDEX_INVALIDATED,
  STORY_MISSING: () => STORY_MISSING,
  STORY_PREPARED: () => STORY_PREPARED,
  STORY_RENDERED: () => STORY_RENDERED,
  STORY_RENDER_PHASE_CHANGED: () => STORY_RENDER_PHASE_CHANGED,
  STORY_SPECIFIED: () => STORY_SPECIFIED,
  STORY_THREW_EXCEPTION: () => STORY_THREW_EXCEPTION,
  STORY_UNCHANGED: () => STORY_UNCHANGED,
  TELEMETRY_ERROR: () => TELEMETRY_ERROR,
  TOGGLE_WHATS_NEW_NOTIFICATIONS: () => TOGGLE_WHATS_NEW_NOTIFICATIONS,
  UNHANDLED_ERRORS_WHILE_PLAYING: () => UNHANDLED_ERRORS_WHILE_PLAYING,
  UPDATE_GLOBALS: () => UPDATE_GLOBALS,
  UPDATE_QUERY_PARAMS: () => UPDATE_QUERY_PARAMS,
  UPDATE_STORY_ARGS: () => UPDATE_STORY_ARGS,
  default: () => core_events_default
});
var events = /* @__PURE__ */ ((events2) => {
  events2["CHANNEL_WS_DISCONNECT"] = "channelWSDisconnect";
  events2["CHANNEL_CREATED"] = "channelCreated";
  events2["CONFIG_ERROR"] = "configError";
  events2["STORY_INDEX_INVALIDATED"] = "storyIndexInvalidated";
  events2["STORY_SPECIFIED"] = "storySpecified";
  events2["SET_CONFIG"] = "setConfig";
  events2["SET_STORIES"] = "setStories";
  events2["SET_INDEX"] = "setIndex";
  events2["SET_CURRENT_STORY"] = "setCurrentStory";
  events2["CURRENT_STORY_WAS_SET"] = "currentStoryWasSet";
  events2["FORCE_RE_RENDER"] = "forceReRender";
  events2["FORCE_REMOUNT"] = "forceRemount";
  events2["PRELOAD_ENTRIES"] = "preloadStories";
  events2["STORY_PREPARED"] = "storyPrepared";
  events2["DOCS_PREPARED"] = "docsPrepared";
  events2["STORY_CHANGED"] = "storyChanged";
  events2["STORY_UNCHANGED"] = "storyUnchanged";
  events2["STORY_RENDERED"] = "storyRendered";
  events2["STORY_FINISHED"] = "storyFinished";
  events2["STORY_MISSING"] = "storyMissing";
  events2["STORY_ERRORED"] = "storyErrored";
  events2["STORY_THREW_EXCEPTION"] = "storyThrewException";
  events2["STORY_RENDER_PHASE_CHANGED"] = "storyRenderPhaseChanged";
  events2["STORY_HOT_UPDATED"] = "storyHotUpdated";
  events2["PLAY_FUNCTION_THREW_EXCEPTION"] = "playFunctionThrewException";
  events2["UNHANDLED_ERRORS_WHILE_PLAYING"] = "unhandledErrorsWhilePlaying";
  events2["UPDATE_STORY_ARGS"] = "updateStoryArgs";
  events2["STORY_ARGS_UPDATED"] = "storyArgsUpdated";
  events2["RESET_STORY_ARGS"] = "resetStoryArgs";
  events2["SET_FILTER"] = "setFilter";
  events2["SET_GLOBALS"] = "setGlobals";
  events2["UPDATE_GLOBALS"] = "updateGlobals";
  events2["GLOBALS_UPDATED"] = "globalsUpdated";
  events2["REGISTER_SUBSCRIPTION"] = "registerSubscription";
  events2["PREVIEW_INITIALIZED"] = "previewInitialized";
  events2["PREVIEW_KEYDOWN"] = "previewKeydown";
  events2["PREVIEW_BUILDER_PROGRESS"] = "preview_builder_progress";
  events2["SELECT_STORY"] = "selectStory";
  events2["STORIES_COLLAPSE_ALL"] = "storiesCollapseAll";
  events2["STORIES_EXPAND_ALL"] = "storiesExpandAll";
  events2["DOCS_RENDERED"] = "docsRendered";
  events2["SHARED_STATE_CHANGED"] = "sharedStateChanged";
  events2["SHARED_STATE_SET"] = "sharedStateSet";
  events2["NAVIGATE_URL"] = "navigateUrl";
  events2["UPDATE_QUERY_PARAMS"] = "updateQueryParams";
  events2["REQUEST_WHATS_NEW_DATA"] = "requestWhatsNewData";
  events2["RESULT_WHATS_NEW_DATA"] = "resultWhatsNewData";
  events2["SET_WHATS_NEW_CACHE"] = "setWhatsNewCache";
  events2["TOGGLE_WHATS_NEW_NOTIFICATIONS"] = "toggleWhatsNewNotifications";
  events2["TELEMETRY_ERROR"] = "telemetryError";
  events2["FILE_COMPONENT_SEARCH_REQUEST"] = "fileComponentSearchRequest";
  events2["FILE_COMPONENT_SEARCH_RESPONSE"] = "fileComponentSearchResponse";
  events2["SAVE_STORY_REQUEST"] = "saveStoryRequest";
  events2["SAVE_STORY_RESPONSE"] = "saveStoryResponse";
  events2["ARGTYPES_INFO_REQUEST"] = "argtypesInfoRequest";
  events2["ARGTYPES_INFO_RESPONSE"] = "argtypesInfoResponse";
  events2["CREATE_NEW_STORYFILE_REQUEST"] = "createNewStoryfileRequest";
  events2["CREATE_NEW_STORYFILE_RESPONSE"] = "createNewStoryfileResponse";
  events2["OPEN_IN_EDITOR_REQUEST"] = "openInEditorRequest";
  events2["OPEN_IN_EDITOR_RESPONSE"] = "openInEditorResponse";
  return events2;
})(events || {});
var core_events_default = events;
var {
  CHANNEL_WS_DISCONNECT,
  CHANNEL_CREATED,
  CONFIG_ERROR,
  CREATE_NEW_STORYFILE_REQUEST,
  CREATE_NEW_STORYFILE_RESPONSE,
  CURRENT_STORY_WAS_SET,
  DOCS_PREPARED,
  DOCS_RENDERED,
  FILE_COMPONENT_SEARCH_REQUEST,
  FILE_COMPONENT_SEARCH_RESPONSE,
  FORCE_RE_RENDER,
  FORCE_REMOUNT,
  GLOBALS_UPDATED,
  NAVIGATE_URL,
  PLAY_FUNCTION_THREW_EXCEPTION,
  UNHANDLED_ERRORS_WHILE_PLAYING,
  PRELOAD_ENTRIES,
  PREVIEW_INITIALIZED,
  PREVIEW_BUILDER_PROGRESS,
  PREVIEW_KEYDOWN,
  REGISTER_SUBSCRIPTION,
  RESET_STORY_ARGS,
  SELECT_STORY,
  SET_CONFIG,
  SET_CURRENT_STORY,
  SET_FILTER,
  SET_GLOBALS,
  SET_INDEX,
  SET_STORIES,
  SHARED_STATE_CHANGED,
  SHARED_STATE_SET,
  STORIES_COLLAPSE_ALL,
  STORIES_EXPAND_ALL,
  STORY_ARGS_UPDATED,
  STORY_CHANGED,
  STORY_ERRORED,
  STORY_INDEX_INVALIDATED,
  STORY_MISSING,
  STORY_PREPARED,
  STORY_RENDER_PHASE_CHANGED,
  STORY_RENDERED,
  STORY_FINISHED,
  STORY_SPECIFIED,
  STORY_THREW_EXCEPTION,
  STORY_UNCHANGED,
  STORY_HOT_UPDATED,
  UPDATE_GLOBALS,
  UPDATE_QUERY_PARAMS,
  UPDATE_STORY_ARGS,
  REQUEST_WHATS_NEW_DATA,
  RESULT_WHATS_NEW_DATA,
  SET_WHATS_NEW_CACHE,
  TOGGLE_WHATS_NEW_NOTIFICATIONS,
  TELEMETRY_ERROR,
  SAVE_STORY_REQUEST,
  SAVE_STORY_RESPONSE,
  ARGTYPES_INFO_REQUEST,
  ARGTYPES_INFO_RESPONSE,
  OPEN_IN_EDITOR_REQUEST,
  OPEN_IN_EDITOR_RESPONSE
} = events;

// ../node_modules/@storybook/global/dist/index.mjs
var dist_exports = {};
__export(dist_exports, {
  global: () => scope
});
var scope = (() => {
  let win;
  if (typeof window !== "undefined") {
    win = window;
  } else if (typeof globalThis !== "undefined") {
    win = globalThis;
  } else if (typeof global !== "undefined") {
    win = global;
  } else if (typeof self !== "undefined") {
    win = self;
  } else {
    win = {};
  }
  return win;
})();

// src/preview/globals/globals.ts
var globalsNameReferenceMap = {
  "@storybook/global": "__STORYBOOK_MODULE_GLOBAL__",
  "storybook/test": "__STORYBOOK_MODULE_TEST__",
  "storybook/actions": "__STORYBOOK_MODULE_ACTIONS__",
  "storybook/preview-api": "__STORYBOOK_MODULE_PREVIEW_API__",
  "storybook/internal/channels": "__STORYBOOK_MODULE_CHANNELS__",
  "storybook/internal/client-logger": "__STORYBOOK_MODULE_CLIENT_LOGGER__",
  "storybook/internal/core-events": "__STORYBOOK_MODULE_CORE_EVENTS__",
  "storybook/internal/preview-errors": "__STORYBOOK_MODULE_CORE_EVENTS_PREVIEW_ERRORS__",
  "storybook/internal/types": "__STORYBOOK_MODULE_TYPES__",
  // @deprecated TODO: Remove in 9.1 or some point in the future, I guess
  "storybook/internal/preview-api": "__STORYBOOK_MODULE_PREVIEW_API__"
};
var globalPackages = Object.keys(globalsNameReferenceMap);

// src/channels/index.ts
var channels_exports = {};
__export(channels_exports, {
  Channel: () => Channel,
  HEARTBEAT_INTERVAL: () => HEARTBEAT_INTERVAL,
  HEARTBEAT_MAX_LATENCY: () => HEARTBEAT_MAX_LATENCY,
  PostMessageTransport: () => PostMessageTransport,
  WebsocketTransport: () => WebsocketTransport,
  createBrowserChannel: () => createBrowserChannel,
  default: () => channels_default
});

// ../node_modules/ts-dedent/esm/index.js
function dedent(templ) {
  var values = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    values[_i - 1] = arguments[_i];
  }
  var strings = Array.from(typeof templ === "string" ? [templ] : templ);
  strings[strings.length - 1] = strings[strings.length - 1].replace(/\r?\n([\t ]*)$/, "");
  var indentLengths = strings.reduce(function(arr, str2) {
    var matches5 = str2.match(/\n([\t ]+|(?!\s).)/g);
    if (matches5) {
      return arr.concat(matches5.map(function(match) {
        var _a3, _b;
        return (_b = (_a3 = match.match(/[\t ]/g)) === null || _a3 === void 0 ? void 0 : _a3.length) !== null && _b !== void 0 ? _b : 0;
      }));
    }
    return arr;
  }, []);
  if (indentLengths.length) {
    var pattern_1 = new RegExp("\n[	 ]{" + Math.min.apply(Math, indentLengths) + "}", "g");
    strings = strings.map(function(str2) {
      return str2.replace(pattern_1, "\n");
    });
  }
  strings[0] = strings[0].replace(/^\r?\n/, "");
  var string = strings[0];
  values.forEach(function(value, i2) {
    var endentations = string.match(/(?:^|\n)( *)$/);
    var endentation = endentations ? endentations[1] : "";
    var indentedValue = value;
    if (typeof value === "string" && value.includes("\n")) {
      indentedValue = String(value).split("\n").map(function(str2, i3) {
        return i3 === 0 ? str2 : "" + endentation + str2;
      }).join("\n");
    }
    string += indentedValue + strings[i2 + 1];
  });
  return string;
}
__name(dedent, "dedent");

// src/shared/universal-store/instances.ts
var instances = /* @__PURE__ */ new Map();

// src/shared/universal-store/index.ts
var CHANNEL_EVENT_PREFIX = "UNIVERSAL_STORE:";
var ProgressState = {
  PENDING: "PENDING",
  RESOLVED: "RESOLVED",
  REJECTED: "REJECTED"
};
var _UniversalStore = class _UniversalStore {
  constructor(options, environmentOverrides) {
    /** Enable debug logs for this store */
    this.debugging = false;
    // TODO: narrow type of listeners based on event type
    this.listeners = /* @__PURE__ */ new Map([["*", /* @__PURE__ */ new Set()]]);
    /** Gets the current state */
    this.getState = /* @__PURE__ */ __name(() => {
      this.debug("getState", { state: this.state });
      return this.state;
    }, "getState");
    /**
     * Subscribes to store events
     *
     * @returns A function to unsubscribe
     */
    this.subscribe = /* @__PURE__ */ __name((eventTypeOrListener, maybeListener) => {
      const subscribesToAllEvents = typeof eventTypeOrListener === "function";
      const eventType = subscribesToAllEvents ? "*" : eventTypeOrListener;
      const listener = subscribesToAllEvents ? eventTypeOrListener : maybeListener;
      this.debug("subscribe", { eventType, listener });
      if (!listener) {
        throw new TypeError(
          `Missing first subscribe argument, or second if first is the event type, when subscribing to a UniversalStore with id '${this.id}'`
        );
      }
      if (!this.listeners.has(eventType)) {
        this.listeners.set(eventType, /* @__PURE__ */ new Set());
      }
      this.listeners.get(eventType).add(listener);
      return () => {
        this.debug("unsubscribe", { eventType, listener });
        if (!this.listeners.has(eventType)) {
          return;
        }
        this.listeners.get(eventType).delete(listener);
        if (this.listeners.get(eventType)?.size === 0) {
          this.listeners.delete(eventType);
        }
      };
    }, "subscribe");
    /** Sends a custom event to the other stores */
    this.send = /* @__PURE__ */ __name((event) => {
      this.debug("send", { event });
      if (this.status !== _UniversalStore.Status.READY) {
        throw new TypeError(
          dedent`Cannot send event before store is ready. You can get the current status with store.status,
        or await store.readyPromise to wait for the store to be ready before sending events.
        ${JSON.stringify(
            {
              event,
              id: this.id,
              actor: this.actor,
              environment: this.environment
            },
            null,
            2
          )}`
        );
      }
      this.emitToListeners(event, { actor: this.actor });
      this.emitToChannel(event, { actor: this.actor });
    }, "send");
    this.debugging = options.debug ?? false;
    if (!_UniversalStore.isInternalConstructing) {
      throw new TypeError(
        "UniversalStore is not constructable - use UniversalStore.create() instead"
      );
    }
    _UniversalStore.isInternalConstructing = false;
    this.id = options.id;
    this.actorId = Date.now().toString(36) + Math.random().toString(36).substring(2);
    this.actorType = options.leader ? _UniversalStore.ActorType.LEADER : _UniversalStore.ActorType.FOLLOWER;
    this.state = options.initialState;
    this.channelEventName = `${CHANNEL_EVENT_PREFIX}${this.id}`;
    this.debug("constructor", {
      options,
      environmentOverrides,
      channelEventName: this.channelEventName
    });
    if (this.actor.type === _UniversalStore.ActorType.LEADER) {
      this.syncing = {
        state: ProgressState.RESOLVED,
        promise: Promise.resolve()
      };
    } else {
      let syncingResolve;
      let syncingReject;
      const syncingPromise = new Promise((resolve, reject) => {
        syncingResolve = /* @__PURE__ */ __name(() => {
          if (this.syncing.state !== ProgressState.PENDING) {
            return;
          }
          this.syncing.state = ProgressState.RESOLVED;
          resolve();
        }, "syncingResolve");
        syncingReject = /* @__PURE__ */ __name((reason) => {
          if (this.syncing.state !== ProgressState.PENDING) {
            return;
          }
          this.syncing.state = ProgressState.REJECTED;
          reject(reason);
        }, "syncingReject");
      });
      this.syncing = {
        state: ProgressState.PENDING,
        promise: syncingPromise,
        resolve: syncingResolve,
        reject: syncingReject
      };
    }
    this.getState = this.getState.bind(this);
    this.setState = this.setState.bind(this);
    this.subscribe = this.subscribe.bind(this);
    this.onStateChange = this.onStateChange.bind(this);
    this.send = this.send.bind(this);
    this.emitToChannel = this.emitToChannel.bind(this);
    this.prepareThis = this.prepareThis.bind(this);
    this.emitToListeners = this.emitToListeners.bind(this);
    this.handleChannelEvents = this.handleChannelEvents.bind(this);
    this.debug = this.debug.bind(this);
    this.channel = environmentOverrides?.channel ?? _UniversalStore.preparation.channel;
    this.environment = environmentOverrides?.environment ?? _UniversalStore.preparation.environment;
    if (this.channel && this.environment) {
      _UniversalStore.preparation.resolve({ channel: this.channel, environment: this.environment });
      this.prepareThis({ channel: this.channel, environment: this.environment });
    } else {
      _UniversalStore.preparation.promise.then(this.prepareThis);
    }
  }
  static setupPreparationPromise() {
    let resolveRef;
    let rejectRef;
    const promise = new Promise(
      (resolve, reject) => {
        resolveRef = /* @__PURE__ */ __name((args) => {
          resolve(args);
        }, "resolveRef");
        rejectRef = /* @__PURE__ */ __name((...args) => {
          reject(args);
        }, "rejectRef");
      }
    );
    _UniversalStore.preparation = {
      resolve: resolveRef,
      reject: rejectRef,
      promise
    };
  }
  /** The actor object representing the store instance with a unique ID and a type */
  get actor() {
    return Object.freeze({
      id: this.actorId,
      type: this.actorType,
      environment: this.environment ?? _UniversalStore.Environment.UNKNOWN
    });
  }
  /**
   * The current state of the store, that signals both if the store is prepared by Storybook and
   * also - in the case of a follower - if the state has been synced with the leader's state.
   */
  get status() {
    if (!this.channel || !this.environment) {
      return _UniversalStore.Status.UNPREPARED;
    }
    switch (this.syncing?.state) {
      case ProgressState.PENDING:
      case void 0:
        return _UniversalStore.Status.SYNCING;
      case ProgressState.REJECTED:
        return _UniversalStore.Status.ERROR;
      case ProgressState.RESOLVED:
      default:
        return _UniversalStore.Status.READY;
    }
  }
  /**
   * A promise that resolves when the store is fully ready. A leader will be ready when the store
   * has been prepared by Storybook, which is almost instantly.
   *
   * A follower will be ready when the state has been synced with the leader's state, within a few
   * hundred milliseconds.
   */
  untilReady() {
    return Promise.all([_UniversalStore.preparation.promise, this.syncing?.promise]);
  }
  /** Creates a new instance of UniversalStore */
  static create(options) {
    if (!options || typeof options?.id !== "string") {
      throw new TypeError("id is required and must be a string, when creating a UniversalStore");
    }
    if (options.debug) {
      console.debug(
        dedent`[UniversalStore]
        create`,
        { options }
      );
    }
    const existing = instances.get(options.id);
    if (existing) {
      console.warn(dedent`UniversalStore with id "${options.id}" already exists in this environment, re-using existing.
        You should reuse the existing instance instead of trying to create a new one.`);
      return existing;
    }
    _UniversalStore.isInternalConstructing = true;
    const store = new _UniversalStore(options);
    instances.set(options.id, store);
    return store;
  }
  /**
   * Used by Storybook to set the channel for all instances of UniversalStore in the given
   * environment.
   *
   * @internal
   */
  static __prepare(channel, environment) {
    _UniversalStore.preparation.channel = channel;
    _UniversalStore.preparation.environment = environment;
    _UniversalStore.preparation.resolve({ channel, environment });
  }
  /**
   * Updates the store's state
   *
   * Either a new state or a state updater function can be passed to the method.
   */
  setState(updater) {
    const previousState = this.state;
    const newState = typeof updater === "function" ? updater(previousState) : updater;
    this.debug("setState", { newState, previousState, updater });
    if (this.status !== _UniversalStore.Status.READY) {
      throw new TypeError(
        dedent`Cannot set state before store is ready. You can get the current status with store.status,
        or await store.readyPromise to wait for the store to be ready before sending events.
        ${JSON.stringify(
          {
            newState,
            id: this.id,
            actor: this.actor,
            environment: this.environment
          },
          null,
          2
        )}`
      );
    }
    this.state = newState;
    const event = {
      type: _UniversalStore.InternalEventType.SET_STATE,
      payload: {
        state: newState,
        previousState
      }
    };
    this.emitToChannel(event, { actor: this.actor });
    this.emitToListeners(event, { actor: this.actor });
  }
  /**
   * Subscribes to state changes
   *
   * @returns Unsubscribe function
   */
  onStateChange(listener) {
    this.debug("onStateChange", { listener });
    return this.subscribe(
      _UniversalStore.InternalEventType.SET_STATE,
      ({ payload }, eventInfo) => {
        listener(payload.state, payload.previousState, eventInfo);
      }
    );
  }
  emitToChannel(event, eventInfo) {
    this.debug("emitToChannel", { event, eventInfo, channel: !!this.channel });
    this.channel?.emit(this.channelEventName, {
      event,
      eventInfo
    });
  }
  prepareThis({
    channel,
    environment
  }) {
    this.channel = channel;
    this.environment = environment;
    this.debug("prepared", { channel: !!channel, environment });
    this.channel.on(this.channelEventName, this.handleChannelEvents);
    if (this.actor.type === _UniversalStore.ActorType.LEADER) {
      this.emitToChannel(
        { type: _UniversalStore.InternalEventType.LEADER_CREATED },
        { actor: this.actor }
      );
    } else {
      this.emitToChannel(
        { type: _UniversalStore.InternalEventType.FOLLOWER_CREATED },
        { actor: this.actor }
      );
      this.emitToChannel(
        { type: _UniversalStore.InternalEventType.EXISTING_STATE_REQUEST },
        { actor: this.actor }
      );
      setTimeout(() => {
        this.syncing.reject(
          new TypeError(
            `No existing state found for follower with id: '${this.id}'. Make sure a leader with the same id exists before creating a follower.`
          )
        );
      }, 1e3);
    }
  }
  emitToListeners(event, eventInfo) {
    const eventTypeListeners = this.listeners.get(event.type);
    const everythingListeners = this.listeners.get("*");
    this.debug("emitToListeners", {
      event,
      eventInfo,
      eventTypeListeners,
      everythingListeners
    });
    [...eventTypeListeners ?? [], ...everythingListeners ?? []].forEach(
      (listener) => listener(event, eventInfo)
    );
  }
  handleChannelEvents(channelEvent) {
    const { event, eventInfo } = channelEvent;
    if ([eventInfo.actor.id, eventInfo.forwardingActor?.id].includes(this.actor.id)) {
      this.debug("handleChannelEvents: Ignoring event from self", { channelEvent });
      return;
    } else if (this.syncing?.state === ProgressState.PENDING && event.type !== _UniversalStore.InternalEventType.EXISTING_STATE_RESPONSE) {
      this.debug("handleChannelEvents: Ignoring event while syncing", { channelEvent });
      return;
    }
    this.debug("handleChannelEvents", { channelEvent });
    if (this.actor.type === _UniversalStore.ActorType.LEADER) {
      let shouldForwardEvent = true;
      switch (event.type) {
        case _UniversalStore.InternalEventType.EXISTING_STATE_REQUEST:
          shouldForwardEvent = false;
          const responseEvent = {
            type: _UniversalStore.InternalEventType.EXISTING_STATE_RESPONSE,
            payload: this.state
          };
          this.debug("handleChannelEvents: responding to existing state request", {
            responseEvent
          });
          this.emitToChannel(responseEvent, { actor: this.actor });
          this.emitToListeners(responseEvent, { actor: this.actor });
          break;
        case _UniversalStore.InternalEventType.LEADER_CREATED:
          shouldForwardEvent = false;
          this.syncing.state = ProgressState.REJECTED;
          this.debug("handleChannelEvents: erroring due to second leader being created", {
            event
          });
          console.error(
            dedent`Detected multiple UniversalStore leaders created with the same id "${this.id}".
            Only one leader can exists at a time, your stores are now in an invalid state.
            Leaders detected:
            this: ${JSON.stringify(this.actor, null, 2)}
            other: ${JSON.stringify(eventInfo.actor, null, 2)}`
          );
          break;
      }
      if (shouldForwardEvent) {
        this.debug("handleChannelEvents: forwarding event", { channelEvent });
        this.emitToChannel(event, { actor: eventInfo.actor, forwardingActor: this.actor });
      }
    }
    if (this.actor.type === _UniversalStore.ActorType.FOLLOWER) {
      switch (event.type) {
        case _UniversalStore.InternalEventType.EXISTING_STATE_RESPONSE:
          this.debug("handleChannelEvents: Setting state from leader's existing state response", {
            event
          });
          if (this.syncing?.state !== ProgressState.PENDING) {
            break;
          }
          this.syncing.resolve?.();
          const setStateEvent = {
            type: _UniversalStore.InternalEventType.SET_STATE,
            payload: {
              state: event.payload,
              previousState: this.state
            }
          };
          this.state = event.payload;
          this.emitToListeners(setStateEvent, eventInfo);
          break;
      }
    }
    switch (event.type) {
      case _UniversalStore.InternalEventType.SET_STATE:
        this.debug("handleChannelEvents: Setting state", { event });
        this.state = event.payload.state;
        break;
    }
    this.emitToListeners(event, { actor: eventInfo.actor });
  }
  debug(message, data) {
    if (this.debugging) {
      console.debug(
        dedent`[UniversalStore::${this.id}::${this.environment ?? _UniversalStore.Environment.UNKNOWN}]
        ${message}`,
        JSON.stringify(
          {
            data,
            actor: this.actor,
            state: this.state,
            status: this.status
          },
          null,
          2
        )
      );
    }
  }
  /**
   * Used to reset the static fields of the UniversalStore class when cleaning up tests
   *
   * @internal
   */
  static __reset() {
    _UniversalStore.preparation.reject(new Error("reset"));
    _UniversalStore.setupPreparationPromise();
    _UniversalStore.isInternalConstructing = false;
  }
};
__name(_UniversalStore, "UniversalStore");
/**
 * Defines the possible actor types in the store system
 *
 * @readonly
 */
_UniversalStore.ActorType = {
  LEADER: "LEADER",
  FOLLOWER: "FOLLOWER"
};
/**
 * Defines the possible environments the store can run in
 *
 * @readonly
 */
_UniversalStore.Environment = {
  SERVER: "SERVER",
  MANAGER: "MANAGER",
  PREVIEW: "PREVIEW",
  UNKNOWN: "UNKNOWN",
  MOCK: "MOCK"
};
/**
 * Internal event types used for store synchronization
 *
 * @readonly
 */
_UniversalStore.InternalEventType = {
  EXISTING_STATE_REQUEST: "__EXISTING_STATE_REQUEST",
  EXISTING_STATE_RESPONSE: "__EXISTING_STATE_RESPONSE",
  SET_STATE: "__SET_STATE",
  LEADER_CREATED: "__LEADER_CREATED",
  FOLLOWER_CREATED: "__FOLLOWER_CREATED"
};
_UniversalStore.Status = {
  UNPREPARED: "UNPREPARED",
  SYNCING: "SYNCING",
  READY: "READY",
  ERROR: "ERROR"
};
// This is used to check if constructor was called from the static factory create()
_UniversalStore.isInternalConstructing = false;
_UniversalStore.setupPreparationPromise();
var UniversalStore = _UniversalStore;

// src/channels/main.ts
var isMulti = /* @__PURE__ */ __name((args) => {
  return args.transports !== void 0;
}, "isMulti");
var generateRandomId = /* @__PURE__ */ __name(() => {
  return Math.random().toString(16).slice(2);
}, "generateRandomId");
var _Channel = class _Channel {
  constructor(input2 = {}) {
    this.sender = generateRandomId();
    this.events = {};
    this.data = {};
    this.transports = [];
    this.isAsync = input2.async || false;
    if (isMulti(input2)) {
      this.transports = input2.transports || [];
      this.transports.forEach((t2) => {
        t2.setHandler((event) => this.handleEvent(event));
      });
    } else {
      this.transports = input2.transport ? [input2.transport] : [];
    }
    this.transports.forEach((t2) => {
      t2.setHandler((event) => this.handleEvent(event));
    });
  }
  get hasTransport() {
    return this.transports.length > 0;
  }
  addListener(eventName, listener) {
    this.events[eventName] = this.events[eventName] || [];
    this.events[eventName].push(listener);
  }
  emit(eventName, ...args) {
    const event = { type: eventName, args, from: this.sender };
    let options = {};
    if (args.length >= 1 && args[0] && args[0].options) {
      options = args[0].options;
    }
    const handler = /* @__PURE__ */ __name(() => {
      this.transports.forEach((t2) => {
        t2.send(event, options);
      });
      this.handleEvent(event);
    }, "handler");
    if (this.isAsync) {
      setImmediate(handler);
    } else {
      handler();
    }
  }
  last(eventName) {
    return this.data[eventName];
  }
  eventNames() {
    return Object.keys(this.events);
  }
  listenerCount(eventName) {
    const listeners3 = this.listeners(eventName);
    return listeners3 ? listeners3.length : 0;
  }
  listeners(eventName) {
    const listeners3 = this.events[eventName];
    return listeners3 || void 0;
  }
  once(eventName, listener) {
    const onceListener = this.onceListener(eventName, listener);
    this.addListener(eventName, onceListener);
  }
  removeAllListeners(eventName) {
    if (!eventName) {
      this.events = {};
    } else if (this.events[eventName]) {
      delete this.events[eventName];
    }
  }
  removeListener(eventName, listener) {
    const listeners3 = this.listeners(eventName);
    if (listeners3) {
      this.events[eventName] = listeners3.filter((l2) => l2 !== listener);
    }
  }
  on(eventName, listener) {
    this.addListener(eventName, listener);
  }
  off(eventName, listener) {
    this.removeListener(eventName, listener);
  }
  handleEvent(event) {
    const listeners3 = this.listeners(event.type);
    if (listeners3 && listeners3.length) {
      listeners3.forEach((fn3) => {
        fn3.apply(event, event.args);
      });
    }
    this.data[event.type] = event.args;
  }
  onceListener(eventName, listener) {
    const onceListener = /* @__PURE__ */ __name((...args) => {
      this.removeListener(eventName, onceListener);
      return listener(...args);
    }, "onceListener");
    return onceListener;
  }
};
__name(_Channel, "Channel");
var Channel = _Channel;

// src/client-logger/index.ts
var client_logger_exports = {};
__export(client_logger_exports, {
  deprecate: () => deprecate,
  logger: () => logger,
  once: () => once,
  pretty: () => pretty
});
var { LOGLEVEL } = scope;
var levels = {
  trace: 1,
  debug: 2,
  info: 3,
  warn: 4,
  error: 5,
  silent: 10
};
var currentLogLevelString = LOGLEVEL;
var currentLogLevelNumber = levels[currentLogLevelString] || levels.info;
var logger = {
  trace: /* @__PURE__ */ __name((message, ...rest) => {
    if (currentLogLevelNumber <= levels.trace) {
      console.trace(message, ...rest);
    }
  }, "trace"),
  debug: /* @__PURE__ */ __name((message, ...rest) => {
    if (currentLogLevelNumber <= levels.debug) {
      console.debug(message, ...rest);
    }
  }, "debug"),
  info: /* @__PURE__ */ __name((message, ...rest) => {
    if (currentLogLevelNumber <= levels.info) {
      console.info(message, ...rest);
    }
  }, "info"),
  warn: /* @__PURE__ */ __name((message, ...rest) => {
    if (currentLogLevelNumber <= levels.warn) {
      console.warn(message, ...rest);
    }
  }, "warn"),
  error: /* @__PURE__ */ __name((message, ...rest) => {
    if (currentLogLevelNumber <= levels.error) {
      console.error(message, ...rest);
    }
  }, "error"),
  log: /* @__PURE__ */ __name((message, ...rest) => {
    if (currentLogLevelNumber < levels.silent) {
      console.log(message, ...rest);
    }
  }, "log")
};
var logged = /* @__PURE__ */ new Set();
var once = /* @__PURE__ */ __name((type5) => (message, ...rest) => {
  if (logged.has(message)) {
    return void 0;
  }
  logged.add(message);
  return logger[type5](message, ...rest);
}, "once");
once.clear = () => logged.clear();
once.trace = once("trace");
once.debug = once("debug");
once.info = once("info");
once.warn = once("warn");
once.error = once("error");
once.log = once("log");
var deprecate = once("warn");
var pretty = /* @__PURE__ */ __name((type5) => (...args) => {
  const argArray = [];
  if (args.length) {
    const startTagRe = /<span\s+style=(['"])([^'"]*)\1\s*>/gi;
    const endTagRe = /<\/span>/gi;
    let reResultArray;
    argArray.push(args[0].replace(startTagRe, "%c").replace(endTagRe, "%c"));
    while (reResultArray = startTagRe.exec(args[0])) {
      argArray.push(reResultArray[2]);
      argArray.push("");
    }
    for (let j2 = 1; j2 < args.length; j2++) {
      argArray.push(args[j2]);
    }
  }
  logger[type5].apply(logger, argArray);
}, "pretty");
pretty.trace = pretty("trace");
pretty.debug = pretty("debug");
pretty.info = pretty("info");
pretty.warn = pretty("warn");
pretty.error = pretty("error");

// ../node_modules/telejson/dist/chunk-EAFQLD22.mjs
var __create2 = Object.create;
var __defProp2 = Object.defineProperty;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames2 = Object.getOwnPropertyNames;
var __getProtoOf2 = Object.getPrototypeOf;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __commonJS2 = /* @__PURE__ */ __name((cb, mod) => /* @__PURE__ */ __name(function __require2() {
  return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
}, "__require"), "__commonJS");
var __copyProps2 = /* @__PURE__ */ __name((to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames2(from))
      if (!__hasOwnProp2.call(to, key) && key !== except)
        __defProp2(to, key, { get: /* @__PURE__ */ __name(() => from[key], "get"), enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
  }
  return to;
}, "__copyProps");
var __toESM2 = /* @__PURE__ */ __name((mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target,
  mod
)), "__toESM");
var eventProperties = [
  "bubbles",
  "cancelBubble",
  "cancelable",
  "composed",
  "currentTarget",
  "defaultPrevented",
  "eventPhase",
  "isTrusted",
  "returnValue",
  "srcElement",
  "target",
  "timeStamp",
  "type"
];
var customEventSpecificProperties = ["detail"];
function extractEventHiddenProperties(event) {
  const rebuildEvent = eventProperties.filter((value) => event[value] !== void 0).reduce((acc, value) => {
    acc[value] = event[value];
    return acc;
  }, {});
  if (event instanceof CustomEvent) {
    for (const value of customEventSpecificProperties.filter(
      (value2) => event[value2] !== void 0
    )) {
      rebuildEvent[value] = event[value];
    }
  }
  return rebuildEvent;
}
__name(extractEventHiddenProperties, "extractEventHiddenProperties");

// ../node_modules/telejson/dist/index.mjs
var require_es_object_atoms = __commonJS2({
  "node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js"(exports, module2) {
    "use strict";
    module2.exports = Object;
  }
});
var require_es_errors = __commonJS2({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/index.js"(exports, module2) {
    "use strict";
    module2.exports = Error;
  }
});
var require_eval = __commonJS2({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/eval.js"(exports, module2) {
    "use strict";
    module2.exports = EvalError;
  }
});
var require_range = __commonJS2({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/range.js"(exports, module2) {
    "use strict";
    module2.exports = RangeError;
  }
});
var require_ref = __commonJS2({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/ref.js"(exports, module2) {
    "use strict";
    module2.exports = ReferenceError;
  }
});
var require_syntax = __commonJS2({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js"(exports, module2) {
    "use strict";
    module2.exports = SyntaxError;
  }
});
var require_type = __commonJS2({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js"(exports, module2) {
    "use strict";
    module2.exports = TypeError;
  }
});
var require_uri = __commonJS2({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/uri.js"(exports, module2) {
    "use strict";
    module2.exports = URIError;
  }
});
var require_abs = __commonJS2({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/abs.js"(exports, module2) {
    "use strict";
    module2.exports = Math.abs;
  }
});
var require_floor = __commonJS2({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/floor.js"(exports, module2) {
    "use strict";
    module2.exports = Math.floor;
  }
});
var require_max = __commonJS2({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/max.js"(exports, module2) {
    "use strict";
    module2.exports = Math.max;
  }
});
var require_min = __commonJS2({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/min.js"(exports, module2) {
    "use strict";
    module2.exports = Math.min;
  }
});
var require_pow = __commonJS2({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/pow.js"(exports, module2) {
    "use strict";
    module2.exports = Math.pow;
  }
});
var require_round = __commonJS2({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/round.js"(exports, module2) {
    "use strict";
    module2.exports = Math.round;
  }
});
var require_isNaN = __commonJS2({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/isNaN.js"(exports, module2) {
    "use strict";
    module2.exports = Number.isNaN || /* @__PURE__ */ __name(function isNaN23(a2) {
      return a2 !== a2;
    }, "isNaN2");
  }
});
var require_sign = __commonJS2({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/sign.js"(exports, module2) {
    "use strict";
    var $isNaN = require_isNaN();
    module2.exports = /* @__PURE__ */ __name(function sign(number) {
      if ($isNaN(number) || number === 0) {
        return number;
      }
      return number < 0 ? -1 : 1;
    }, "sign");
  }
});
var require_gOPD = __commonJS2({
  "node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/gOPD.js"(exports, module2) {
    "use strict";
    module2.exports = Object.getOwnPropertyDescriptor;
  }
});
var require_gopd = __commonJS2({
  "node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js"(exports, module2) {
    "use strict";
    var $gOPD = require_gOPD();
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e2) {
        $gOPD = null;
      }
    }
    module2.exports = $gOPD;
  }
});
var require_es_define_property = __commonJS2({
  "node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js"(exports, module2) {
    "use strict";
    var $defineProperty = Object.defineProperty || false;
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e2) {
        $defineProperty = false;
      }
    }
    module2.exports = $defineProperty;
  }
});
var require_shams = __commonJS2({
  "node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js"(exports, module2) {
    "use strict";
    module2.exports = /* @__PURE__ */ __name(function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (var _ in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = (
          /** @type {PropertyDescriptor} */
          Object.getOwnPropertyDescriptor(obj, sym)
        );
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    }, "hasSymbols");
  }
});
var require_has_symbols = __commonJS2({
  "node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/index.js"(exports, module2) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module2.exports = /* @__PURE__ */ __name(function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    }, "hasNativeSymbols");
  }
});
var require_Reflect_getPrototypeOf = __commonJS2({
  "node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js"(exports, module2) {
    "use strict";
    module2.exports = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  }
});
var require_Object_getPrototypeOf = __commonJS2({
  "node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js"(exports, module2) {
    "use strict";
    var $Object = require_es_object_atoms();
    module2.exports = $Object.getPrototypeOf || null;
  }
});
var require_implementation = __commonJS2({
  "node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js"(exports, module2) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr3 = Object.prototype.toString;
    var max = Math.max;
    var funcType = "[object Function]";
    var concatty = /* @__PURE__ */ __name(function concatty2(a2, b2) {
      var arr = [];
      for (var i2 = 0; i2 < a2.length; i2 += 1) {
        arr[i2] = a2[i2];
      }
      for (var j2 = 0; j2 < b2.length; j2 += 1) {
        arr[j2 + a2.length] = b2[j2];
      }
      return arr;
    }, "concatty2");
    var slicy = /* @__PURE__ */ __name(function slicy2(arrLike, offset2) {
      var arr = [];
      for (var i2 = offset2 || 0, j2 = 0; i2 < arrLike.length; i2 += 1, j2 += 1) {
        arr[j2] = arrLike[i2];
      }
      return arr;
    }, "slicy2");
    var joiny = /* @__PURE__ */ __name(function(arr, joiner) {
      var str2 = "";
      for (var i2 = 0; i2 < arr.length; i2 += 1) {
        str2 += arr[i2];
        if (i2 + 1 < arr.length) {
          str2 += joiner;
        }
      }
      return str2;
    }, "joiny");
    module2.exports = /* @__PURE__ */ __name(function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr3.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = /* @__PURE__ */ __name(function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      }, "binder");
      var boundLength = max(0, target.length - args.length);
      var boundArgs = [];
      for (var i2 = 0; i2 < boundLength; i2++) {
        boundArgs[i2] = "$" + i2;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = /* @__PURE__ */ __name(function Empty2() {
        }, "Empty2");
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    }, "bind");
  }
});
var require_function_bind = __commonJS2({
  "node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js"(exports, module2) {
    "use strict";
    var implementation = require_implementation();
    module2.exports = Function.prototype.bind || implementation;
  }
});
var require_functionCall = __commonJS2({
  "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js"(exports, module2) {
    "use strict";
    module2.exports = Function.prototype.call;
  }
});
var require_functionApply = __commonJS2({
  "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js"(exports, module2) {
    "use strict";
    module2.exports = Function.prototype.apply;
  }
});
var require_reflectApply = __commonJS2({
  "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/reflectApply.js"(exports, module2) {
    "use strict";
    module2.exports = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  }
});
var require_actualApply = __commonJS2({
  "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/actualApply.js"(exports, module2) {
    "use strict";
    var bind = require_function_bind();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var $reflectApply = require_reflectApply();
    module2.exports = $reflectApply || bind.call($call, $apply);
  }
});
var require_call_bind_apply_helpers = __commonJS2({
  "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js"(exports, module2) {
    "use strict";
    var bind = require_function_bind();
    var $TypeError = require_type();
    var $call = require_functionCall();
    var $actualApply = require_actualApply();
    module2.exports = /* @__PURE__ */ __name(function callBindBasic(args) {
      if (args.length < 1 || typeof args[0] !== "function") {
        throw new $TypeError("a function is required");
      }
      return $actualApply(bind, $call, args);
    }, "callBindBasic");
  }
});
var require_get = __commonJS2({
  "node_modules/.pnpm/dunder-proto@1.0.1/node_modules/dunder-proto/get.js"(exports, module2) {
    "use strict";
    var callBind = require_call_bind_apply_helpers();
    var gOPD = require_gopd();
    var hasProtoAccessor;
    try {
      hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
      [].__proto__ === Array.prototype;
    } catch (e2) {
      if (!e2 || typeof e2 !== "object" || !("code" in e2) || e2.code !== "ERR_PROTO_ACCESS") {
        throw e2;
      }
    }
    var desc = !!hasProtoAccessor && gOPD && gOPD(
      Object.prototype,
      /** @type {keyof typeof Object.prototype} */
      "__proto__"
    );
    var $Object = Object;
    var $getPrototypeOf = $Object.getPrototypeOf;
    module2.exports = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? (
      /** @type {import('./get')} */
      /* @__PURE__ */ __name(function getDunder(value) {
        return $getPrototypeOf(value == null ? value : $Object(value));
      }, "getDunder")
    ) : false;
  }
});
var require_get_proto = __commonJS2({
  "node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js"(exports, module2) {
    "use strict";
    var reflectGetProto = require_Reflect_getPrototypeOf();
    var originalGetProto = require_Object_getPrototypeOf();
    var getDunderProto = require_get();
    module2.exports = reflectGetProto ? /* @__PURE__ */ __name(function getProto(O) {
      return reflectGetProto(O);
    }, "getProto") : originalGetProto ? /* @__PURE__ */ __name(function getProto(O) {
      if (!O || typeof O !== "object" && typeof O !== "function") {
        throw new TypeError("getProto: not an object");
      }
      return originalGetProto(O);
    }, "getProto") : getDunderProto ? /* @__PURE__ */ __name(function getProto(O) {
      return getDunderProto(O);
    }, "getProto") : null;
  }
});
var require_hasown = __commonJS2({
  "node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js"(exports, module2) {
    "use strict";
    var call2 = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind = require_function_bind();
    module2.exports = bind.call(call2, $hasOwn);
  }
});
var require_get_intrinsic = __commonJS2({
  "node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js"(exports, module2) {
    "use strict";
    var undefined2;
    var $Object = require_es_object_atoms();
    var $Error = require_es_errors();
    var $EvalError = require_eval();
    var $RangeError = require_range();
    var $ReferenceError = require_ref();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var $URIError = require_uri();
    var abs = require_abs();
    var floor = require_floor();
    var max = require_max();
    var min = require_min();
    var pow = require_pow();
    var round2 = require_round();
    var sign = require_sign();
    var $Function = Function;
    var getEvalledConstructor = /* @__PURE__ */ __name(function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e2) {
      }
    }, "getEvalledConstructor");
    var $gOPD = require_gopd();
    var $defineProperty = require_es_define_property();
    var throwTypeError = /* @__PURE__ */ __name(function() {
      throw new $TypeError();
    }, "throwTypeError");
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getProto = require_get_proto();
    var $ObjectGPO = require_Object_getPrototypeOf();
    var $ReflectGPO = require_Reflect_getPrototypeOf();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": $Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": $EvalError,
      "%Float16Array%": typeof Float16Array === "undefined" ? undefined2 : Float16Array,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": $Object,
      "%Object.getOwnPropertyDescriptor%": $gOPD,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": $RangeError,
      "%ReferenceError%": $ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": $URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet,
      "%Function.prototype.call%": $call,
      "%Function.prototype.apply%": $apply,
      "%Object.defineProperty%": $defineProperty,
      "%Object.getPrototypeOf%": $ObjectGPO,
      "%Math.abs%": abs,
      "%Math.floor%": floor,
      "%Math.max%": max,
      "%Math.min%": min,
      "%Math.pow%": pow,
      "%Math.round%": round2,
      "%Math.sign%": sign,
      "%Reflect.getPrototypeOf%": $ReflectGPO
    };
    if (getProto) {
      try {
        null.error;
      } catch (e2) {
        errorProto = getProto(getProto(e2));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = /* @__PURE__ */ __name(function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn3 = doEval2("%AsyncGeneratorFunction%");
        if (fn3) {
          value = fn3.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    }, "doEval2");
    var LEGACY_ALIASES = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_hasown();
    var $concat = bind.call($call, Array.prototype.concat);
    var $spliceApply = bind.call($apply, Array.prototype.splice);
    var $replace = bind.call($call, String.prototype.replace);
    var $strSlice = bind.call($call, String.prototype.slice);
    var $exec = bind.call($call, RegExp.prototype.exec);
    var rePropName2 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar2 = /\\(\\)?/g;
    var stringToPath2 = /* @__PURE__ */ __name(function stringToPath3(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName2, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar2, "$1") : number || match;
      });
      return result;
    }, "stringToPath3");
    var getBaseIntrinsic = /* @__PURE__ */ __name(function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    }, "getBaseIntrinsic2");
    module2.exports = /* @__PURE__ */ __name(function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath2(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i2 = 1, isOwn = true; i2 < parts.length; i2 += 1) {
        var part = parts[i2];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i2 + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    }, "GetIntrinsic");
  }
});
var require_call_bound = __commonJS2({
  "node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBindBasic = require_call_bind_apply_helpers();
    var $indexOf = callBindBasic([GetIntrinsic("%String.prototype.indexOf%")]);
    module2.exports = /* @__PURE__ */ __name(function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = (
        /** @type {(this: unknown, ...args: unknown[]) => unknown} */
        GetIntrinsic(name, !!allowMissing)
      );
      if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
        return callBindBasic(
          /** @type {const} */
          [intrinsic]
        );
      }
      return intrinsic;
    }, "callBoundIntrinsic");
  }
});
var require_shams2 = __commonJS2({
  "node_modules/.pnpm/has-tostringtag@1.0.2/node_modules/has-tostringtag/shams.js"(exports, module2) {
    "use strict";
    var hasSymbols = require_shams();
    module2.exports = /* @__PURE__ */ __name(function hasToStringTagShams() {
      return hasSymbols() && !!Symbol.toStringTag;
    }, "hasToStringTagShams");
  }
});
var require_is_regex = __commonJS2({
  "node_modules/.pnpm/is-regex@1.2.1/node_modules/is-regex/index.js"(exports, module2) {
    "use strict";
    var callBound = require_call_bound();
    var hasToStringTag = require_shams2()();
    var hasOwn = require_hasown();
    var gOPD = require_gopd();
    var fn3;
    if (hasToStringTag) {
      $exec = callBound("RegExp.prototype.exec");
      isRegexMarker = {};
      throwRegexMarker = /* @__PURE__ */ __name(function() {
        throw isRegexMarker;
      }, "throwRegexMarker");
      badStringifier = {
        toString: throwRegexMarker,
        valueOf: throwRegexMarker
      };
      if (typeof Symbol.toPrimitive === "symbol") {
        badStringifier[Symbol.toPrimitive] = throwRegexMarker;
      }
      fn3 = /* @__PURE__ */ __name(function isRegex(value) {
        if (!value || typeof value !== "object") {
          return false;
        }
        var descriptor = (
          /** @type {NonNullable<typeof gOPD>} */
          gOPD(
            /** @type {{ lastIndex?: unknown }} */
            value,
            "lastIndex"
          )
        );
        var hasLastIndexDataProperty = descriptor && hasOwn(descriptor, "value");
        if (!hasLastIndexDataProperty) {
          return false;
        }
        try {
          $exec(
            value,
            /** @type {string} */
            /** @type {unknown} */
            badStringifier
          );
        } catch (e2) {
          return e2 === isRegexMarker;
        }
      }, "isRegex");
    } else {
      $toString = callBound("Object.prototype.toString");
      regexClass = "[object RegExp]";
      fn3 = /* @__PURE__ */ __name(function isRegex(value) {
        if (!value || typeof value !== "object" && typeof value !== "function") {
          return false;
        }
        return $toString(value) === regexClass;
      }, "isRegex");
    }
    var $exec;
    var isRegexMarker;
    var throwRegexMarker;
    var badStringifier;
    var $toString;
    var regexClass;
    module2.exports = fn3;
  }
});
var require_is_function = __commonJS2({
  "node_modules/.pnpm/is-function@1.0.2/node_modules/is-function/index.js"(exports, module2) {
    module2.exports = isFunction32;
    var toString22 = Object.prototype.toString;
    function isFunction32(fn3) {
      if (!fn3) {
        return false;
      }
      var string = toString22.call(fn3);
      return string === "[object Function]" || typeof fn3 === "function" && string !== "[object RegExp]" || typeof window !== "undefined" && // IE8 and below
      (fn3 === window.setTimeout || fn3 === window.alert || fn3 === window.confirm || fn3 === window.prompt);
    }
    __name(isFunction32, "isFunction3");
  }
});
var require_safe_regex_test = __commonJS2({
  "node_modules/.pnpm/safe-regex-test@1.1.0/node_modules/safe-regex-test/index.js"(exports, module2) {
    "use strict";
    var callBound = require_call_bound();
    var isRegex = require_is_regex();
    var $exec = callBound("RegExp.prototype.exec");
    var $TypeError = require_type();
    module2.exports = /* @__PURE__ */ __name(function regexTester(regex) {
      if (!isRegex(regex)) {
        throw new $TypeError("`regex` must be a RegExp");
      }
      return /* @__PURE__ */ __name(function test3(s3) {
        return $exec(regex, s3) !== null;
      }, "test");
    }, "regexTester");
  }
});
var require_is_symbol = __commonJS2({
  "node_modules/.pnpm/is-symbol@1.1.1/node_modules/is-symbol/index.js"(exports, module2) {
    "use strict";
    var callBound = require_call_bound();
    var $toString = callBound("Object.prototype.toString");
    var hasSymbols = require_has_symbols()();
    var safeRegexTest = require_safe_regex_test();
    if (hasSymbols) {
      $symToStr = callBound("Symbol.prototype.toString");
      isSymString = safeRegexTest(/^Symbol\(.*\)$/);
      isSymbolObject = /* @__PURE__ */ __name(function isRealSymbolObject(value) {
        if (typeof value.valueOf() !== "symbol") {
          return false;
        }
        return isSymString($symToStr(value));
      }, "isRealSymbolObject");
      module2.exports = /* @__PURE__ */ __name(function isSymbol3(value) {
        if (typeof value === "symbol") {
          return true;
        }
        if (!value || typeof value !== "object" || $toString(value) !== "[object Symbol]") {
          return false;
        }
        try {
          return isSymbolObject(value);
        } catch (e2) {
          return false;
        }
      }, "isSymbol3");
    } else {
      module2.exports = /* @__PURE__ */ __name(function isSymbol3(value) {
        return false;
      }, "isSymbol3");
    }
    var $symToStr;
    var isSymString;
    var isSymbolObject;
  }
});
var import_is_regex = __toESM2(require_is_regex());
var import_is_function = __toESM2(require_is_function());
var import_is_symbol = __toESM2(require_is_symbol());
function isObject(val) {
  return val != null && typeof val === "object" && Array.isArray(val) === false;
}
__name(isObject, "isObject");
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal_default = freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal_default || freeSelf || Function("return this")();
var root_default = root;
var Symbol2 = root_default.Symbol;
var Symbol_default = Symbol2;
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var nativeObjectToString = objectProto.toString;
var symToStringTag = Symbol_default ? Symbol_default.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
  try {
    value[symToStringTag] = void 0;
    var unmasked = true;
  } catch (e2) {
  }
  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}
__name(getRawTag, "getRawTag");
var getRawTag_default = getRawTag;
var objectProto2 = Object.prototype;
var nativeObjectToString2 = objectProto2.toString;
function objectToString(value) {
  return nativeObjectToString2.call(value);
}
__name(objectToString, "objectToString");
var objectToString_default = objectToString;
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag2 = Symbol_default ? Symbol_default.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag2 && symToStringTag2 in Object(value) ? getRawTag_default(value) : objectToString_default(value);
}
__name(baseGetTag, "baseGetTag");
var baseGetTag_default = baseGetTag;
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
__name(isObjectLike, "isObjectLike");
var isObjectLike_default = isObjectLike;
var symbolTag = "[object Symbol]";
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike_default(value) && baseGetTag_default(value) == symbolTag;
}
__name(isSymbol, "isSymbol");
var isSymbol_default = isSymbol;
function arrayMap(array, iteratee) {
  var index2 = -1, length = array == null ? 0 : array.length, result = Array(length);
  while (++index2 < length) {
    result[index2] = iteratee(array[index2], index2, array);
  }
  return result;
}
__name(arrayMap, "arrayMap");
var arrayMap_default = arrayMap;
var isArray = Array.isArray;
var isArray_default = isArray;
var INFINITY = 1 / 0;
var symbolProto = Symbol_default ? Symbol_default.prototype : void 0;
var symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray_default(value)) {
    return arrayMap_default(value, baseToString) + "";
  }
  if (isSymbol_default(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
__name(baseToString, "baseToString");
var baseToString_default = baseToString;
function isObject2(value) {
  var type5 = typeof value;
  return value != null && (type5 == "object" || type5 == "function");
}
__name(isObject2, "isObject2");
var isObject_default = isObject2;
var asyncTag = "[object AsyncFunction]";
var funcTag = "[object Function]";
var genTag = "[object GeneratorFunction]";
var proxyTag = "[object Proxy]";
function isFunction(value) {
  if (!isObject_default(value)) {
    return false;
  }
  var tag = baseGetTag_default(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
__name(isFunction, "isFunction");
var isFunction_default = isFunction;
var coreJsData = root_default["__core-js_shared__"];
var coreJsData_default = coreJsData;
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData_default && coreJsData_default.keys && coreJsData_default.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
__name(isMasked, "isMasked");
var isMasked_default = isMasked;
var funcProto = Function.prototype;
var funcToString = funcProto.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e2) {
    }
    try {
      return func + "";
    } catch (e2) {
    }
  }
  return "";
}
__name(toSource, "toSource");
var toSource_default = toSource;
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto2 = Function.prototype;
var objectProto3 = Object.prototype;
var funcToString2 = funcProto2.toString;
var hasOwnProperty2 = objectProto3.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(value) {
  if (!isObject_default(value) || isMasked_default(value)) {
    return false;
  }
  var pattern = isFunction_default(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource_default(value));
}
__name(baseIsNative, "baseIsNative");
var baseIsNative_default = baseIsNative;
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
__name(getValue, "getValue");
var getValue_default = getValue;
function getNative(object, key) {
  var value = getValue_default(object, key);
  return baseIsNative_default(value) ? value : void 0;
}
__name(getNative, "getNative");
var getNative_default = getNative;
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
__name(eq, "eq");
var eq_default = eq;
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp = /^\w*$/;
function isKey(value, object) {
  if (isArray_default(value)) {
    return false;
  }
  var type5 = typeof value;
  if (type5 == "number" || type5 == "symbol" || type5 == "boolean" || value == null || isSymbol_default(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
__name(isKey, "isKey");
var isKey_default = isKey;
var nativeCreate = getNative_default(Object, "create");
var nativeCreate_default = nativeCreate;
function hashClear() {
  this.__data__ = nativeCreate_default ? nativeCreate_default(null) : {};
  this.size = 0;
}
__name(hashClear, "hashClear");
var hashClear_default = hashClear;
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
__name(hashDelete, "hashDelete");
var hashDelete_default = hashDelete;
var HASH_UNDEFINED = "__lodash_hash_undefined__";
var objectProto4 = Object.prototype;
var hasOwnProperty3 = objectProto4.hasOwnProperty;
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate_default) {
    var result = data[key];
    return result === HASH_UNDEFINED ? void 0 : result;
  }
  return hasOwnProperty3.call(data, key) ? data[key] : void 0;
}
__name(hashGet, "hashGet");
var hashGet_default = hashGet;
var objectProto5 = Object.prototype;
var hasOwnProperty4 = objectProto5.hasOwnProperty;
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate_default ? data[key] !== void 0 : hasOwnProperty4.call(data, key);
}
__name(hashHas, "hashHas");
var hashHas_default = hashHas;
var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate_default && value === void 0 ? HASH_UNDEFINED2 : value;
  return this;
}
__name(hashSet, "hashSet");
var hashSet_default = hashSet;
function Hash(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
__name(Hash, "Hash");
Hash.prototype.clear = hashClear_default;
Hash.prototype["delete"] = hashDelete_default;
Hash.prototype.get = hashGet_default;
Hash.prototype.has = hashHas_default;
Hash.prototype.set = hashSet_default;
var Hash_default = Hash;
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
__name(listCacheClear, "listCacheClear");
var listCacheClear_default = listCacheClear;
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq_default(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
__name(assocIndexOf, "assocIndexOf");
var assocIndexOf_default = assocIndexOf;
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key) {
  var data = this.__data__, index2 = assocIndexOf_default(data, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index2, 1);
  }
  --this.size;
  return true;
}
__name(listCacheDelete, "listCacheDelete");
var listCacheDelete_default = listCacheDelete;
function listCacheGet(key) {
  var data = this.__data__, index2 = assocIndexOf_default(data, key);
  return index2 < 0 ? void 0 : data[index2][1];
}
__name(listCacheGet, "listCacheGet");
var listCacheGet_default = listCacheGet;
function listCacheHas(key) {
  return assocIndexOf_default(this.__data__, key) > -1;
}
__name(listCacheHas, "listCacheHas");
var listCacheHas_default = listCacheHas;
function listCacheSet(key, value) {
  var data = this.__data__, index2 = assocIndexOf_default(data, key);
  if (index2 < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index2][1] = value;
  }
  return this;
}
__name(listCacheSet, "listCacheSet");
var listCacheSet_default = listCacheSet;
function ListCache(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
__name(ListCache, "ListCache");
ListCache.prototype.clear = listCacheClear_default;
ListCache.prototype["delete"] = listCacheDelete_default;
ListCache.prototype.get = listCacheGet_default;
ListCache.prototype.has = listCacheHas_default;
ListCache.prototype.set = listCacheSet_default;
var ListCache_default = ListCache;
var Map2 = getNative_default(root_default, "Map");
var Map_default = Map2;
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash_default(),
    "map": new (Map_default || ListCache_default)(),
    "string": new Hash_default()
  };
}
__name(mapCacheClear, "mapCacheClear");
var mapCacheClear_default = mapCacheClear;
function isKeyable(value) {
  var type5 = typeof value;
  return type5 == "string" || type5 == "number" || type5 == "symbol" || type5 == "boolean" ? value !== "__proto__" : value === null;
}
__name(isKeyable, "isKeyable");
var isKeyable_default = isKeyable;
function getMapData(map2, key) {
  var data = map2.__data__;
  return isKeyable_default(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
__name(getMapData, "getMapData");
var getMapData_default = getMapData;
function mapCacheDelete(key) {
  var result = getMapData_default(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
__name(mapCacheDelete, "mapCacheDelete");
var mapCacheDelete_default = mapCacheDelete;
function mapCacheGet(key) {
  return getMapData_default(this, key).get(key);
}
__name(mapCacheGet, "mapCacheGet");
var mapCacheGet_default = mapCacheGet;
function mapCacheHas(key) {
  return getMapData_default(this, key).has(key);
}
__name(mapCacheHas, "mapCacheHas");
var mapCacheHas_default = mapCacheHas;
function mapCacheSet(key, value) {
  var data = getMapData_default(this, key), size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}
__name(mapCacheSet, "mapCacheSet");
var mapCacheSet_default = mapCacheSet;
function MapCache(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
__name(MapCache, "MapCache");
MapCache.prototype.clear = mapCacheClear_default;
MapCache.prototype["delete"] = mapCacheDelete_default;
MapCache.prototype.get = mapCacheGet_default;
MapCache.prototype.has = mapCacheHas_default;
MapCache.prototype.set = mapCacheSet_default;
var MapCache_default = MapCache;
var FUNC_ERROR_TEXT = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = /* @__PURE__ */ __name(function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  }, "memoized");
  memoized.cache = new (memoize.Cache || MapCache_default)();
  return memoized;
}
__name(memoize, "memoize");
memoize.Cache = MapCache_default;
var memoize_default = memoize;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result = memoize_default(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });
  var cache = result.cache;
  return result;
}
__name(memoizeCapped, "memoizeCapped");
var memoizeCapped_default = memoizeCapped;
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = memoizeCapped_default(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
  });
  return result;
});
var stringToPath_default = stringToPath;
function toString(value) {
  return value == null ? "" : baseToString_default(value);
}
__name(toString, "toString");
var toString_default = toString;
function castPath(value, object) {
  if (isArray_default(value)) {
    return value;
  }
  return isKey_default(value, object) ? [value] : stringToPath_default(toString_default(value));
}
__name(castPath, "castPath");
var castPath_default = castPath;
var INFINITY2 = 1 / 0;
function toKey(value) {
  if (typeof value == "string" || isSymbol_default(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY2 ? "-0" : result;
}
__name(toKey, "toKey");
var toKey_default = toKey;
function baseGet(object, path) {
  path = castPath_default(path, object);
  var index2 = 0, length = path.length;
  while (object != null && index2 < length) {
    object = object[toKey_default(path[index2++])];
  }
  return index2 && index2 == length ? object : void 0;
}
__name(baseGet, "baseGet");
var baseGet_default = baseGet;
function get(object, path, defaultValue) {
  var result = object == null ? void 0 : baseGet_default(object, path);
  return result === void 0 ? defaultValue : result;
}
__name(get, "get");
var get_default = get;
var isObject3 = isObject;
var dateFormat = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d{3})?Z$/;
var isJSON = /* @__PURE__ */ __name((input2) => input2.match(/^[\[\{\"\}].*[\]\}\"]$/), "isJSON");
function convertUnconventionalData(data) {
  if (!isObject3(data)) {
    return data;
  }
  let result = data;
  let wasMutated = false;
  if (typeof Event !== "undefined" && data instanceof Event) {
    result = extractEventHiddenProperties(result);
    wasMutated = true;
  }
  result = Object.keys(result).reduce((acc, key) => {
    try {
      if (result[key]) {
        result[key].toJSON;
      }
      acc[key] = result[key];
    } catch (_err) {
      wasMutated = true;
    }
    return acc;
  }, {});
  return wasMutated ? result : data;
}
__name(convertUnconventionalData, "convertUnconventionalData");
var replacer = /* @__PURE__ */ __name(function replacer2(options) {
  let objects;
  let map2;
  let stack;
  let keys2;
  return /* @__PURE__ */ __name(function replace(key, value) {
    try {
      if (key === "") {
        keys2 = [];
        objects = /* @__PURE__ */ new Map([[value, "[]"]]);
        map2 = /* @__PURE__ */ new Map();
        stack = [];
        return value;
      }
      const origin = map2.get(this) || this;
      while (stack.length && origin !== stack[0]) {
        stack.shift();
        keys2.pop();
      }
      if (typeof value === "boolean") {
        return value;
      }
      if (value === void 0) {
        if (!options.allowUndefined) {
          return void 0;
        }
        return "_undefined_";
      }
      if (value === null) {
        return null;
      }
      if (typeof value === "number") {
        if (value === Number.NEGATIVE_INFINITY) {
          return "_-Infinity_";
        }
        if (value === Number.POSITIVE_INFINITY) {
          return "_Infinity_";
        }
        if (Number.isNaN(value)) {
          return "_NaN_";
        }
        return value;
      }
      if (typeof value === "bigint") {
        return `_bigint_${value.toString()}`;
      }
      if (typeof value === "string") {
        if (dateFormat.test(value)) {
          if (!options.allowDate) {
            return void 0;
          }
          return `_date_${value}`;
        }
        return value;
      }
      if ((0, import_is_regex.default)(value)) {
        if (!options.allowRegExp) {
          return void 0;
        }
        return `_regexp_${value.flags}|${value.source}`;
      }
      if ((0, import_is_function.default)(value)) {
        return void 0;
      }
      if ((0, import_is_symbol.default)(value)) {
        if (!options.allowSymbol) {
          return void 0;
        }
        const globalRegistryKey = Symbol.keyFor(value);
        if (globalRegistryKey !== void 0) {
          return `_gsymbol_${globalRegistryKey}`;
        }
        return `_symbol_${value.toString().slice(7, -1)}`;
      }
      if (stack.length >= options.maxDepth) {
        if (Array.isArray(value)) {
          return `[Array(${value.length})]`;
        }
        return "[Object]";
      }
      if (value === this) {
        return `_duplicate_${JSON.stringify(keys2)}`;
      }
      if (value instanceof Error && options.allowError) {
        return {
          __isConvertedError__: true,
          errorProperties: {
            // @ts-expect-error cause is not defined in the current tsconfig target(es2020)
            ...value.cause ? { cause: value.cause } : {},
            ...value,
            name: value.name,
            message: value.message,
            stack: value.stack,
            "_constructor-name_": value.constructor.name
          }
        };
      }
      if (value?.constructor?.name && value.constructor.name !== "Object" && !Array.isArray(value)) {
        const found2 = objects.get(value);
        if (!found2) {
          const plainObject = {
            __isClassInstance__: true,
            __className__: value.constructor.name,
            ...Object.getOwnPropertyNames(value).reduce(
              (acc, prop) => {
                try {
                  acc[prop] = value[prop];
                } catch (_err) {
                }
                return acc;
              },
              {}
            )
          };
          keys2.push(key);
          stack.unshift(plainObject);
          objects.set(value, JSON.stringify(keys2));
          if (value !== plainObject) {
            map2.set(value, plainObject);
          }
          return plainObject;
        }
        return `_duplicate_${found2}`;
      }
      const found = objects.get(value);
      if (!found) {
        const converted = Array.isArray(value) ? value : convertUnconventionalData(value);
        keys2.push(key);
        stack.unshift(converted);
        objects.set(value, JSON.stringify(keys2));
        if (value !== converted) {
          map2.set(value, converted);
        }
        return converted;
      }
      return `_duplicate_${found}`;
    } catch (_e2) {
      return void 0;
    }
  }, "replace");
}, "replacer2");
var reviver = /* @__PURE__ */ __name(function reviver2(options) {
  const refs = [];
  let root2;
  return /* @__PURE__ */ __name(function revive(key, value) {
    if (key === "") {
      root2 = value;
      refs.forEach(({ target, container, replacement }) => {
        const replacementArr = isJSON(replacement) ? JSON.parse(replacement) : replacement.split(".");
        if (replacementArr.length === 0) {
          container[target] = root2;
        } else {
          container[target] = get_default(root2, replacementArr);
        }
      });
    }
    if (key === "_constructor-name_") {
      return value;
    }
    if (isObject3(value) && value.__isConvertedError__) {
      const { message, ...properties } = value.errorProperties;
      const error = new Error(message);
      Object.assign(error, properties);
      return error;
    }
    if (typeof value === "string" && value.startsWith("_regexp_") && options.allowRegExp) {
      const [, flags, source] = value.match(/_regexp_([^|]*)\|(.*)/) || [];
      return new RegExp(source, flags);
    }
    if (typeof value === "string" && value.startsWith("_date_") && options.allowDate) {
      return new Date(value.replace("_date_", ""));
    }
    if (typeof value === "string" && value.startsWith("_duplicate_")) {
      refs.push({ target: key, container: this, replacement: value.replace(/^_duplicate_/, "") });
      return null;
    }
    if (typeof value === "string" && value.startsWith("_symbol_") && options.allowSymbol) {
      return Symbol(value.replace("_symbol_", ""));
    }
    if (typeof value === "string" && value.startsWith("_gsymbol_") && options.allowSymbol) {
      return Symbol.for(value.replace("_gsymbol_", ""));
    }
    if (typeof value === "string" && value === "_-Infinity_") {
      return Number.NEGATIVE_INFINITY;
    }
    if (typeof value === "string" && value === "_Infinity_") {
      return Number.POSITIVE_INFINITY;
    }
    if (typeof value === "string" && value === "_NaN_") {
      return Number.NaN;
    }
    if (typeof value === "string" && value.startsWith("_bigint_") && typeof BigInt === "function") {
      return BigInt(value.replace("_bigint_", ""));
    }
    return value;
  }, "revive");
}, "reviver2");
var defaultOptions = {
  maxDepth: 10,
  space: void 0,
  allowRegExp: true,
  allowDate: true,
  allowError: true,
  allowUndefined: true,
  allowSymbol: true
};
var stringify = /* @__PURE__ */ __name((data, options = {}) => {
  const mergedOptions = { ...defaultOptions, ...options };
  return JSON.stringify(convertUnconventionalData(data), replacer(mergedOptions), options.space);
}, "stringify");
var mutator = /* @__PURE__ */ __name(() => {
  const mutated = /* @__PURE__ */ new Map();
  return /* @__PURE__ */ __name(function mutateUndefined(value) {
    if (isObject3(value)) {
      Object.entries(value).forEach(([k2, v2]) => {
        if (v2 === "_undefined_") {
          value[k2] = void 0;
        } else if (!mutated.get(v2)) {
          mutated.set(v2, true);
          mutateUndefined(v2);
        }
      });
    }
    if (Array.isArray(value)) {
      value.forEach((v2, index2) => {
        if (v2 === "_undefined_") {
          mutated.set(v2, true);
          value[index2] = void 0;
        } else if (!mutated.get(v2)) {
          mutated.set(v2, true);
          mutateUndefined(v2);
        }
      });
    }
  }, "mutateUndefined");
}, "mutator");
var parse = /* @__PURE__ */ __name((data, options = {}) => {
  const mergedOptions = { ...defaultOptions, ...options };
  const result = JSON.parse(data, reviver(mergedOptions));
  mutator()(result);
  return result;
}, "parse");

// ../node_modules/tiny-invariant/dist/esm/tiny-invariant.js
var isProduction = true;
var prefix = "Invariant failed";
function invariant(condition, message) {
  if (condition) {
    return;
  }
  if (isProduction) {
    throw new Error(prefix);
  }
  var provided = typeof message === "function" ? message() : message;
  var value = provided ? "".concat(prefix, ": ").concat(provided) : prefix;
  throw new Error(value);
}
__name(invariant, "invariant");

// src/channels/postmessage/getEventSourceUrl.ts
var getEventSourceUrl = /* @__PURE__ */ __name((event) => {
  const frames = Array.from(
    document.querySelectorAll("iframe[data-is-storybook]")
  );
  const [frame, ...remainder] = frames.filter((element) => {
    try {
      return element.contentWindow?.location.origin === event.source.location.origin && element.contentWindow?.location.pathname === event.source.location.pathname;
    } catch (err) {
    }
    try {
      return element.contentWindow === event.source;
    } catch (err) {
    }
    const src2 = element.getAttribute("src");
    let origin;
    try {
      if (!src2) {
        return false;
      }
      ({ origin } = new URL(src2, document.location.toString()));
    } catch (err) {
      return false;
    }
    return origin === event.origin;
  });
  const src = frame?.getAttribute("src");
  if (src && remainder.length === 0) {
    const { protocol, host, pathname } = new URL(src, document.location.toString());
    return `${protocol}//${host}${pathname}`;
  }
  if (remainder.length > 0) {
    logger.error("found multiple candidates for event source");
  }
  return null;
}, "getEventSourceUrl");

// src/channels/postmessage/index.ts
var { document: document2, location } = scope;
var KEY = "storybook-channel";
var defaultEventOptions = { maxDepth: 25 };
var _PostMessageTransport = class _PostMessageTransport {
  constructor(config4) {
    this.config = config4;
    this.connected = false;
    this.buffer = [];
    if (typeof scope?.addEventListener === "function") {
      scope.addEventListener("message", this.handleEvent.bind(this), false);
    }
    if (config4.page !== "manager" && config4.page !== "preview") {
      throw new Error(`postmsg-channel: "config.page" cannot be "${config4.page}"`);
    }
  }
  setHandler(handler) {
    this.handler = (...args) => {
      handler.apply(this, args);
      if (!this.connected && this.getLocalFrame().length) {
        this.flush();
        this.connected = true;
      }
    };
  }
  /**
   * Sends `event` to the associated window. If the window does not yet exist the event will be
   * stored in a buffer and sent when the window exists.
   *
   * @param event
   */
  send(event, options) {
    const {
      target,
      // telejson options
      allowRegExp,
      allowSymbol,
      allowDate,
      allowError,
      allowUndefined,
      maxDepth,
      space
    } = options || {};
    const eventOptions = Object.fromEntries(
      Object.entries({
        allowRegExp,
        allowSymbol,
        allowDate,
        allowError,
        allowUndefined,
        maxDepth,
        space
      }).filter(([k2, v2]) => typeof v2 !== "undefined")
    );
    const stringifyOptions = {
      ...defaultEventOptions,
      ...scope.CHANNEL_OPTIONS || {},
      ...eventOptions
    };
    const frames = this.getFrames(target);
    const query = new URLSearchParams(location?.search || "");
    const data = stringify(
      {
        key: KEY,
        event,
        refId: query.get("refId")
      },
      stringifyOptions
    );
    if (!frames.length) {
      return new Promise((resolve, reject) => {
        this.buffer.push({ event, resolve, reject });
      });
    }
    if (this.buffer.length) {
      this.flush();
    }
    frames.forEach((f4) => {
      try {
        f4.postMessage(data, "*");
      } catch (e2) {
        logger.error("sending over postmessage fail");
      }
    });
    return Promise.resolve(null);
  }
  flush() {
    const { buffer } = this;
    this.buffer = [];
    buffer.forEach((item) => {
      this.send(item.event).then(item.resolve).catch(item.reject);
    });
  }
  getFrames(target) {
    if (this.config.page === "manager") {
      const nodes = Array.from(
        document2.querySelectorAll("iframe[data-is-storybook][data-is-loaded]")
      );
      const list = nodes.flatMap((e2) => {
        try {
          if (!!e2.contentWindow && e2.dataset.isStorybook !== void 0 && e2.id === target) {
            return [e2.contentWindow];
          }
          return [];
        } catch (er) {
          return [];
        }
      });
      return list?.length ? list : this.getCurrentFrames();
    }
    if (scope && scope.parent && scope.parent !== scope.self) {
      return [scope.parent];
    }
    return [];
  }
  getCurrentFrames() {
    if (this.config.page === "manager") {
      const list = Array.from(
        document2.querySelectorAll('[data-is-storybook="true"]')
      );
      return list.flatMap((e2) => e2.contentWindow ? [e2.contentWindow] : []);
    }
    if (scope && scope.parent) {
      return [scope.parent];
    }
    return [];
  }
  getLocalFrame() {
    if (this.config.page === "manager") {
      const list = Array.from(
        document2.querySelectorAll("#storybook-preview-iframe")
      );
      return list.flatMap((e2) => e2.contentWindow ? [e2.contentWindow] : []);
    }
    if (scope && scope.parent) {
      return [scope.parent];
    }
    return [];
  }
  handleEvent(rawEvent) {
    try {
      const { data } = rawEvent;
      const { key, event, refId } = typeof data === "string" && isJSON(data) ? parse(data, scope.CHANNEL_OPTIONS || {}) : data;
      if (key === KEY) {
        const pageString = this.config.page === "manager" ? `<span style="color: #37D5D3; background: black"> manager </span>` : `<span style="color: #1EA7FD; background: black"> preview </span>`;
        const eventString = Object.values(core_events_exports).includes(event.type) ? `<span style="color: #FF4785">${event.type}</span>` : `<span style="color: #FFAE00">${event.type}</span>`;
        if (refId) {
          event.refId = refId;
        }
        event.source = this.config.page === "preview" ? rawEvent.origin : getEventSourceUrl(rawEvent);
        if (!event.source) {
          pretty.error(
            `${pageString} received ${eventString} but was unable to determine the source of the event`
          );
          return;
        }
        const message = `${pageString} received ${eventString} (${data.length})`;
        pretty.debug(
          location.origin !== event.source ? message : `${message} <span style="color: gray">(on ${location.origin} from ${event.source})</span>`,
          ...event.args
        );
        invariant(this.handler, "ChannelHandler should be set");
        this.handler(event);
      }
    } catch (error) {
      logger.error(error);
    }
  }
};
__name(_PostMessageTransport, "PostMessageTransport");
var PostMessageTransport = _PostMessageTransport;

// src/channels/websocket/index.ts
var { WebSocket } = scope;
var HEARTBEAT_INTERVAL = 15e3;
var HEARTBEAT_MAX_LATENCY = 5e3;
var _WebsocketTransport = class _WebsocketTransport {
  constructor({ url, onError, page }) {
    this.buffer = [];
    this.isReady = false;
    this.isClosed = false;
    this.pingTimeout = 0;
    this.socket = new WebSocket(url);
    this.socket.onopen = () => {
      this.isReady = true;
      this.heartbeat();
      this.flush();
    };
    this.socket.onmessage = ({ data }) => {
      const event = typeof data === "string" && isJSON(data) ? parse(data) : data;
      invariant(this.handler, "WebsocketTransport handler should be set");
      this.handler(event);
      if (event.type === "ping") {
        this.heartbeat();
        this.send({ type: "pong" });
      }
    };
    this.socket.onerror = (e2) => {
      if (onError) {
        onError(e2);
      }
    };
    this.socket.onclose = (ev) => {
      invariant(this.handler, "WebsocketTransport handler should be set");
      this.handler({
        type: CHANNEL_WS_DISCONNECT,
        args: [{ reason: ev.reason, code: ev.code }],
        from: page || "preview"
      });
      this.isClosed = true;
      clearTimeout(this.pingTimeout);
    };
  }
  heartbeat() {
    clearTimeout(this.pingTimeout);
    this.pingTimeout = setTimeout(() => {
      this.socket.close(3008, "timeout");
    }, HEARTBEAT_INTERVAL + HEARTBEAT_MAX_LATENCY);
  }
  setHandler(handler) {
    this.handler = handler;
  }
  send(event) {
    if (!this.isClosed) {
      if (!this.isReady) {
        this.sendLater(event);
      } else {
        this.sendNow(event);
      }
    }
  }
  sendLater(event) {
    this.buffer.push(event);
  }
  sendNow(event) {
    const data = stringify(event, {
      maxDepth: 15,
      ...scope.CHANNEL_OPTIONS
    });
    this.socket.send(data);
  }
  flush() {
    const { buffer } = this;
    this.buffer = [];
    buffer.forEach((event) => this.send(event));
  }
};
__name(_WebsocketTransport, "WebsocketTransport");
var WebsocketTransport = _WebsocketTransport;

// src/channels/index.ts
var { CONFIG_TYPE } = scope;
var channels_default = Channel;
function createBrowserChannel({ page, extraTransports = [] }) {
  const transports = [new PostMessageTransport({ page }), ...extraTransports];
  if (CONFIG_TYPE === "DEVELOPMENT") {
    const protocol = window.location.protocol === "http:" ? "ws" : "wss";
    const { hostname, port } = window.location;
    const channelUrl = `${protocol}://${hostname}:${port}/storybook-server-channel`;
    transports.push(new WebsocketTransport({ url: channelUrl, onError: /* @__PURE__ */ __name(() => {
    }, "onError"), page }));
  }
  const channel = new Channel({ transports });
  UniversalStore.__prepare(
    channel,
    page === "manager" ? UniversalStore.Environment.MANAGER : UniversalStore.Environment.PREVIEW
  );
  return channel;
}
__name(createBrowserChannel, "createBrowserChannel");

// src/preview-errors.ts
var preview_errors_exports = {};
__export(preview_errors_exports, {
  CalledExtractOnStoreError: () => CalledExtractOnStoreError,
  CalledPreviewMethodBeforeInitializationError: () => CalledPreviewMethodBeforeInitializationError,
  Category: () => Category,
  ElementA11yParameterError: () => ElementA11yParameterError,
  EmptyIndexError: () => EmptyIndexError,
  ImplicitActionsDuringRendering: () => ImplicitActionsDuringRendering,
  MdxFileWithNoCsfReferencesError: () => MdxFileWithNoCsfReferencesError,
  MissingRenderToCanvasError: () => MissingRenderToCanvasError,
  MissingStoryAfterHmrError: () => MissingStoryAfterHmrError,
  MissingStoryFromCsfFileError: () => MissingStoryFromCsfFileError,
  MountMustBeDestructuredError: () => MountMustBeDestructuredError,
  NextJsSharpError: () => NextJsSharpError,
  NextjsRouterMocksNotAvailable: () => NextjsRouterMocksNotAvailable,
  NoRenderFunctionError: () => NoRenderFunctionError,
  NoStoryMatchError: () => NoStoryMatchError,
  NoStoryMountedError: () => NoStoryMountedError,
  StatusTypeIdMismatchError: () => StatusTypeIdMismatchError,
  StoryIndexFetchError: () => StoryIndexFetchError,
  StoryStoreAccessedBeforeInitializationError: () => StoryStoreAccessedBeforeInitializationError,
  UnknownArgTypesError: () => UnknownArgTypesError,
  UnsupportedViewportDimensionError: () => UnsupportedViewportDimensionError
});

// src/storybook-error.ts
function parseErrorCode({
  code,
  category
}) {
  const paddedCode = String(code).padStart(4, "0");
  return `SB_${category}_${paddedCode}`;
}
__name(parseErrorCode, "parseErrorCode");
function appendErrorRef(url) {
  if (/^(?!.*storybook\.js\.org)|[?&]ref=error\b/.test(url)) {
    return url;
  }
  try {
    const urlObj = new URL(url);
    urlObj.searchParams.set("ref", "error");
    return urlObj.toString();
  } catch {
    return url;
  }
}
__name(appendErrorRef, "appendErrorRef");
var _StorybookError = class _StorybookError extends Error {
  constructor(props) {
    super(_StorybookError.getFullMessage(props));
    /**
     * Data associated with the error. Used to provide additional information in the error message or
     * to be passed to telemetry.
     */
    this.data = {};
    /** Flag used to easily determine if the error originates from Storybook. */
    this.fromStorybook = true;
    this.category = props.category;
    this.documentation = props.documentation ?? false;
    this.code = props.code;
  }
  get fullErrorCode() {
    return parseErrorCode({ code: this.code, category: this.category });
  }
  /** Overrides the default `Error.name` property in the format: SB_<CATEGORY>_<CODE>. */
  get name() {
    const errorName = this.constructor.name;
    return `${this.fullErrorCode} (${errorName})`;
  }
  /** Generates the error message along with additional documentation link (if applicable). */
  static getFullMessage({
    documentation,
    code,
    category,
    message
  }) {
    let page;
    if (documentation === true) {
      page = `https://storybook.js.org/error/${parseErrorCode({ code, category })}?ref=error`;
    } else if (typeof documentation === "string") {
      page = appendErrorRef(documentation);
    } else if (Array.isArray(documentation)) {
      page = `
${documentation.map((doc) => `	- ${appendErrorRef(doc)}`).join("\n")}`;
    }
    return `${message}${page != null ? `

More info: ${page}
` : ""}`;
  }
};
__name(_StorybookError, "StorybookError");
var StorybookError = _StorybookError;

// src/preview-errors.ts
var Category = /* @__PURE__ */ ((Category2) => {
  Category2["BLOCKS"] = "BLOCKS";
  Category2["DOCS_TOOLS"] = "DOCS-TOOLS";
  Category2["PREVIEW_CLIENT_LOGGER"] = "PREVIEW_CLIENT-LOGGER";
  Category2["PREVIEW_CHANNELS"] = "PREVIEW_CHANNELS";
  Category2["PREVIEW_CORE_EVENTS"] = "PREVIEW_CORE-EVENTS";
  Category2["PREVIEW_INSTRUMENTER"] = "PREVIEW_INSTRUMENTER";
  Category2["PREVIEW_API"] = "PREVIEW_API";
  Category2["PREVIEW_REACT_DOM_SHIM"] = "PREVIEW_REACT-DOM-SHIM";
  Category2["PREVIEW_ROUTER"] = "PREVIEW_ROUTER";
  Category2["PREVIEW_THEMING"] = "PREVIEW_THEMING";
  Category2["RENDERER_HTML"] = "RENDERER_HTML";
  Category2["RENDERER_PREACT"] = "RENDERER_PREACT";
  Category2["RENDERER_REACT"] = "RENDERER_REACT";
  Category2["RENDERER_SERVER"] = "RENDERER_SERVER";
  Category2["RENDERER_SVELTE"] = "RENDERER_SVELTE";
  Category2["RENDERER_VUE"] = "RENDERER_VUE";
  Category2["RENDERER_VUE3"] = "RENDERER_VUE3";
  Category2["RENDERER_WEB_COMPONENTS"] = "RENDERER_WEB-COMPONENTS";
  Category2["FRAMEWORK_NEXTJS"] = "FRAMEWORK_NEXTJS";
  Category2["ADDON_VITEST"] = "ADDON_VITEST";
  Category2["ADDON_A11Y"] = "ADDON_A11Y";
  return Category2;
})(Category || {});
var _MissingStoryAfterHmrError = class _MissingStoryAfterHmrError extends StorybookError {
  constructor(data) {
    super({
      category: "PREVIEW_API" /* PREVIEW_API */,
      code: 1,
      message: dedent`
        Couldn't find story matching id '${data.storyId}' after HMR.
        - Did you just rename a story?
        - Did you remove it from your CSF file?
        - Are you sure a story with the id '${data.storyId}' exists?
        - Please check the values in the stories field of your main.js config and see if they would match your CSF File.
        - Also check the browser console and terminal for potential error messages.`
    });
    this.data = data;
  }
};
__name(_MissingStoryAfterHmrError, "MissingStoryAfterHmrError");
var MissingStoryAfterHmrError = _MissingStoryAfterHmrError;
var _ImplicitActionsDuringRendering = class _ImplicitActionsDuringRendering extends StorybookError {
  constructor(data) {
    super({
      category: "PREVIEW_API" /* PREVIEW_API */,
      code: 2,
      documentation: "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#using-implicit-actions-during-rendering-is-deprecated-for-example-in-the-play-function",
      message: dedent`
        We detected that you use an implicit action arg while ${data.phase} of your story.  
        ${data.deprecated ? `
This is deprecated and won't work in Storybook 8 anymore.
` : ``}
        Please provide an explicit spy to your args like this:
          import { fn } from 'storybook/test';
          ... 
          args: {
           ${data.name}: fn()
          }`
    });
    this.data = data;
  }
};
__name(_ImplicitActionsDuringRendering, "ImplicitActionsDuringRendering");
var ImplicitActionsDuringRendering = _ImplicitActionsDuringRendering;
var _CalledExtractOnStoreError = class _CalledExtractOnStoreError extends StorybookError {
  constructor() {
    super({
      category: "PREVIEW_API" /* PREVIEW_API */,
      code: 3,
      message: dedent`
        Cannot call \`storyStore.extract()\` without calling \`storyStore.cacheAllCsfFiles()\` first.

        You probably meant to call \`await preview.extract()\` which does the above for you.`
    });
  }
};
__name(_CalledExtractOnStoreError, "CalledExtractOnStoreError");
var CalledExtractOnStoreError = _CalledExtractOnStoreError;
var _MissingRenderToCanvasError = class _MissingRenderToCanvasError extends StorybookError {
  constructor() {
    super({
      category: "PREVIEW_API" /* PREVIEW_API */,
      code: 4,
      message: dedent`
        Expected your framework's preset to export a \`renderToCanvas\` field.

        Perhaps it needs to be upgraded for Storybook 7.0?`,
      documentation: "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#mainjs-framework-field"
    });
  }
};
__name(_MissingRenderToCanvasError, "MissingRenderToCanvasError");
var MissingRenderToCanvasError = _MissingRenderToCanvasError;
var _CalledPreviewMethodBeforeInitializationError = class _CalledPreviewMethodBeforeInitializationError extends StorybookError {
  constructor(data) {
    super({
      category: "PREVIEW_API" /* PREVIEW_API */,
      code: 5,
      message: dedent`
        Called \`Preview.${data.methodName}()\` before initialization.
        
        The preview needs to load the story index before most methods can be called. If you want
        to call \`${data.methodName}\`, try \`await preview.initializationPromise;\` first.
        
        If you didn't call the above code, then likely it was called by an addon that needs to
        do the above.`
    });
    this.data = data;
  }
};
__name(_CalledPreviewMethodBeforeInitializationError, "CalledPreviewMethodBeforeInitializationError");
var CalledPreviewMethodBeforeInitializationError = _CalledPreviewMethodBeforeInitializationError;
var _StoryIndexFetchError = class _StoryIndexFetchError extends StorybookError {
  constructor(data) {
    super({
      category: "PREVIEW_API" /* PREVIEW_API */,
      code: 6,
      message: dedent`
        Error fetching \`/index.json\`:
        
        ${data.text}

        If you are in development, this likely indicates a problem with your Storybook process,
        check the terminal for errors.

        If you are in a deployed Storybook, there may have been an issue deploying the full Storybook
        build.`
    });
    this.data = data;
  }
};
__name(_StoryIndexFetchError, "StoryIndexFetchError");
var StoryIndexFetchError = _StoryIndexFetchError;
var _MdxFileWithNoCsfReferencesError = class _MdxFileWithNoCsfReferencesError extends StorybookError {
  constructor(data) {
    super({
      category: "PREVIEW_API" /* PREVIEW_API */,
      code: 7,
      message: dedent`
        Tried to render docs entry ${data.storyId} but it is a MDX file that has no CSF
        references, or autodocs for a CSF file that some doesn't refer to itself.
        
        This likely is an internal error in Storybook's indexing, or you've attached the
        \`attached-mdx\` tag to an MDX file that is not attached.`
    });
    this.data = data;
  }
};
__name(_MdxFileWithNoCsfReferencesError, "MdxFileWithNoCsfReferencesError");
var MdxFileWithNoCsfReferencesError = _MdxFileWithNoCsfReferencesError;
var _EmptyIndexError = class _EmptyIndexError extends StorybookError {
  constructor() {
    super({
      category: "PREVIEW_API" /* PREVIEW_API */,
      code: 8,
      message: dedent`
        Couldn't find any stories in your Storybook.

        - Please check your stories field of your main.js config: does it match correctly?
        - Also check the browser console and terminal for error messages.`
    });
  }
};
__name(_EmptyIndexError, "EmptyIndexError");
var EmptyIndexError = _EmptyIndexError;
var _NoStoryMatchError = class _NoStoryMatchError extends StorybookError {
  constructor(data) {
    super({
      category: "PREVIEW_API" /* PREVIEW_API */,
      code: 9,
      message: dedent`
        Couldn't find story matching '${data.storySpecifier}'.

        - Are you sure a story with that id exists?
        - Please check your stories field of your main.js config.
        - Also check the browser console and terminal for error messages.`
    });
    this.data = data;
  }
};
__name(_NoStoryMatchError, "NoStoryMatchError");
var NoStoryMatchError = _NoStoryMatchError;
var _MissingStoryFromCsfFileError = class _MissingStoryFromCsfFileError extends StorybookError {
  constructor(data) {
    super({
      category: "PREVIEW_API" /* PREVIEW_API */,
      code: 10,
      message: dedent`
        Couldn't find story matching id '${data.storyId}' after importing a CSF file.

        The file was indexed as if the story was there, but then after importing the file in the browser
        we didn't find the story. Possible reasons:
        - You are using a custom story indexer that is misbehaving.
        - You have a custom file loader that is removing or renaming exports.

        Please check your browser console and terminal for errors that may explain the issue.`
    });
    this.data = data;
  }
};
__name(_MissingStoryFromCsfFileError, "MissingStoryFromCsfFileError");
var MissingStoryFromCsfFileError = _MissingStoryFromCsfFileError;
var _StoryStoreAccessedBeforeInitializationError = class _StoryStoreAccessedBeforeInitializationError extends StorybookError {
  constructor() {
    super({
      category: "PREVIEW_API" /* PREVIEW_API */,
      code: 11,
      message: dedent`
        Cannot access the Story Store until the index is ready.

        It is not recommended to use methods directly on the Story Store anyway, in Storybook 9 we will
        remove access to the store entirely`
    });
  }
};
__name(_StoryStoreAccessedBeforeInitializationError, "StoryStoreAccessedBeforeInitializationError");
var StoryStoreAccessedBeforeInitializationError = _StoryStoreAccessedBeforeInitializationError;
var _MountMustBeDestructuredError = class _MountMustBeDestructuredError extends StorybookError {
  constructor(data) {
    super({
      category: "PREVIEW_API" /* PREVIEW_API */,
      code: 12,
      message: dedent`
      Incorrect use of mount in the play function.
      
      To use mount in the play function, you must satisfy the following two requirements: 
      
      1. You *must* destructure the mount property from the \`context\` (the argument passed to your play function). 
         This makes sure that Storybook does not start rendering the story before the play function begins.
      
      2. Your Storybook framework or builder must be configured to transpile to ES2017 or newer. 
         This is because destructuring statements and async/await usages are otherwise transpiled away, 
         which prevents Storybook from recognizing your usage of \`mount\`.
      
      Note that Angular is not supported. As async/await is transpiled to support the zone.js polyfill. 
      
      More info: https://storybook.js.org/docs/writing-tests/interaction-testing?ref=error#run-code-before-the-component-gets-rendered
      
      Received the following play function:
      ${data.playFunction}`
    });
    this.data = data;
  }
};
__name(_MountMustBeDestructuredError, "MountMustBeDestructuredError");
var MountMustBeDestructuredError = _MountMustBeDestructuredError;
var _NoRenderFunctionError = class _NoRenderFunctionError extends StorybookError {
  constructor(data) {
    super({
      category: "PREVIEW_API" /* PREVIEW_API */,
      code: 14,
      message: dedent`
        No render function available for storyId '${data.id}'
      `
    });
    this.data = data;
  }
};
__name(_NoRenderFunctionError, "NoRenderFunctionError");
var NoRenderFunctionError = _NoRenderFunctionError;
var _NoStoryMountedError = class _NoStoryMountedError extends StorybookError {
  constructor() {
    super({
      category: "PREVIEW_API" /* PREVIEW_API */,
      code: 15,
      message: dedent`
        No component is mounted in your story.
        
        This usually occurs when you destructure mount in the play function, but forget to call it.
        
        For example:

        async play({ mount, canvasElement }) {
          //  mount should be called: await mount(); 
          const canvas = within(canvasElement);
          const button = await canvas.findByRole('button');
          await userEvent.click(button);
        };

        Make sure to either remove it or call mount in your play function.
      `
    });
  }
};
__name(_NoStoryMountedError, "NoStoryMountedError");
var NoStoryMountedError = _NoStoryMountedError;
var _StatusTypeIdMismatchError = class _StatusTypeIdMismatchError extends StorybookError {
  constructor(data) {
    super({
      category: "PREVIEW_API" /* PREVIEW_API */,
      code: 16,
      message: `Status has typeId "${data.status.typeId}" but was added to store with typeId "${data.typeId}". Full status: ${JSON.stringify(
        data.status,
        null,
        2
      )}`
    });
    this.data = data;
  }
};
__name(_StatusTypeIdMismatchError, "StatusTypeIdMismatchError");
var StatusTypeIdMismatchError = _StatusTypeIdMismatchError;
var _NextJsSharpError = class _NextJsSharpError extends StorybookError {
  constructor() {
    super({
      category: "FRAMEWORK_NEXTJS" /* FRAMEWORK_NEXTJS */,
      code: 1,
      documentation: "https://storybook.js.org/docs/get-started/nextjs#faq",
      message: dedent`
      You are importing avif images, but you don't have sharp installed.

      You have to install sharp in order to use image optimization features in Next.js.
      `
    });
  }
};
__name(_NextJsSharpError, "NextJsSharpError");
var NextJsSharpError = _NextJsSharpError;
var _NextjsRouterMocksNotAvailable = class _NextjsRouterMocksNotAvailable extends StorybookError {
  constructor(data) {
    super({
      category: "FRAMEWORK_NEXTJS" /* FRAMEWORK_NEXTJS */,
      code: 2,
      message: dedent`
        Tried to access router mocks from "${data.importType}" but they were not created yet. You might be running code in an unsupported environment.
      `
    });
    this.data = data;
  }
};
__name(_NextjsRouterMocksNotAvailable, "NextjsRouterMocksNotAvailable");
var NextjsRouterMocksNotAvailable = _NextjsRouterMocksNotAvailable;
var _UnknownArgTypesError = class _UnknownArgTypesError extends StorybookError {
  constructor(data) {
    super({
      category: "DOCS-TOOLS" /* DOCS_TOOLS */,
      code: 1,
      documentation: "https://github.com/storybookjs/storybook/issues/26606",
      message: dedent`
        There was a failure when generating detailed ArgTypes in ${data.language} for:
        ${JSON.stringify(data.type, null, 2)} 
        
        Storybook will fall back to use a generic type description instead.

        This type is either not supported or it is a bug in the docgen generation in Storybook.
        If you think this is a bug, please detail it as much as possible in the Github issue.
      `
    });
    this.data = data;
  }
};
__name(_UnknownArgTypesError, "UnknownArgTypesError");
var UnknownArgTypesError = _UnknownArgTypesError;
var _UnsupportedViewportDimensionError = class _UnsupportedViewportDimensionError extends StorybookError {
  constructor(data) {
    super({
      category: "ADDON_VITEST" /* ADDON_VITEST */,
      code: 1,
      // TODO: Add documentation about viewports support
      // documentation: '',
      message: dedent`
        Encountered an unsupported value "${data.value}" when setting the viewport ${data.dimension} dimension.
        
        The Storybook plugin only supports values in the following units:
        - px, vh, vw, em, rem and %.
        
        You can either change the viewport for this story to use one of the supported units or skip the test by adding '!test' to the story's tags per https://storybook.js.org/docs/writing-stories/tags
      `
    });
    this.data = data;
  }
};
__name(_UnsupportedViewportDimensionError, "UnsupportedViewportDimensionError");
var UnsupportedViewportDimensionError = _UnsupportedViewportDimensionError;
var _ElementA11yParameterError = class _ElementA11yParameterError extends StorybookError {
  constructor() {
    super({
      category: "ADDON_A11Y" /* ADDON_A11Y */,
      code: 1,
      documentation: "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#a11y-addon-replace-element-parameter-with-context-parameter",
      message: 'The "element" parameter in parameters.a11y has been removed. Use "context" instead.'
    });
  }
};
__name(_ElementA11yParameterError, "ElementA11yParameterError");
var ElementA11yParameterError = _ElementA11yParameterError;

// src/types/index.ts
var types_exports = {};
__export(types_exports, {
  Addon_TypesEnum: () => Addon_TypesEnum
});

// src/types/modules/addons.ts
var Addon_TypesEnum = /* @__PURE__ */ ((Addon_TypesEnum2) => {
  Addon_TypesEnum2["TAB"] = "tab";
  Addon_TypesEnum2["PANEL"] = "panel";
  Addon_TypesEnum2["TOOL"] = "tool";
  Addon_TypesEnum2["TOOLEXTRA"] = "toolextra";
  Addon_TypesEnum2["PREVIEW"] = "preview";
  Addon_TypesEnum2["experimental_PAGE"] = "page";
  Addon_TypesEnum2["experimental_TEST_PROVIDER"] = "test-provider";
  return Addon_TypesEnum2;
})(Addon_TypesEnum || {});

// src/actions/index.ts
var actions_exports = {};
__export(actions_exports, {
  ADDON_ID: () => ADDON_ID,
  CLEAR_ID: () => CLEAR_ID,
  CYCLIC_KEY: () => CYCLIC_KEY,
  EVENT_ID: () => EVENT_ID,
  PANEL_ID: () => PANEL_ID,
  PARAM_KEY: () => PARAM_KEY,
  action: () => action,
  actions: () => actions,
  config: () => config3,
  configureActions: () => configureActions
});

// src/actions/constants.ts
var PARAM_KEY = "actions";
var ADDON_ID = "storybook/actions";
var PANEL_ID = `${ADDON_ID}/panel`;
var EVENT_ID = `${ADDON_ID}/action-event`;
var CLEAR_ID = `${ADDON_ID}/action-clear`;
var CYCLIC_KEY = "$___storybook.isCyclic";

// src/preview-api/index.ts
var preview_api_exports = {};
__export(preview_api_exports, {
  DocsContext: () => DocsContext,
  HooksContext: () => HooksContext,
  Preview: () => Preview,
  PreviewWeb: () => PreviewWeb,
  PreviewWithSelection: () => PreviewWithSelection,
  ReporterAPI: () => ReporterAPI,
  StoryStore: () => StoryStore,
  UrlStore: () => UrlStore,
  WebView: () => WebView,
  addons: () => addons,
  applyHooks: () => applyHooks,
  combineArgs: () => combineArgs,
  combineParameters: () => combineParameters,
  composeConfigs: () => composeConfigs,
  composeStepRunners: () => composeStepRunners,
  composeStories: () => composeStories,
  composeStory: () => composeStory,
  createPlaywrightTest: () => createPlaywrightTest,
  decorateStory: () => decorateStory,
  defaultDecorateStory: () => defaultDecorateStory,
  emitTransformCode: () => emitTransformCode,
  filterArgTypes: () => filterArgTypes,
  getCsfFactoryAnnotations: () => getCsfFactoryAnnotations,
  inferControls: () => inferControls,
  makeDecorator: () => makeDecorator,
  mockChannel: () => mockChannel,
  normalizeArrays: () => normalizeArrays,
  normalizeProjectAnnotations: () => normalizeProjectAnnotations,
  normalizeStory: () => normalizeStory,
  pauseAnimations: () => pauseAnimations,
  prepareMeta: () => prepareMeta,
  prepareStory: () => prepareStory,
  sanitizeStoryContextUpdate: () => sanitizeStoryContextUpdate,
  setDefaultProjectAnnotations: () => setDefaultProjectAnnotations,
  setProjectAnnotations: () => setProjectAnnotations,
  simulateDOMContentLoaded: () => simulateDOMContentLoaded,
  simulatePageLoad: () => simulatePageLoad,
  sortStoriesV7: () => sortStoriesV7,
  useArgs: () => useArgs,
  useCallback: () => useCallback,
  useChannel: () => useChannel,
  useEffect: () => useEffect,
  useGlobals: () => useGlobals,
  useMemo: () => useMemo,
  useParameter: () => useParameter,
  useReducer: () => useReducer,
  useRef: () => useRef,
  useState: () => useState,
  useStoryContext: () => useStoryContext,
  userOrAutoTitle: () => userOrAutoTitle,
  userOrAutoTitleFromSpecifier: () => userOrAutoTitleFromSpecifier,
  waitForAnimations: () => waitForAnimations
});

// src/preview-api/modules/addons/storybook-channel-mock.ts
function mockChannel() {
  const transport = {
    setHandler: /* @__PURE__ */ __name(() => {
    }, "setHandler"),
    send: /* @__PURE__ */ __name(() => {
    }, "send")
  };
  return new Channel({ transport });
}
__name(mockChannel, "mockChannel");

// src/preview-api/modules/addons/main.ts
var _AddonStore = class _AddonStore {
  constructor() {
    this.getChannel = /* @__PURE__ */ __name(() => {
      if (!this.channel) {
        const channel = mockChannel();
        this.setChannel(channel);
        return channel;
      }
      return this.channel;
    }, "getChannel");
    this.ready = /* @__PURE__ */ __name(() => this.promise, "ready");
    this.hasChannel = /* @__PURE__ */ __name(() => !!this.channel, "hasChannel");
    this.setChannel = /* @__PURE__ */ __name((channel) => {
      this.channel = channel;
      this.resolve();
    }, "setChannel");
    this.promise = new Promise((res) => {
      this.resolve = () => res(this.getChannel());
    });
  }
};
__name(_AddonStore, "AddonStore");
var AddonStore = _AddonStore;
var KEY2 = "__STORYBOOK_ADDONS_PREVIEW";
function getAddonsStore() {
  if (!scope[KEY2]) {
    scope[KEY2] = new AddonStore();
  }
  return scope[KEY2];
}
__name(getAddonsStore, "getAddonsStore");
var addons = getAddonsStore();

// src/preview-api/modules/addons/hooks.ts
var _HooksContext = class _HooksContext {
  constructor() {
    this.hookListsMap = void 0;
    this.mountedDecorators = void 0;
    this.prevMountedDecorators = void 0;
    this.currentHooks = void 0;
    this.nextHookIndex = void 0;
    this.currentPhase = void 0;
    this.currentEffects = void 0;
    this.prevEffects = void 0;
    this.currentDecoratorName = void 0;
    this.hasUpdates = void 0;
    this.currentContext = void 0;
    this.renderListener = /* @__PURE__ */ __name((storyId) => {
      if (storyId !== this.currentContext?.id) {
        return;
      }
      this.triggerEffects();
      this.currentContext = null;
      this.removeRenderListeners();
    }, "renderListener");
    this.init();
  }
  init() {
    this.hookListsMap = /* @__PURE__ */ new WeakMap();
    this.mountedDecorators = /* @__PURE__ */ new Set();
    this.prevMountedDecorators = /* @__PURE__ */ new Set();
    this.currentHooks = [];
    this.nextHookIndex = 0;
    this.currentPhase = "NONE";
    this.currentEffects = [];
    this.prevEffects = [];
    this.currentDecoratorName = null;
    this.hasUpdates = false;
    this.currentContext = null;
  }
  clean() {
    this.prevEffects.forEach((effect) => {
      if (effect.destroy) {
        effect.destroy();
      }
    });
    this.init();
    this.removeRenderListeners();
  }
  getNextHook() {
    const hook = this.currentHooks[this.nextHookIndex];
    this.nextHookIndex += 1;
    return hook;
  }
  triggerEffects() {
    this.prevEffects.forEach((effect) => {
      if (!this.currentEffects.includes(effect) && effect.destroy) {
        effect.destroy();
      }
    });
    this.currentEffects.forEach((effect) => {
      if (!this.prevEffects.includes(effect)) {
        effect.destroy = effect.create();
      }
    });
    this.prevEffects = this.currentEffects;
    this.currentEffects = [];
  }
  addRenderListeners() {
    this.removeRenderListeners();
    const channel = addons.getChannel();
    channel.on(STORY_RENDERED, this.renderListener);
  }
  removeRenderListeners() {
    const channel = addons.getChannel();
    channel.removeListener(STORY_RENDERED, this.renderListener);
  }
};
__name(_HooksContext, "HooksContext");
var HooksContext = _HooksContext;
function hookify(fn3) {
  const hookified = /* @__PURE__ */ __name((...args) => {
    const { hooks } = typeof args[0] === "function" ? args[1] : args[0];
    const prevPhase = hooks.currentPhase;
    const prevHooks = hooks.currentHooks;
    const prevNextHookIndex = hooks.nextHookIndex;
    const prevDecoratorName = hooks.currentDecoratorName;
    hooks.currentDecoratorName = fn3.name;
    if (hooks.prevMountedDecorators.has(fn3)) {
      hooks.currentPhase = "UPDATE";
      hooks.currentHooks = hooks.hookListsMap.get(fn3) || [];
    } else {
      hooks.currentPhase = "MOUNT";
      hooks.currentHooks = [];
      hooks.hookListsMap.set(fn3, hooks.currentHooks);
      hooks.prevMountedDecorators.add(fn3);
    }
    hooks.nextHookIndex = 0;
    const prevContext = scope.STORYBOOK_HOOKS_CONTEXT;
    scope.STORYBOOK_HOOKS_CONTEXT = hooks;
    const result = fn3(...args);
    scope.STORYBOOK_HOOKS_CONTEXT = prevContext;
    if (hooks.currentPhase === "UPDATE" && hooks.getNextHook() != null) {
      throw new Error(
        "Rendered fewer hooks than expected. This may be caused by an accidental early return statement."
      );
    }
    hooks.currentPhase = prevPhase;
    hooks.currentHooks = prevHooks;
    hooks.nextHookIndex = prevNextHookIndex;
    hooks.currentDecoratorName = prevDecoratorName;
    return result;
  }, "hookified");
  hookified.originalFn = fn3;
  return hookified;
}
__name(hookify, "hookify");
var numberOfRenders = 0;
var RENDER_LIMIT = 25;
var applyHooks = /* @__PURE__ */ __name((applyDecorators) => (storyFn, decorators4) => {
  const decorated = applyDecorators(
    hookify(storyFn),
    decorators4.map((decorator) => hookify(decorator))
  );
  return (context) => {
    const { hooks } = context;
    hooks.prevMountedDecorators ??= /* @__PURE__ */ new Set();
    hooks.mountedDecorators = /* @__PURE__ */ new Set([storyFn, ...decorators4]);
    hooks.currentContext = context;
    hooks.hasUpdates = false;
    let result = decorated(context);
    numberOfRenders = 1;
    while (hooks.hasUpdates) {
      hooks.hasUpdates = false;
      hooks.currentEffects = [];
      result = decorated(context);
      numberOfRenders += 1;
      if (numberOfRenders > RENDER_LIMIT) {
        throw new Error(
          "Too many re-renders. Storybook limits the number of renders to prevent an infinite loop."
        );
      }
    }
    hooks.addRenderListeners();
    return result;
  };
}, "applyHooks");
var areDepsEqual = /* @__PURE__ */ __name((deps, nextDeps) => deps.length === nextDeps.length && deps.every((dep, i2) => dep === nextDeps[i2]), "areDepsEqual");
var invalidHooksError = /* @__PURE__ */ __name(() => new Error("Storybook preview hooks can only be called inside decorators and story functions."), "invalidHooksError");
function getHooksContextOrNull() {
  return scope.STORYBOOK_HOOKS_CONTEXT || null;
}
__name(getHooksContextOrNull, "getHooksContextOrNull");
function getHooksContextOrThrow() {
  const hooks = getHooksContextOrNull();
  if (hooks == null) {
    throw invalidHooksError();
  }
  return hooks;
}
__name(getHooksContextOrThrow, "getHooksContextOrThrow");
function useHook(name, callback, deps) {
  const hooks = getHooksContextOrThrow();
  if (hooks.currentPhase === "MOUNT") {
    if (deps != null && !Array.isArray(deps)) {
      logger.warn(
        `${name} received a final argument that is not an array (instead, received ${deps}). When specified, the final argument must be an array.`
      );
    }
    const hook = { name, deps };
    hooks.currentHooks.push(hook);
    callback(hook);
    return hook;
  }
  if (hooks.currentPhase === "UPDATE") {
    const hook = hooks.getNextHook();
    if (hook == null) {
      throw new Error("Rendered more hooks than during the previous render.");
    }
    if (hook.name !== name) {
      logger.warn(
        `Storybook has detected a change in the order of Hooks${hooks.currentDecoratorName ? ` called by ${hooks.currentDecoratorName}` : ""}. This will lead to bugs and errors if not fixed.`
      );
    }
    if (deps != null && hook.deps == null) {
      logger.warn(
        `${name} received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.`
      );
    }
    if (deps != null && hook.deps != null && deps.length !== hook.deps.length) {
      logger.warn(`The final argument passed to ${name} changed size between renders. The order and size of this array must remain constant.
Previous: ${hook.deps}
Incoming: ${deps}`);
    }
    if (deps == null || hook.deps == null || !areDepsEqual(deps, hook.deps)) {
      callback(hook);
      hook.deps = deps;
    }
    return hook;
  }
  throw invalidHooksError();
}
__name(useHook, "useHook");
function useMemoLike(name, nextCreate, deps) {
  const { memoizedState } = useHook(
    name,
    (hook) => {
      hook.memoizedState = nextCreate();
    },
    deps
  );
  return memoizedState;
}
__name(useMemoLike, "useMemoLike");
function useMemo(nextCreate, deps) {
  return useMemoLike("useMemo", nextCreate, deps);
}
__name(useMemo, "useMemo");
function useCallback(callback, deps) {
  return useMemoLike("useCallback", () => callback, deps);
}
__name(useCallback, "useCallback");
function useRefLike(name, initialValue2) {
  return useMemoLike(name, () => ({ current: initialValue2 }), []);
}
__name(useRefLike, "useRefLike");
function useRef(initialValue2) {
  return useRefLike("useRef", initialValue2);
}
__name(useRef, "useRef");
function triggerUpdate() {
  const hooks = getHooksContextOrNull();
  if (hooks != null && hooks.currentPhase !== "NONE") {
    hooks.hasUpdates = true;
  } else {
    try {
      addons.getChannel().emit(FORCE_RE_RENDER);
    } catch (e2) {
      logger.warn("State updates of Storybook preview hooks work only in browser");
    }
  }
}
__name(triggerUpdate, "triggerUpdate");
function useStateLike(name, initialState) {
  const stateRef = useRefLike(
    name,
    // @ts-expect-error S type should never be function, but there's no way to tell that to TypeScript
    typeof initialState === "function" ? initialState() : initialState
  );
  const setState2 = /* @__PURE__ */ __name((update) => {
    stateRef.current = typeof update === "function" ? update(stateRef.current) : update;
    triggerUpdate();
  }, "setState");
  return [stateRef.current, setState2];
}
__name(useStateLike, "useStateLike");
function useState(initialState) {
  return useStateLike("useState", initialState);
}
__name(useState, "useState");
function useReducer(reducer, initialArg, init2) {
  const initialState = init2 != null ? () => init2(initialArg) : initialArg;
  const [state3, setState2] = useStateLike("useReducer", initialState);
  const dispatch = /* @__PURE__ */ __name((action2) => setState2((prevState) => reducer(prevState, action2)), "dispatch");
  return [state3, dispatch];
}
__name(useReducer, "useReducer");
function useEffect(create, deps) {
  const hooks = getHooksContextOrThrow();
  const effect = useMemoLike("useEffect", () => ({ create }), deps);
  if (!hooks.currentEffects.includes(effect)) {
    hooks.currentEffects.push(effect);
  }
}
__name(useEffect, "useEffect");
function useChannel(eventMap3, deps = []) {
  const channel = addons.getChannel();
  useEffect(() => {
    Object.entries(eventMap3).forEach(([type5, listener]) => channel.on(type5, listener));
    return () => {
      Object.entries(eventMap3).forEach(
        ([type5, listener]) => channel.removeListener(type5, listener)
      );
    };
  }, [...Object.keys(eventMap3), ...deps]);
  return useCallback(channel.emit.bind(channel), [channel]);
}
__name(useChannel, "useChannel");
function useStoryContext() {
  const { currentContext } = getHooksContextOrThrow();
  if (currentContext == null) {
    throw invalidHooksError();
  }
  return currentContext;
}
__name(useStoryContext, "useStoryContext");
function useParameter(parameterKey, defaultValue) {
  const { parameters: parameters2 } = useStoryContext();
  if (parameterKey) {
    return parameters2[parameterKey] ?? defaultValue;
  }
  return void 0;
}
__name(useParameter, "useParameter");
function useArgs() {
  const channel = addons.getChannel();
  const { id: storyId, args } = useStoryContext();
  const updateArgs = useCallback(
    (updatedArgs) => channel.emit(UPDATE_STORY_ARGS, { storyId, updatedArgs }),
    [channel, storyId]
  );
  const resetArgs = useCallback(
    (argNames) => channel.emit(RESET_STORY_ARGS, { storyId, argNames }),
    [channel, storyId]
  );
  return [args, updateArgs, resetArgs];
}
__name(useArgs, "useArgs");
function useGlobals() {
  const channel = addons.getChannel();
  const { globals } = useStoryContext();
  const updateGlobals = useCallback(
    (newGlobals) => channel.emit(UPDATE_GLOBALS, { globals: newGlobals }),
    [channel]
  );
  return [globals, updateGlobals];
}
__name(useGlobals, "useGlobals");

// src/preview-api/modules/addons/make-decorator.ts
var makeDecorator = /* @__PURE__ */ __name(({
  name,
  parameterName,
  wrapper,
  skipIfNoParametersOrOptions = false
}) => {
  const decorator = /* @__PURE__ */ __name((options) => (storyFn, context) => {
    const parameters2 = context.parameters && context.parameters[parameterName];
    if (parameters2 && parameters2.disable) {
      return storyFn(context);
    }
    if (skipIfNoParametersOrOptions && !options && !parameters2) {
      return storyFn(context);
    }
    return wrapper(storyFn, context, {
      options,
      parameters: parameters2
    });
  }, "decorator");
  return (...args) => {
    if (typeof args[0] === "function") {
      return decorator()(...args);
    }
    return (...innerArgs) => {
      if (innerArgs.length > 1) {
        if (args.length > 1) {
          return decorator(args)(...innerArgs);
        }
        return decorator(...args)(...innerArgs);
      }
      throw new Error(
        `Passing stories directly into ${name}() is not allowed,
        instead use addDecorator(${name}) and pass options with the '${parameterName}' parameter`
      );
    };
  };
}, "makeDecorator");

// src/csf/toStartCaseStr.ts
function toStartCaseStr(str2) {
  return str2.replace(/_/g, " ").replace(/-/g, " ").replace(/\./g, " ").replace(/([^\n])([A-Z])([a-z])/g, (str22, $1, $2, $3) => `${$1} ${$2}${$3}`).replace(/([a-z])([A-Z])/g, (str22, $1, $2) => `${$1} ${$2}`).replace(/([a-z])([0-9])/gi, (str22, $1, $2) => `${$1} ${$2}`).replace(/([0-9])([a-z])/gi, (str22, $1, $2) => `${$1} ${$2}`).replace(/(\s|^)(\w)/g, (str22, $1, $2) => `${$1}${$2.toUpperCase()}`).replace(/ +/g, " ").trim();
}
__name(toStartCaseStr, "toStartCaseStr");

// src/csf/includeConditionalArg.ts
var import_tiny_isequal = __toESM(require_tiny_isequal(), 1);
var count = /* @__PURE__ */ __name((vals) => vals.map((v2) => typeof v2 !== "undefined").filter(Boolean).length, "count");
var testValue = /* @__PURE__ */ __name((cond, value) => {
  const { exists, eq: eq4, neq, truthy } = cond;
  if (count([exists, eq4, neq, truthy]) > 1) {
    throw new Error(`Invalid conditional test ${JSON.stringify({ exists, eq: eq4, neq })}`);
  }
  if (typeof eq4 !== "undefined") {
    return (0, import_tiny_isequal.isEqual)(value, eq4);
  }
  if (typeof neq !== "undefined") {
    return !(0, import_tiny_isequal.isEqual)(value, neq);
  }
  if (typeof exists !== "undefined") {
    const valueExists = typeof value !== "undefined";
    return exists ? valueExists : !valueExists;
  }
  const shouldBeTruthy = typeof truthy === "undefined" ? true : truthy;
  return shouldBeTruthy ? !!value : !value;
}, "testValue");
var includeConditionalArg = /* @__PURE__ */ __name((argType, args, globals) => {
  if (!argType.if) {
    return true;
  }
  const { arg, global: global2 } = argType.if;
  if (count([arg, global2]) !== 1) {
    throw new Error(`Invalid conditional value ${JSON.stringify({ arg, global: global2 })}`);
  }
  const value = arg ? args[arg] : globals[global2];
  return testValue(argType.if, value);
}, "includeConditionalArg");

// src/preview-api/modules/preview-web/render/mount-utils.ts
function mountDestructured(playFunction) {
  return playFunction != null && getUsedProps(playFunction).includes("mount");
}
__name(mountDestructured, "mountDestructured");
function getUsedProps(fn3) {
  const match = fn3.toString().match(/[^(]*\(([^)]*)/);
  if (!match) {
    return [];
  }
  const args = splitByComma(match[1]);
  if (!args.length) {
    return [];
  }
  const first = args[0];
  if (!(first.startsWith("{") && first.endsWith("}"))) {
    return [];
  }
  const props = splitByComma(first.slice(1, -1).replace(/\s/g, "")).map((prop) => {
    return prop.replace(/:.*|=.*/g, "");
  });
  return props;
}
__name(getUsedProps, "getUsedProps");
function splitByComma(s3) {
  const result = [];
  const stack = [];
  let start = 0;
  for (let i2 = 0; i2 < s3.length; i2++) {
    if (s3[i2] === "{" || s3[i2] === "[") {
      stack.push(s3[i2] === "{" ? "}" : "]");
    } else if (s3[i2] === stack[stack.length - 1]) {
      stack.pop();
    } else if (!stack.length && s3[i2] === ",") {
      const token = s3.substring(start, i2).trim();
      if (token) {
        result.push(token);
      }
      start = i2 + 1;
    }
  }
  const lastToken = s3.substring(start).trim();
  if (lastToken) {
    result.push(lastToken);
  }
  return result;
}
__name(splitByComma, "splitByComma");

// src/actions/addArgs.ts
var addArgs_exports = {};
__export(addArgs_exports, {
  argsEnhancers: () => argsEnhancers
});

// src/actions/addArgsHelpers.ts
var isInInitialArgs = /* @__PURE__ */ __name((name, initialArgs) => typeof initialArgs[name] === "undefined" && !(name in initialArgs), "isInInitialArgs");
var inferActionsFromArgTypesRegex = /* @__PURE__ */ __name((context) => {
  const {
    initialArgs,
    argTypes,
    id,
    parameters: { actions: actions2 }
  } = context;
  if (!actions2 || actions2.disable || !actions2.argTypesRegex || !argTypes) {
    return {};
  }
  const argTypesRegex = new RegExp(actions2.argTypesRegex);
  const argTypesMatchingRegex = Object.entries(argTypes).filter(
    ([name]) => !!argTypesRegex.test(name)
  );
  return argTypesMatchingRegex.reduce((acc, [name, argType]) => {
    if (isInInitialArgs(name, initialArgs)) {
      acc[name] = action(name, { implicit: true, id });
    }
    return acc;
  }, {});
}, "inferActionsFromArgTypesRegex");
var addActionsFromArgTypes = /* @__PURE__ */ __name((context) => {
  const {
    initialArgs,
    argTypes,
    parameters: { actions: actions2 }
  } = context;
  if (actions2?.disable || !argTypes) {
    return {};
  }
  const argTypesWithAction = Object.entries(argTypes).filter(([name, argType]) => !!argType.action);
  return argTypesWithAction.reduce((acc, [name, argType]) => {
    if (isInInitialArgs(name, initialArgs)) {
      acc[name] = action(typeof argType.action === "string" ? argType.action : name);
    }
    return acc;
  }, {});
}, "addActionsFromArgTypes");

// src/actions/addArgs.ts
var argsEnhancers = [
  addActionsFromArgTypes,
  inferActionsFromArgTypesRegex
];

// src/actions/loaders.ts
var loaders_exports = {};
__export(loaders_exports, {
  loaders: () => loaders
});

// src/test/index.ts
var test_exports = {};
__export(test_exports, {
  buildQueries: () => buildQueries2,
  clearAllMocks: () => clearAllMocks,
  configure: () => configure2,
  createEvent: () => createEvent3,
  expect: () => expect3,
  findAllByAltText: () => findAllByAltText2,
  findAllByDisplayValue: () => findAllByDisplayValue2,
  findAllByLabelText: () => findAllByLabelText2,
  findAllByPlaceholderText: () => findAllByPlaceholderText2,
  findAllByRole: () => findAllByRole2,
  findAllByTestId: () => findAllByTestId2,
  findAllByText: () => findAllByText2,
  findAllByTitle: () => findAllByTitle2,
  findByAltText: () => findByAltText2,
  findByDisplayValue: () => findByDisplayValue2,
  findByLabelText: () => findByLabelText2,
  findByPlaceholderText: () => findByPlaceholderText2,
  findByRole: () => findByRole2,
  findByTestId: () => findByTestId2,
  findByText: () => findByText2,
  findByTitle: () => findByTitle2,
  fireEvent: () => fireEvent2,
  fn: () => fn2,
  getAllByAltText: () => getAllByAltText2,
  getAllByDisplayValue: () => getAllByDisplayValue2,
  getAllByLabelText: () => getAllByLabelText2,
  getAllByPlaceholderText: () => getAllByPlaceholderText2,
  getAllByRole: () => getAllByRole2,
  getAllByTestId: () => getAllByTestId2,
  getAllByText: () => getAllByText2,
  getAllByTitle: () => getAllByTitle2,
  getByAltText: () => getByAltText2,
  getByDisplayValue: () => getByDisplayValue2,
  getByLabelText: () => getByLabelText2,
  getByPlaceholderText: () => getByPlaceholderText2,
  getByRole: () => getByRole2,
  getByTestId: () => getByTestId2,
  getByText: () => getByText2,
  getByTitle: () => getByTitle2,
  getConfig: () => getConfig3,
  getDefaultNormalizer: () => getDefaultNormalizer2,
  getElementError: () => getElementError2,
  getNodeText: () => getNodeText2,
  getQueriesForElement: () => getQueriesForElement2,
  getRoles: () => getRoles2,
  getSuggestedQuery: () => getSuggestedQuery2,
  isInaccessible: () => isInaccessible2,
  isMockFunction: () => isMockFunction,
  logDOM: () => logDOM2,
  logRoles: () => logRoles2,
  mocked: () => mocked,
  mocks: () => mocks,
  onMockCall: () => onMockCall,
  prettyDOM: () => prettyDOM2,
  prettyFormat: () => prettyFormat2,
  queries: () => queries2,
  queryAllByAltText: () => queryAllByAltText2,
  queryAllByAttribute: () => queryAllByAttribute2,
  queryAllByDisplayValue: () => queryAllByDisplayValue2,
  queryAllByLabelText: () => queryAllByLabelText2,
  queryAllByPlaceholderText: () => queryAllByPlaceholderText2,
  queryAllByRole: () => queryAllByRole2,
  queryAllByTestId: () => queryAllByTestId2,
  queryAllByText: () => queryAllByText2,
  queryAllByTitle: () => queryAllByTitle2,
  queryByAltText: () => queryByAltText2,
  queryByAttribute: () => queryByAttribute2,
  queryByDisplayValue: () => queryByDisplayValue2,
  queryByLabelText: () => queryByLabelText2,
  queryByPlaceholderText: () => queryByPlaceholderText2,
  queryByRole: () => queryByRole2,
  queryByTestId: () => queryByTestId2,
  queryByText: () => queryByText2,
  queryByTitle: () => queryByTitle2,
  queryHelpers: () => queryHelpers2,
  resetAllMocks: () => resetAllMocks,
  restoreAllMocks: () => restoreAllMocks,
  sb: () => sb,
  screen: () => screen2,
  spyOn: () => spyOn2,
  uninstrumentedUserEvent: () => uninstrumentedUserEvent,
  userEvent: () => userEvent2,
  waitFor: () => waitFor2,
  waitForElementToBeRemoved: () => waitForElementToBeRemoved2,
  within: () => within
});

// ../node_modules/tinyrainbow/dist/chunk-BVHSVHOK.js
var f = {
  reset: [0, 0],
  bold: [1, 22, "\x1B[22m\x1B[1m"],
  dim: [2, 22, "\x1B[22m\x1B[2m"],
  italic: [3, 23],
  underline: [4, 24],
  inverse: [7, 27],
  hidden: [8, 28],
  strikethrough: [9, 29],
  black: [30, 39],
  red: [31, 39],
  green: [32, 39],
  yellow: [33, 39],
  blue: [34, 39],
  magenta: [35, 39],
  cyan: [36, 39],
  white: [37, 39],
  gray: [90, 39],
  bgBlack: [40, 49],
  bgRed: [41, 49],
  bgGreen: [42, 49],
  bgYellow: [43, 49],
  bgBlue: [44, 49],
  bgMagenta: [45, 49],
  bgCyan: [46, 49],
  bgWhite: [47, 49],
  blackBright: [90, 39],
  redBright: [91, 39],
  greenBright: [92, 39],
  yellowBright: [93, 39],
  blueBright: [94, 39],
  magentaBright: [95, 39],
  cyanBright: [96, 39],
  whiteBright: [97, 39],
  bgBlackBright: [100, 49],
  bgRedBright: [101, 49],
  bgGreenBright: [102, 49],
  bgYellowBright: [103, 49],
  bgBlueBright: [104, 49],
  bgMagentaBright: [105, 49],
  bgCyanBright: [106, 49],
  bgWhiteBright: [107, 49]
};
var h = Object.entries(f);
function a(n2) {
  return String(n2);
}
__name(a, "a");
a.open = "";
a.close = "";
var B = h.reduce(
  (n2, [e2]) => (n2[e2] = a, n2),
  { isColorSupported: false }
);
function C(n2 = false) {
  let e2 = typeof process != "undefined" ? process : void 0, i2 = (e2 == null ? void 0 : e2.env) || {}, g2 = (e2 == null ? void 0 : e2.argv) || [];
  return !("NO_COLOR" in i2 || g2.includes("--no-color")) && ("FORCE_COLOR" in i2 || g2.includes("--color") || (e2 == null ? void 0 : e2.platform) === "win32" || n2 && i2.TERM !== "dumb" || "CI" in i2) || typeof window != "undefined" && !!window.chrome;
}
__name(C, "C");
function p(n2 = false) {
  let e2 = C(n2), i2 = /* @__PURE__ */ __name((r2, t2, c2, o2) => {
    let l2 = "", s3 = 0;
    do
      l2 += r2.substring(s3, o2) + c2, s3 = o2 + t2.length, o2 = r2.indexOf(t2, s3);
    while (~o2);
    return l2 + r2.substring(s3);
  }, "i"), g2 = /* @__PURE__ */ __name((r2, t2, c2 = r2) => {
    let o2 = /* @__PURE__ */ __name((l2) => {
      let s3 = String(l2), b2 = s3.indexOf(t2, r2.length);
      return ~b2 ? r2 + i2(s3, t2, c2, b2) + t2 : r2 + s3 + t2;
    }, "o");
    return o2.open = r2, o2.close = t2, o2;
  }, "g"), u3 = {
    isColorSupported: e2
  }, d = /* @__PURE__ */ __name((r2) => `\x1B[${r2}m`, "d");
  for (let [r2, t2] of h)
    u3[r2] = e2 ? g2(
      d(t2[0]),
      d(t2[1]),
      t2[2]
    ) : a;
  return u3;
}
__name(p, "p");

// ../node_modules/tinyrainbow/dist/browser.js
var s = p();

// ../node_modules/@vitest/pretty-format/dist/index.js
function _mergeNamespaces(n2, m3) {
  m3.forEach(function(e2) {
    e2 && typeof e2 !== "string" && !Array.isArray(e2) && Object.keys(e2).forEach(function(k2) {
      if (k2 !== "default" && !(k2 in n2)) {
        var d = Object.getOwnPropertyDescriptor(e2, k2);
        Object.defineProperty(n2, k2, d.get ? d : {
          enumerable: true,
          get: /* @__PURE__ */ __name(function() {
            return e2[k2];
          }, "get")
        });
      }
    });
  });
  return Object.freeze(n2);
}
__name(_mergeNamespaces, "_mergeNamespaces");
function getKeysOfEnumerableProperties(object, compareKeys) {
  const rawKeys = Object.keys(object);
  const keys2 = compareKeys === null ? rawKeys : rawKeys.sort(compareKeys);
  if (Object.getOwnPropertySymbols) {
    for (const symbol of Object.getOwnPropertySymbols(object)) {
      if (Object.getOwnPropertyDescriptor(object, symbol).enumerable) {
        keys2.push(symbol);
      }
    }
  }
  return keys2;
}
__name(getKeysOfEnumerableProperties, "getKeysOfEnumerableProperties");
function printIteratorEntries(iterator, config4, indentation, depth, refs, printer2, separator = ": ") {
  let result = "";
  let width = 0;
  let current = iterator.next();
  if (!current.done) {
    result += config4.spacingOuter;
    const indentationNext = indentation + config4.indent;
    while (!current.done) {
      result += indentationNext;
      if (width++ === config4.maxWidth) {
        result += "\u2026";
        break;
      }
      const name = printer2(current.value[0], config4, indentationNext, depth, refs);
      const value = printer2(current.value[1], config4, indentationNext, depth, refs);
      result += name + separator + value;
      current = iterator.next();
      if (!current.done) {
        result += `,${config4.spacingInner}`;
      } else if (!config4.min) {
        result += ",";
      }
    }
    result += config4.spacingOuter + indentation;
  }
  return result;
}
__name(printIteratorEntries, "printIteratorEntries");
function printIteratorValues(iterator, config4, indentation, depth, refs, printer2) {
  let result = "";
  let width = 0;
  let current = iterator.next();
  if (!current.done) {
    result += config4.spacingOuter;
    const indentationNext = indentation + config4.indent;
    while (!current.done) {
      result += indentationNext;
      if (width++ === config4.maxWidth) {
        result += "\u2026";
        break;
      }
      result += printer2(current.value, config4, indentationNext, depth, refs);
      current = iterator.next();
      if (!current.done) {
        result += `,${config4.spacingInner}`;
      } else if (!config4.min) {
        result += ",";
      }
    }
    result += config4.spacingOuter + indentation;
  }
  return result;
}
__name(printIteratorValues, "printIteratorValues");
function printListItems(list, config4, indentation, depth, refs, printer2) {
  let result = "";
  list = list instanceof ArrayBuffer ? new DataView(list) : list;
  const isDataView = /* @__PURE__ */ __name((l2) => l2 instanceof DataView, "isDataView");
  const length = isDataView(list) ? list.byteLength : list.length;
  if (length > 0) {
    result += config4.spacingOuter;
    const indentationNext = indentation + config4.indent;
    for (let i2 = 0; i2 < length; i2++) {
      result += indentationNext;
      if (i2 === config4.maxWidth) {
        result += "\u2026";
        break;
      }
      if (isDataView(list) || i2 in list) {
        result += printer2(isDataView(list) ? list.getInt8(i2) : list[i2], config4, indentationNext, depth, refs);
      }
      if (i2 < length - 1) {
        result += `,${config4.spacingInner}`;
      } else if (!config4.min) {
        result += ",";
      }
    }
    result += config4.spacingOuter + indentation;
  }
  return result;
}
__name(printListItems, "printListItems");
function printObjectProperties(val, config4, indentation, depth, refs, printer2) {
  let result = "";
  const keys2 = getKeysOfEnumerableProperties(val, config4.compareKeys);
  if (keys2.length > 0) {
    result += config4.spacingOuter;
    const indentationNext = indentation + config4.indent;
    for (let i2 = 0; i2 < keys2.length; i2++) {
      const key = keys2[i2];
      const name = printer2(key, config4, indentationNext, depth, refs);
      const value = printer2(val[key], config4, indentationNext, depth, refs);
      result += `${indentationNext + name}: ${value}`;
      if (i2 < keys2.length - 1) {
        result += `,${config4.spacingInner}`;
      } else if (!config4.min) {
        result += ",";
      }
    }
    result += config4.spacingOuter + indentation;
  }
  return result;
}
__name(printObjectProperties, "printObjectProperties");
var asymmetricMatcher = typeof Symbol === "function" && Symbol.for ? Symbol.for("jest.asymmetricMatcher") : 1267621;
var SPACE$2 = " ";
var serialize$5 = /* @__PURE__ */ __name((val, config4, indentation, depth, refs, printer2) => {
  const stringedValue = val.toString();
  if (stringedValue === "ArrayContaining" || stringedValue === "ArrayNotContaining") {
    if (++depth > config4.maxDepth) {
      return `[${stringedValue}]`;
    }
    return `${stringedValue + SPACE$2}[${printListItems(val.sample, config4, indentation, depth, refs, printer2)}]`;
  }
  if (stringedValue === "ObjectContaining" || stringedValue === "ObjectNotContaining") {
    if (++depth > config4.maxDepth) {
      return `[${stringedValue}]`;
    }
    return `${stringedValue + SPACE$2}{${printObjectProperties(val.sample, config4, indentation, depth, refs, printer2)}}`;
  }
  if (stringedValue === "StringMatching" || stringedValue === "StringNotMatching") {
    return stringedValue + SPACE$2 + printer2(val.sample, config4, indentation, depth, refs);
  }
  if (stringedValue === "StringContaining" || stringedValue === "StringNotContaining") {
    return stringedValue + SPACE$2 + printer2(val.sample, config4, indentation, depth, refs);
  }
  if (typeof val.toAsymmetricMatcher !== "function") {
    throw new TypeError(`Asymmetric matcher ${val.constructor.name} does not implement toAsymmetricMatcher()`);
  }
  return val.toAsymmetricMatcher();
}, "serialize$5");
var test$5 = /* @__PURE__ */ __name((val) => val && val.$$typeof === asymmetricMatcher, "test$5");
var plugin$5 = {
  serialize: serialize$5,
  test: test$5
};
var SPACE$1 = " ";
var OBJECT_NAMES = /* @__PURE__ */ new Set(["DOMStringMap", "NamedNodeMap"]);
var ARRAY_REGEXP = /^(?:HTML\w*Collection|NodeList)$/;
function testName(name) {
  return OBJECT_NAMES.has(name) || ARRAY_REGEXP.test(name);
}
__name(testName, "testName");
var test$4 = /* @__PURE__ */ __name((val) => val && val.constructor && !!val.constructor.name && testName(val.constructor.name), "test$4");
function isNamedNodeMap(collection) {
  return collection.constructor.name === "NamedNodeMap";
}
__name(isNamedNodeMap, "isNamedNodeMap");
var serialize$4 = /* @__PURE__ */ __name((collection, config4, indentation, depth, refs, printer2) => {
  const name = collection.constructor.name;
  if (++depth > config4.maxDepth) {
    return `[${name}]`;
  }
  return (config4.min ? "" : name + SPACE$1) + (OBJECT_NAMES.has(name) ? `{${printObjectProperties(isNamedNodeMap(collection) ? [...collection].reduce((props, attribute) => {
    props[attribute.name] = attribute.value;
    return props;
  }, {}) : { ...collection }, config4, indentation, depth, refs, printer2)}}` : `[${printListItems([...collection], config4, indentation, depth, refs, printer2)}]`);
}, "serialize$4");
var plugin$4 = {
  serialize: serialize$4,
  test: test$4
};
function escapeHTML(str2) {
  return str2.replaceAll("<", "&lt;").replaceAll(">", "&gt;");
}
__name(escapeHTML, "escapeHTML");
function printProps(keys2, props, config4, indentation, depth, refs, printer2) {
  const indentationNext = indentation + config4.indent;
  const colors3 = config4.colors;
  return keys2.map((key) => {
    const value = props[key];
    let printed = printer2(value, config4, indentationNext, depth, refs);
    if (typeof value !== "string") {
      if (printed.includes("\n")) {
        printed = config4.spacingOuter + indentationNext + printed + config4.spacingOuter + indentation;
      }
      printed = `{${printed}}`;
    }
    return `${config4.spacingInner + indentation + colors3.prop.open + key + colors3.prop.close}=${colors3.value.open}${printed}${colors3.value.close}`;
  }).join("");
}
__name(printProps, "printProps");
function printChildren(children, config4, indentation, depth, refs, printer2) {
  return children.map((child) => config4.spacingOuter + indentation + (typeof child === "string" ? printText(child, config4) : printer2(child, config4, indentation, depth, refs))).join("");
}
__name(printChildren, "printChildren");
function printText(text, config4) {
  const contentColor = config4.colors.content;
  return contentColor.open + escapeHTML(text) + contentColor.close;
}
__name(printText, "printText");
function printComment(comment, config4) {
  const commentColor = config4.colors.comment;
  return `${commentColor.open}<!--${escapeHTML(comment)}-->${commentColor.close}`;
}
__name(printComment, "printComment");
function printElement(type5, printedProps, printedChildren, config4, indentation) {
  const tagColor = config4.colors.tag;
  return `${tagColor.open}<${type5}${printedProps && tagColor.close + printedProps + config4.spacingOuter + indentation + tagColor.open}${printedChildren ? `>${tagColor.close}${printedChildren}${config4.spacingOuter}${indentation}${tagColor.open}</${type5}` : `${printedProps && !config4.min ? "" : " "}/`}>${tagColor.close}`;
}
__name(printElement, "printElement");
function printElementAsLeaf(type5, config4) {
  const tagColor = config4.colors.tag;
  return `${tagColor.open}<${type5}${tagColor.close} \u2026${tagColor.open} />${tagColor.close}`;
}
__name(printElementAsLeaf, "printElementAsLeaf");
var ELEMENT_NODE = 1;
var TEXT_NODE = 3;
var COMMENT_NODE = 8;
var FRAGMENT_NODE = 11;
var ELEMENT_REGEXP = /^(?:(?:HTML|SVG)\w*)?Element$/;
function testHasAttribute(val) {
  try {
    return typeof val.hasAttribute === "function" && val.hasAttribute("is");
  } catch {
    return false;
  }
}
__name(testHasAttribute, "testHasAttribute");
function testNode(val) {
  const constructorName = val.constructor.name;
  const { nodeType, tagName } = val;
  const isCustomElement3 = typeof tagName === "string" && tagName.includes("-") || testHasAttribute(val);
  return nodeType === ELEMENT_NODE && (ELEMENT_REGEXP.test(constructorName) || isCustomElement3) || nodeType === TEXT_NODE && constructorName === "Text" || nodeType === COMMENT_NODE && constructorName === "Comment" || nodeType === FRAGMENT_NODE && constructorName === "DocumentFragment";
}
__name(testNode, "testNode");
var test$3 = /* @__PURE__ */ __name((val) => {
  var _val$constructor;
  return (val === null || val === void 0 || (_val$constructor = val.constructor) === null || _val$constructor === void 0 ? void 0 : _val$constructor.name) && testNode(val);
}, "test$3");
function nodeIsText(node) {
  return node.nodeType === TEXT_NODE;
}
__name(nodeIsText, "nodeIsText");
function nodeIsComment(node) {
  return node.nodeType === COMMENT_NODE;
}
__name(nodeIsComment, "nodeIsComment");
function nodeIsFragment(node) {
  return node.nodeType === FRAGMENT_NODE;
}
__name(nodeIsFragment, "nodeIsFragment");
var serialize$3 = /* @__PURE__ */ __name((node, config4, indentation, depth, refs, printer2) => {
  if (nodeIsText(node)) {
    return printText(node.data, config4);
  }
  if (nodeIsComment(node)) {
    return printComment(node.data, config4);
  }
  const type5 = nodeIsFragment(node) ? "DocumentFragment" : node.tagName.toLowerCase();
  if (++depth > config4.maxDepth) {
    return printElementAsLeaf(type5, config4);
  }
  return printElement(type5, printProps(nodeIsFragment(node) ? [] : Array.from(node.attributes, (attr) => attr.name).sort(), nodeIsFragment(node) ? {} : [...node.attributes].reduce((props, attribute) => {
    props[attribute.name] = attribute.value;
    return props;
  }, {}), config4, indentation + config4.indent, depth, refs, printer2), printChildren(Array.prototype.slice.call(node.childNodes || node.children), config4, indentation + config4.indent, depth, refs, printer2), config4, indentation);
}, "serialize$3");
var plugin$3 = {
  serialize: serialize$3,
  test: test$3
};
var IS_ITERABLE_SENTINEL = "@@__IMMUTABLE_ITERABLE__@@";
var IS_LIST_SENTINEL = "@@__IMMUTABLE_LIST__@@";
var IS_KEYED_SENTINEL = "@@__IMMUTABLE_KEYED__@@";
var IS_MAP_SENTINEL = "@@__IMMUTABLE_MAP__@@";
var IS_ORDERED_SENTINEL = "@@__IMMUTABLE_ORDERED__@@";
var IS_RECORD_SENTINEL = "@@__IMMUTABLE_RECORD__@@";
var IS_SEQ_SENTINEL = "@@__IMMUTABLE_SEQ__@@";
var IS_SET_SENTINEL = "@@__IMMUTABLE_SET__@@";
var IS_STACK_SENTINEL = "@@__IMMUTABLE_STACK__@@";
var getImmutableName = /* @__PURE__ */ __name((name) => `Immutable.${name}`, "getImmutableName");
var printAsLeaf = /* @__PURE__ */ __name((name) => `[${name}]`, "printAsLeaf");
var SPACE = " ";
var LAZY = "\u2026";
function printImmutableEntries(val, config4, indentation, depth, refs, printer2, type5) {
  return ++depth > config4.maxDepth ? printAsLeaf(getImmutableName(type5)) : `${getImmutableName(type5) + SPACE}{${printIteratorEntries(val.entries(), config4, indentation, depth, refs, printer2)}}`;
}
__name(printImmutableEntries, "printImmutableEntries");
function getRecordEntries(val) {
  let i2 = 0;
  return { next() {
    if (i2 < val._keys.length) {
      const key = val._keys[i2++];
      return {
        done: false,
        value: [key, val.get(key)]
      };
    }
    return {
      done: true,
      value: void 0
    };
  } };
}
__name(getRecordEntries, "getRecordEntries");
function printImmutableRecord(val, config4, indentation, depth, refs, printer2) {
  const name = getImmutableName(val._name || "Record");
  return ++depth > config4.maxDepth ? printAsLeaf(name) : `${name + SPACE}{${printIteratorEntries(getRecordEntries(val), config4, indentation, depth, refs, printer2)}}`;
}
__name(printImmutableRecord, "printImmutableRecord");
function printImmutableSeq(val, config4, indentation, depth, refs, printer2) {
  const name = getImmutableName("Seq");
  if (++depth > config4.maxDepth) {
    return printAsLeaf(name);
  }
  if (val[IS_KEYED_SENTINEL]) {
    return `${name + SPACE}{${val._iter || val._object ? printIteratorEntries(val.entries(), config4, indentation, depth, refs, printer2) : LAZY}}`;
  }
  return `${name + SPACE}[${val._iter || val._array || val._collection || val._iterable ? printIteratorValues(val.values(), config4, indentation, depth, refs, printer2) : LAZY}]`;
}
__name(printImmutableSeq, "printImmutableSeq");
function printImmutableValues(val, config4, indentation, depth, refs, printer2, type5) {
  return ++depth > config4.maxDepth ? printAsLeaf(getImmutableName(type5)) : `${getImmutableName(type5) + SPACE}[${printIteratorValues(val.values(), config4, indentation, depth, refs, printer2)}]`;
}
__name(printImmutableValues, "printImmutableValues");
var serialize$2 = /* @__PURE__ */ __name((val, config4, indentation, depth, refs, printer2) => {
  if (val[IS_MAP_SENTINEL]) {
    return printImmutableEntries(val, config4, indentation, depth, refs, printer2, val[IS_ORDERED_SENTINEL] ? "OrderedMap" : "Map");
  }
  if (val[IS_LIST_SENTINEL]) {
    return printImmutableValues(val, config4, indentation, depth, refs, printer2, "List");
  }
  if (val[IS_SET_SENTINEL]) {
    return printImmutableValues(val, config4, indentation, depth, refs, printer2, val[IS_ORDERED_SENTINEL] ? "OrderedSet" : "Set");
  }
  if (val[IS_STACK_SENTINEL]) {
    return printImmutableValues(val, config4, indentation, depth, refs, printer2, "Stack");
  }
  if (val[IS_SEQ_SENTINEL]) {
    return printImmutableSeq(val, config4, indentation, depth, refs, printer2);
  }
  return printImmutableRecord(val, config4, indentation, depth, refs, printer2);
}, "serialize$2");
var test$2 = /* @__PURE__ */ __name((val) => val && (val[IS_ITERABLE_SENTINEL] === true || val[IS_RECORD_SENTINEL] === true), "test$2");
var plugin$2 = {
  serialize: serialize$2,
  test: test$2
};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
__name(getDefaultExportFromCjs, "getDefaultExportFromCjs");
var reactIs$1 = { exports: {} };
var reactIs_production = {};
var hasRequiredReactIs_production;
function requireReactIs_production() {
  if (hasRequiredReactIs_production) return reactIs_production;
  hasRequiredReactIs_production = 1;
  var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
  var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
  function typeOf(object) {
    if ("object" === typeof object && null !== object) {
      var $$typeof = object.$$typeof;
      switch ($$typeof) {
        case REACT_ELEMENT_TYPE:
          switch (object = object.type, object) {
            case REACT_FRAGMENT_TYPE:
            case REACT_PROFILER_TYPE:
            case REACT_STRICT_MODE_TYPE:
            case REACT_SUSPENSE_TYPE:
            case REACT_SUSPENSE_LIST_TYPE:
            case REACT_VIEW_TRANSITION_TYPE:
              return object;
            default:
              switch (object = object && object.$$typeof, object) {
                case REACT_CONTEXT_TYPE:
                case REACT_FORWARD_REF_TYPE:
                case REACT_LAZY_TYPE:
                case REACT_MEMO_TYPE:
                  return object;
                case REACT_CONSUMER_TYPE:
                  return object;
                default:
                  return $$typeof;
              }
          }
        case REACT_PORTAL_TYPE:
          return $$typeof;
      }
    }
  }
  __name(typeOf, "typeOf");
  reactIs_production.ContextConsumer = REACT_CONSUMER_TYPE;
  reactIs_production.ContextProvider = REACT_CONTEXT_TYPE;
  reactIs_production.Element = REACT_ELEMENT_TYPE;
  reactIs_production.ForwardRef = REACT_FORWARD_REF_TYPE;
  reactIs_production.Fragment = REACT_FRAGMENT_TYPE;
  reactIs_production.Lazy = REACT_LAZY_TYPE;
  reactIs_production.Memo = REACT_MEMO_TYPE;
  reactIs_production.Portal = REACT_PORTAL_TYPE;
  reactIs_production.Profiler = REACT_PROFILER_TYPE;
  reactIs_production.StrictMode = REACT_STRICT_MODE_TYPE;
  reactIs_production.Suspense = REACT_SUSPENSE_TYPE;
  reactIs_production.SuspenseList = REACT_SUSPENSE_LIST_TYPE;
  reactIs_production.isContextConsumer = function(object) {
    return typeOf(object) === REACT_CONSUMER_TYPE;
  };
  reactIs_production.isContextProvider = function(object) {
    return typeOf(object) === REACT_CONTEXT_TYPE;
  };
  reactIs_production.isElement = function(object) {
    return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
  };
  reactIs_production.isForwardRef = function(object) {
    return typeOf(object) === REACT_FORWARD_REF_TYPE;
  };
  reactIs_production.isFragment = function(object) {
    return typeOf(object) === REACT_FRAGMENT_TYPE;
  };
  reactIs_production.isLazy = function(object) {
    return typeOf(object) === REACT_LAZY_TYPE;
  };
  reactIs_production.isMemo = function(object) {
    return typeOf(object) === REACT_MEMO_TYPE;
  };
  reactIs_production.isPortal = function(object) {
    return typeOf(object) === REACT_PORTAL_TYPE;
  };
  reactIs_production.isProfiler = function(object) {
    return typeOf(object) === REACT_PROFILER_TYPE;
  };
  reactIs_production.isStrictMode = function(object) {
    return typeOf(object) === REACT_STRICT_MODE_TYPE;
  };
  reactIs_production.isSuspense = function(object) {
    return typeOf(object) === REACT_SUSPENSE_TYPE;
  };
  reactIs_production.isSuspenseList = function(object) {
    return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
  };
  reactIs_production.isValidElementType = function(type5) {
    return "string" === typeof type5 || "function" === typeof type5 || type5 === REACT_FRAGMENT_TYPE || type5 === REACT_PROFILER_TYPE || type5 === REACT_STRICT_MODE_TYPE || type5 === REACT_SUSPENSE_TYPE || type5 === REACT_SUSPENSE_LIST_TYPE || "object" === typeof type5 && null !== type5 && (type5.$$typeof === REACT_LAZY_TYPE || type5.$$typeof === REACT_MEMO_TYPE || type5.$$typeof === REACT_CONTEXT_TYPE || type5.$$typeof === REACT_CONSUMER_TYPE || type5.$$typeof === REACT_FORWARD_REF_TYPE || type5.$$typeof === REACT_CLIENT_REFERENCE || void 0 !== type5.getModuleId) ? true : false;
  };
  reactIs_production.typeOf = typeOf;
  return reactIs_production;
}
__name(requireReactIs_production, "requireReactIs_production");
var hasRequiredReactIs$1;
function requireReactIs$1() {
  if (hasRequiredReactIs$1) return reactIs$1.exports;
  hasRequiredReactIs$1 = 1;
  if (true) {
    reactIs$1.exports = requireReactIs_production();
  } else {
    reactIs$1.exports = requireReactIs_development$1();
  }
  return reactIs$1.exports;
}
__name(requireReactIs$1, "requireReactIs$1");
var reactIsExports$1 = requireReactIs$1();
var index$1 = getDefaultExportFromCjs(reactIsExports$1);
var ReactIs19 = _mergeNamespaces({
  __proto__: null,
  default: index$1
}, [reactIsExports$1]);
var reactIs = { exports: {} };
var reactIs_production_min = {};
var hasRequiredReactIs_production_min;
function requireReactIs_production_min() {
  if (hasRequiredReactIs_production_min) return reactIs_production_min;
  hasRequiredReactIs_production_min = 1;
  var b2 = Symbol.for("react.element"), c2 = Symbol.for("react.portal"), d = Symbol.for("react.fragment"), e2 = Symbol.for("react.strict_mode"), f4 = Symbol.for("react.profiler"), g2 = Symbol.for("react.provider"), h3 = Symbol.for("react.context"), k2 = Symbol.for("react.server_context"), l2 = Symbol.for("react.forward_ref"), m3 = Symbol.for("react.suspense"), n2 = Symbol.for("react.suspense_list"), p2 = Symbol.for("react.memo"), q = Symbol.for("react.lazy"), t2 = Symbol.for("react.offscreen"), u3;
  u3 = Symbol.for("react.module.reference");
  function v2(a2) {
    if ("object" === typeof a2 && null !== a2) {
      var r2 = a2.$$typeof;
      switch (r2) {
        case b2:
          switch (a2 = a2.type, a2) {
            case d:
            case f4:
            case e2:
            case m3:
            case n2:
              return a2;
            default:
              switch (a2 = a2 && a2.$$typeof, a2) {
                case k2:
                case h3:
                case l2:
                case q:
                case p2:
                case g2:
                  return a2;
                default:
                  return r2;
              }
          }
        case c2:
          return r2;
      }
    }
  }
  __name(v2, "v");
  reactIs_production_min.ContextConsumer = h3;
  reactIs_production_min.ContextProvider = g2;
  reactIs_production_min.Element = b2;
  reactIs_production_min.ForwardRef = l2;
  reactIs_production_min.Fragment = d;
  reactIs_production_min.Lazy = q;
  reactIs_production_min.Memo = p2;
  reactIs_production_min.Portal = c2;
  reactIs_production_min.Profiler = f4;
  reactIs_production_min.StrictMode = e2;
  reactIs_production_min.Suspense = m3;
  reactIs_production_min.SuspenseList = n2;
  reactIs_production_min.isAsyncMode = function() {
    return false;
  };
  reactIs_production_min.isConcurrentMode = function() {
    return false;
  };
  reactIs_production_min.isContextConsumer = function(a2) {
    return v2(a2) === h3;
  };
  reactIs_production_min.isContextProvider = function(a2) {
    return v2(a2) === g2;
  };
  reactIs_production_min.isElement = function(a2) {
    return "object" === typeof a2 && null !== a2 && a2.$$typeof === b2;
  };
  reactIs_production_min.isForwardRef = function(a2) {
    return v2(a2) === l2;
  };
  reactIs_production_min.isFragment = function(a2) {
    return v2(a2) === d;
  };
  reactIs_production_min.isLazy = function(a2) {
    return v2(a2) === q;
  };
  reactIs_production_min.isMemo = function(a2) {
    return v2(a2) === p2;
  };
  reactIs_production_min.isPortal = function(a2) {
    return v2(a2) === c2;
  };
  reactIs_production_min.isProfiler = function(a2) {
    return v2(a2) === f4;
  };
  reactIs_production_min.isStrictMode = function(a2) {
    return v2(a2) === e2;
  };
  reactIs_production_min.isSuspense = function(a2) {
    return v2(a2) === m3;
  };
  reactIs_production_min.isSuspenseList = function(a2) {
    return v2(a2) === n2;
  };
  reactIs_production_min.isValidElementType = function(a2) {
    return "string" === typeof a2 || "function" === typeof a2 || a2 === d || a2 === f4 || a2 === e2 || a2 === m3 || a2 === n2 || a2 === t2 || "object" === typeof a2 && null !== a2 && (a2.$$typeof === q || a2.$$typeof === p2 || a2.$$typeof === g2 || a2.$$typeof === h3 || a2.$$typeof === l2 || a2.$$typeof === u3 || void 0 !== a2.getModuleId) ? true : false;
  };
  reactIs_production_min.typeOf = v2;
  return reactIs_production_min;
}
__name(requireReactIs_production_min, "requireReactIs_production_min");
var hasRequiredReactIs;
function requireReactIs() {
  if (hasRequiredReactIs) return reactIs.exports;
  hasRequiredReactIs = 1;
  if (true) {
    reactIs.exports = requireReactIs_production_min();
  } else {
    reactIs.exports = requireReactIs_development();
  }
  return reactIs.exports;
}
__name(requireReactIs, "requireReactIs");
var reactIsExports = requireReactIs();
var index = getDefaultExportFromCjs(reactIsExports);
var ReactIs18 = _mergeNamespaces({
  __proto__: null,
  default: index
}, [reactIsExports]);
var reactIsMethods = [
  "isAsyncMode",
  "isConcurrentMode",
  "isContextConsumer",
  "isContextProvider",
  "isElement",
  "isForwardRef",
  "isFragment",
  "isLazy",
  "isMemo",
  "isPortal",
  "isProfiler",
  "isStrictMode",
  "isSuspense",
  "isSuspenseList",
  "isValidElementType"
];
var ReactIs = Object.fromEntries(reactIsMethods.map((m3) => [m3, (v2) => ReactIs18[m3](v2) || ReactIs19[m3](v2)]));
function getChildren(arg, children = []) {
  if (Array.isArray(arg)) {
    for (const item of arg) {
      getChildren(item, children);
    }
  } else if (arg != null && arg !== false && arg !== "") {
    children.push(arg);
  }
  return children;
}
__name(getChildren, "getChildren");
function getType(element) {
  const type5 = element.type;
  if (typeof type5 === "string") {
    return type5;
  }
  if (typeof type5 === "function") {
    return type5.displayName || type5.name || "Unknown";
  }
  if (ReactIs.isFragment(element)) {
    return "React.Fragment";
  }
  if (ReactIs.isSuspense(element)) {
    return "React.Suspense";
  }
  if (typeof type5 === "object" && type5 !== null) {
    if (ReactIs.isContextProvider(element)) {
      return "Context.Provider";
    }
    if (ReactIs.isContextConsumer(element)) {
      return "Context.Consumer";
    }
    if (ReactIs.isForwardRef(element)) {
      if (type5.displayName) {
        return type5.displayName;
      }
      const functionName = type5.render.displayName || type5.render.name || "";
      return functionName === "" ? "ForwardRef" : `ForwardRef(${functionName})`;
    }
    if (ReactIs.isMemo(element)) {
      const functionName = type5.displayName || type5.type.displayName || type5.type.name || "";
      return functionName === "" ? "Memo" : `Memo(${functionName})`;
    }
  }
  return "UNDEFINED";
}
__name(getType, "getType");
function getPropKeys$1(element) {
  const { props } = element;
  return Object.keys(props).filter((key) => key !== "children" && props[key] !== void 0).sort();
}
__name(getPropKeys$1, "getPropKeys$1");
var serialize$1 = /* @__PURE__ */ __name((element, config4, indentation, depth, refs, printer2) => ++depth > config4.maxDepth ? printElementAsLeaf(getType(element), config4) : printElement(getType(element), printProps(getPropKeys$1(element), element.props, config4, indentation + config4.indent, depth, refs, printer2), printChildren(getChildren(element.props.children), config4, indentation + config4.indent, depth, refs, printer2), config4, indentation), "serialize$1");
var test$1 = /* @__PURE__ */ __name((val) => val != null && ReactIs.isElement(val), "test$1");
var plugin$1 = {
  serialize: serialize$1,
  test: test$1
};
var testSymbol = typeof Symbol === "function" && Symbol.for ? Symbol.for("react.test.json") : 245830487;
function getPropKeys(object) {
  const { props } = object;
  return props ? Object.keys(props).filter((key) => props[key] !== void 0).sort() : [];
}
__name(getPropKeys, "getPropKeys");
var serialize = /* @__PURE__ */ __name((object, config4, indentation, depth, refs, printer2) => ++depth > config4.maxDepth ? printElementAsLeaf(object.type, config4) : printElement(object.type, object.props ? printProps(getPropKeys(object), object.props, config4, indentation + config4.indent, depth, refs, printer2) : "", object.children ? printChildren(object.children, config4, indentation + config4.indent, depth, refs, printer2) : "", config4, indentation), "serialize");
var test = /* @__PURE__ */ __name((val) => val && val.$$typeof === testSymbol, "test");
var plugin = {
  serialize,
  test
};
var toString2 = Object.prototype.toString;
var toISOString = Date.prototype.toISOString;
var errorToString = Error.prototype.toString;
var regExpToString = RegExp.prototype.toString;
function getConstructorName(val) {
  return typeof val.constructor === "function" && val.constructor.name || "Object";
}
__name(getConstructorName, "getConstructorName");
function isWindow(val) {
  return typeof window !== "undefined" && val === window;
}
__name(isWindow, "isWindow");
var SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;
var NEWLINE_REGEXP = /\n/g;
var _PrettyFormatPluginError = class _PrettyFormatPluginError extends Error {
  constructor(message, stack) {
    super(message);
    this.stack = stack;
    this.name = this.constructor.name;
  }
};
__name(_PrettyFormatPluginError, "PrettyFormatPluginError");
var PrettyFormatPluginError = _PrettyFormatPluginError;
function isToStringedArrayType(toStringed) {
  return toStringed === "[object Array]" || toStringed === "[object ArrayBuffer]" || toStringed === "[object DataView]" || toStringed === "[object Float32Array]" || toStringed === "[object Float64Array]" || toStringed === "[object Int8Array]" || toStringed === "[object Int16Array]" || toStringed === "[object Int32Array]" || toStringed === "[object Uint8Array]" || toStringed === "[object Uint8ClampedArray]" || toStringed === "[object Uint16Array]" || toStringed === "[object Uint32Array]";
}
__name(isToStringedArrayType, "isToStringedArrayType");
function printNumber(val) {
  return Object.is(val, -0) ? "-0" : String(val);
}
__name(printNumber, "printNumber");
function printBigInt(val) {
  return String(`${val}n`);
}
__name(printBigInt, "printBigInt");
function printFunction(val, printFunctionName) {
  if (!printFunctionName) {
    return "[Function]";
  }
  return `[Function ${val.name || "anonymous"}]`;
}
__name(printFunction, "printFunction");
function printSymbol(val) {
  return String(val).replace(SYMBOL_REGEXP, "Symbol($1)");
}
__name(printSymbol, "printSymbol");
function printError(val) {
  return `[${errorToString.call(val)}]`;
}
__name(printError, "printError");
function printBasicValue(val, printFunctionName, escapeRegex, escapeString) {
  if (val === true || val === false) {
    return `${val}`;
  }
  if (val === void 0) {
    return "undefined";
  }
  if (val === null) {
    return "null";
  }
  const typeOf = typeof val;
  if (typeOf === "number") {
    return printNumber(val);
  }
  if (typeOf === "bigint") {
    return printBigInt(val);
  }
  if (typeOf === "string") {
    if (escapeString) {
      return `"${val.replaceAll(/"|\\/g, "\\$&")}"`;
    }
    return `"${val}"`;
  }
  if (typeOf === "function") {
    return printFunction(val, printFunctionName);
  }
  if (typeOf === "symbol") {
    return printSymbol(val);
  }
  const toStringed = toString2.call(val);
  if (toStringed === "[object WeakMap]") {
    return "WeakMap {}";
  }
  if (toStringed === "[object WeakSet]") {
    return "WeakSet {}";
  }
  if (toStringed === "[object Function]" || toStringed === "[object GeneratorFunction]") {
    return printFunction(val, printFunctionName);
  }
  if (toStringed === "[object Symbol]") {
    return printSymbol(val);
  }
  if (toStringed === "[object Date]") {
    return Number.isNaN(+val) ? "Date { NaN }" : toISOString.call(val);
  }
  if (toStringed === "[object Error]") {
    return printError(val);
  }
  if (toStringed === "[object RegExp]") {
    if (escapeRegex) {
      return regExpToString.call(val).replaceAll(/[$()*+.?[\\\]^{|}]/g, "\\$&");
    }
    return regExpToString.call(val);
  }
  if (val instanceof Error) {
    return printError(val);
  }
  return null;
}
__name(printBasicValue, "printBasicValue");
function printComplexValue(val, config4, indentation, depth, refs, hasCalledToJSON) {
  if (refs.includes(val)) {
    return "[Circular]";
  }
  refs = [...refs];
  refs.push(val);
  const hitMaxDepth = ++depth > config4.maxDepth;
  const min = config4.min;
  if (config4.callToJSON && !hitMaxDepth && val.toJSON && typeof val.toJSON === "function" && !hasCalledToJSON) {
    return printer(val.toJSON(), config4, indentation, depth, refs, true);
  }
  const toStringed = toString2.call(val);
  if (toStringed === "[object Arguments]") {
    return hitMaxDepth ? "[Arguments]" : `${min ? "" : "Arguments "}[${printListItems(val, config4, indentation, depth, refs, printer)}]`;
  }
  if (isToStringedArrayType(toStringed)) {
    return hitMaxDepth ? `[${val.constructor.name}]` : `${min ? "" : !config4.printBasicPrototype && val.constructor.name === "Array" ? "" : `${val.constructor.name} `}[${printListItems(val, config4, indentation, depth, refs, printer)}]`;
  }
  if (toStringed === "[object Map]") {
    return hitMaxDepth ? "[Map]" : `Map {${printIteratorEntries(val.entries(), config4, indentation, depth, refs, printer, " => ")}}`;
  }
  if (toStringed === "[object Set]") {
    return hitMaxDepth ? "[Set]" : `Set {${printIteratorValues(val.values(), config4, indentation, depth, refs, printer)}}`;
  }
  return hitMaxDepth || isWindow(val) ? `[${getConstructorName(val)}]` : `${min ? "" : !config4.printBasicPrototype && getConstructorName(val) === "Object" ? "" : `${getConstructorName(val)} `}{${printObjectProperties(val, config4, indentation, depth, refs, printer)}}`;
}
__name(printComplexValue, "printComplexValue");
var ErrorPlugin = {
  test: /* @__PURE__ */ __name((val) => val && val instanceof Error, "test"),
  serialize(val, config4, indentation, depth, refs, printer2) {
    if (refs.includes(val)) {
      return "[Circular]";
    }
    refs = [...refs, val];
    const hitMaxDepth = ++depth > config4.maxDepth;
    const { message, cause, ...rest } = val;
    const entries = {
      message,
      ...typeof cause !== "undefined" ? { cause } : {},
      ...val instanceof AggregateError ? { errors: val.errors } : {},
      ...rest
    };
    const name = val.name !== "Error" ? val.name : getConstructorName(val);
    return hitMaxDepth ? `[${name}]` : `${name} {${printIteratorEntries(Object.entries(entries).values(), config4, indentation, depth, refs, printer2)}}`;
  }
};
function isNewPlugin(plugin2) {
  return plugin2.serialize != null;
}
__name(isNewPlugin, "isNewPlugin");
function printPlugin(plugin2, val, config4, indentation, depth, refs) {
  let printed;
  try {
    printed = isNewPlugin(plugin2) ? plugin2.serialize(val, config4, indentation, depth, refs, printer) : plugin2.print(val, (valChild) => printer(valChild, config4, indentation, depth, refs), (str2) => {
      const indentationNext = indentation + config4.indent;
      return indentationNext + str2.replaceAll(NEWLINE_REGEXP, `
${indentationNext}`);
    }, {
      edgeSpacing: config4.spacingOuter,
      min: config4.min,
      spacing: config4.spacingInner
    }, config4.colors);
  } catch (error) {
    throw new PrettyFormatPluginError(error.message, error.stack);
  }
  if (typeof printed !== "string") {
    throw new TypeError(`pretty-format: Plugin must return type "string" but instead returned "${typeof printed}".`);
  }
  return printed;
}
__name(printPlugin, "printPlugin");
function findPlugin(plugins3, val) {
  for (const plugin2 of plugins3) {
    try {
      if (plugin2.test(val)) {
        return plugin2;
      }
    } catch (error) {
      throw new PrettyFormatPluginError(error.message, error.stack);
    }
  }
  return null;
}
__name(findPlugin, "findPlugin");
function printer(val, config4, indentation, depth, refs, hasCalledToJSON) {
  const plugin2 = findPlugin(config4.plugins, val);
  if (plugin2 !== null) {
    return printPlugin(plugin2, val, config4, indentation, depth, refs);
  }
  const basicResult = printBasicValue(val, config4.printFunctionName, config4.escapeRegex, config4.escapeString);
  if (basicResult !== null) {
    return basicResult;
  }
  return printComplexValue(val, config4, indentation, depth, refs, hasCalledToJSON);
}
__name(printer, "printer");
var DEFAULT_THEME = {
  comment: "gray",
  content: "reset",
  prop: "yellow",
  tag: "cyan",
  value: "green"
};
var DEFAULT_THEME_KEYS = Object.keys(DEFAULT_THEME);
var DEFAULT_OPTIONS = {
  callToJSON: true,
  compareKeys: void 0,
  escapeRegex: false,
  escapeString: true,
  highlight: false,
  indent: 2,
  maxDepth: Number.POSITIVE_INFINITY,
  maxWidth: Number.POSITIVE_INFINITY,
  min: false,
  plugins: [],
  printBasicPrototype: true,
  printFunctionName: true,
  theme: DEFAULT_THEME
};
function validateOptions(options) {
  for (const key of Object.keys(options)) {
    if (!Object.prototype.hasOwnProperty.call(DEFAULT_OPTIONS, key)) {
      throw new Error(`pretty-format: Unknown option "${key}".`);
    }
  }
  if (options.min && options.indent !== void 0 && options.indent !== 0) {
    throw new Error('pretty-format: Options "min" and "indent" cannot be used together.');
  }
}
__name(validateOptions, "validateOptions");
function getColorsHighlight() {
  return DEFAULT_THEME_KEYS.reduce((colors3, key) => {
    const value = DEFAULT_THEME[key];
    const color = value && s[value];
    if (color && typeof color.close === "string" && typeof color.open === "string") {
      colors3[key] = color;
    } else {
      throw new Error(`pretty-format: Option "theme" has a key "${key}" whose value "${value}" is undefined in ansi-styles.`);
    }
    return colors3;
  }, /* @__PURE__ */ Object.create(null));
}
__name(getColorsHighlight, "getColorsHighlight");
function getColorsEmpty() {
  return DEFAULT_THEME_KEYS.reduce((colors3, key) => {
    colors3[key] = {
      close: "",
      open: ""
    };
    return colors3;
  }, /* @__PURE__ */ Object.create(null));
}
__name(getColorsEmpty, "getColorsEmpty");
function getPrintFunctionName(options) {
  return (options === null || options === void 0 ? void 0 : options.printFunctionName) ?? DEFAULT_OPTIONS.printFunctionName;
}
__name(getPrintFunctionName, "getPrintFunctionName");
function getEscapeRegex(options) {
  return (options === null || options === void 0 ? void 0 : options.escapeRegex) ?? DEFAULT_OPTIONS.escapeRegex;
}
__name(getEscapeRegex, "getEscapeRegex");
function getEscapeString(options) {
  return (options === null || options === void 0 ? void 0 : options.escapeString) ?? DEFAULT_OPTIONS.escapeString;
}
__name(getEscapeString, "getEscapeString");
function getConfig(options) {
  return {
    callToJSON: (options === null || options === void 0 ? void 0 : options.callToJSON) ?? DEFAULT_OPTIONS.callToJSON,
    colors: (options === null || options === void 0 ? void 0 : options.highlight) ? getColorsHighlight() : getColorsEmpty(),
    compareKeys: typeof (options === null || options === void 0 ? void 0 : options.compareKeys) === "function" || (options === null || options === void 0 ? void 0 : options.compareKeys) === null ? options.compareKeys : DEFAULT_OPTIONS.compareKeys,
    escapeRegex: getEscapeRegex(options),
    escapeString: getEscapeString(options),
    indent: (options === null || options === void 0 ? void 0 : options.min) ? "" : createIndent((options === null || options === void 0 ? void 0 : options.indent) ?? DEFAULT_OPTIONS.indent),
    maxDepth: (options === null || options === void 0 ? void 0 : options.maxDepth) ?? DEFAULT_OPTIONS.maxDepth,
    maxWidth: (options === null || options === void 0 ? void 0 : options.maxWidth) ?? DEFAULT_OPTIONS.maxWidth,
    min: (options === null || options === void 0 ? void 0 : options.min) ?? DEFAULT_OPTIONS.min,
    plugins: (options === null || options === void 0 ? void 0 : options.plugins) ?? DEFAULT_OPTIONS.plugins,
    printBasicPrototype: (options === null || options === void 0 ? void 0 : options.printBasicPrototype) ?? true,
    printFunctionName: getPrintFunctionName(options),
    spacingInner: (options === null || options === void 0 ? void 0 : options.min) ? " " : "\n",
    spacingOuter: (options === null || options === void 0 ? void 0 : options.min) ? "" : "\n"
  };
}
__name(getConfig, "getConfig");
function createIndent(indent2) {
  return Array.from({ length: indent2 + 1 }).join(" ");
}
__name(createIndent, "createIndent");
function format(val, options) {
  if (options) {
    validateOptions(options);
    if (options.plugins) {
      const plugin2 = findPlugin(options.plugins, val);
      if (plugin2 !== null) {
        return printPlugin(plugin2, val, getConfig(options), "", 0, []);
      }
    }
  }
  const basicResult = printBasicValue(val, getPrintFunctionName(options), getEscapeRegex(options), getEscapeString(options));
  if (basicResult !== null) {
    return basicResult;
  }
  return printComplexValue(val, getConfig(options), "", 0, []);
}
__name(format, "format");
var plugins = {
  AsymmetricMatcher: plugin$5,
  DOMCollection: plugin$4,
  DOMElement: plugin$3,
  Immutable: plugin$2,
  ReactElement: plugin$1,
  ReactTestComponent: plugin,
  Error: ErrorPlugin
};

// ../node_modules/loupe/lib/helpers.js
var ansiColors = {
  bold: ["1", "22"],
  dim: ["2", "22"],
  italic: ["3", "23"],
  underline: ["4", "24"],
  // 5 & 6 are blinking
  inverse: ["7", "27"],
  hidden: ["8", "28"],
  strike: ["9", "29"],
  // 10-20 are fonts
  // 21-29 are resets for 1-9
  black: ["30", "39"],
  red: ["31", "39"],
  green: ["32", "39"],
  yellow: ["33", "39"],
  blue: ["34", "39"],
  magenta: ["35", "39"],
  cyan: ["36", "39"],
  white: ["37", "39"],
  brightblack: ["30;1", "39"],
  brightred: ["31;1", "39"],
  brightgreen: ["32;1", "39"],
  brightyellow: ["33;1", "39"],
  brightblue: ["34;1", "39"],
  brightmagenta: ["35;1", "39"],
  brightcyan: ["36;1", "39"],
  brightwhite: ["37;1", "39"],
  grey: ["90", "39"]
};
var styles = {
  special: "cyan",
  number: "yellow",
  bigint: "yellow",
  boolean: "yellow",
  undefined: "grey",
  null: "bold",
  string: "green",
  symbol: "green",
  date: "magenta",
  regexp: "red"
};
var truncator = "\u2026";
function colorise(value, styleType) {
  const color = ansiColors[styles[styleType]] || ansiColors[styleType] || "";
  if (!color) {
    return String(value);
  }
  return `\x1B[${color[0]}m${String(value)}\x1B[${color[1]}m`;
}
__name(colorise, "colorise");
function normaliseOptions({
  showHidden = false,
  depth = 2,
  colors: colors3 = false,
  customInspect = true,
  showProxy = false,
  maxArrayLength = Infinity,
  breakLength = Infinity,
  seen = [],
  // eslint-disable-next-line no-shadow
  truncate: truncate3 = Infinity,
  stylize = String
} = {}, inspect5) {
  const options = {
    showHidden: Boolean(showHidden),
    depth: Number(depth),
    colors: Boolean(colors3),
    customInspect: Boolean(customInspect),
    showProxy: Boolean(showProxy),
    maxArrayLength: Number(maxArrayLength),
    breakLength: Number(breakLength),
    truncate: Number(truncate3),
    seen,
    inspect: inspect5,
    stylize
  };
  if (options.colors) {
    options.stylize = colorise;
  }
  return options;
}
__name(normaliseOptions, "normaliseOptions");
function isHighSurrogate(char) {
  return char >= "\uD800" && char <= "\uDBFF";
}
__name(isHighSurrogate, "isHighSurrogate");
function truncate(string, length, tail = truncator) {
  string = String(string);
  const tailLength = tail.length;
  const stringLength = string.length;
  if (tailLength > length && stringLength > tailLength) {
    return tail;
  }
  if (stringLength > length && stringLength > tailLength) {
    let end = length - tailLength;
    if (end > 0 && isHighSurrogate(string[end - 1])) {
      end = end - 1;
    }
    return `${string.slice(0, end)}${tail}`;
  }
  return string;
}
__name(truncate, "truncate");
function inspectList(list, options, inspectItem, separator = ", ") {
  inspectItem = inspectItem || options.inspect;
  const size = list.length;
  if (size === 0)
    return "";
  const originalLength = options.truncate;
  let output = "";
  let peek = "";
  let truncated = "";
  for (let i2 = 0; i2 < size; i2 += 1) {
    const last = i2 + 1 === list.length;
    const secondToLast = i2 + 2 === list.length;
    truncated = `${truncator}(${list.length - i2})`;
    const value = list[i2];
    options.truncate = originalLength - output.length - (last ? 0 : separator.length);
    const string = peek || inspectItem(value, options) + (last ? "" : separator);
    const nextLength = output.length + string.length;
    const truncatedLength = nextLength + truncated.length;
    if (last && nextLength > originalLength && output.length + truncated.length <= originalLength) {
      break;
    }
    if (!last && !secondToLast && truncatedLength > originalLength) {
      break;
    }
    peek = last ? "" : inspectItem(list[i2 + 1], options) + (secondToLast ? "" : separator);
    if (!last && secondToLast && truncatedLength > originalLength && nextLength + peek.length > originalLength) {
      break;
    }
    output += string;
    if (!last && !secondToLast && nextLength + peek.length >= originalLength) {
      truncated = `${truncator}(${list.length - i2 - 1})`;
      break;
    }
    truncated = "";
  }
  return `${output}${truncated}`;
}
__name(inspectList, "inspectList");
function quoteComplexKey(key) {
  if (key.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/)) {
    return key;
  }
  return JSON.stringify(key).replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
}
__name(quoteComplexKey, "quoteComplexKey");
function inspectProperty([key, value], options) {
  options.truncate -= 2;
  if (typeof key === "string") {
    key = quoteComplexKey(key);
  } else if (typeof key !== "number") {
    key = `[${options.inspect(key, options)}]`;
  }
  options.truncate -= key.length;
  value = options.inspect(value, options);
  return `${key}: ${value}`;
}
__name(inspectProperty, "inspectProperty");

// ../node_modules/loupe/lib/array.js
function inspectArray(array, options) {
  const nonIndexProperties = Object.keys(array).slice(array.length);
  if (!array.length && !nonIndexProperties.length)
    return "[]";
  options.truncate -= 4;
  const listContents = inspectList(array, options);
  options.truncate -= listContents.length;
  let propertyContents = "";
  if (nonIndexProperties.length) {
    propertyContents = inspectList(nonIndexProperties.map((key) => [key, array[key]]), options, inspectProperty);
  }
  return `[ ${listContents}${propertyContents ? `, ${propertyContents}` : ""} ]`;
}
__name(inspectArray, "inspectArray");

// ../node_modules/loupe/lib/typedarray.js
var getArrayName = /* @__PURE__ */ __name((array) => {
  if (typeof Buffer === "function" && array instanceof Buffer) {
    return "Buffer";
  }
  if (array[Symbol.toStringTag]) {
    return array[Symbol.toStringTag];
  }
  return array.constructor.name;
}, "getArrayName");
function inspectTypedArray(array, options) {
  const name = getArrayName(array);
  options.truncate -= name.length + 4;
  const nonIndexProperties = Object.keys(array).slice(array.length);
  if (!array.length && !nonIndexProperties.length)
    return `${name}[]`;
  let output = "";
  for (let i2 = 0; i2 < array.length; i2++) {
    const string = `${options.stylize(truncate(array[i2], options.truncate), "number")}${i2 === array.length - 1 ? "" : ", "}`;
    options.truncate -= string.length;
    if (array[i2] !== array.length && options.truncate <= 3) {
      output += `${truncator}(${array.length - array[i2] + 1})`;
      break;
    }
    output += string;
  }
  let propertyContents = "";
  if (nonIndexProperties.length) {
    propertyContents = inspectList(nonIndexProperties.map((key) => [key, array[key]]), options, inspectProperty);
  }
  return `${name}[ ${output}${propertyContents ? `, ${propertyContents}` : ""} ]`;
}
__name(inspectTypedArray, "inspectTypedArray");

// ../node_modules/loupe/lib/date.js
function inspectDate(dateObject, options) {
  const stringRepresentation = dateObject.toJSON();
  if (stringRepresentation === null) {
    return "Invalid Date";
  }
  const split = stringRepresentation.split("T");
  const date = split[0];
  return options.stylize(`${date}T${truncate(split[1], options.truncate - date.length - 1)}`, "date");
}
__name(inspectDate, "inspectDate");

// ../node_modules/loupe/lib/function.js
function inspectFunction(func, options) {
  const functionType = func[Symbol.toStringTag] || "Function";
  const name = func.name;
  if (!name) {
    return options.stylize(`[${functionType}]`, "special");
  }
  return options.stylize(`[${functionType} ${truncate(name, options.truncate - 11)}]`, "special");
}
__name(inspectFunction, "inspectFunction");

// ../node_modules/loupe/lib/map.js
function inspectMapEntry([key, value], options) {
  options.truncate -= 4;
  key = options.inspect(key, options);
  options.truncate -= key.length;
  value = options.inspect(value, options);
  return `${key} => ${value}`;
}
__name(inspectMapEntry, "inspectMapEntry");
function mapToEntries(map2) {
  const entries = [];
  map2.forEach((value, key) => {
    entries.push([key, value]);
  });
  return entries;
}
__name(mapToEntries, "mapToEntries");
function inspectMap(map2, options) {
  if (map2.size === 0)
    return "Map{}";
  options.truncate -= 7;
  return `Map{ ${inspectList(mapToEntries(map2), options, inspectMapEntry)} }`;
}
__name(inspectMap, "inspectMap");

// ../node_modules/loupe/lib/number.js
var isNaN2 = Number.isNaN || ((i2) => i2 !== i2);
function inspectNumber(number, options) {
  if (isNaN2(number)) {
    return options.stylize("NaN", "number");
  }
  if (number === Infinity) {
    return options.stylize("Infinity", "number");
  }
  if (number === -Infinity) {
    return options.stylize("-Infinity", "number");
  }
  if (number === 0) {
    return options.stylize(1 / number === Infinity ? "+0" : "-0", "number");
  }
  return options.stylize(truncate(String(number), options.truncate), "number");
}
__name(inspectNumber, "inspectNumber");

// ../node_modules/loupe/lib/bigint.js
function inspectBigInt(number, options) {
  let nums = truncate(number.toString(), options.truncate - 1);
  if (nums !== truncator)
    nums += "n";
  return options.stylize(nums, "bigint");
}
__name(inspectBigInt, "inspectBigInt");

// ../node_modules/loupe/lib/regexp.js
function inspectRegExp(value, options) {
  const flags = value.toString().split("/")[2];
  const sourceLength = options.truncate - (2 + flags.length);
  const source = value.source;
  return options.stylize(`/${truncate(source, sourceLength)}/${flags}`, "regexp");
}
__name(inspectRegExp, "inspectRegExp");

// ../node_modules/loupe/lib/set.js
function arrayFromSet(set2) {
  const values = [];
  set2.forEach((value) => {
    values.push(value);
  });
  return values;
}
__name(arrayFromSet, "arrayFromSet");
function inspectSet(set2, options) {
  if (set2.size === 0)
    return "Set{}";
  options.truncate -= 7;
  return `Set{ ${inspectList(arrayFromSet(set2), options)} }`;
}
__name(inspectSet, "inspectSet");

// ../node_modules/loupe/lib/string.js
var stringEscapeChars = new RegExp("['\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]", "g");
var escapeCharacters = {
  "\b": "\\b",
  "	": "\\t",
  "\n": "\\n",
  "\f": "\\f",
  "\r": "\\r",
  "'": "\\'",
  "\\": "\\\\"
};
var hex = 16;
var unicodeLength = 4;
function escape(char) {
  return escapeCharacters[char] || `\\u${`0000${char.charCodeAt(0).toString(hex)}`.slice(-unicodeLength)}`;
}
__name(escape, "escape");
function inspectString(string, options) {
  if (stringEscapeChars.test(string)) {
    string = string.replace(stringEscapeChars, escape);
  }
  return options.stylize(`'${truncate(string, options.truncate - 2)}'`, "string");
}
__name(inspectString, "inspectString");

// ../node_modules/loupe/lib/symbol.js
function inspectSymbol(value) {
  if ("description" in Symbol.prototype) {
    return value.description ? `Symbol(${value.description})` : "Symbol()";
  }
  return value.toString();
}
__name(inspectSymbol, "inspectSymbol");

// ../node_modules/loupe/lib/promise.js
var getPromiseValue = /* @__PURE__ */ __name(() => "Promise{\u2026}", "getPromiseValue");
var promise_default = getPromiseValue;

// ../node_modules/loupe/lib/object.js
function inspectObject(object, options) {
  const properties = Object.getOwnPropertyNames(object);
  const symbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(object) : [];
  if (properties.length === 0 && symbols.length === 0) {
    return "{}";
  }
  options.truncate -= 4;
  options.seen = options.seen || [];
  if (options.seen.includes(object)) {
    return "[Circular]";
  }
  options.seen.push(object);
  const propertyContents = inspectList(properties.map((key) => [key, object[key]]), options, inspectProperty);
  const symbolContents = inspectList(symbols.map((key) => [key, object[key]]), options, inspectProperty);
  options.seen.pop();
  let sep = "";
  if (propertyContents && symbolContents) {
    sep = ", ";
  }
  return `{ ${propertyContents}${sep}${symbolContents} }`;
}
__name(inspectObject, "inspectObject");

// ../node_modules/loupe/lib/class.js
var toStringTag = typeof Symbol !== "undefined" && Symbol.toStringTag ? Symbol.toStringTag : false;
function inspectClass(value, options) {
  let name = "";
  if (toStringTag && toStringTag in value) {
    name = value[toStringTag];
  }
  name = name || value.constructor.name;
  if (!name || name === "_class") {
    name = "<Anonymous Class>";
  }
  options.truncate -= name.length;
  return `${name}${inspectObject(value, options)}`;
}
__name(inspectClass, "inspectClass");

// ../node_modules/loupe/lib/arguments.js
function inspectArguments(args, options) {
  if (args.length === 0)
    return "Arguments[]";
  options.truncate -= 13;
  return `Arguments[ ${inspectList(args, options)} ]`;
}
__name(inspectArguments, "inspectArguments");

// ../node_modules/loupe/lib/error.js
var errorKeys = [
  "stack",
  "line",
  "column",
  "name",
  "message",
  "fileName",
  "lineNumber",
  "columnNumber",
  "number",
  "description",
  "cause"
];
function inspectObject2(error, options) {
  const properties = Object.getOwnPropertyNames(error).filter((key) => errorKeys.indexOf(key) === -1);
  const name = error.name;
  options.truncate -= name.length;
  let message = "";
  if (typeof error.message === "string") {
    message = truncate(error.message, options.truncate);
  } else {
    properties.unshift("message");
  }
  message = message ? `: ${message}` : "";
  options.truncate -= message.length + 5;
  options.seen = options.seen || [];
  if (options.seen.includes(error)) {
    return "[Circular]";
  }
  options.seen.push(error);
  const propertyContents = inspectList(properties.map((key) => [key, error[key]]), options, inspectProperty);
  return `${name}${message}${propertyContents ? ` { ${propertyContents} }` : ""}`;
}
__name(inspectObject2, "inspectObject");

// ../node_modules/loupe/lib/html.js
function inspectAttribute([key, value], options) {
  options.truncate -= 3;
  if (!value) {
    return `${options.stylize(String(key), "yellow")}`;
  }
  return `${options.stylize(String(key), "yellow")}=${options.stylize(`"${value}"`, "string")}`;
}
__name(inspectAttribute, "inspectAttribute");
function inspectNodeCollection(collection, options) {
  return inspectList(collection, options, inspectNode, "\n");
}
__name(inspectNodeCollection, "inspectNodeCollection");
function inspectNode(node, options) {
  switch (node.nodeType) {
    case 1:
      return inspectHTML(node, options);
    case 3:
      return options.inspect(node.data, options);
    default:
      return options.inspect(node, options);
  }
}
__name(inspectNode, "inspectNode");
function inspectHTML(element, options) {
  const properties = element.getAttributeNames();
  const name = element.tagName.toLowerCase();
  const head = options.stylize(`<${name}`, "special");
  const headClose = options.stylize(`>`, "special");
  const tail = options.stylize(`</${name}>`, "special");
  options.truncate -= name.length * 2 + 5;
  let propertyContents = "";
  if (properties.length > 0) {
    propertyContents += " ";
    propertyContents += inspectList(properties.map((key) => [key, element.getAttribute(key)]), options, inspectAttribute, " ");
  }
  options.truncate -= propertyContents.length;
  const truncate3 = options.truncate;
  let children = inspectNodeCollection(element.children, options);
  if (children && children.length > truncate3) {
    children = `${truncator}(${element.children.length})`;
  }
  return `${head}${propertyContents}${headClose}${children}${tail}`;
}
__name(inspectHTML, "inspectHTML");

// ../node_modules/loupe/lib/index.js
var symbolsSupported = typeof Symbol === "function" && typeof Symbol.for === "function";
var chaiInspect = symbolsSupported ? Symbol.for("chai/inspect") : "@@chai/inspect";
var nodeInspect = Symbol.for("nodejs.util.inspect.custom");
var constructorMap = /* @__PURE__ */ new WeakMap();
var stringTagMap = {};
var baseTypesMap = {
  undefined: /* @__PURE__ */ __name((value, options) => options.stylize("undefined", "undefined"), "undefined"),
  null: /* @__PURE__ */ __name((value, options) => options.stylize("null", "null"), "null"),
  boolean: /* @__PURE__ */ __name((value, options) => options.stylize(String(value), "boolean"), "boolean"),
  Boolean: /* @__PURE__ */ __name((value, options) => options.stylize(String(value), "boolean"), "Boolean"),
  number: inspectNumber,
  Number: inspectNumber,
  bigint: inspectBigInt,
  BigInt: inspectBigInt,
  string: inspectString,
  String: inspectString,
  function: inspectFunction,
  Function: inspectFunction,
  symbol: inspectSymbol,
  // A Symbol polyfill will return `Symbol` not `symbol` from typedetect
  Symbol: inspectSymbol,
  Array: inspectArray,
  Date: inspectDate,
  Map: inspectMap,
  Set: inspectSet,
  RegExp: inspectRegExp,
  Promise: promise_default,
  // WeakSet, WeakMap are totally opaque to us
  WeakSet: /* @__PURE__ */ __name((value, options) => options.stylize("WeakSet{\u2026}", "special"), "WeakSet"),
  WeakMap: /* @__PURE__ */ __name((value, options) => options.stylize("WeakMap{\u2026}", "special"), "WeakMap"),
  Arguments: inspectArguments,
  Int8Array: inspectTypedArray,
  Uint8Array: inspectTypedArray,
  Uint8ClampedArray: inspectTypedArray,
  Int16Array: inspectTypedArray,
  Uint16Array: inspectTypedArray,
  Int32Array: inspectTypedArray,
  Uint32Array: inspectTypedArray,
  Float32Array: inspectTypedArray,
  Float64Array: inspectTypedArray,
  Generator: /* @__PURE__ */ __name(() => "", "Generator"),
  DataView: /* @__PURE__ */ __name(() => "", "DataView"),
  ArrayBuffer: /* @__PURE__ */ __name(() => "", "ArrayBuffer"),
  Error: inspectObject2,
  HTMLCollection: inspectNodeCollection,
  NodeList: inspectNodeCollection
};
var inspectCustom = /* @__PURE__ */ __name((value, options, type5, inspectFn) => {
  if (chaiInspect in value && typeof value[chaiInspect] === "function") {
    return value[chaiInspect](options);
  }
  if (nodeInspect in value && typeof value[nodeInspect] === "function") {
    return value[nodeInspect](options.depth, options, inspectFn);
  }
  if ("inspect" in value && typeof value.inspect === "function") {
    return value.inspect(options.depth, options);
  }
  if ("constructor" in value && constructorMap.has(value.constructor)) {
    return constructorMap.get(value.constructor)(value, options);
  }
  if (stringTagMap[type5]) {
    return stringTagMap[type5](value, options);
  }
  return "";
}, "inspectCustom");
var toString3 = Object.prototype.toString;
function inspect(value, opts = {}) {
  const options = normaliseOptions(opts, inspect);
  const { customInspect } = options;
  let type5 = value === null ? "null" : typeof value;
  if (type5 === "object") {
    type5 = toString3.call(value).slice(8, -1);
  }
  if (type5 in baseTypesMap) {
    return baseTypesMap[type5](value, options);
  }
  if (customInspect && value) {
    const output = inspectCustom(value, options, type5, inspect);
    if (output) {
      if (typeof output === "string")
        return output;
      return inspect(output, options);
    }
  }
  const proto = value ? Object.getPrototypeOf(value) : false;
  if (proto === Object.prototype || proto === null) {
    return inspectObject(value, options);
  }
  if (value && typeof HTMLElement === "function" && value instanceof HTMLElement) {
    return inspectHTML(value, options);
  }
  if ("constructor" in value) {
    if (value.constructor !== Object) {
      return inspectClass(value, options);
    }
    return inspectObject(value, options);
  }
  if (value === Object(value)) {
    return inspectObject(value, options);
  }
  return options.stylize(String(value), type5);
}
__name(inspect, "inspect");

// ../node_modules/@vitest/utils/dist/chunk-_commonjsHelpers.js
var { AsymmetricMatcher, DOMCollection, DOMElement, Immutable, ReactElement, ReactTestComponent } = plugins;
var PLUGINS = [
  ReactTestComponent,
  ReactElement,
  DOMElement,
  DOMCollection,
  Immutable,
  AsymmetricMatcher
];
function stringify2(object, maxDepth = 10, { maxLength, ...options } = {}) {
  const MAX_LENGTH = maxLength ?? 1e4;
  let result;
  try {
    result = format(object, {
      maxDepth,
      escapeString: false,
      plugins: PLUGINS,
      ...options
    });
  } catch {
    result = format(object, {
      callToJSON: false,
      maxDepth,
      escapeString: false,
      plugins: PLUGINS,
      ...options
    });
  }
  return result.length >= MAX_LENGTH && maxDepth > 1 ? stringify2(object, Math.floor(Math.min(maxDepth, Number.MAX_SAFE_INTEGER) / 2), {
    maxLength,
    ...options
  }) : result;
}
__name(stringify2, "stringify");
var formatRegExp = /%[sdjifoOc%]/g;
function format2(...args) {
  if (typeof args[0] !== "string") {
    const objects = [];
    for (let i3 = 0; i3 < args.length; i3++) {
      objects.push(inspect2(args[i3], {
        depth: 0,
        colors: false
      }));
    }
    return objects.join(" ");
  }
  const len = args.length;
  let i2 = 1;
  const template = args[0];
  let str2 = String(template).replace(formatRegExp, (x2) => {
    if (x2 === "%%") {
      return "%";
    }
    if (i2 >= len) {
      return x2;
    }
    switch (x2) {
      case "%s": {
        const value = args[i2++];
        if (typeof value === "bigint") {
          return `${value.toString()}n`;
        }
        if (typeof value === "number" && value === 0 && 1 / value < 0) {
          return "-0";
        }
        if (typeof value === "object" && value !== null) {
          if (typeof value.toString === "function" && value.toString !== Object.prototype.toString) {
            return value.toString();
          }
          return inspect2(value, {
            depth: 0,
            colors: false
          });
        }
        return String(value);
      }
      case "%d": {
        const value = args[i2++];
        if (typeof value === "bigint") {
          return `${value.toString()}n`;
        }
        return Number(value).toString();
      }
      case "%i": {
        const value = args[i2++];
        if (typeof value === "bigint") {
          return `${value.toString()}n`;
        }
        return Number.parseInt(String(value)).toString();
      }
      case "%f":
        return Number.parseFloat(String(args[i2++])).toString();
      case "%o":
        return inspect2(args[i2++], {
          showHidden: true,
          showProxy: true
        });
      case "%O":
        return inspect2(args[i2++]);
      case "%c": {
        i2++;
        return "";
      }
      case "%j":
        try {
          return JSON.stringify(args[i2++]);
        } catch (err) {
          const m3 = err.message;
          if (m3.includes("circular structure") || m3.includes("cyclic structures") || m3.includes("cyclic object")) {
            return "[Circular]";
          }
          throw err;
        }
      default:
        return x2;
    }
  });
  for (let x2 = args[i2]; i2 < len; x2 = args[++i2]) {
    if (x2 === null || typeof x2 !== "object") {
      str2 += ` ${x2}`;
    } else {
      str2 += ` ${inspect2(x2)}`;
    }
  }
  return str2;
}
__name(format2, "format");
function inspect2(obj, options = {}) {
  if (options.truncate === 0) {
    options.truncate = Number.POSITIVE_INFINITY;
  }
  return inspect(obj, options);
}
__name(inspect2, "inspect");
function getDefaultExportFromCjs2(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
__name(getDefaultExportFromCjs2, "getDefaultExportFromCjs");

// ../node_modules/@vitest/utils/dist/helpers.js
function assertTypes(value, name, types) {
  const receivedType = typeof value;
  const pass = types.includes(receivedType);
  if (!pass) {
    throw new TypeError(`${name} value must be ${types.join(" or ")}, received "${receivedType}"`);
  }
}
__name(assertTypes, "assertTypes");
function isObject4(item) {
  return item != null && typeof item === "object" && !Array.isArray(item);
}
__name(isObject4, "isObject");
function isFinalObj(obj) {
  return obj === Object.prototype || obj === Function.prototype || obj === RegExp.prototype;
}
__name(isFinalObj, "isFinalObj");
function getType2(value) {
  return Object.prototype.toString.apply(value).slice(8, -1);
}
__name(getType2, "getType");
function collectOwnProperties(obj, collector) {
  const collect = typeof collector === "function" ? collector : (key) => collector.add(key);
  Object.getOwnPropertyNames(obj).forEach(collect);
  Object.getOwnPropertySymbols(obj).forEach(collect);
}
__name(collectOwnProperties, "collectOwnProperties");
function getOwnProperties(obj) {
  const ownProps = /* @__PURE__ */ new Set();
  if (isFinalObj(obj)) {
    return [];
  }
  collectOwnProperties(obj, ownProps);
  return Array.from(ownProps);
}
__name(getOwnProperties, "getOwnProperties");
var defaultCloneOptions = { forceWritable: false };
function deepClone(val, options = defaultCloneOptions) {
  const seen = /* @__PURE__ */ new WeakMap();
  return clone(val, seen, options);
}
__name(deepClone, "deepClone");
function clone(val, seen, options = defaultCloneOptions) {
  let k2, out;
  if (seen.has(val)) {
    return seen.get(val);
  }
  if (Array.isArray(val)) {
    out = Array.from({ length: k2 = val.length });
    seen.set(val, out);
    while (k2--) {
      out[k2] = clone(val[k2], seen, options);
    }
    return out;
  }
  if (Object.prototype.toString.call(val) === "[object Object]") {
    out = Object.create(Object.getPrototypeOf(val));
    seen.set(val, out);
    const props = getOwnProperties(val);
    for (const k3 of props) {
      const descriptor = Object.getOwnPropertyDescriptor(val, k3);
      if (!descriptor) {
        continue;
      }
      const cloned = clone(val[k3], seen, options);
      if (options.forceWritable) {
        Object.defineProperty(out, k3, {
          enumerable: descriptor.enumerable,
          configurable: true,
          writable: true,
          value: cloned
        });
      } else if ("get" in descriptor) {
        Object.defineProperty(out, k3, {
          ...descriptor,
          get() {
            return cloned;
          }
        });
      } else {
        Object.defineProperty(out, k3, {
          ...descriptor,
          value: cloned
        });
      }
    }
    return out;
  }
  return val;
}
__name(clone, "clone");
function noop() {
}
__name(noop, "noop");

// ../node_modules/@vitest/utils/dist/diff.js
var DIFF_DELETE = -1;
var DIFF_INSERT = 1;
var DIFF_EQUAL = 0;
var _Diff = class _Diff {
  0;
  1;
  constructor(op, text) {
    this[0] = op;
    this[1] = text;
  }
};
__name(_Diff, "Diff");
var Diff = _Diff;
function diff_commonPrefix(text1, text2) {
  if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0)) {
    return 0;
  }
  let pointermin = 0;
  let pointermax = Math.min(text1.length, text2.length);
  let pointermid = pointermax;
  let pointerstart = 0;
  while (pointermin < pointermid) {
    if (text1.substring(pointerstart, pointermid) === text2.substring(pointerstart, pointermid)) {
      pointermin = pointermid;
      pointerstart = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
}
__name(diff_commonPrefix, "diff_commonPrefix");
function diff_commonSuffix(text1, text2) {
  if (!text1 || !text2 || text1.charAt(text1.length - 1) !== text2.charAt(text2.length - 1)) {
    return 0;
  }
  let pointermin = 0;
  let pointermax = Math.min(text1.length, text2.length);
  let pointermid = pointermax;
  let pointerend = 0;
  while (pointermin < pointermid) {
    if (text1.substring(text1.length - pointermid, text1.length - pointerend) === text2.substring(text2.length - pointermid, text2.length - pointerend)) {
      pointermin = pointermid;
      pointerend = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
}
__name(diff_commonSuffix, "diff_commonSuffix");
function diff_commonOverlap_(text1, text2) {
  const text1_length = text1.length;
  const text2_length = text2.length;
  if (text1_length === 0 || text2_length === 0) {
    return 0;
  }
  if (text1_length > text2_length) {
    text1 = text1.substring(text1_length - text2_length);
  } else if (text1_length < text2_length) {
    text2 = text2.substring(0, text1_length);
  }
  const text_length = Math.min(text1_length, text2_length);
  if (text1 === text2) {
    return text_length;
  }
  let best = 0;
  let length = 1;
  while (true) {
    const pattern = text1.substring(text_length - length);
    const found = text2.indexOf(pattern);
    if (found === -1) {
      return best;
    }
    length += found;
    if (found === 0 || text1.substring(text_length - length) === text2.substring(0, length)) {
      best = length;
      length++;
    }
  }
}
__name(diff_commonOverlap_, "diff_commonOverlap_");
function diff_cleanupSemantic(diffs) {
  let changes = false;
  const equalities = [];
  let equalitiesLength = 0;
  let lastEquality = null;
  let pointer4 = 0;
  let length_insertions1 = 0;
  let length_deletions1 = 0;
  let length_insertions2 = 0;
  let length_deletions2 = 0;
  while (pointer4 < diffs.length) {
    if (diffs[pointer4][0] === DIFF_EQUAL) {
      equalities[equalitiesLength++] = pointer4;
      length_insertions1 = length_insertions2;
      length_deletions1 = length_deletions2;
      length_insertions2 = 0;
      length_deletions2 = 0;
      lastEquality = diffs[pointer4][1];
    } else {
      if (diffs[pointer4][0] === DIFF_INSERT) {
        length_insertions2 += diffs[pointer4][1].length;
      } else {
        length_deletions2 += diffs[pointer4][1].length;
      }
      if (lastEquality && lastEquality.length <= Math.max(length_insertions1, length_deletions1) && lastEquality.length <= Math.max(length_insertions2, length_deletions2)) {
        diffs.splice(equalities[equalitiesLength - 1], 0, new Diff(DIFF_DELETE, lastEquality));
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
        equalitiesLength--;
        equalitiesLength--;
        pointer4 = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
        length_insertions1 = 0;
        length_deletions1 = 0;
        length_insertions2 = 0;
        length_deletions2 = 0;
        lastEquality = null;
        changes = true;
      }
    }
    pointer4++;
  }
  if (changes) {
    diff_cleanupMerge(diffs);
  }
  diff_cleanupSemanticLossless(diffs);
  pointer4 = 1;
  while (pointer4 < diffs.length) {
    if (diffs[pointer4 - 1][0] === DIFF_DELETE && diffs[pointer4][0] === DIFF_INSERT) {
      const deletion = diffs[pointer4 - 1][1];
      const insertion = diffs[pointer4][1];
      const overlap_length1 = diff_commonOverlap_(deletion, insertion);
      const overlap_length2 = diff_commonOverlap_(insertion, deletion);
      if (overlap_length1 >= overlap_length2) {
        if (overlap_length1 >= deletion.length / 2 || overlap_length1 >= insertion.length / 2) {
          diffs.splice(pointer4, 0, new Diff(DIFF_EQUAL, insertion.substring(0, overlap_length1)));
          diffs[pointer4 - 1][1] = deletion.substring(0, deletion.length - overlap_length1);
          diffs[pointer4 + 1][1] = insertion.substring(overlap_length1);
          pointer4++;
        }
      } else {
        if (overlap_length2 >= deletion.length / 2 || overlap_length2 >= insertion.length / 2) {
          diffs.splice(pointer4, 0, new Diff(DIFF_EQUAL, deletion.substring(0, overlap_length2)));
          diffs[pointer4 - 1][0] = DIFF_INSERT;
          diffs[pointer4 - 1][1] = insertion.substring(0, insertion.length - overlap_length2);
          diffs[pointer4 + 1][0] = DIFF_DELETE;
          diffs[pointer4 + 1][1] = deletion.substring(overlap_length2);
          pointer4++;
        }
      }
      pointer4++;
    }
    pointer4++;
  }
}
__name(diff_cleanupSemantic, "diff_cleanupSemantic");
var nonAlphaNumericRegex_ = /[^a-z0-9]/i;
var whitespaceRegex_ = /\s/;
var linebreakRegex_ = /[\r\n]/;
var blanklineEndRegex_ = /\n\r?\n$/;
var blanklineStartRegex_ = /^\r?\n\r?\n/;
function diff_cleanupSemanticLossless(diffs) {
  let pointer4 = 1;
  while (pointer4 < diffs.length - 1) {
    if (diffs[pointer4 - 1][0] === DIFF_EQUAL && diffs[pointer4 + 1][0] === DIFF_EQUAL) {
      let equality1 = diffs[pointer4 - 1][1];
      let edit = diffs[pointer4][1];
      let equality2 = diffs[pointer4 + 1][1];
      const commonOffset = diff_commonSuffix(equality1, edit);
      if (commonOffset) {
        const commonString = edit.substring(edit.length - commonOffset);
        equality1 = equality1.substring(0, equality1.length - commonOffset);
        edit = commonString + edit.substring(0, edit.length - commonOffset);
        equality2 = commonString + equality2;
      }
      let bestEquality1 = equality1;
      let bestEdit = edit;
      let bestEquality2 = equality2;
      let bestScore = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
      while (edit.charAt(0) === equality2.charAt(0)) {
        equality1 += edit.charAt(0);
        edit = edit.substring(1) + equality2.charAt(0);
        equality2 = equality2.substring(1);
        const score = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
        if (score >= bestScore) {
          bestScore = score;
          bestEquality1 = equality1;
          bestEdit = edit;
          bestEquality2 = equality2;
        }
      }
      if (diffs[pointer4 - 1][1] !== bestEquality1) {
        if (bestEquality1) {
          diffs[pointer4 - 1][1] = bestEquality1;
        } else {
          diffs.splice(pointer4 - 1, 1);
          pointer4--;
        }
        diffs[pointer4][1] = bestEdit;
        if (bestEquality2) {
          diffs[pointer4 + 1][1] = bestEquality2;
        } else {
          diffs.splice(pointer4 + 1, 1);
          pointer4--;
        }
      }
    }
    pointer4++;
  }
}
__name(diff_cleanupSemanticLossless, "diff_cleanupSemanticLossless");
function diff_cleanupMerge(diffs) {
  diffs.push(new Diff(DIFF_EQUAL, ""));
  let pointer4 = 0;
  let count_delete = 0;
  let count_insert = 0;
  let text_delete = "";
  let text_insert = "";
  let commonlength;
  while (pointer4 < diffs.length) {
    switch (diffs[pointer4][0]) {
      case DIFF_INSERT:
        count_insert++;
        text_insert += diffs[pointer4][1];
        pointer4++;
        break;
      case DIFF_DELETE:
        count_delete++;
        text_delete += diffs[pointer4][1];
        pointer4++;
        break;
      case DIFF_EQUAL:
        if (count_delete + count_insert > 1) {
          if (count_delete !== 0 && count_insert !== 0) {
            commonlength = diff_commonPrefix(text_insert, text_delete);
            if (commonlength !== 0) {
              if (pointer4 - count_delete - count_insert > 0 && diffs[pointer4 - count_delete - count_insert - 1][0] === DIFF_EQUAL) {
                diffs[pointer4 - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength);
              } else {
                diffs.splice(0, 0, new Diff(DIFF_EQUAL, text_insert.substring(0, commonlength)));
                pointer4++;
              }
              text_insert = text_insert.substring(commonlength);
              text_delete = text_delete.substring(commonlength);
            }
            commonlength = diff_commonSuffix(text_insert, text_delete);
            if (commonlength !== 0) {
              diffs[pointer4][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer4][1];
              text_insert = text_insert.substring(0, text_insert.length - commonlength);
              text_delete = text_delete.substring(0, text_delete.length - commonlength);
            }
          }
          pointer4 -= count_delete + count_insert;
          diffs.splice(pointer4, count_delete + count_insert);
          if (text_delete.length) {
            diffs.splice(pointer4, 0, new Diff(DIFF_DELETE, text_delete));
            pointer4++;
          }
          if (text_insert.length) {
            diffs.splice(pointer4, 0, new Diff(DIFF_INSERT, text_insert));
            pointer4++;
          }
          pointer4++;
        } else if (pointer4 !== 0 && diffs[pointer4 - 1][0] === DIFF_EQUAL) {
          diffs[pointer4 - 1][1] += diffs[pointer4][1];
          diffs.splice(pointer4, 1);
        } else {
          pointer4++;
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = "";
        text_insert = "";
        break;
    }
  }
  if (diffs[diffs.length - 1][1] === "") {
    diffs.pop();
  }
  let changes = false;
  pointer4 = 1;
  while (pointer4 < diffs.length - 1) {
    if (diffs[pointer4 - 1][0] === DIFF_EQUAL && diffs[pointer4 + 1][0] === DIFF_EQUAL) {
      if (diffs[pointer4][1].substring(diffs[pointer4][1].length - diffs[pointer4 - 1][1].length) === diffs[pointer4 - 1][1]) {
        diffs[pointer4][1] = diffs[pointer4 - 1][1] + diffs[pointer4][1].substring(0, diffs[pointer4][1].length - diffs[pointer4 - 1][1].length);
        diffs[pointer4 + 1][1] = diffs[pointer4 - 1][1] + diffs[pointer4 + 1][1];
        diffs.splice(pointer4 - 1, 1);
        changes = true;
      } else if (diffs[pointer4][1].substring(0, diffs[pointer4 + 1][1].length) === diffs[pointer4 + 1][1]) {
        diffs[pointer4 - 1][1] += diffs[pointer4 + 1][1];
        diffs[pointer4][1] = diffs[pointer4][1].substring(diffs[pointer4 + 1][1].length) + diffs[pointer4 + 1][1];
        diffs.splice(pointer4 + 1, 1);
        changes = true;
      }
    }
    pointer4++;
  }
  if (changes) {
    diff_cleanupMerge(diffs);
  }
}
__name(diff_cleanupMerge, "diff_cleanupMerge");
function diff_cleanupSemanticScore_(one, two) {
  if (!one || !two) {
    return 6;
  }
  const char1 = one.charAt(one.length - 1);
  const char2 = two.charAt(0);
  const nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex_);
  const nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex_);
  const whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex_);
  const whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex_);
  const lineBreak1 = whitespace1 && char1.match(linebreakRegex_);
  const lineBreak2 = whitespace2 && char2.match(linebreakRegex_);
  const blankLine1 = lineBreak1 && one.match(blanklineEndRegex_);
  const blankLine2 = lineBreak2 && two.match(blanklineStartRegex_);
  if (blankLine1 || blankLine2) {
    return 5;
  } else if (lineBreak1 || lineBreak2) {
    return 4;
  } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
    return 3;
  } else if (whitespace1 || whitespace2) {
    return 2;
  } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
    return 1;
  }
  return 0;
}
__name(diff_cleanupSemanticScore_, "diff_cleanupSemanticScore_");
var NO_DIFF_MESSAGE = "Compared values have no visual difference.";
var SIMILAR_MESSAGE = "Compared values serialize to the same structure.\nPrinting internal object structure without calling `toJSON` instead.";
var build = {};
var hasRequiredBuild;
function requireBuild() {
  if (hasRequiredBuild) return build;
  hasRequiredBuild = 1;
  Object.defineProperty(build, "__esModule", {
    value: true
  });
  build.default = diffSequence;
  const pkg = "diff-sequences";
  const NOT_YET_SET = 0;
  const countCommonItemsF = /* @__PURE__ */ __name((aIndex, aEnd, bIndex, bEnd, isCommon) => {
    let nCommon = 0;
    while (aIndex < aEnd && bIndex < bEnd && isCommon(aIndex, bIndex)) {
      aIndex += 1;
      bIndex += 1;
      nCommon += 1;
    }
    return nCommon;
  }, "countCommonItemsF");
  const countCommonItemsR = /* @__PURE__ */ __name((aStart, aIndex, bStart, bIndex, isCommon) => {
    let nCommon = 0;
    while (aStart <= aIndex && bStart <= bIndex && isCommon(aIndex, bIndex)) {
      aIndex -= 1;
      bIndex -= 1;
      nCommon += 1;
    }
    return nCommon;
  }, "countCommonItemsR");
  const extendPathsF = /* @__PURE__ */ __name((d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF) => {
    let iF = 0;
    let kF = -d;
    let aFirst = aIndexesF[iF];
    let aIndexPrev1 = aFirst;
    aIndexesF[iF] += countCommonItemsF(
      aFirst + 1,
      aEnd,
      bF + aFirst - kF + 1,
      bEnd,
      isCommon
    );
    const nF = d < iMaxF ? d : iMaxF;
    for (iF += 1, kF += 2; iF <= nF; iF += 1, kF += 2) {
      if (iF !== d && aIndexPrev1 < aIndexesF[iF]) {
        aFirst = aIndexesF[iF];
      } else {
        aFirst = aIndexPrev1 + 1;
        if (aEnd <= aFirst) {
          return iF - 1;
        }
      }
      aIndexPrev1 = aIndexesF[iF];
      aIndexesF[iF] = aFirst + countCommonItemsF(aFirst + 1, aEnd, bF + aFirst - kF + 1, bEnd, isCommon);
    }
    return iMaxF;
  }, "extendPathsF");
  const extendPathsR = /* @__PURE__ */ __name((d, aStart, bStart, bR, isCommon, aIndexesR, iMaxR) => {
    let iR = 0;
    let kR = d;
    let aFirst = aIndexesR[iR];
    let aIndexPrev1 = aFirst;
    aIndexesR[iR] -= countCommonItemsR(
      aStart,
      aFirst - 1,
      bStart,
      bR + aFirst - kR - 1,
      isCommon
    );
    const nR = d < iMaxR ? d : iMaxR;
    for (iR += 1, kR -= 2; iR <= nR; iR += 1, kR -= 2) {
      if (iR !== d && aIndexesR[iR] < aIndexPrev1) {
        aFirst = aIndexesR[iR];
      } else {
        aFirst = aIndexPrev1 - 1;
        if (aFirst < aStart) {
          return iR - 1;
        }
      }
      aIndexPrev1 = aIndexesR[iR];
      aIndexesR[iR] = aFirst - countCommonItemsR(
        aStart,
        aFirst - 1,
        bStart,
        bR + aFirst - kR - 1,
        isCommon
      );
    }
    return iMaxR;
  }, "extendPathsR");
  const extendOverlappablePathsF = /* @__PURE__ */ __name((d, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division) => {
    const bF = bStart - aStart;
    const aLength = aEnd - aStart;
    const bLength = bEnd - bStart;
    const baDeltaLength = bLength - aLength;
    const kMinOverlapF = -baDeltaLength - (d - 1);
    const kMaxOverlapF = -baDeltaLength + (d - 1);
    let aIndexPrev1 = NOT_YET_SET;
    const nF = d < iMaxF ? d : iMaxF;
    for (let iF = 0, kF = -d; iF <= nF; iF += 1, kF += 2) {
      const insert = iF === 0 || iF !== d && aIndexPrev1 < aIndexesF[iF];
      const aLastPrev = insert ? aIndexesF[iF] : aIndexPrev1;
      const aFirst = insert ? aLastPrev : aLastPrev + 1;
      const bFirst = bF + aFirst - kF;
      const nCommonF = countCommonItemsF(
        aFirst + 1,
        aEnd,
        bFirst + 1,
        bEnd,
        isCommon
      );
      const aLast = aFirst + nCommonF;
      aIndexPrev1 = aIndexesF[iF];
      aIndexesF[iF] = aLast;
      if (kMinOverlapF <= kF && kF <= kMaxOverlapF) {
        const iR = (d - 1 - (kF + baDeltaLength)) / 2;
        if (iR <= iMaxR && aIndexesR[iR] - 1 <= aLast) {
          const bLastPrev = bF + aLastPrev - (insert ? kF + 1 : kF - 1);
          const nCommonR = countCommonItemsR(
            aStart,
            aLastPrev,
            bStart,
            bLastPrev,
            isCommon
          );
          const aIndexPrevFirst = aLastPrev - nCommonR;
          const bIndexPrevFirst = bLastPrev - nCommonR;
          const aEndPreceding = aIndexPrevFirst + 1;
          const bEndPreceding = bIndexPrevFirst + 1;
          division.nChangePreceding = d - 1;
          if (d - 1 === aEndPreceding + bEndPreceding - aStart - bStart) {
            division.aEndPreceding = aStart;
            division.bEndPreceding = bStart;
          } else {
            division.aEndPreceding = aEndPreceding;
            division.bEndPreceding = bEndPreceding;
          }
          division.nCommonPreceding = nCommonR;
          if (nCommonR !== 0) {
            division.aCommonPreceding = aEndPreceding;
            division.bCommonPreceding = bEndPreceding;
          }
          division.nCommonFollowing = nCommonF;
          if (nCommonF !== 0) {
            division.aCommonFollowing = aFirst + 1;
            division.bCommonFollowing = bFirst + 1;
          }
          const aStartFollowing = aLast + 1;
          const bStartFollowing = bFirst + nCommonF + 1;
          division.nChangeFollowing = d - 1;
          if (d - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing) {
            division.aStartFollowing = aEnd;
            division.bStartFollowing = bEnd;
          } else {
            division.aStartFollowing = aStartFollowing;
            division.bStartFollowing = bStartFollowing;
          }
          return true;
        }
      }
    }
    return false;
  }, "extendOverlappablePathsF");
  const extendOverlappablePathsR = /* @__PURE__ */ __name((d, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division) => {
    const bR = bEnd - aEnd;
    const aLength = aEnd - aStart;
    const bLength = bEnd - bStart;
    const baDeltaLength = bLength - aLength;
    const kMinOverlapR = baDeltaLength - d;
    const kMaxOverlapR = baDeltaLength + d;
    let aIndexPrev1 = NOT_YET_SET;
    const nR = d < iMaxR ? d : iMaxR;
    for (let iR = 0, kR = d; iR <= nR; iR += 1, kR -= 2) {
      const insert = iR === 0 || iR !== d && aIndexesR[iR] < aIndexPrev1;
      const aLastPrev = insert ? aIndexesR[iR] : aIndexPrev1;
      const aFirst = insert ? aLastPrev : aLastPrev - 1;
      const bFirst = bR + aFirst - kR;
      const nCommonR = countCommonItemsR(
        aStart,
        aFirst - 1,
        bStart,
        bFirst - 1,
        isCommon
      );
      const aLast = aFirst - nCommonR;
      aIndexPrev1 = aIndexesR[iR];
      aIndexesR[iR] = aLast;
      if (kMinOverlapR <= kR && kR <= kMaxOverlapR) {
        const iF = (d + (kR - baDeltaLength)) / 2;
        if (iF <= iMaxF && aLast - 1 <= aIndexesF[iF]) {
          const bLast = bFirst - nCommonR;
          division.nChangePreceding = d;
          if (d === aLast + bLast - aStart - bStart) {
            division.aEndPreceding = aStart;
            division.bEndPreceding = bStart;
          } else {
            division.aEndPreceding = aLast;
            division.bEndPreceding = bLast;
          }
          division.nCommonPreceding = nCommonR;
          if (nCommonR !== 0) {
            division.aCommonPreceding = aLast;
            division.bCommonPreceding = bLast;
          }
          division.nChangeFollowing = d - 1;
          if (d === 1) {
            division.nCommonFollowing = 0;
            division.aStartFollowing = aEnd;
            division.bStartFollowing = bEnd;
          } else {
            const bLastPrev = bR + aLastPrev - (insert ? kR - 1 : kR + 1);
            const nCommonF = countCommonItemsF(
              aLastPrev,
              aEnd,
              bLastPrev,
              bEnd,
              isCommon
            );
            division.nCommonFollowing = nCommonF;
            if (nCommonF !== 0) {
              division.aCommonFollowing = aLastPrev;
              division.bCommonFollowing = bLastPrev;
            }
            const aStartFollowing = aLastPrev + nCommonF;
            const bStartFollowing = bLastPrev + nCommonF;
            if (d - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing) {
              division.aStartFollowing = aEnd;
              division.bStartFollowing = bEnd;
            } else {
              division.aStartFollowing = aStartFollowing;
              division.bStartFollowing = bStartFollowing;
            }
          }
          return true;
        }
      }
    }
    return false;
  }, "extendOverlappablePathsR");
  const divide = /* @__PURE__ */ __name((nChange, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, aIndexesR, division) => {
    const bF = bStart - aStart;
    const bR = bEnd - aEnd;
    const aLength = aEnd - aStart;
    const bLength = bEnd - bStart;
    const baDeltaLength = bLength - aLength;
    let iMaxF = aLength;
    let iMaxR = aLength;
    aIndexesF[0] = aStart - 1;
    aIndexesR[0] = aEnd;
    if (baDeltaLength % 2 === 0) {
      const dMin = (nChange || baDeltaLength) / 2;
      const dMax = (aLength + bLength) / 2;
      for (let d = 1; d <= dMax; d += 1) {
        iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);
        if (d < dMin) {
          iMaxR = extendPathsR(d, aStart, bStart, bR, isCommon, aIndexesR, iMaxR);
        } else if (
          // If a reverse path overlaps a forward path in the same diagonal,
          // return a division of the index intervals at the middle change.
          extendOverlappablePathsR(
            d,
            aStart,
            aEnd,
            bStart,
            bEnd,
            isCommon,
            aIndexesF,
            iMaxF,
            aIndexesR,
            iMaxR,
            division
          )
        ) {
          return;
        }
      }
    } else {
      const dMin = ((nChange || baDeltaLength) + 1) / 2;
      const dMax = (aLength + bLength + 1) / 2;
      let d = 1;
      iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);
      for (d += 1; d <= dMax; d += 1) {
        iMaxR = extendPathsR(
          d - 1,
          aStart,
          bStart,
          bR,
          isCommon,
          aIndexesR,
          iMaxR
        );
        if (d < dMin) {
          iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);
        } else if (
          // If a forward path overlaps a reverse path in the same diagonal,
          // return a division of the index intervals at the middle change.
          extendOverlappablePathsF(
            d,
            aStart,
            aEnd,
            bStart,
            bEnd,
            isCommon,
            aIndexesF,
            iMaxF,
            aIndexesR,
            iMaxR,
            division
          )
        ) {
          return;
        }
      }
    }
    throw new Error(
      `${pkg}: no overlap aStart=${aStart} aEnd=${aEnd} bStart=${bStart} bEnd=${bEnd}`
    );
  }, "divide");
  const findSubsequences = /* @__PURE__ */ __name((nChange, aStart, aEnd, bStart, bEnd, transposed, callbacks, aIndexesF, aIndexesR, division) => {
    if (bEnd - bStart < aEnd - aStart) {
      transposed = !transposed;
      if (transposed && callbacks.length === 1) {
        const { foundSubsequence: foundSubsequence2, isCommon: isCommon2 } = callbacks[0];
        callbacks[1] = {
          foundSubsequence: /* @__PURE__ */ __name((nCommon, bCommon, aCommon) => {
            foundSubsequence2(nCommon, aCommon, bCommon);
          }, "foundSubsequence"),
          isCommon: /* @__PURE__ */ __name((bIndex, aIndex) => isCommon2(aIndex, bIndex), "isCommon")
        };
      }
      const tStart = aStart;
      const tEnd = aEnd;
      aStart = bStart;
      aEnd = bEnd;
      bStart = tStart;
      bEnd = tEnd;
    }
    const { foundSubsequence, isCommon } = callbacks[transposed ? 1 : 0];
    divide(
      nChange,
      aStart,
      aEnd,
      bStart,
      bEnd,
      isCommon,
      aIndexesF,
      aIndexesR,
      division
    );
    const {
      nChangePreceding,
      aEndPreceding,
      bEndPreceding,
      nCommonPreceding,
      aCommonPreceding,
      bCommonPreceding,
      nCommonFollowing,
      aCommonFollowing,
      bCommonFollowing,
      nChangeFollowing,
      aStartFollowing,
      bStartFollowing
    } = division;
    if (aStart < aEndPreceding && bStart < bEndPreceding) {
      findSubsequences(
        nChangePreceding,
        aStart,
        aEndPreceding,
        bStart,
        bEndPreceding,
        transposed,
        callbacks,
        aIndexesF,
        aIndexesR,
        division
      );
    }
    if (nCommonPreceding !== 0) {
      foundSubsequence(nCommonPreceding, aCommonPreceding, bCommonPreceding);
    }
    if (nCommonFollowing !== 0) {
      foundSubsequence(nCommonFollowing, aCommonFollowing, bCommonFollowing);
    }
    if (aStartFollowing < aEnd && bStartFollowing < bEnd) {
      findSubsequences(
        nChangeFollowing,
        aStartFollowing,
        aEnd,
        bStartFollowing,
        bEnd,
        transposed,
        callbacks,
        aIndexesF,
        aIndexesR,
        division
      );
    }
  }, "findSubsequences");
  const validateLength = /* @__PURE__ */ __name((name, arg) => {
    if (typeof arg !== "number") {
      throw new TypeError(`${pkg}: ${name} typeof ${typeof arg} is not a number`);
    }
    if (!Number.isSafeInteger(arg)) {
      throw new RangeError(`${pkg}: ${name} value ${arg} is not a safe integer`);
    }
    if (arg < 0) {
      throw new RangeError(`${pkg}: ${name} value ${arg} is a negative integer`);
    }
  }, "validateLength");
  const validateCallback = /* @__PURE__ */ __name((name, arg) => {
    const type5 = typeof arg;
    if (type5 !== "function") {
      throw new TypeError(`${pkg}: ${name} typeof ${type5} is not a function`);
    }
  }, "validateCallback");
  function diffSequence(aLength, bLength, isCommon, foundSubsequence) {
    validateLength("aLength", aLength);
    validateLength("bLength", bLength);
    validateCallback("isCommon", isCommon);
    validateCallback("foundSubsequence", foundSubsequence);
    const nCommonF = countCommonItemsF(0, aLength, 0, bLength, isCommon);
    if (nCommonF !== 0) {
      foundSubsequence(nCommonF, 0, 0);
    }
    if (aLength !== nCommonF || bLength !== nCommonF) {
      const aStart = nCommonF;
      const bStart = nCommonF;
      const nCommonR = countCommonItemsR(
        aStart,
        aLength - 1,
        bStart,
        bLength - 1,
        isCommon
      );
      const aEnd = aLength - nCommonR;
      const bEnd = bLength - nCommonR;
      const nCommonFR = nCommonF + nCommonR;
      if (aLength !== nCommonFR && bLength !== nCommonFR) {
        const nChange = 0;
        const transposed = false;
        const callbacks = [
          {
            foundSubsequence,
            isCommon
          }
        ];
        const aIndexesF = [NOT_YET_SET];
        const aIndexesR = [NOT_YET_SET];
        const division = {
          aCommonFollowing: NOT_YET_SET,
          aCommonPreceding: NOT_YET_SET,
          aEndPreceding: NOT_YET_SET,
          aStartFollowing: NOT_YET_SET,
          bCommonFollowing: NOT_YET_SET,
          bCommonPreceding: NOT_YET_SET,
          bEndPreceding: NOT_YET_SET,
          bStartFollowing: NOT_YET_SET,
          nChangeFollowing: NOT_YET_SET,
          nChangePreceding: NOT_YET_SET,
          nCommonFollowing: NOT_YET_SET,
          nCommonPreceding: NOT_YET_SET
        };
        findSubsequences(
          nChange,
          aStart,
          aEnd,
          bStart,
          bEnd,
          transposed,
          callbacks,
          aIndexesF,
          aIndexesR,
          division
        );
      }
      if (nCommonR !== 0) {
        foundSubsequence(nCommonR, aEnd, bEnd);
      }
    }
  }
  __name(diffSequence, "diffSequence");
  return build;
}
__name(requireBuild, "requireBuild");
var buildExports = requireBuild();
var diffSequences = getDefaultExportFromCjs2(buildExports);
function formatTrailingSpaces(line, trailingSpaceFormatter) {
  return line.replace(/\s+$/, (match) => trailingSpaceFormatter(match));
}
__name(formatTrailingSpaces, "formatTrailingSpaces");
function printDiffLine(line, isFirstOrLast, color, indicator, trailingSpaceFormatter, emptyFirstOrLastLinePlaceholder) {
  return line.length !== 0 ? color(`${indicator} ${formatTrailingSpaces(line, trailingSpaceFormatter)}`) : indicator !== " " ? color(indicator) : isFirstOrLast && emptyFirstOrLastLinePlaceholder.length !== 0 ? color(`${indicator} ${emptyFirstOrLastLinePlaceholder}`) : "";
}
__name(printDiffLine, "printDiffLine");
function printDeleteLine(line, isFirstOrLast, { aColor, aIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder }) {
  return printDiffLine(line, isFirstOrLast, aColor, aIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);
}
__name(printDeleteLine, "printDeleteLine");
function printInsertLine(line, isFirstOrLast, { bColor, bIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder }) {
  return printDiffLine(line, isFirstOrLast, bColor, bIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);
}
__name(printInsertLine, "printInsertLine");
function printCommonLine(line, isFirstOrLast, { commonColor, commonIndicator, commonLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder }) {
  return printDiffLine(line, isFirstOrLast, commonColor, commonIndicator, commonLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);
}
__name(printCommonLine, "printCommonLine");
function createPatchMark(aStart, aEnd, bStart, bEnd, { patchColor }) {
  return patchColor(`@@ -${aStart + 1},${aEnd - aStart} +${bStart + 1},${bEnd - bStart} @@`);
}
__name(createPatchMark, "createPatchMark");
function joinAlignedDiffsNoExpand(diffs, options) {
  const iLength = diffs.length;
  const nContextLines = options.contextLines;
  const nContextLines2 = nContextLines + nContextLines;
  let jLength = iLength;
  let hasExcessAtStartOrEnd = false;
  let nExcessesBetweenChanges = 0;
  let i2 = 0;
  while (i2 !== iLength) {
    const iStart = i2;
    while (i2 !== iLength && diffs[i2][0] === DIFF_EQUAL) {
      i2 += 1;
    }
    if (iStart !== i2) {
      if (iStart === 0) {
        if (i2 > nContextLines) {
          jLength -= i2 - nContextLines;
          hasExcessAtStartOrEnd = true;
        }
      } else if (i2 === iLength) {
        const n2 = i2 - iStart;
        if (n2 > nContextLines) {
          jLength -= n2 - nContextLines;
          hasExcessAtStartOrEnd = true;
        }
      } else {
        const n2 = i2 - iStart;
        if (n2 > nContextLines2) {
          jLength -= n2 - nContextLines2;
          nExcessesBetweenChanges += 1;
        }
      }
    }
    while (i2 !== iLength && diffs[i2][0] !== DIFF_EQUAL) {
      i2 += 1;
    }
  }
  const hasPatch = nExcessesBetweenChanges !== 0 || hasExcessAtStartOrEnd;
  if (nExcessesBetweenChanges !== 0) {
    jLength += nExcessesBetweenChanges + 1;
  } else if (hasExcessAtStartOrEnd) {
    jLength += 1;
  }
  const jLast = jLength - 1;
  const lines = [];
  let jPatchMark = 0;
  if (hasPatch) {
    lines.push("");
  }
  let aStart = 0;
  let bStart = 0;
  let aEnd = 0;
  let bEnd = 0;
  const pushCommonLine = /* @__PURE__ */ __name((line) => {
    const j2 = lines.length;
    lines.push(printCommonLine(line, j2 === 0 || j2 === jLast, options));
    aEnd += 1;
    bEnd += 1;
  }, "pushCommonLine");
  const pushDeleteLine = /* @__PURE__ */ __name((line) => {
    const j2 = lines.length;
    lines.push(printDeleteLine(line, j2 === 0 || j2 === jLast, options));
    aEnd += 1;
  }, "pushDeleteLine");
  const pushInsertLine = /* @__PURE__ */ __name((line) => {
    const j2 = lines.length;
    lines.push(printInsertLine(line, j2 === 0 || j2 === jLast, options));
    bEnd += 1;
  }, "pushInsertLine");
  i2 = 0;
  while (i2 !== iLength) {
    let iStart = i2;
    while (i2 !== iLength && diffs[i2][0] === DIFF_EQUAL) {
      i2 += 1;
    }
    if (iStart !== i2) {
      if (iStart === 0) {
        if (i2 > nContextLines) {
          iStart = i2 - nContextLines;
          aStart = iStart;
          bStart = iStart;
          aEnd = aStart;
          bEnd = bStart;
        }
        for (let iCommon = iStart; iCommon !== i2; iCommon += 1) {
          pushCommonLine(diffs[iCommon][1]);
        }
      } else if (i2 === iLength) {
        const iEnd = i2 - iStart > nContextLines ? iStart + nContextLines : i2;
        for (let iCommon = iStart; iCommon !== iEnd; iCommon += 1) {
          pushCommonLine(diffs[iCommon][1]);
        }
      } else {
        const nCommon = i2 - iStart;
        if (nCommon > nContextLines2) {
          const iEnd = iStart + nContextLines;
          for (let iCommon = iStart; iCommon !== iEnd; iCommon += 1) {
            pushCommonLine(diffs[iCommon][1]);
          }
          lines[jPatchMark] = createPatchMark(aStart, aEnd, bStart, bEnd, options);
          jPatchMark = lines.length;
          lines.push("");
          const nOmit = nCommon - nContextLines2;
          aStart = aEnd + nOmit;
          bStart = bEnd + nOmit;
          aEnd = aStart;
          bEnd = bStart;
          for (let iCommon = i2 - nContextLines; iCommon !== i2; iCommon += 1) {
            pushCommonLine(diffs[iCommon][1]);
          }
        } else {
          for (let iCommon = iStart; iCommon !== i2; iCommon += 1) {
            pushCommonLine(diffs[iCommon][1]);
          }
        }
      }
    }
    while (i2 !== iLength && diffs[i2][0] === DIFF_DELETE) {
      pushDeleteLine(diffs[i2][1]);
      i2 += 1;
    }
    while (i2 !== iLength && diffs[i2][0] === DIFF_INSERT) {
      pushInsertLine(diffs[i2][1]);
      i2 += 1;
    }
  }
  if (hasPatch) {
    lines[jPatchMark] = createPatchMark(aStart, aEnd, bStart, bEnd, options);
  }
  return lines.join("\n");
}
__name(joinAlignedDiffsNoExpand, "joinAlignedDiffsNoExpand");
function joinAlignedDiffsExpand(diffs, options) {
  return diffs.map((diff2, i2, diffs2) => {
    const line = diff2[1];
    const isFirstOrLast = i2 === 0 || i2 === diffs2.length - 1;
    switch (diff2[0]) {
      case DIFF_DELETE:
        return printDeleteLine(line, isFirstOrLast, options);
      case DIFF_INSERT:
        return printInsertLine(line, isFirstOrLast, options);
      default:
        return printCommonLine(line, isFirstOrLast, options);
    }
  }).join("\n");
}
__name(joinAlignedDiffsExpand, "joinAlignedDiffsExpand");
var noColor = /* @__PURE__ */ __name((string) => string, "noColor");
var DIFF_CONTEXT_DEFAULT = 5;
var DIFF_TRUNCATE_THRESHOLD_DEFAULT = 0;
function getDefaultOptions() {
  return {
    aAnnotation: "Expected",
    aColor: s.green,
    aIndicator: "-",
    bAnnotation: "Received",
    bColor: s.red,
    bIndicator: "+",
    changeColor: s.inverse,
    changeLineTrailingSpaceColor: noColor,
    commonColor: s.dim,
    commonIndicator: " ",
    commonLineTrailingSpaceColor: noColor,
    compareKeys: void 0,
    contextLines: DIFF_CONTEXT_DEFAULT,
    emptyFirstOrLastLinePlaceholder: "",
    expand: false,
    includeChangeCounts: false,
    omitAnnotationLines: false,
    patchColor: s.yellow,
    printBasicPrototype: false,
    truncateThreshold: DIFF_TRUNCATE_THRESHOLD_DEFAULT,
    truncateAnnotation: "... Diff result is truncated",
    truncateAnnotationColor: noColor
  };
}
__name(getDefaultOptions, "getDefaultOptions");
function getCompareKeys(compareKeys) {
  return compareKeys && typeof compareKeys === "function" ? compareKeys : void 0;
}
__name(getCompareKeys, "getCompareKeys");
function getContextLines(contextLines) {
  return typeof contextLines === "number" && Number.isSafeInteger(contextLines) && contextLines >= 0 ? contextLines : DIFF_CONTEXT_DEFAULT;
}
__name(getContextLines, "getContextLines");
function normalizeDiffOptions(options = {}) {
  return {
    ...getDefaultOptions(),
    ...options,
    compareKeys: getCompareKeys(options.compareKeys),
    contextLines: getContextLines(options.contextLines)
  };
}
__name(normalizeDiffOptions, "normalizeDiffOptions");
function isEmptyString(lines) {
  return lines.length === 1 && lines[0].length === 0;
}
__name(isEmptyString, "isEmptyString");
function countChanges(diffs) {
  let a2 = 0;
  let b2 = 0;
  diffs.forEach((diff2) => {
    switch (diff2[0]) {
      case DIFF_DELETE:
        a2 += 1;
        break;
      case DIFF_INSERT:
        b2 += 1;
        break;
    }
  });
  return {
    a: a2,
    b: b2
  };
}
__name(countChanges, "countChanges");
function printAnnotation({ aAnnotation, aColor, aIndicator, bAnnotation, bColor, bIndicator, includeChangeCounts, omitAnnotationLines }, changeCounts) {
  if (omitAnnotationLines) {
    return "";
  }
  let aRest = "";
  let bRest = "";
  if (includeChangeCounts) {
    const aCount = String(changeCounts.a);
    const bCount = String(changeCounts.b);
    const baAnnotationLengthDiff = bAnnotation.length - aAnnotation.length;
    const aAnnotationPadding = " ".repeat(Math.max(0, baAnnotationLengthDiff));
    const bAnnotationPadding = " ".repeat(Math.max(0, -baAnnotationLengthDiff));
    const baCountLengthDiff = bCount.length - aCount.length;
    const aCountPadding = " ".repeat(Math.max(0, baCountLengthDiff));
    const bCountPadding = " ".repeat(Math.max(0, -baCountLengthDiff));
    aRest = `${aAnnotationPadding}  ${aIndicator} ${aCountPadding}${aCount}`;
    bRest = `${bAnnotationPadding}  ${bIndicator} ${bCountPadding}${bCount}`;
  }
  const a2 = `${aIndicator} ${aAnnotation}${aRest}`;
  const b2 = `${bIndicator} ${bAnnotation}${bRest}`;
  return `${aColor(a2)}
${bColor(b2)}

`;
}
__name(printAnnotation, "printAnnotation");
function printDiffLines(diffs, truncated, options) {
  return printAnnotation(options, countChanges(diffs)) + (options.expand ? joinAlignedDiffsExpand(diffs, options) : joinAlignedDiffsNoExpand(diffs, options)) + (truncated ? options.truncateAnnotationColor(`
${options.truncateAnnotation}`) : "");
}
__name(printDiffLines, "printDiffLines");
function diffLinesUnified(aLines, bLines, options) {
  const normalizedOptions = normalizeDiffOptions(options);
  const [diffs, truncated] = diffLinesRaw(isEmptyString(aLines) ? [] : aLines, isEmptyString(bLines) ? [] : bLines, normalizedOptions);
  return printDiffLines(diffs, truncated, normalizedOptions);
}
__name(diffLinesUnified, "diffLinesUnified");
function diffLinesUnified2(aLinesDisplay, bLinesDisplay, aLinesCompare, bLinesCompare, options) {
  if (isEmptyString(aLinesDisplay) && isEmptyString(aLinesCompare)) {
    aLinesDisplay = [];
    aLinesCompare = [];
  }
  if (isEmptyString(bLinesDisplay) && isEmptyString(bLinesCompare)) {
    bLinesDisplay = [];
    bLinesCompare = [];
  }
  if (aLinesDisplay.length !== aLinesCompare.length || bLinesDisplay.length !== bLinesCompare.length) {
    return diffLinesUnified(aLinesDisplay, bLinesDisplay, options);
  }
  const [diffs, truncated] = diffLinesRaw(aLinesCompare, bLinesCompare, options);
  let aIndex = 0;
  let bIndex = 0;
  diffs.forEach((diff2) => {
    switch (diff2[0]) {
      case DIFF_DELETE:
        diff2[1] = aLinesDisplay[aIndex];
        aIndex += 1;
        break;
      case DIFF_INSERT:
        diff2[1] = bLinesDisplay[bIndex];
        bIndex += 1;
        break;
      default:
        diff2[1] = bLinesDisplay[bIndex];
        aIndex += 1;
        bIndex += 1;
    }
  });
  return printDiffLines(diffs, truncated, normalizeDiffOptions(options));
}
__name(diffLinesUnified2, "diffLinesUnified2");
function diffLinesRaw(aLines, bLines, options) {
  const truncate3 = (options === null || options === void 0 ? void 0 : options.truncateThreshold) ?? false;
  const truncateThreshold = Math.max(Math.floor((options === null || options === void 0 ? void 0 : options.truncateThreshold) ?? 0), 0);
  const aLength = truncate3 ? Math.min(aLines.length, truncateThreshold) : aLines.length;
  const bLength = truncate3 ? Math.min(bLines.length, truncateThreshold) : bLines.length;
  const truncated = aLength !== aLines.length || bLength !== bLines.length;
  const isCommon = /* @__PURE__ */ __name((aIndex2, bIndex2) => aLines[aIndex2] === bLines[bIndex2], "isCommon");
  const diffs = [];
  let aIndex = 0;
  let bIndex = 0;
  const foundSubsequence = /* @__PURE__ */ __name((nCommon, aCommon, bCommon) => {
    for (; aIndex !== aCommon; aIndex += 1) {
      diffs.push(new Diff(DIFF_DELETE, aLines[aIndex]));
    }
    for (; bIndex !== bCommon; bIndex += 1) {
      diffs.push(new Diff(DIFF_INSERT, bLines[bIndex]));
    }
    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {
      diffs.push(new Diff(DIFF_EQUAL, bLines[bIndex]));
    }
  }, "foundSubsequence");
  diffSequences(aLength, bLength, isCommon, foundSubsequence);
  for (; aIndex !== aLength; aIndex += 1) {
    diffs.push(new Diff(DIFF_DELETE, aLines[aIndex]));
  }
  for (; bIndex !== bLength; bIndex += 1) {
    diffs.push(new Diff(DIFF_INSERT, bLines[bIndex]));
  }
  return [diffs, truncated];
}
__name(diffLinesRaw, "diffLinesRaw");
function getType3(value) {
  if (value === void 0) {
    return "undefined";
  } else if (value === null) {
    return "null";
  } else if (Array.isArray(value)) {
    return "array";
  } else if (typeof value === "boolean") {
    return "boolean";
  } else if (typeof value === "function") {
    return "function";
  } else if (typeof value === "number") {
    return "number";
  } else if (typeof value === "string") {
    return "string";
  } else if (typeof value === "bigint") {
    return "bigint";
  } else if (typeof value === "object") {
    if (value != null) {
      if (value.constructor === RegExp) {
        return "regexp";
      } else if (value.constructor === Map) {
        return "map";
      } else if (value.constructor === Set) {
        return "set";
      } else if (value.constructor === Date) {
        return "date";
      }
    }
    return "object";
  } else if (typeof value === "symbol") {
    return "symbol";
  }
  throw new Error(`value of unknown type: ${value}`);
}
__name(getType3, "getType");
function getNewLineSymbol(string) {
  return string.includes("\r\n") ? "\r\n" : "\n";
}
__name(getNewLineSymbol, "getNewLineSymbol");
function diffStrings(a2, b2, options) {
  const truncate3 = (options === null || options === void 0 ? void 0 : options.truncateThreshold) ?? false;
  const truncateThreshold = Math.max(Math.floor((options === null || options === void 0 ? void 0 : options.truncateThreshold) ?? 0), 0);
  let aLength = a2.length;
  let bLength = b2.length;
  if (truncate3) {
    const aMultipleLines = a2.includes("\n");
    const bMultipleLines = b2.includes("\n");
    const aNewLineSymbol = getNewLineSymbol(a2);
    const bNewLineSymbol = getNewLineSymbol(b2);
    const _a3 = aMultipleLines ? `${a2.split(aNewLineSymbol, truncateThreshold).join(aNewLineSymbol)}
` : a2;
    const _b = bMultipleLines ? `${b2.split(bNewLineSymbol, truncateThreshold).join(bNewLineSymbol)}
` : b2;
    aLength = _a3.length;
    bLength = _b.length;
  }
  const truncated = aLength !== a2.length || bLength !== b2.length;
  const isCommon = /* @__PURE__ */ __name((aIndex2, bIndex2) => a2[aIndex2] === b2[bIndex2], "isCommon");
  let aIndex = 0;
  let bIndex = 0;
  const diffs = [];
  const foundSubsequence = /* @__PURE__ */ __name((nCommon, aCommon, bCommon) => {
    if (aIndex !== aCommon) {
      diffs.push(new Diff(DIFF_DELETE, a2.slice(aIndex, aCommon)));
    }
    if (bIndex !== bCommon) {
      diffs.push(new Diff(DIFF_INSERT, b2.slice(bIndex, bCommon)));
    }
    aIndex = aCommon + nCommon;
    bIndex = bCommon + nCommon;
    diffs.push(new Diff(DIFF_EQUAL, b2.slice(bCommon, bIndex)));
  }, "foundSubsequence");
  diffSequences(aLength, bLength, isCommon, foundSubsequence);
  if (aIndex !== aLength) {
    diffs.push(new Diff(DIFF_DELETE, a2.slice(aIndex)));
  }
  if (bIndex !== bLength) {
    diffs.push(new Diff(DIFF_INSERT, b2.slice(bIndex)));
  }
  return [diffs, truncated];
}
__name(diffStrings, "diffStrings");
function concatenateRelevantDiffs(op, diffs, changeColor) {
  return diffs.reduce((reduced, diff2) => reduced + (diff2[0] === DIFF_EQUAL ? diff2[1] : diff2[0] === op && diff2[1].length !== 0 ? changeColor(diff2[1]) : ""), "");
}
__name(concatenateRelevantDiffs, "concatenateRelevantDiffs");
var _ChangeBuffer = class _ChangeBuffer {
  op;
  line;
  lines;
  changeColor;
  constructor(op, changeColor) {
    this.op = op;
    this.line = [];
    this.lines = [];
    this.changeColor = changeColor;
  }
  pushSubstring(substring) {
    this.pushDiff(new Diff(this.op, substring));
  }
  pushLine() {
    this.lines.push(this.line.length !== 1 ? new Diff(this.op, concatenateRelevantDiffs(this.op, this.line, this.changeColor)) : this.line[0][0] === this.op ? this.line[0] : new Diff(this.op, this.line[0][1]));
    this.line.length = 0;
  }
  isLineEmpty() {
    return this.line.length === 0;
  }
  // Minor input to buffer.
  pushDiff(diff2) {
    this.line.push(diff2);
  }
  // Main input to buffer.
  align(diff2) {
    const string = diff2[1];
    if (string.includes("\n")) {
      const substrings = string.split("\n");
      const iLast = substrings.length - 1;
      substrings.forEach((substring, i2) => {
        if (i2 < iLast) {
          this.pushSubstring(substring);
          this.pushLine();
        } else if (substring.length !== 0) {
          this.pushSubstring(substring);
        }
      });
    } else {
      this.pushDiff(diff2);
    }
  }
  // Output from buffer.
  moveLinesTo(lines) {
    if (!this.isLineEmpty()) {
      this.pushLine();
    }
    lines.push(...this.lines);
    this.lines.length = 0;
  }
};
__name(_ChangeBuffer, "ChangeBuffer");
var ChangeBuffer = _ChangeBuffer;
var _CommonBuffer = class _CommonBuffer {
  deleteBuffer;
  insertBuffer;
  lines;
  constructor(deleteBuffer, insertBuffer) {
    this.deleteBuffer = deleteBuffer;
    this.insertBuffer = insertBuffer;
    this.lines = [];
  }
  pushDiffCommonLine(diff2) {
    this.lines.push(diff2);
  }
  pushDiffChangeLines(diff2) {
    const isDiffEmpty = diff2[1].length === 0;
    if (!isDiffEmpty || this.deleteBuffer.isLineEmpty()) {
      this.deleteBuffer.pushDiff(diff2);
    }
    if (!isDiffEmpty || this.insertBuffer.isLineEmpty()) {
      this.insertBuffer.pushDiff(diff2);
    }
  }
  flushChangeLines() {
    this.deleteBuffer.moveLinesTo(this.lines);
    this.insertBuffer.moveLinesTo(this.lines);
  }
  // Input to buffer.
  align(diff2) {
    const op = diff2[0];
    const string = diff2[1];
    if (string.includes("\n")) {
      const substrings = string.split("\n");
      const iLast = substrings.length - 1;
      substrings.forEach((substring, i2) => {
        if (i2 === 0) {
          const subdiff = new Diff(op, substring);
          if (this.deleteBuffer.isLineEmpty() && this.insertBuffer.isLineEmpty()) {
            this.flushChangeLines();
            this.pushDiffCommonLine(subdiff);
          } else {
            this.pushDiffChangeLines(subdiff);
            this.flushChangeLines();
          }
        } else if (i2 < iLast) {
          this.pushDiffCommonLine(new Diff(op, substring));
        } else if (substring.length !== 0) {
          this.pushDiffChangeLines(new Diff(op, substring));
        }
      });
    } else {
      this.pushDiffChangeLines(diff2);
    }
  }
  // Output from buffer.
  getLines() {
    this.flushChangeLines();
    return this.lines;
  }
};
__name(_CommonBuffer, "CommonBuffer");
var CommonBuffer = _CommonBuffer;
function getAlignedDiffs(diffs, changeColor) {
  const deleteBuffer = new ChangeBuffer(DIFF_DELETE, changeColor);
  const insertBuffer = new ChangeBuffer(DIFF_INSERT, changeColor);
  const commonBuffer = new CommonBuffer(deleteBuffer, insertBuffer);
  diffs.forEach((diff2) => {
    switch (diff2[0]) {
      case DIFF_DELETE:
        deleteBuffer.align(diff2);
        break;
      case DIFF_INSERT:
        insertBuffer.align(diff2);
        break;
      default:
        commonBuffer.align(diff2);
    }
  });
  return commonBuffer.getLines();
}
__name(getAlignedDiffs, "getAlignedDiffs");
function hasCommonDiff(diffs, isMultiline) {
  if (isMultiline) {
    const iLast = diffs.length - 1;
    return diffs.some((diff2, i2) => diff2[0] === DIFF_EQUAL && (i2 !== iLast || diff2[1] !== "\n"));
  }
  return diffs.some((diff2) => diff2[0] === DIFF_EQUAL);
}
__name(hasCommonDiff, "hasCommonDiff");
function diffStringsUnified(a2, b2, options) {
  if (a2 !== b2 && a2.length !== 0 && b2.length !== 0) {
    const isMultiline = a2.includes("\n") || b2.includes("\n");
    const [diffs, truncated] = diffStringsRaw(isMultiline ? `${a2}
` : a2, isMultiline ? `${b2}
` : b2, true, options);
    if (hasCommonDiff(diffs, isMultiline)) {
      const optionsNormalized = normalizeDiffOptions(options);
      const lines = getAlignedDiffs(diffs, optionsNormalized.changeColor);
      return printDiffLines(lines, truncated, optionsNormalized);
    }
  }
  return diffLinesUnified(a2.split("\n"), b2.split("\n"), options);
}
__name(diffStringsUnified, "diffStringsUnified");
function diffStringsRaw(a2, b2, cleanup, options) {
  const [diffs, truncated] = diffStrings(a2, b2, options);
  if (cleanup) {
    diff_cleanupSemantic(diffs);
  }
  return [diffs, truncated];
}
__name(diffStringsRaw, "diffStringsRaw");
function getCommonMessage(message, options) {
  const { commonColor } = normalizeDiffOptions(options);
  return commonColor(message);
}
__name(getCommonMessage, "getCommonMessage");
var { AsymmetricMatcher: AsymmetricMatcher2, DOMCollection: DOMCollection2, DOMElement: DOMElement2, Immutable: Immutable2, ReactElement: ReactElement2, ReactTestComponent: ReactTestComponent2 } = plugins;
var PLUGINS2 = [
  ReactTestComponent2,
  ReactElement2,
  DOMElement2,
  DOMCollection2,
  Immutable2,
  AsymmetricMatcher2,
  plugins.Error
];
var FORMAT_OPTIONS = {
  maxDepth: 20,
  plugins: PLUGINS2
};
var FALLBACK_FORMAT_OPTIONS = {
  callToJSON: false,
  maxDepth: 8,
  plugins: PLUGINS2
};
function diff(a2, b2, options) {
  if (Object.is(a2, b2)) {
    return "";
  }
  const aType = getType3(a2);
  let expectedType = aType;
  let omitDifference = false;
  if (aType === "object" && typeof a2.asymmetricMatch === "function") {
    if (a2.$$typeof !== Symbol.for("jest.asymmetricMatcher")) {
      return void 0;
    }
    if (typeof a2.getExpectedType !== "function") {
      return void 0;
    }
    expectedType = a2.getExpectedType();
    omitDifference = expectedType === "string";
  }
  if (expectedType !== getType3(b2)) {
    let truncate3 = function(s3) {
      return s3.length <= MAX_LENGTH ? s3 : `${s3.slice(0, MAX_LENGTH)}...`;
    };
    __name(truncate3, "truncate");
    const { aAnnotation, aColor, aIndicator, bAnnotation, bColor, bIndicator } = normalizeDiffOptions(options);
    const formatOptions = getFormatOptions(FALLBACK_FORMAT_OPTIONS, options);
    let aDisplay = format(a2, formatOptions);
    let bDisplay = format(b2, formatOptions);
    const MAX_LENGTH = 1e5;
    aDisplay = truncate3(aDisplay);
    bDisplay = truncate3(bDisplay);
    const aDiff = `${aColor(`${aIndicator} ${aAnnotation}:`)} 
${aDisplay}`;
    const bDiff = `${bColor(`${bIndicator} ${bAnnotation}:`)} 
${bDisplay}`;
    return `${aDiff}

${bDiff}`;
  }
  if (omitDifference) {
    return void 0;
  }
  switch (aType) {
    case "string":
      return diffLinesUnified(a2.split("\n"), b2.split("\n"), options);
    case "boolean":
    case "number":
      return comparePrimitive(a2, b2, options);
    case "map":
      return compareObjects(sortMap(a2), sortMap(b2), options);
    case "set":
      return compareObjects(sortSet(a2), sortSet(b2), options);
    default:
      return compareObjects(a2, b2, options);
  }
}
__name(diff, "diff");
function comparePrimitive(a2, b2, options) {
  const aFormat = format(a2, FORMAT_OPTIONS);
  const bFormat = format(b2, FORMAT_OPTIONS);
  return aFormat === bFormat ? "" : diffLinesUnified(aFormat.split("\n"), bFormat.split("\n"), options);
}
__name(comparePrimitive, "comparePrimitive");
function sortMap(map2) {
  return new Map(Array.from(map2.entries()).sort());
}
__name(sortMap, "sortMap");
function sortSet(set2) {
  return new Set(Array.from(set2.values()).sort());
}
__name(sortSet, "sortSet");
function compareObjects(a2, b2, options) {
  let difference;
  let hasThrown = false;
  try {
    const formatOptions = getFormatOptions(FORMAT_OPTIONS, options);
    difference = getObjectsDifference(a2, b2, formatOptions, options);
  } catch {
    hasThrown = true;
  }
  const noDiffMessage = getCommonMessage(NO_DIFF_MESSAGE, options);
  if (difference === void 0 || difference === noDiffMessage) {
    const formatOptions = getFormatOptions(FALLBACK_FORMAT_OPTIONS, options);
    difference = getObjectsDifference(a2, b2, formatOptions, options);
    if (difference !== noDiffMessage && !hasThrown) {
      difference = `${getCommonMessage(SIMILAR_MESSAGE, options)}

${difference}`;
    }
  }
  return difference;
}
__name(compareObjects, "compareObjects");
function getFormatOptions(formatOptions, options) {
  const { compareKeys, printBasicPrototype, maxDepth } = normalizeDiffOptions(options);
  return {
    ...formatOptions,
    compareKeys,
    printBasicPrototype,
    maxDepth: maxDepth ?? formatOptions.maxDepth
  };
}
__name(getFormatOptions, "getFormatOptions");
function getObjectsDifference(a2, b2, formatOptions, options) {
  const formatOptionsZeroIndent = {
    ...formatOptions,
    indent: 0
  };
  const aCompare = format(a2, formatOptionsZeroIndent);
  const bCompare = format(b2, formatOptionsZeroIndent);
  if (aCompare === bCompare) {
    return getCommonMessage(NO_DIFF_MESSAGE, options);
  } else {
    const aDisplay = format(a2, formatOptions);
    const bDisplay = format(b2, formatOptions);
    return diffLinesUnified2(aDisplay.split("\n"), bDisplay.split("\n"), aCompare.split("\n"), bCompare.split("\n"), options);
  }
}
__name(getObjectsDifference, "getObjectsDifference");
var MAX_DIFF_STRING_LENGTH = 2e4;
function isAsymmetricMatcher(data) {
  const type5 = getType2(data);
  return type5 === "Object" && typeof data.asymmetricMatch === "function";
}
__name(isAsymmetricMatcher, "isAsymmetricMatcher");
function isReplaceable(obj1, obj2) {
  const obj1Type = getType2(obj1);
  const obj2Type = getType2(obj2);
  return obj1Type === obj2Type && (obj1Type === "Object" || obj1Type === "Array");
}
__name(isReplaceable, "isReplaceable");
function printDiffOrStringify(received, expected, options) {
  const { aAnnotation, bAnnotation } = normalizeDiffOptions(options);
  if (typeof expected === "string" && typeof received === "string" && expected.length > 0 && received.length > 0 && expected.length <= MAX_DIFF_STRING_LENGTH && received.length <= MAX_DIFF_STRING_LENGTH && expected !== received) {
    if (expected.includes("\n") || received.includes("\n")) {
      return diffStringsUnified(expected, received, options);
    }
    const [diffs] = diffStringsRaw(expected, received, true);
    const hasCommonDiff2 = diffs.some((diff2) => diff2[0] === DIFF_EQUAL);
    const printLabel = getLabelPrinter(aAnnotation, bAnnotation);
    const expectedLine = printLabel(aAnnotation) + printExpected(getCommonAndChangedSubstrings(diffs, DIFF_DELETE, hasCommonDiff2));
    const receivedLine = printLabel(bAnnotation) + printReceived(getCommonAndChangedSubstrings(diffs, DIFF_INSERT, hasCommonDiff2));
    return `${expectedLine}
${receivedLine}`;
  }
  const clonedExpected = deepClone(expected, { forceWritable: true });
  const clonedReceived = deepClone(received, { forceWritable: true });
  const { replacedExpected, replacedActual } = replaceAsymmetricMatcher(clonedReceived, clonedExpected);
  const difference = diff(replacedExpected, replacedActual, options);
  return difference;
}
__name(printDiffOrStringify, "printDiffOrStringify");
function replaceAsymmetricMatcher(actual, expected, actualReplaced = /* @__PURE__ */ new WeakSet(), expectedReplaced = /* @__PURE__ */ new WeakSet()) {
  if (actual instanceof Error && expected instanceof Error && typeof actual.cause !== "undefined" && typeof expected.cause === "undefined") {
    delete actual.cause;
    return {
      replacedActual: actual,
      replacedExpected: expected
    };
  }
  if (!isReplaceable(actual, expected)) {
    return {
      replacedActual: actual,
      replacedExpected: expected
    };
  }
  if (actualReplaced.has(actual) || expectedReplaced.has(expected)) {
    return {
      replacedActual: actual,
      replacedExpected: expected
    };
  }
  actualReplaced.add(actual);
  expectedReplaced.add(expected);
  getOwnProperties(expected).forEach((key) => {
    const expectedValue = expected[key];
    const actualValue = actual[key];
    if (isAsymmetricMatcher(expectedValue)) {
      if (expectedValue.asymmetricMatch(actualValue)) {
        actual[key] = expectedValue;
      }
    } else if (isAsymmetricMatcher(actualValue)) {
      if (actualValue.asymmetricMatch(expectedValue)) {
        expected[key] = actualValue;
      }
    } else if (isReplaceable(actualValue, expectedValue)) {
      const replaced = replaceAsymmetricMatcher(actualValue, expectedValue, actualReplaced, expectedReplaced);
      actual[key] = replaced.replacedActual;
      expected[key] = replaced.replacedExpected;
    }
  });
  return {
    replacedActual: actual,
    replacedExpected: expected
  };
}
__name(replaceAsymmetricMatcher, "replaceAsymmetricMatcher");
function getLabelPrinter(...strings) {
  const maxLength = strings.reduce((max, string) => string.length > max ? string.length : max, 0);
  return (string) => `${string}: ${" ".repeat(maxLength - string.length)}`;
}
__name(getLabelPrinter, "getLabelPrinter");
var SPACE_SYMBOL = "\xB7";
function replaceTrailingSpaces(text) {
  return text.replace(/\s+$/gm, (spaces) => SPACE_SYMBOL.repeat(spaces.length));
}
__name(replaceTrailingSpaces, "replaceTrailingSpaces");
function printReceived(object) {
  return s.red(replaceTrailingSpaces(stringify2(object)));
}
__name(printReceived, "printReceived");
function printExpected(value) {
  return s.green(replaceTrailingSpaces(stringify2(value)));
}
__name(printExpected, "printExpected");
function getCommonAndChangedSubstrings(diffs, op, hasCommonDiff2) {
  return diffs.reduce((reduced, diff2) => reduced + (diff2[0] === DIFF_EQUAL ? diff2[1] : diff2[0] === op ? hasCommonDiff2 ? s.inverse(diff2[1]) : diff2[1] : ""), "");
}
__name(getCommonAndChangedSubstrings, "getCommonAndChangedSubstrings");

// ../node_modules/@vitest/utils/dist/error.js
var IS_RECORD_SYMBOL = "@@__IMMUTABLE_RECORD__@@";
var IS_COLLECTION_SYMBOL = "@@__IMMUTABLE_ITERABLE__@@";
function isImmutable(v2) {
  return v2 && (v2[IS_COLLECTION_SYMBOL] || v2[IS_RECORD_SYMBOL]);
}
__name(isImmutable, "isImmutable");
var OBJECT_PROTO = Object.getPrototypeOf({});
function getUnserializableMessage(err) {
  if (err instanceof Error) {
    return `<unserializable>: ${err.message}`;
  }
  if (typeof err === "string") {
    return `<unserializable>: ${err}`;
  }
  return "<unserializable>";
}
__name(getUnserializableMessage, "getUnserializableMessage");
function serializeValue(val, seen = /* @__PURE__ */ new WeakMap()) {
  if (!val || typeof val === "string") {
    return val;
  }
  if (val instanceof Error && "toJSON" in val && typeof val.toJSON === "function") {
    const jsonValue = val.toJSON();
    if (jsonValue && jsonValue !== val && typeof jsonValue === "object") {
      if (typeof val.message === "string") {
        safe(() => jsonValue.message ?? (jsonValue.message = val.message));
      }
      if (typeof val.stack === "string") {
        safe(() => jsonValue.stack ?? (jsonValue.stack = val.stack));
      }
      if (typeof val.name === "string") {
        safe(() => jsonValue.name ?? (jsonValue.name = val.name));
      }
      if (val.cause != null) {
        safe(() => jsonValue.cause ?? (jsonValue.cause = serializeValue(val.cause, seen)));
      }
    }
    return serializeValue(jsonValue, seen);
  }
  if (typeof val === "function") {
    return `Function<${val.name || "anonymous"}>`;
  }
  if (typeof val === "symbol") {
    return val.toString();
  }
  if (typeof val !== "object") {
    return val;
  }
  if (typeof Buffer !== "undefined" && val instanceof Buffer) {
    return `<Buffer(${val.length}) ...>`;
  }
  if (typeof Uint8Array !== "undefined" && val instanceof Uint8Array) {
    return `<Uint8Array(${val.length}) ...>`;
  }
  if (isImmutable(val)) {
    return serializeValue(val.toJSON(), seen);
  }
  if (val instanceof Promise || val.constructor && val.constructor.prototype === "AsyncFunction") {
    return "Promise";
  }
  if (typeof Element !== "undefined" && val instanceof Element) {
    return val.tagName;
  }
  if (typeof val.asymmetricMatch === "function") {
    return `${val.toString()} ${format2(val.sample)}`;
  }
  if (typeof val.toJSON === "function") {
    return serializeValue(val.toJSON(), seen);
  }
  if (seen.has(val)) {
    return seen.get(val);
  }
  if (Array.isArray(val)) {
    const clone3 = new Array(val.length);
    seen.set(val, clone3);
    val.forEach((e2, i2) => {
      try {
        clone3[i2] = serializeValue(e2, seen);
      } catch (err) {
        clone3[i2] = getUnserializableMessage(err);
      }
    });
    return clone3;
  } else {
    const clone3 = /* @__PURE__ */ Object.create(null);
    seen.set(val, clone3);
    let obj = val;
    while (obj && obj !== OBJECT_PROTO) {
      Object.getOwnPropertyNames(obj).forEach((key) => {
        if (key in clone3) {
          return;
        }
        try {
          clone3[key] = serializeValue(val[key], seen);
        } catch (err) {
          delete clone3[key];
          clone3[key] = getUnserializableMessage(err);
        }
      });
      obj = Object.getPrototypeOf(obj);
    }
    return clone3;
  }
}
__name(serializeValue, "serializeValue");
function safe(fn3) {
  try {
    return fn3();
  } catch {
  }
}
__name(safe, "safe");
function normalizeErrorMessage(message) {
  return message.replace(/__(vite_ssr_import|vi_import)_\d+__\./g, "");
}
__name(normalizeErrorMessage, "normalizeErrorMessage");
function processError(_err, diffOptions, seen = /* @__PURE__ */ new WeakSet()) {
  if (!_err || typeof _err !== "object") {
    return { message: String(_err) };
  }
  const err = _err;
  if (err.showDiff || err.showDiff === void 0 && err.expected !== void 0 && err.actual !== void 0) {
    err.diff = printDiffOrStringify(err.actual, err.expected, {
      ...diffOptions,
      ...err.diffOptions
    });
  }
  if ("expected" in err && typeof err.expected !== "string") {
    err.expected = stringify2(err.expected, 10);
  }
  if ("actual" in err && typeof err.actual !== "string") {
    err.actual = stringify2(err.actual, 10);
  }
  try {
    if (typeof err.message === "string") {
      err.message = normalizeErrorMessage(err.message);
    }
  } catch {
  }
  try {
    if (!seen.has(err) && typeof err.cause === "object") {
      seen.add(err);
      err.cause = processError(err.cause, diffOptions, seen);
    }
  } catch {
  }
  try {
    return serializeValue(err);
  } catch (e2) {
    return serializeValue(new Error(`Failed to fully serialize error: ${e2 === null || e2 === void 0 ? void 0 : e2.message}
Inner error message: ${err === null || err === void 0 ? void 0 : err.message}`));
  }
}
__name(processError, "processError");

// src/instrumenter/EVENTS.ts
var EVENTS = {
  CALL: "storybook/instrumenter/call",
  SYNC: "storybook/instrumenter/sync",
  START: "storybook/instrumenter/start",
  BACK: "storybook/instrumenter/back",
  GOTO: "storybook/instrumenter/goto",
  NEXT: "storybook/instrumenter/next",
  END: "storybook/instrumenter/end"
};

// src/instrumenter/preview-api.ts
var addons2 = globalThis.__STORYBOOK_ADDONS_PREVIEW;

// src/instrumenter/instrumenter.ts
var alreadyCompletedException = new Error(
  `This function ran after the play function completed. Did you forget to \`await\` it?`
);
var isObject5 = /* @__PURE__ */ __name((o2) => Object.prototype.toString.call(o2) === "[object Object]", "isObject");
var isModule = /* @__PURE__ */ __name((o2) => Object.prototype.toString.call(o2) === "[object Module]", "isModule");
var isInstrumentable = /* @__PURE__ */ __name((o2) => {
  if (!isObject5(o2) && !isModule(o2)) {
    return false;
  }
  if (o2.constructor === void 0) {
    return true;
  }
  const proto = o2.constructor.prototype;
  if (!isObject5(proto)) {
    return false;
  }
  return true;
}, "isInstrumentable");
var construct = /* @__PURE__ */ __name((obj) => {
  try {
    return new obj.constructor();
  } catch {
    return {};
  }
}, "construct");
var getInitialState = /* @__PURE__ */ __name(() => ({
  renderPhase: "preparing",
  isDebugging: false,
  isPlaying: false,
  isLocked: false,
  cursor: 0,
  calls: [],
  shadowCalls: [],
  callRefsByResult: /* @__PURE__ */ new Map(),
  chainedCallIds: /* @__PURE__ */ new Set(),
  ancestors: [],
  playUntil: void 0,
  resolvers: {},
  syncTimeout: void 0
}), "getInitialState");
var getRetainedState = /* @__PURE__ */ __name((state3, isDebugging = false) => {
  const calls = (isDebugging ? state3.shadowCalls : state3.calls).filter((call2) => call2.retain);
  if (!calls.length) {
    return void 0;
  }
  const callRefsByResult = new Map(
    Array.from(state3.callRefsByResult.entries()).filter(([, ref]) => ref.retain)
  );
  return { cursor: calls.length, calls, callRefsByResult };
}, "getRetainedState");
var _Instrumenter = class _Instrumenter {
  constructor() {
    this.detached = false;
    this.initialized = false;
    // State is tracked per story to deal with multiple stories on the same canvas (i.e. docs mode)
    this.state = {};
    this.loadParentWindowState = /* @__PURE__ */ __name(() => {
      try {
        this.state = scope.window?.parent?.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ || {};
      } catch {
        this.detached = true;
      }
    }, "loadParentWindowState");
    this.updateParentWindowState = /* @__PURE__ */ __name(() => {
      try {
        scope.window.parent.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ = this.state;
      } catch {
        this.detached = true;
      }
    }, "updateParentWindowState");
    this.loadParentWindowState();
    const resetState = /* @__PURE__ */ __name(({
      storyId,
      renderPhase,
      isPlaying = true,
      isDebugging = false
    }) => {
      const state3 = this.getState(storyId);
      this.setState(storyId, {
        ...getInitialState(),
        ...getRetainedState(state3, isDebugging),
        renderPhase: renderPhase || state3.renderPhase,
        shadowCalls: isDebugging ? state3.shadowCalls : [],
        chainedCallIds: isDebugging ? state3.chainedCallIds : /* @__PURE__ */ new Set(),
        playUntil: isDebugging ? state3.playUntil : void 0,
        isPlaying,
        isDebugging
      });
      this.sync(storyId);
    }, "resetState");
    const start = /* @__PURE__ */ __name((channel) => ({ storyId, playUntil }) => {
      if (!this.getState(storyId).isDebugging) {
        this.setState(storyId, ({ calls }) => ({
          calls: [],
          shadowCalls: calls.map((call2) => ({ ...call2, status: "waiting" /* WAITING */ })),
          isDebugging: true
        }));
      }
      const log = this.getLog(storyId);
      this.setState(storyId, ({ shadowCalls }) => {
        if (playUntil || !log.length) {
          return { playUntil };
        }
        const firstRowIndex = shadowCalls.findIndex((call2) => call2.id === log[0].callId);
        return {
          playUntil: shadowCalls.slice(0, firstRowIndex).filter((call2) => call2.interceptable && !call2.ancestors?.length).slice(-1)[0]?.id
        };
      });
      channel.emit(FORCE_REMOUNT, { storyId, isDebugging: true });
    }, "start");
    const back = /* @__PURE__ */ __name((channel) => ({ storyId }) => {
      const log = this.getLog(storyId).filter((call2) => !call2.ancestors?.length);
      const last = log.reduceRight((res, item, index2) => {
        if (res >= 0 || item.status === "waiting" /* WAITING */) {
          return res;
        }
        return index2;
      }, -1);
      start(channel)({ storyId, playUntil: log[last - 1]?.callId });
    }, "back");
    const goto = /* @__PURE__ */ __name((channel) => ({ storyId, callId }) => {
      const { calls, shadowCalls, resolvers } = this.getState(storyId);
      const call2 = calls.find(({ id }) => id === callId);
      const shadowCall = shadowCalls.find(({ id }) => id === callId);
      if (!call2 && shadowCall && Object.values(resolvers).length > 0) {
        const nextId = this.getLog(storyId).find((c2) => c2.status === "waiting" /* WAITING */)?.callId;
        if (shadowCall.id !== nextId) {
          this.setState(storyId, { playUntil: shadowCall.id });
        }
        Object.values(resolvers).forEach((resolve) => resolve());
      } else {
        start(channel)({ storyId, playUntil: callId });
      }
    }, "goto");
    const next = /* @__PURE__ */ __name((channel) => ({ storyId }) => {
      const { resolvers } = this.getState(storyId);
      if (Object.values(resolvers).length > 0) {
        Object.values(resolvers).forEach((resolve) => resolve());
      } else {
        const nextId = this.getLog(storyId).find((c2) => c2.status === "waiting" /* WAITING */)?.callId;
        if (nextId) {
          start(channel)({ storyId, playUntil: nextId });
        } else {
          end({ storyId });
        }
      }
    }, "next");
    const end = /* @__PURE__ */ __name(({ storyId }) => {
      this.setState(storyId, { playUntil: void 0, isDebugging: false });
      Object.values(this.getState(storyId).resolvers).forEach((resolve) => resolve());
    }, "end");
    const renderPhaseChanged = /* @__PURE__ */ __name(({
      storyId,
      newPhase
    }) => {
      const { isDebugging } = this.getState(storyId);
      if (newPhase === "preparing" && isDebugging) {
        return resetState({ storyId, renderPhase: newPhase, isDebugging });
      } else if (newPhase === "playing") {
        return resetState({ storyId, renderPhase: newPhase, isDebugging });
      }
      if (newPhase === "played") {
        this.setState(storyId, {
          renderPhase: newPhase,
          isLocked: false,
          isPlaying: false,
          isDebugging: false
        });
      } else if (newPhase === "errored") {
        this.setState(storyId, {
          renderPhase: newPhase,
          isLocked: false,
          isPlaying: false
        });
      } else if (newPhase === "aborted") {
        this.setState(storyId, {
          renderPhase: newPhase,
          isLocked: true,
          isPlaying: false
        });
      } else {
        this.setState(storyId, {
          renderPhase: newPhase
        });
      }
      this.sync(storyId);
    }, "renderPhaseChanged");
    if (addons2) {
      addons2.ready().then(() => {
        this.channel = addons2.getChannel();
        this.channel.on(FORCE_REMOUNT, resetState);
        this.channel.on(STORY_RENDER_PHASE_CHANGED, renderPhaseChanged);
        this.channel.on(SET_CURRENT_STORY, () => {
          if (this.initialized) {
            this.cleanup();
          } else {
            this.initialized = true;
          }
        });
        this.channel.on(EVENTS.START, start(this.channel));
        this.channel.on(EVENTS.BACK, back(this.channel));
        this.channel.on(EVENTS.GOTO, goto(this.channel));
        this.channel.on(EVENTS.NEXT, next(this.channel));
        this.channel.on(EVENTS.END, end);
      });
    }
  }
  getState(storyId) {
    return this.state[storyId] || getInitialState();
  }
  setState(storyId, update) {
    if (storyId) {
      const state3 = this.getState(storyId);
      const patch = typeof update === "function" ? update(state3) : update;
      this.state = { ...this.state, [storyId]: { ...state3, ...patch } };
      this.updateParentWindowState();
    }
  }
  cleanup() {
    this.state = Object.entries(this.state).reduce(
      (acc, [storyId, state3]) => {
        const retainedState = getRetainedState(state3);
        if (!retainedState) {
          return acc;
        }
        acc[storyId] = Object.assign(getInitialState(), retainedState);
        return acc;
      },
      {}
    );
    const controlStates = {
      detached: this.detached,
      start: false,
      back: false,
      goto: false,
      next: false,
      end: false
    };
    const payload = { controlStates, logItems: [] };
    this.channel?.emit(EVENTS.SYNC, payload);
    this.updateParentWindowState();
  }
  getLog(storyId) {
    const { calls, shadowCalls } = this.getState(storyId);
    const merged = [...shadowCalls];
    calls.forEach((call2, index2) => {
      merged[index2] = call2;
    });
    const seen = /* @__PURE__ */ new Set();
    return merged.reduceRight((acc, call2) => {
      call2.args.forEach((arg) => {
        if (arg?.__callId__) {
          seen.add(arg.__callId__);
        }
      });
      call2.path.forEach((node) => {
        if (node.__callId__) {
          seen.add(node.__callId__);
        }
      });
      if ((call2.interceptable || call2.exception) && !seen.has(call2.id)) {
        acc.unshift({ callId: call2.id, status: call2.status, ancestors: call2.ancestors });
        seen.add(call2.id);
      }
      return acc;
    }, []);
  }
  // Traverses the object structure to recursively patch all function properties.
  // Returns the original object, or a new object with the same constructor,
  // depending on whether it should mutate.
  instrument(obj, options, depth = 0) {
    if (!isInstrumentable(obj)) {
      return obj;
    }
    const { mutate = false, path = [] } = options;
    const keys2 = options.getKeys ? options.getKeys(obj, depth) : Object.keys(obj);
    depth += 1;
    return keys2.reduce(
      (acc, key) => {
        const descriptor = getPropertyDescriptor(obj, key);
        if (typeof descriptor?.get === "function") {
          if (descriptor.configurable) {
            const getter = /* @__PURE__ */ __name(() => descriptor?.get?.bind(obj)?.(), "getter");
            Object.defineProperty(acc, key, {
              get: /* @__PURE__ */ __name(() => {
                return this.instrument(getter(), { ...options, path: path.concat(key) }, depth);
              }, "get")
            });
          }
          return acc;
        }
        const value = obj[key];
        if (typeof value !== "function") {
          acc[key] = this.instrument(value, { ...options, path: path.concat(key) }, depth);
          return acc;
        }
        if ("__originalFn__" in value && typeof value.__originalFn__ === "function") {
          acc[key] = value;
          return acc;
        }
        acc[key] = (...args) => this.track(key, value, obj, args, options);
        acc[key].__originalFn__ = value;
        Object.defineProperty(acc[key], "name", { value: key, writable: false });
        if (Object.keys(value).length > 0) {
          Object.assign(
            acc[key],
            this.instrument({ ...value }, { ...options, path: path.concat(key) }, depth)
          );
        }
        return acc;
      },
      mutate ? obj : construct(obj)
    );
  }
  // Monkey patch an object method to record calls.
  // Returns a function that invokes the original function, records the invocation ("call") and
  // returns the original result.
  track(method, fn3, object, args, options) {
    const storyId = args?.[0]?.__storyId__ || scope.__STORYBOOK_PREVIEW__?.selectionStore?.selection?.storyId;
    const { cursor, ancestors } = this.getState(storyId);
    this.setState(storyId, { cursor: cursor + 1 });
    const id = `${ancestors.slice(-1)[0] || storyId} [${cursor}] ${method}`;
    const { path = [], intercept = false, retain = false } = options;
    const interceptable = typeof intercept === "function" ? intercept(method, path) : intercept;
    const call2 = { id, cursor, storyId, ancestors, path, method, args, interceptable, retain };
    const interceptOrInvoke = interceptable && !ancestors.length ? this.intercept : this.invoke;
    const result = interceptOrInvoke.call(this, fn3, object, call2, options);
    return this.instrument(result, { ...options, mutate: true, path: [{ __callId__: call2.id }] });
  }
  intercept(fn3, object, call2, options) {
    const { chainedCallIds, isDebugging, playUntil } = this.getState(call2.storyId);
    const isChainedUpon = chainedCallIds.has(call2.id);
    if (!isDebugging || isChainedUpon || playUntil) {
      if (playUntil === call2.id) {
        this.setState(call2.storyId, { playUntil: void 0 });
      }
      return this.invoke(fn3, object, call2, options);
    }
    return new Promise((resolve) => {
      this.setState(call2.storyId, ({ resolvers }) => ({
        isLocked: false,
        resolvers: { ...resolvers, [call2.id]: resolve }
      }));
    }).then(() => {
      this.setState(call2.storyId, (state3) => {
        const { [call2.id]: _, ...resolvers } = state3.resolvers;
        return { isLocked: true, resolvers };
      });
      return this.invoke(fn3, object, call2, options);
    });
  }
  invoke(fn3, object, call2, options) {
    const { callRefsByResult, renderPhase } = this.getState(call2.storyId);
    const maximumDepth = 25;
    const serializeValues = /* @__PURE__ */ __name((value, depth, seen) => {
      if (seen.includes(value)) {
        return "[Circular]";
      }
      seen = [...seen, value];
      if (depth > maximumDepth) {
        return "...";
      }
      if (callRefsByResult.has(value)) {
        return callRefsByResult.get(value);
      }
      if (value instanceof Array) {
        return value.map((it) => serializeValues(it, ++depth, seen));
      }
      if (value instanceof Date) {
        return { __date__: { value: value.toISOString() } };
      }
      if (value instanceof Error) {
        const { name, message, stack } = value;
        return { __error__: { name, message, stack } };
      }
      if (value instanceof RegExp) {
        const { flags, source } = value;
        return { __regexp__: { flags, source } };
      }
      if (value instanceof scope.window?.HTMLElement) {
        const { prefix: prefix2, localName, id, classList, innerText } = value;
        const classNames = Array.from(classList);
        return { __element__: { prefix: prefix2, localName, id, classNames, innerText } };
      }
      if (typeof value === "function") {
        return {
          __function__: { name: "getMockName" in value ? value.getMockName() : value.name }
        };
      }
      if (typeof value === "symbol") {
        return { __symbol__: { description: value.description } };
      }
      if (typeof value === "object" && value?.constructor?.name && value?.constructor?.name !== "Object") {
        return { __class__: { name: value.constructor.name } };
      }
      if (Object.prototype.toString.call(value) === "[object Object]") {
        return Object.fromEntries(
          Object.entries(value).map(([key, val]) => [key, serializeValues(val, ++depth, seen)])
        );
      }
      return value;
    }, "serializeValues");
    const info = {
      ...call2,
      args: call2.args.map((arg) => serializeValues(arg, 0, []))
    };
    call2.path.forEach((ref) => {
      if (ref?.__callId__) {
        this.setState(call2.storyId, ({ chainedCallIds }) => ({
          chainedCallIds: new Set(Array.from(chainedCallIds).concat(ref.__callId__))
        }));
      }
    });
    const handleException = /* @__PURE__ */ __name((e2) => {
      if (e2 instanceof Error) {
        const { name, message, stack, callId = call2.id } = e2;
        const {
          showDiff = void 0,
          diff: diff2 = void 0,
          actual = void 0,
          expected = void 0
        } = e2.name === "AssertionError" ? processError(e2) : e2;
        const exception = { name, message, stack, callId, showDiff, diff: diff2, actual, expected };
        this.update({ ...info, status: "error" /* ERROR */, exception });
        this.setState(call2.storyId, (state3) => ({
          callRefsByResult: new Map([
            ...Array.from(state3.callRefsByResult.entries()),
            [e2, { __callId__: call2.id, retain: call2.retain }]
          ])
        }));
        if (call2.ancestors?.length) {
          if (!Object.prototype.hasOwnProperty.call(e2, "callId")) {
            Object.defineProperty(e2, "callId", { value: call2.id });
          }
          throw e2;
        }
      }
      throw e2;
    }, "handleException");
    try {
      if (renderPhase === "played" && !call2.retain) {
        throw alreadyCompletedException;
      }
      const actualArgs = options.getArgs ? options.getArgs(call2, this.getState(call2.storyId)) : call2.args;
      const finalArgs = actualArgs.map((arg) => {
        if (typeof arg !== "function" || isClass(arg) || Object.keys(arg).length) {
          return arg;
        }
        return (...args) => {
          const { cursor, ancestors } = this.getState(call2.storyId);
          this.setState(call2.storyId, { cursor: 0, ancestors: [...ancestors, call2.id] });
          const restore = /* @__PURE__ */ __name(() => this.setState(call2.storyId, { cursor, ancestors }), "restore");
          let willRestore = false;
          try {
            const res = arg(...args);
            if (res instanceof Promise) {
              willRestore = true;
              return res.finally(restore);
            }
            return res;
          } finally {
            if (!willRestore) {
              restore();
            }
          }
        };
      });
      const result = fn3.apply(object, finalArgs);
      if (result && ["object", "function", "symbol"].includes(typeof result)) {
        this.setState(call2.storyId, (state3) => ({
          callRefsByResult: new Map([
            ...Array.from(state3.callRefsByResult.entries()),
            [result, { __callId__: call2.id, retain: call2.retain }]
          ])
        }));
      }
      this.update({
        ...info,
        status: result instanceof Promise ? "active" /* ACTIVE */ : "done" /* DONE */
      });
      if (result instanceof Promise) {
        return result.then((value) => {
          this.update({ ...info, status: "done" /* DONE */ });
          return value;
        }, handleException);
      }
      return result;
    } catch (e2) {
      return handleException(e2);
    }
  }
  // Sends the call info to the manager and synchronizes the log.
  update(call2) {
    this.channel?.emit(EVENTS.CALL, call2);
    this.setState(call2.storyId, ({ calls }) => {
      const callsById = calls.concat(call2).reduce((a2, c2) => Object.assign(a2, { [c2.id]: c2 }), {});
      return {
        // Calls are sorted to ensure parent calls always come before calls in their callback.
        calls: Object.values(callsById).sort(
          (a2, b2) => a2.id.localeCompare(b2.id, void 0, { numeric: true })
        )
      };
    });
    this.sync(call2.storyId);
  }
  // Builds a log of interceptable calls and control states and sends it to the manager.
  // Uses a 0ms debounce because this might get called many times in one tick.
  sync(storyId) {
    const synchronize = /* @__PURE__ */ __name(() => {
      const { isLocked, isPlaying } = this.getState(storyId);
      const logItems = this.getLog(storyId);
      const pausedAt = logItems.filter(({ ancestors }) => !ancestors.length).find((item) => item.status === "waiting" /* WAITING */)?.callId;
      const hasActive = logItems.some((item) => item.status === "active" /* ACTIVE */);
      if (this.detached || isLocked || hasActive || logItems.length === 0) {
        const controlStates2 = {
          detached: this.detached,
          start: false,
          back: false,
          goto: false,
          next: false,
          end: false
        };
        const payload2 = { controlStates: controlStates2, logItems };
        this.channel?.emit(EVENTS.SYNC, payload2);
        return;
      }
      const hasPrevious = logItems.some(
        (item) => item.status === "done" /* DONE */ || item.status === "error" /* ERROR */
      );
      const controlStates = {
        detached: this.detached,
        start: hasPrevious,
        back: hasPrevious,
        goto: true,
        next: isPlaying,
        end: isPlaying
      };
      const payload = { controlStates, logItems, pausedAt };
      this.channel?.emit(EVENTS.SYNC, payload);
    }, "synchronize");
    this.setState(storyId, ({ syncTimeout }) => {
      clearTimeout(syncTimeout);
      return { syncTimeout: setTimeout(synchronize, 0) };
    });
  }
};
__name(_Instrumenter, "Instrumenter");
var Instrumenter = _Instrumenter;
function instrument(obj, options = {}) {
  try {
    let forceInstrument = false;
    let skipInstrument = false;
    if (scope.window?.location?.search?.includes("instrument=true")) {
      forceInstrument = true;
    } else if (scope.window?.location?.search?.includes("instrument=false")) {
      skipInstrument = true;
    }
    if (scope.window?.parent === scope.window && !forceInstrument || skipInstrument) {
      return obj;
    }
    if (scope.window && !scope.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__) {
      scope.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__ = new Instrumenter();
    }
    const instrumenter = scope.window?.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__;
    return instrumenter.instrument(obj, options);
  } catch (e2) {
    once.warn(e2);
    return obj;
  }
}
__name(instrument, "instrument");
function getPropertyDescriptor(obj, propName) {
  let target = obj;
  while (target != null) {
    const descriptor = Object.getOwnPropertyDescriptor(target, propName);
    if (descriptor) {
      return descriptor;
    }
    target = Object.getPrototypeOf(target);
  }
  return void 0;
}
__name(getPropertyDescriptor, "getPropertyDescriptor");
function isClass(obj) {
  if (typeof obj !== "function") {
    return false;
  }
  const descriptor = Object.getOwnPropertyDescriptor(obj, "prototype");
  if (!descriptor) {
    return false;
  }
  return !descriptor.writable;
}
__name(isClass, "isClass");

// ../node_modules/chai/index.js
var __defProp3 = Object.defineProperty;
var __name2 = /* @__PURE__ */ __name((target, value) => __defProp3(target, "name", { value, configurable: true }), "__name");
var __export2 = /* @__PURE__ */ __name((target, all) => {
  for (var name in all)
    __defProp3(target, name, { get: all[name], enumerable: true });
}, "__export");
var utils_exports = {};
__export2(utils_exports, {
  addChainableMethod: /* @__PURE__ */ __name(() => addChainableMethod, "addChainableMethod"),
  addLengthGuard: /* @__PURE__ */ __name(() => addLengthGuard, "addLengthGuard"),
  addMethod: /* @__PURE__ */ __name(() => addMethod, "addMethod"),
  addProperty: /* @__PURE__ */ __name(() => addProperty, "addProperty"),
  checkError: /* @__PURE__ */ __name(() => check_error_exports, "checkError"),
  compareByInspect: /* @__PURE__ */ __name(() => compareByInspect, "compareByInspect"),
  eql: /* @__PURE__ */ __name(() => deep_eql_default, "eql"),
  expectTypes: /* @__PURE__ */ __name(() => expectTypes, "expectTypes"),
  flag: /* @__PURE__ */ __name(() => flag, "flag"),
  getActual: /* @__PURE__ */ __name(() => getActual, "getActual"),
  getMessage: /* @__PURE__ */ __name(() => getMessage2, "getMessage"),
  getName: /* @__PURE__ */ __name(() => getName, "getName"),
  getOperator: /* @__PURE__ */ __name(() => getOperator, "getOperator"),
  getOwnEnumerableProperties: /* @__PURE__ */ __name(() => getOwnEnumerableProperties, "getOwnEnumerableProperties"),
  getOwnEnumerablePropertySymbols: /* @__PURE__ */ __name(() => getOwnEnumerablePropertySymbols, "getOwnEnumerablePropertySymbols"),
  getPathInfo: /* @__PURE__ */ __name(() => getPathInfo, "getPathInfo"),
  hasProperty: /* @__PURE__ */ __name(() => hasProperty, "hasProperty"),
  inspect: /* @__PURE__ */ __name(() => inspect22, "inspect"),
  isNaN: /* @__PURE__ */ __name(() => isNaN22, "isNaN"),
  isNumeric: /* @__PURE__ */ __name(() => isNumeric, "isNumeric"),
  isProxyEnabled: /* @__PURE__ */ __name(() => isProxyEnabled, "isProxyEnabled"),
  isRegExp: /* @__PURE__ */ __name(() => isRegExp2, "isRegExp"),
  objDisplay: /* @__PURE__ */ __name(() => objDisplay, "objDisplay"),
  overwriteChainableMethod: /* @__PURE__ */ __name(() => overwriteChainableMethod, "overwriteChainableMethod"),
  overwriteMethod: /* @__PURE__ */ __name(() => overwriteMethod, "overwriteMethod"),
  overwriteProperty: /* @__PURE__ */ __name(() => overwriteProperty, "overwriteProperty"),
  proxify: /* @__PURE__ */ __name(() => proxify, "proxify"),
  test: /* @__PURE__ */ __name(() => test2, "test"),
  transferFlags: /* @__PURE__ */ __name(() => transferFlags, "transferFlags"),
  type: /* @__PURE__ */ __name(() => type, "type")
});
var check_error_exports = {};
__export2(check_error_exports, {
  compatibleConstructor: /* @__PURE__ */ __name(() => compatibleConstructor, "compatibleConstructor"),
  compatibleInstance: /* @__PURE__ */ __name(() => compatibleInstance, "compatibleInstance"),
  compatibleMessage: /* @__PURE__ */ __name(() => compatibleMessage, "compatibleMessage"),
  getConstructorName: /* @__PURE__ */ __name(() => getConstructorName2, "getConstructorName"),
  getMessage: /* @__PURE__ */ __name(() => getMessage, "getMessage")
});
function isErrorInstance(obj) {
  return obj instanceof Error || Object.prototype.toString.call(obj) === "[object Error]";
}
__name(isErrorInstance, "isErrorInstance");
__name2(isErrorInstance, "isErrorInstance");
function isRegExp(obj) {
  return Object.prototype.toString.call(obj) === "[object RegExp]";
}
__name(isRegExp, "isRegExp");
__name2(isRegExp, "isRegExp");
function compatibleInstance(thrown, errorLike) {
  return isErrorInstance(errorLike) && thrown === errorLike;
}
__name(compatibleInstance, "compatibleInstance");
__name2(compatibleInstance, "compatibleInstance");
function compatibleConstructor(thrown, errorLike) {
  if (isErrorInstance(errorLike)) {
    return thrown.constructor === errorLike.constructor || thrown instanceof errorLike.constructor;
  } else if ((typeof errorLike === "object" || typeof errorLike === "function") && errorLike.prototype) {
    return thrown.constructor === errorLike || thrown instanceof errorLike;
  }
  return false;
}
__name(compatibleConstructor, "compatibleConstructor");
__name2(compatibleConstructor, "compatibleConstructor");
function compatibleMessage(thrown, errMatcher) {
  const comparisonString = typeof thrown === "string" ? thrown : thrown.message;
  if (isRegExp(errMatcher)) {
    return errMatcher.test(comparisonString);
  } else if (typeof errMatcher === "string") {
    return comparisonString.indexOf(errMatcher) !== -1;
  }
  return false;
}
__name(compatibleMessage, "compatibleMessage");
__name2(compatibleMessage, "compatibleMessage");
function getConstructorName2(errorLike) {
  let constructorName = errorLike;
  if (isErrorInstance(errorLike)) {
    constructorName = errorLike.constructor.name;
  } else if (typeof errorLike === "function") {
    constructorName = errorLike.name;
    if (constructorName === "") {
      const newConstructorName = new errorLike().name;
      constructorName = newConstructorName || constructorName;
    }
  }
  return constructorName;
}
__name(getConstructorName2, "getConstructorName");
__name2(getConstructorName2, "getConstructorName");
function getMessage(errorLike) {
  let msg = "";
  if (errorLike && errorLike.message) {
    msg = errorLike.message;
  } else if (typeof errorLike === "string") {
    msg = errorLike;
  }
  return msg;
}
__name(getMessage, "getMessage");
__name2(getMessage, "getMessage");
function flag(obj, key, value) {
  let flags = obj.__flags || (obj.__flags = /* @__PURE__ */ Object.create(null));
  if (arguments.length === 3) {
    flags[key] = value;
  } else {
    return flags[key];
  }
}
__name(flag, "flag");
__name2(flag, "flag");
function test2(obj, args) {
  let negate = flag(obj, "negate"), expr = args[0];
  return negate ? !expr : expr;
}
__name(test2, "test");
__name2(test2, "test");
function type(obj) {
  if (typeof obj === "undefined") {
    return "undefined";
  }
  if (obj === null) {
    return "null";
  }
  const stringTag2 = obj[Symbol.toStringTag];
  if (typeof stringTag2 === "string") {
    return stringTag2;
  }
  const type32 = Object.prototype.toString.call(obj).slice(8, -1);
  return type32;
}
__name(type, "type");
__name2(type, "type");
var canElideFrames = "captureStackTrace" in Error;
var _a;
var AssertionError = (_a = class extends Error {
  message;
  get name() {
    return "AssertionError";
  }
  get ok() {
    return false;
  }
  constructor(message = "Unspecified AssertionError", props, ssf) {
    super(message);
    this.message = message;
    if (canElideFrames) {
      Error.captureStackTrace(this, ssf || _a);
    }
    for (const key in props) {
      if (!(key in this)) {
        this[key] = props[key];
      }
    }
  }
  toJSON(stack) {
    return {
      ...this,
      name: this.name,
      message: this.message,
      ok: false,
      stack: stack !== false ? this.stack : void 0
    };
  }
}, __name(_a, "_AssertionError"), __name2(_a, "AssertionError"), _a);
function expectTypes(obj, types) {
  let flagMsg = flag(obj, "message");
  let ssfi = flag(obj, "ssfi");
  flagMsg = flagMsg ? flagMsg + ": " : "";
  obj = flag(obj, "object");
  types = types.map(function(t2) {
    return t2.toLowerCase();
  });
  types.sort();
  let str2 = types.map(function(t2, index2) {
    let art = ~["a", "e", "i", "o", "u"].indexOf(t2.charAt(0)) ? "an" : "a";
    let or = types.length > 1 && index2 === types.length - 1 ? "or " : "";
    return or + art + " " + t2;
  }).join(", ");
  let objType = type(obj).toLowerCase();
  if (!types.some(function(expected) {
    return objType === expected;
  })) {
    throw new AssertionError(
      flagMsg + "object tested must be " + str2 + ", but " + objType + " given",
      void 0,
      ssfi
    );
  }
}
__name(expectTypes, "expectTypes");
__name2(expectTypes, "expectTypes");
function getActual(obj, args) {
  return args.length > 4 ? args[4] : obj._obj;
}
__name(getActual, "getActual");
__name2(getActual, "getActual");
var ansiColors2 = {
  bold: ["1", "22"],
  dim: ["2", "22"],
  italic: ["3", "23"],
  underline: ["4", "24"],
  // 5 & 6 are blinking
  inverse: ["7", "27"],
  hidden: ["8", "28"],
  strike: ["9", "29"],
  // 10-20 are fonts
  // 21-29 are resets for 1-9
  black: ["30", "39"],
  red: ["31", "39"],
  green: ["32", "39"],
  yellow: ["33", "39"],
  blue: ["34", "39"],
  magenta: ["35", "39"],
  cyan: ["36", "39"],
  white: ["37", "39"],
  brightblack: ["30;1", "39"],
  brightred: ["31;1", "39"],
  brightgreen: ["32;1", "39"],
  brightyellow: ["33;1", "39"],
  brightblue: ["34;1", "39"],
  brightmagenta: ["35;1", "39"],
  brightcyan: ["36;1", "39"],
  brightwhite: ["37;1", "39"],
  grey: ["90", "39"]
};
var styles2 = {
  special: "cyan",
  number: "yellow",
  bigint: "yellow",
  boolean: "yellow",
  undefined: "grey",
  null: "bold",
  string: "green",
  symbol: "green",
  date: "magenta",
  regexp: "red"
};
var truncator2 = "\u2026";
function colorise2(value, styleType) {
  const color = ansiColors2[styles2[styleType]] || ansiColors2[styleType] || "";
  if (!color) {
    return String(value);
  }
  return `\x1B[${color[0]}m${String(value)}\x1B[${color[1]}m`;
}
__name(colorise2, "colorise");
__name2(colorise2, "colorise");
function normaliseOptions2({
  showHidden = false,
  depth = 2,
  colors: colors3 = false,
  customInspect = true,
  showProxy = false,
  maxArrayLength = Infinity,
  breakLength = Infinity,
  seen = [],
  // eslint-disable-next-line no-shadow
  truncate: truncate22 = Infinity,
  stylize = String
} = {}, inspect32) {
  const options = {
    showHidden: Boolean(showHidden),
    depth: Number(depth),
    colors: Boolean(colors3),
    customInspect: Boolean(customInspect),
    showProxy: Boolean(showProxy),
    maxArrayLength: Number(maxArrayLength),
    breakLength: Number(breakLength),
    truncate: Number(truncate22),
    seen,
    inspect: inspect32,
    stylize
  };
  if (options.colors) {
    options.stylize = colorise2;
  }
  return options;
}
__name(normaliseOptions2, "normaliseOptions");
__name2(normaliseOptions2, "normaliseOptions");
function isHighSurrogate2(char) {
  return char >= "\uD800" && char <= "\uDBFF";
}
__name(isHighSurrogate2, "isHighSurrogate");
__name2(isHighSurrogate2, "isHighSurrogate");
function truncate2(string, length, tail = truncator2) {
  string = String(string);
  const tailLength = tail.length;
  const stringLength = string.length;
  if (tailLength > length && stringLength > tailLength) {
    return tail;
  }
  if (stringLength > length && stringLength > tailLength) {
    let end = length - tailLength;
    if (end > 0 && isHighSurrogate2(string[end - 1])) {
      end = end - 1;
    }
    return `${string.slice(0, end)}${tail}`;
  }
  return string;
}
__name(truncate2, "truncate");
__name2(truncate2, "truncate");
function inspectList2(list, options, inspectItem, separator = ", ") {
  inspectItem = inspectItem || options.inspect;
  const size = list.length;
  if (size === 0)
    return "";
  const originalLength = options.truncate;
  let output = "";
  let peek = "";
  let truncated = "";
  for (let i2 = 0; i2 < size; i2 += 1) {
    const last = i2 + 1 === list.length;
    const secondToLast = i2 + 2 === list.length;
    truncated = `${truncator2}(${list.length - i2})`;
    const value = list[i2];
    options.truncate = originalLength - output.length - (last ? 0 : separator.length);
    const string = peek || inspectItem(value, options) + (last ? "" : separator);
    const nextLength = output.length + string.length;
    const truncatedLength = nextLength + truncated.length;
    if (last && nextLength > originalLength && output.length + truncated.length <= originalLength) {
      break;
    }
    if (!last && !secondToLast && truncatedLength > originalLength) {
      break;
    }
    peek = last ? "" : inspectItem(list[i2 + 1], options) + (secondToLast ? "" : separator);
    if (!last && secondToLast && truncatedLength > originalLength && nextLength + peek.length > originalLength) {
      break;
    }
    output += string;
    if (!last && !secondToLast && nextLength + peek.length >= originalLength) {
      truncated = `${truncator2}(${list.length - i2 - 1})`;
      break;
    }
    truncated = "";
  }
  return `${output}${truncated}`;
}
__name(inspectList2, "inspectList");
__name2(inspectList2, "inspectList");
function quoteComplexKey2(key) {
  if (key.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/)) {
    return key;
  }
  return JSON.stringify(key).replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
}
__name(quoteComplexKey2, "quoteComplexKey");
__name2(quoteComplexKey2, "quoteComplexKey");
function inspectProperty2([key, value], options) {
  options.truncate -= 2;
  if (typeof key === "string") {
    key = quoteComplexKey2(key);
  } else if (typeof key !== "number") {
    key = `[${options.inspect(key, options)}]`;
  }
  options.truncate -= key.length;
  value = options.inspect(value, options);
  return `${key}: ${value}`;
}
__name(inspectProperty2, "inspectProperty");
__name2(inspectProperty2, "inspectProperty");
function inspectArray2(array, options) {
  const nonIndexProperties = Object.keys(array).slice(array.length);
  if (!array.length && !nonIndexProperties.length)
    return "[]";
  options.truncate -= 4;
  const listContents = inspectList2(array, options);
  options.truncate -= listContents.length;
  let propertyContents = "";
  if (nonIndexProperties.length) {
    propertyContents = inspectList2(nonIndexProperties.map((key) => [key, array[key]]), options, inspectProperty2);
  }
  return `[ ${listContents}${propertyContents ? `, ${propertyContents}` : ""} ]`;
}
__name(inspectArray2, "inspectArray");
__name2(inspectArray2, "inspectArray");
var getArrayName2 = __name2((array) => {
  if (typeof Buffer === "function" && array instanceof Buffer) {
    return "Buffer";
  }
  if (array[Symbol.toStringTag]) {
    return array[Symbol.toStringTag];
  }
  return array.constructor.name;
}, "getArrayName");
function inspectTypedArray2(array, options) {
  const name = getArrayName2(array);
  options.truncate -= name.length + 4;
  const nonIndexProperties = Object.keys(array).slice(array.length);
  if (!array.length && !nonIndexProperties.length)
    return `${name}[]`;
  let output = "";
  for (let i2 = 0; i2 < array.length; i2++) {
    const string = `${options.stylize(truncate2(array[i2], options.truncate), "number")}${i2 === array.length - 1 ? "" : ", "}`;
    options.truncate -= string.length;
    if (array[i2] !== array.length && options.truncate <= 3) {
      output += `${truncator2}(${array.length - array[i2] + 1})`;
      break;
    }
    output += string;
  }
  let propertyContents = "";
  if (nonIndexProperties.length) {
    propertyContents = inspectList2(nonIndexProperties.map((key) => [key, array[key]]), options, inspectProperty2);
  }
  return `${name}[ ${output}${propertyContents ? `, ${propertyContents}` : ""} ]`;
}
__name(inspectTypedArray2, "inspectTypedArray");
__name2(inspectTypedArray2, "inspectTypedArray");
function inspectDate2(dateObject, options) {
  const stringRepresentation = dateObject.toJSON();
  if (stringRepresentation === null) {
    return "Invalid Date";
  }
  const split = stringRepresentation.split("T");
  const date = split[0];
  return options.stylize(`${date}T${truncate2(split[1], options.truncate - date.length - 1)}`, "date");
}
__name(inspectDate2, "inspectDate");
__name2(inspectDate2, "inspectDate");
function inspectFunction2(func, options) {
  const functionType = func[Symbol.toStringTag] || "Function";
  const name = func.name;
  if (!name) {
    return options.stylize(`[${functionType}]`, "special");
  }
  return options.stylize(`[${functionType} ${truncate2(name, options.truncate - 11)}]`, "special");
}
__name(inspectFunction2, "inspectFunction");
__name2(inspectFunction2, "inspectFunction");
function inspectMapEntry2([key, value], options) {
  options.truncate -= 4;
  key = options.inspect(key, options);
  options.truncate -= key.length;
  value = options.inspect(value, options);
  return `${key} => ${value}`;
}
__name(inspectMapEntry2, "inspectMapEntry");
__name2(inspectMapEntry2, "inspectMapEntry");
function mapToEntries2(map2) {
  const entries = [];
  map2.forEach((value, key) => {
    entries.push([key, value]);
  });
  return entries;
}
__name(mapToEntries2, "mapToEntries");
__name2(mapToEntries2, "mapToEntries");
function inspectMap2(map2, options) {
  if (map2.size === 0)
    return "Map{}";
  options.truncate -= 7;
  return `Map{ ${inspectList2(mapToEntries2(map2), options, inspectMapEntry2)} }`;
}
__name(inspectMap2, "inspectMap");
__name2(inspectMap2, "inspectMap");
var isNaN3 = Number.isNaN || ((i2) => i2 !== i2);
function inspectNumber2(number, options) {
  if (isNaN3(number)) {
    return options.stylize("NaN", "number");
  }
  if (number === Infinity) {
    return options.stylize("Infinity", "number");
  }
  if (number === -Infinity) {
    return options.stylize("-Infinity", "number");
  }
  if (number === 0) {
    return options.stylize(1 / number === Infinity ? "+0" : "-0", "number");
  }
  return options.stylize(truncate2(String(number), options.truncate), "number");
}
__name(inspectNumber2, "inspectNumber");
__name2(inspectNumber2, "inspectNumber");
function inspectBigInt2(number, options) {
  let nums = truncate2(number.toString(), options.truncate - 1);
  if (nums !== truncator2)
    nums += "n";
  return options.stylize(nums, "bigint");
}
__name(inspectBigInt2, "inspectBigInt");
__name2(inspectBigInt2, "inspectBigInt");
function inspectRegExp2(value, options) {
  const flags = value.toString().split("/")[2];
  const sourceLength = options.truncate - (2 + flags.length);
  const source = value.source;
  return options.stylize(`/${truncate2(source, sourceLength)}/${flags}`, "regexp");
}
__name(inspectRegExp2, "inspectRegExp");
__name2(inspectRegExp2, "inspectRegExp");
function arrayFromSet2(set2) {
  const values = [];
  set2.forEach((value) => {
    values.push(value);
  });
  return values;
}
__name(arrayFromSet2, "arrayFromSet");
__name2(arrayFromSet2, "arrayFromSet");
function inspectSet2(set2, options) {
  if (set2.size === 0)
    return "Set{}";
  options.truncate -= 7;
  return `Set{ ${inspectList2(arrayFromSet2(set2), options)} }`;
}
__name(inspectSet2, "inspectSet");
__name2(inspectSet2, "inspectSet");
var stringEscapeChars2 = new RegExp("['\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]", "g");
var escapeCharacters2 = {
  "\b": "\\b",
  "	": "\\t",
  "\n": "\\n",
  "\f": "\\f",
  "\r": "\\r",
  "'": "\\'",
  "\\": "\\\\"
};
var hex2 = 16;
var unicodeLength2 = 4;
function escape2(char) {
  return escapeCharacters2[char] || `\\u${`0000${char.charCodeAt(0).toString(hex2)}`.slice(-unicodeLength2)}`;
}
__name(escape2, "escape");
__name2(escape2, "escape");
function inspectString2(string, options) {
  if (stringEscapeChars2.test(string)) {
    string = string.replace(stringEscapeChars2, escape2);
  }
  return options.stylize(`'${truncate2(string, options.truncate - 2)}'`, "string");
}
__name(inspectString2, "inspectString");
__name2(inspectString2, "inspectString");
function inspectSymbol2(value) {
  if ("description" in Symbol.prototype) {
    return value.description ? `Symbol(${value.description})` : "Symbol()";
  }
  return value.toString();
}
__name(inspectSymbol2, "inspectSymbol");
__name2(inspectSymbol2, "inspectSymbol");
var getPromiseValue2 = __name2(() => "Promise{\u2026}", "getPromiseValue");
var promise_default2 = getPromiseValue2;
function inspectObject3(object, options) {
  const properties = Object.getOwnPropertyNames(object);
  const symbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(object) : [];
  if (properties.length === 0 && symbols.length === 0) {
    return "{}";
  }
  options.truncate -= 4;
  options.seen = options.seen || [];
  if (options.seen.includes(object)) {
    return "[Circular]";
  }
  options.seen.push(object);
  const propertyContents = inspectList2(properties.map((key) => [key, object[key]]), options, inspectProperty2);
  const symbolContents = inspectList2(symbols.map((key) => [key, object[key]]), options, inspectProperty2);
  options.seen.pop();
  let sep = "";
  if (propertyContents && symbolContents) {
    sep = ", ";
  }
  return `{ ${propertyContents}${sep}${symbolContents} }`;
}
__name(inspectObject3, "inspectObject");
__name2(inspectObject3, "inspectObject");
var toStringTag2 = typeof Symbol !== "undefined" && Symbol.toStringTag ? Symbol.toStringTag : false;
function inspectClass2(value, options) {
  let name = "";
  if (toStringTag2 && toStringTag2 in value) {
    name = value[toStringTag2];
  }
  name = name || value.constructor.name;
  if (!name || name === "_class") {
    name = "<Anonymous Class>";
  }
  options.truncate -= name.length;
  return `${name}${inspectObject3(value, options)}`;
}
__name(inspectClass2, "inspectClass");
__name2(inspectClass2, "inspectClass");
function inspectArguments2(args, options) {
  if (args.length === 0)
    return "Arguments[]";
  options.truncate -= 13;
  return `Arguments[ ${inspectList2(args, options)} ]`;
}
__name(inspectArguments2, "inspectArguments");
__name2(inspectArguments2, "inspectArguments");
var errorKeys2 = [
  "stack",
  "line",
  "column",
  "name",
  "message",
  "fileName",
  "lineNumber",
  "columnNumber",
  "number",
  "description",
  "cause"
];
function inspectObject22(error, options) {
  const properties = Object.getOwnPropertyNames(error).filter((key) => errorKeys2.indexOf(key) === -1);
  const name = error.name;
  options.truncate -= name.length;
  let message = "";
  if (typeof error.message === "string") {
    message = truncate2(error.message, options.truncate);
  } else {
    properties.unshift("message");
  }
  message = message ? `: ${message}` : "";
  options.truncate -= message.length + 5;
  options.seen = options.seen || [];
  if (options.seen.includes(error)) {
    return "[Circular]";
  }
  options.seen.push(error);
  const propertyContents = inspectList2(properties.map((key) => [key, error[key]]), options, inspectProperty2);
  return `${name}${message}${propertyContents ? ` { ${propertyContents} }` : ""}`;
}
__name(inspectObject22, "inspectObject2");
__name2(inspectObject22, "inspectObject");
function inspectAttribute2([key, value], options) {
  options.truncate -= 3;
  if (!value) {
    return `${options.stylize(String(key), "yellow")}`;
  }
  return `${options.stylize(String(key), "yellow")}=${options.stylize(`"${value}"`, "string")}`;
}
__name(inspectAttribute2, "inspectAttribute");
__name2(inspectAttribute2, "inspectAttribute");
function inspectNodeCollection2(collection, options) {
  return inspectList2(collection, options, inspectNode2, "\n");
}
__name(inspectNodeCollection2, "inspectNodeCollection");
__name2(inspectNodeCollection2, "inspectNodeCollection");
function inspectNode2(node, options) {
  switch (node.nodeType) {
    case 1:
      return inspectHTML2(node, options);
    case 3:
      return options.inspect(node.data, options);
    default:
      return options.inspect(node, options);
  }
}
__name(inspectNode2, "inspectNode");
__name2(inspectNode2, "inspectNode");
function inspectHTML2(element, options) {
  const properties = element.getAttributeNames();
  const name = element.tagName.toLowerCase();
  const head = options.stylize(`<${name}`, "special");
  const headClose = options.stylize(`>`, "special");
  const tail = options.stylize(`</${name}>`, "special");
  options.truncate -= name.length * 2 + 5;
  let propertyContents = "";
  if (properties.length > 0) {
    propertyContents += " ";
    propertyContents += inspectList2(properties.map((key) => [key, element.getAttribute(key)]), options, inspectAttribute2, " ");
  }
  options.truncate -= propertyContents.length;
  const truncate22 = options.truncate;
  let children = inspectNodeCollection2(element.children, options);
  if (children && children.length > truncate22) {
    children = `${truncator2}(${element.children.length})`;
  }
  return `${head}${propertyContents}${headClose}${children}${tail}`;
}
__name(inspectHTML2, "inspectHTML");
__name2(inspectHTML2, "inspectHTML");
var symbolsSupported2 = typeof Symbol === "function" && typeof Symbol.for === "function";
var chaiInspect2 = symbolsSupported2 ? Symbol.for("chai/inspect") : "@@chai/inspect";
var nodeInspect2 = Symbol.for("nodejs.util.inspect.custom");
var constructorMap2 = /* @__PURE__ */ new WeakMap();
var stringTagMap2 = {};
var baseTypesMap2 = {
  undefined: __name2((value, options) => options.stylize("undefined", "undefined"), "undefined"),
  null: __name2((value, options) => options.stylize("null", "null"), "null"),
  boolean: __name2((value, options) => options.stylize(String(value), "boolean"), "boolean"),
  Boolean: __name2((value, options) => options.stylize(String(value), "boolean"), "Boolean"),
  number: inspectNumber2,
  Number: inspectNumber2,
  bigint: inspectBigInt2,
  BigInt: inspectBigInt2,
  string: inspectString2,
  String: inspectString2,
  function: inspectFunction2,
  Function: inspectFunction2,
  symbol: inspectSymbol2,
  // A Symbol polyfill will return `Symbol` not `symbol` from typedetect
  Symbol: inspectSymbol2,
  Array: inspectArray2,
  Date: inspectDate2,
  Map: inspectMap2,
  Set: inspectSet2,
  RegExp: inspectRegExp2,
  Promise: promise_default2,
  // WeakSet, WeakMap are totally opaque to us
  WeakSet: __name2((value, options) => options.stylize("WeakSet{\u2026}", "special"), "WeakSet"),
  WeakMap: __name2((value, options) => options.stylize("WeakMap{\u2026}", "special"), "WeakMap"),
  Arguments: inspectArguments2,
  Int8Array: inspectTypedArray2,
  Uint8Array: inspectTypedArray2,
  Uint8ClampedArray: inspectTypedArray2,
  Int16Array: inspectTypedArray2,
  Uint16Array: inspectTypedArray2,
  Int32Array: inspectTypedArray2,
  Uint32Array: inspectTypedArray2,
  Float32Array: inspectTypedArray2,
  Float64Array: inspectTypedArray2,
  Generator: __name2(() => "", "Generator"),
  DataView: __name2(() => "", "DataView"),
  ArrayBuffer: __name2(() => "", "ArrayBuffer"),
  Error: inspectObject22,
  HTMLCollection: inspectNodeCollection2,
  NodeList: inspectNodeCollection2
};
var inspectCustom2 = __name2((value, options, type32) => {
  if (chaiInspect2 in value && typeof value[chaiInspect2] === "function") {
    return value[chaiInspect2](options);
  }
  if (nodeInspect2 in value && typeof value[nodeInspect2] === "function") {
    return value[nodeInspect2](options.depth, options);
  }
  if ("inspect" in value && typeof value.inspect === "function") {
    return value.inspect(options.depth, options);
  }
  if ("constructor" in value && constructorMap2.has(value.constructor)) {
    return constructorMap2.get(value.constructor)(value, options);
  }
  if (stringTagMap2[type32]) {
    return stringTagMap2[type32](value, options);
  }
  return "";
}, "inspectCustom");
var toString4 = Object.prototype.toString;
function inspect3(value, opts = {}) {
  const options = normaliseOptions2(opts, inspect3);
  const { customInspect } = options;
  let type32 = value === null ? "null" : typeof value;
  if (type32 === "object") {
    type32 = toString4.call(value).slice(8, -1);
  }
  if (type32 in baseTypesMap2) {
    return baseTypesMap2[type32](value, options);
  }
  if (customInspect && value) {
    const output = inspectCustom2(value, options, type32);
    if (output) {
      if (typeof output === "string")
        return output;
      return inspect3(output, options);
    }
  }
  const proto = value ? Object.getPrototypeOf(value) : false;
  if (proto === Object.prototype || proto === null) {
    return inspectObject3(value, options);
  }
  if (value && typeof HTMLElement === "function" && value instanceof HTMLElement) {
    return inspectHTML2(value, options);
  }
  if ("constructor" in value) {
    if (value.constructor !== Object) {
      return inspectClass2(value, options);
    }
    return inspectObject3(value, options);
  }
  if (value === Object(value)) {
    return inspectObject3(value, options);
  }
  return options.stylize(String(value), type32);
}
__name(inspect3, "inspect");
__name2(inspect3, "inspect");
var config = {
  /**
   * ### config.includeStack
   *
   * User configurable property, influences whether stack trace
   * is included in Assertion error message. Default of false
   * suppresses stack trace in the error message.
   *
   *     chai.config.includeStack = true;  // enable stack on error
   *
   * @param {boolean}
   * @public
   */
  includeStack: false,
  /**
   * ### config.showDiff
   *
   * User configurable property, influences whether or not
   * the `showDiff` flag should be included in the thrown
   * AssertionErrors. `false` will always be `false`; `true`
   * will be true when the assertion has requested a diff
   * be shown.
   *
   * @param {boolean}
   * @public
   */
  showDiff: true,
  /**
   * ### config.truncateThreshold
   *
   * User configurable property, sets length threshold for actual and
   * expected values in assertion errors. If this threshold is exceeded, for
   * example for large data structures, the value is replaced with something
   * like `[ Array(3) ]` or `{ Object (prop1, prop2) }`.
   *
   * Set it to zero if you want to disable truncating altogether.
   *
   * This is especially userful when doing assertions on arrays: having this
   * set to a reasonable large value makes the failure messages readily
   * inspectable.
   *
   *     chai.config.truncateThreshold = 0;  // disable truncating
   *
   * @param {number}
   * @public
   */
  truncateThreshold: 40,
  /**
   * ### config.useProxy
   *
   * User configurable property, defines if chai will use a Proxy to throw
   * an error when a non-existent property is read, which protects users
   * from typos when using property-based assertions.
   *
   * Set it to false if you want to disable this feature.
   *
   *     chai.config.useProxy = false;  // disable use of Proxy
   *
   * This feature is automatically disabled regardless of this config value
   * in environments that don't support proxies.
   *
   * @param {boolean}
   * @public
   */
  useProxy: true,
  /**
   * ### config.proxyExcludedKeys
   *
   * User configurable property, defines which properties should be ignored
   * instead of throwing an error if they do not exist on the assertion.
   * This is only applied if the environment Chai is running in supports proxies and
   * if the `useProxy` configuration setting is enabled.
   * By default, `then` and `inspect` will not throw an error if they do not exist on the
   * assertion object because the `.inspect` property is read by `util.inspect` (for example, when
   * using `console.log` on the assertion object) and `.then` is necessary for promise type-checking.
   *
   *     // By default these keys will not throw an error if they do not exist on the assertion object
   *     chai.config.proxyExcludedKeys = ['then', 'inspect'];
   *
   * @param {Array}
   * @public
   */
  proxyExcludedKeys: ["then", "catch", "inspect", "toJSON"],
  /**
   * ### config.deepEqual
   *
   * User configurable property, defines which a custom function to use for deepEqual
   * comparisons.
   * By default, the function used is the one from the `deep-eql` package without custom comparator.
   *
   *     // use a custom comparator
   *     chai.config.deepEqual = (expected, actual) => {
   *         return chai.util.eql(expected, actual, {
   *             comparator: (expected, actual) => {
   *                 // for non number comparison, use the default behavior
   *                 if(typeof expected !== 'number') return null;
   *                 // allow a difference of 10 between compared numbers
   *                 return typeof actual === 'number' && Math.abs(actual - expected) < 10
   *             }
   *         })
   *     };
   *
   * @param {Function}
   * @public
   */
  deepEqual: null
};
function inspect22(obj, showHidden, depth, colors3) {
  let options = {
    colors: colors3,
    depth: typeof depth === "undefined" ? 2 : depth,
    showHidden,
    truncate: config.truncateThreshold ? config.truncateThreshold : Infinity
  };
  return inspect3(obj, options);
}
__name(inspect22, "inspect2");
__name2(inspect22, "inspect");
function objDisplay(obj) {
  let str2 = inspect22(obj), type32 = Object.prototype.toString.call(obj);
  if (config.truncateThreshold && str2.length >= config.truncateThreshold) {
    if (type32 === "[object Function]") {
      return !obj.name || obj.name === "" ? "[Function]" : "[Function: " + obj.name + "]";
    } else if (type32 === "[object Array]") {
      return "[ Array(" + obj.length + ") ]";
    } else if (type32 === "[object Object]") {
      let keys2 = Object.keys(obj), kstr = keys2.length > 2 ? keys2.splice(0, 2).join(", ") + ", ..." : keys2.join(", ");
      return "{ Object (" + kstr + ") }";
    } else {
      return str2;
    }
  } else {
    return str2;
  }
}
__name(objDisplay, "objDisplay");
__name2(objDisplay, "objDisplay");
function getMessage2(obj, args) {
  let negate = flag(obj, "negate");
  let val = flag(obj, "object");
  let expected = args[3];
  let actual = getActual(obj, args);
  let msg = negate ? args[2] : args[1];
  let flagMsg = flag(obj, "message");
  if (typeof msg === "function") msg = msg();
  msg = msg || "";
  msg = msg.replace(/#\{this\}/g, function() {
    return objDisplay(val);
  }).replace(/#\{act\}/g, function() {
    return objDisplay(actual);
  }).replace(/#\{exp\}/g, function() {
    return objDisplay(expected);
  });
  return flagMsg ? flagMsg + ": " + msg : msg;
}
__name(getMessage2, "getMessage2");
__name2(getMessage2, "getMessage");
function transferFlags(assertion, object, includeAll) {
  let flags = assertion.__flags || (assertion.__flags = /* @__PURE__ */ Object.create(null));
  if (!object.__flags) {
    object.__flags = /* @__PURE__ */ Object.create(null);
  }
  includeAll = arguments.length === 3 ? includeAll : true;
  for (let flag3 in flags) {
    if (includeAll || flag3 !== "object" && flag3 !== "ssfi" && flag3 !== "lockSsfi" && flag3 != "message") {
      object.__flags[flag3] = flags[flag3];
    }
  }
}
__name(transferFlags, "transferFlags");
__name2(transferFlags, "transferFlags");
function type2(obj) {
  if (typeof obj === "undefined") {
    return "undefined";
  }
  if (obj === null) {
    return "null";
  }
  const stringTag2 = obj[Symbol.toStringTag];
  if (typeof stringTag2 === "string") {
    return stringTag2;
  }
  const sliceStart = 8;
  const sliceEnd = -1;
  return Object.prototype.toString.call(obj).slice(sliceStart, sliceEnd);
}
__name(type2, "type2");
__name2(type2, "type");
function FakeMap() {
  this._key = "chai/deep-eql__" + Math.random() + Date.now();
}
__name(FakeMap, "FakeMap");
__name2(FakeMap, "FakeMap");
FakeMap.prototype = {
  get: __name2(/* @__PURE__ */ __name(function get2(key) {
    return key[this._key];
  }, "get"), "get"),
  set: __name2(/* @__PURE__ */ __name(function set(key, value) {
    if (Object.isExtensible(key)) {
      Object.defineProperty(key, this._key, {
        value,
        configurable: true
      });
    }
  }, "set"), "set")
};
var MemoizeMap = typeof WeakMap === "function" ? WeakMap : FakeMap;
function memoizeCompare(leftHandOperand, rightHandOperand, memoizeMap) {
  if (!memoizeMap || isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {
    return null;
  }
  var leftHandMap = memoizeMap.get(leftHandOperand);
  if (leftHandMap) {
    var result = leftHandMap.get(rightHandOperand);
    if (typeof result === "boolean") {
      return result;
    }
  }
  return null;
}
__name(memoizeCompare, "memoizeCompare");
__name2(memoizeCompare, "memoizeCompare");
function memoizeSet(leftHandOperand, rightHandOperand, memoizeMap, result) {
  if (!memoizeMap || isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {
    return;
  }
  var leftHandMap = memoizeMap.get(leftHandOperand);
  if (leftHandMap) {
    leftHandMap.set(rightHandOperand, result);
  } else {
    leftHandMap = new MemoizeMap();
    leftHandMap.set(rightHandOperand, result);
    memoizeMap.set(leftHandOperand, leftHandMap);
  }
}
__name(memoizeSet, "memoizeSet");
__name2(memoizeSet, "memoizeSet");
var deep_eql_default = deepEqual;
function deepEqual(leftHandOperand, rightHandOperand, options) {
  if (options && options.comparator) {
    return extensiveDeepEqual(leftHandOperand, rightHandOperand, options);
  }
  var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);
  if (simpleResult !== null) {
    return simpleResult;
  }
  return extensiveDeepEqual(leftHandOperand, rightHandOperand, options);
}
__name(deepEqual, "deepEqual");
__name2(deepEqual, "deepEqual");
function simpleEqual(leftHandOperand, rightHandOperand) {
  if (leftHandOperand === rightHandOperand) {
    return leftHandOperand !== 0 || 1 / leftHandOperand === 1 / rightHandOperand;
  }
  if (leftHandOperand !== leftHandOperand && // eslint-disable-line no-self-compare
  rightHandOperand !== rightHandOperand) {
    return true;
  }
  if (isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {
    return false;
  }
  return null;
}
__name(simpleEqual, "simpleEqual");
__name2(simpleEqual, "simpleEqual");
function extensiveDeepEqual(leftHandOperand, rightHandOperand, options) {
  options = options || {};
  options.memoize = options.memoize === false ? false : options.memoize || new MemoizeMap();
  var comparator = options && options.comparator;
  var memoizeResultLeft = memoizeCompare(leftHandOperand, rightHandOperand, options.memoize);
  if (memoizeResultLeft !== null) {
    return memoizeResultLeft;
  }
  var memoizeResultRight = memoizeCompare(rightHandOperand, leftHandOperand, options.memoize);
  if (memoizeResultRight !== null) {
    return memoizeResultRight;
  }
  if (comparator) {
    var comparatorResult = comparator(leftHandOperand, rightHandOperand);
    if (comparatorResult === false || comparatorResult === true) {
      memoizeSet(leftHandOperand, rightHandOperand, options.memoize, comparatorResult);
      return comparatorResult;
    }
    var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);
    if (simpleResult !== null) {
      return simpleResult;
    }
  }
  var leftHandType = type2(leftHandOperand);
  if (leftHandType !== type2(rightHandOperand)) {
    memoizeSet(leftHandOperand, rightHandOperand, options.memoize, false);
    return false;
  }
  memoizeSet(leftHandOperand, rightHandOperand, options.memoize, true);
  var result = extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options);
  memoizeSet(leftHandOperand, rightHandOperand, options.memoize, result);
  return result;
}
__name(extensiveDeepEqual, "extensiveDeepEqual");
__name2(extensiveDeepEqual, "extensiveDeepEqual");
function extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options) {
  switch (leftHandType) {
    case "String":
    case "Number":
    case "Boolean":
    case "Date":
      return deepEqual(leftHandOperand.valueOf(), rightHandOperand.valueOf());
    case "Promise":
    case "Symbol":
    case "function":
    case "WeakMap":
    case "WeakSet":
      return leftHandOperand === rightHandOperand;
    case "Error":
      return keysEqual(leftHandOperand, rightHandOperand, ["name", "message", "code"], options);
    case "Arguments":
    case "Int8Array":
    case "Uint8Array":
    case "Uint8ClampedArray":
    case "Int16Array":
    case "Uint16Array":
    case "Int32Array":
    case "Uint32Array":
    case "Float32Array":
    case "Float64Array":
    case "Array":
      return iterableEqual(leftHandOperand, rightHandOperand, options);
    case "RegExp":
      return regexpEqual(leftHandOperand, rightHandOperand);
    case "Generator":
      return generatorEqual(leftHandOperand, rightHandOperand, options);
    case "DataView":
      return iterableEqual(new Uint8Array(leftHandOperand.buffer), new Uint8Array(rightHandOperand.buffer), options);
    case "ArrayBuffer":
      return iterableEqual(new Uint8Array(leftHandOperand), new Uint8Array(rightHandOperand), options);
    case "Set":
      return entriesEqual(leftHandOperand, rightHandOperand, options);
    case "Map":
      return entriesEqual(leftHandOperand, rightHandOperand, options);
    case "Temporal.PlainDate":
    case "Temporal.PlainTime":
    case "Temporal.PlainDateTime":
    case "Temporal.Instant":
    case "Temporal.ZonedDateTime":
    case "Temporal.PlainYearMonth":
    case "Temporal.PlainMonthDay":
      return leftHandOperand.equals(rightHandOperand);
    case "Temporal.Duration":
      return leftHandOperand.total("nanoseconds") === rightHandOperand.total("nanoseconds");
    case "Temporal.TimeZone":
    case "Temporal.Calendar":
      return leftHandOperand.toString() === rightHandOperand.toString();
    default:
      return objectEqual(leftHandOperand, rightHandOperand, options);
  }
}
__name(extensiveDeepEqualByType, "extensiveDeepEqualByType");
__name2(extensiveDeepEqualByType, "extensiveDeepEqualByType");
function regexpEqual(leftHandOperand, rightHandOperand) {
  return leftHandOperand.toString() === rightHandOperand.toString();
}
__name(regexpEqual, "regexpEqual");
__name2(regexpEqual, "regexpEqual");
function entriesEqual(leftHandOperand, rightHandOperand, options) {
  try {
    if (leftHandOperand.size !== rightHandOperand.size) {
      return false;
    }
    if (leftHandOperand.size === 0) {
      return true;
    }
  } catch (sizeError) {
    return false;
  }
  var leftHandItems = [];
  var rightHandItems = [];
  leftHandOperand.forEach(__name2(/* @__PURE__ */ __name(function gatherEntries(key, value) {
    leftHandItems.push([key, value]);
  }, "gatherEntries"), "gatherEntries"));
  rightHandOperand.forEach(__name2(/* @__PURE__ */ __name(function gatherEntries(key, value) {
    rightHandItems.push([key, value]);
  }, "gatherEntries"), "gatherEntries"));
  return iterableEqual(leftHandItems.sort(), rightHandItems.sort(), options);
}
__name(entriesEqual, "entriesEqual");
__name2(entriesEqual, "entriesEqual");
function iterableEqual(leftHandOperand, rightHandOperand, options) {
  var length = leftHandOperand.length;
  if (length !== rightHandOperand.length) {
    return false;
  }
  if (length === 0) {
    return true;
  }
  var index2 = -1;
  while (++index2 < length) {
    if (deepEqual(leftHandOperand[index2], rightHandOperand[index2], options) === false) {
      return false;
    }
  }
  return true;
}
__name(iterableEqual, "iterableEqual");
__name2(iterableEqual, "iterableEqual");
function generatorEqual(leftHandOperand, rightHandOperand, options) {
  return iterableEqual(getGeneratorEntries(leftHandOperand), getGeneratorEntries(rightHandOperand), options);
}
__name(generatorEqual, "generatorEqual");
__name2(generatorEqual, "generatorEqual");
function hasIteratorFunction(target) {
  return typeof Symbol !== "undefined" && typeof target === "object" && typeof Symbol.iterator !== "undefined" && typeof target[Symbol.iterator] === "function";
}
__name(hasIteratorFunction, "hasIteratorFunction");
__name2(hasIteratorFunction, "hasIteratorFunction");
function getIteratorEntries(target) {
  if (hasIteratorFunction(target)) {
    try {
      return getGeneratorEntries(target[Symbol.iterator]());
    } catch (iteratorError) {
      return [];
    }
  }
  return [];
}
__name(getIteratorEntries, "getIteratorEntries");
__name2(getIteratorEntries, "getIteratorEntries");
function getGeneratorEntries(generator) {
  var generatorResult = generator.next();
  var accumulator = [generatorResult.value];
  while (generatorResult.done === false) {
    generatorResult = generator.next();
    accumulator.push(generatorResult.value);
  }
  return accumulator;
}
__name(getGeneratorEntries, "getGeneratorEntries");
__name2(getGeneratorEntries, "getGeneratorEntries");
function getEnumerableKeys(target) {
  var keys2 = [];
  for (var key in target) {
    keys2.push(key);
  }
  return keys2;
}
__name(getEnumerableKeys, "getEnumerableKeys");
__name2(getEnumerableKeys, "getEnumerableKeys");
function getEnumerableSymbols(target) {
  var keys2 = [];
  var allKeys = Object.getOwnPropertySymbols(target);
  for (var i2 = 0; i2 < allKeys.length; i2 += 1) {
    var key = allKeys[i2];
    if (Object.getOwnPropertyDescriptor(target, key).enumerable) {
      keys2.push(key);
    }
  }
  return keys2;
}
__name(getEnumerableSymbols, "getEnumerableSymbols");
__name2(getEnumerableSymbols, "getEnumerableSymbols");
function keysEqual(leftHandOperand, rightHandOperand, keys2, options) {
  var length = keys2.length;
  if (length === 0) {
    return true;
  }
  for (var i2 = 0; i2 < length; i2 += 1) {
    if (deepEqual(leftHandOperand[keys2[i2]], rightHandOperand[keys2[i2]], options) === false) {
      return false;
    }
  }
  return true;
}
__name(keysEqual, "keysEqual");
__name2(keysEqual, "keysEqual");
function objectEqual(leftHandOperand, rightHandOperand, options) {
  var leftHandKeys = getEnumerableKeys(leftHandOperand);
  var rightHandKeys = getEnumerableKeys(rightHandOperand);
  var leftHandSymbols = getEnumerableSymbols(leftHandOperand);
  var rightHandSymbols = getEnumerableSymbols(rightHandOperand);
  leftHandKeys = leftHandKeys.concat(leftHandSymbols);
  rightHandKeys = rightHandKeys.concat(rightHandSymbols);
  if (leftHandKeys.length && leftHandKeys.length === rightHandKeys.length) {
    if (iterableEqual(mapSymbols(leftHandKeys).sort(), mapSymbols(rightHandKeys).sort()) === false) {
      return false;
    }
    return keysEqual(leftHandOperand, rightHandOperand, leftHandKeys, options);
  }
  var leftHandEntries = getIteratorEntries(leftHandOperand);
  var rightHandEntries = getIteratorEntries(rightHandOperand);
  if (leftHandEntries.length && leftHandEntries.length === rightHandEntries.length) {
    leftHandEntries.sort();
    rightHandEntries.sort();
    return iterableEqual(leftHandEntries, rightHandEntries, options);
  }
  if (leftHandKeys.length === 0 && leftHandEntries.length === 0 && rightHandKeys.length === 0 && rightHandEntries.length === 0) {
    return true;
  }
  return false;
}
__name(objectEqual, "objectEqual");
__name2(objectEqual, "objectEqual");
function isPrimitive(value) {
  return value === null || typeof value !== "object";
}
__name(isPrimitive, "isPrimitive");
__name2(isPrimitive, "isPrimitive");
function mapSymbols(arr) {
  return arr.map(__name2(/* @__PURE__ */ __name(function mapSymbol(entry) {
    if (typeof entry === "symbol") {
      return entry.toString();
    }
    return entry;
  }, "mapSymbol"), "mapSymbol"));
}
__name(mapSymbols, "mapSymbols");
__name2(mapSymbols, "mapSymbols");
function hasProperty(obj, name) {
  if (typeof obj === "undefined" || obj === null) {
    return false;
  }
  return name in Object(obj);
}
__name(hasProperty, "hasProperty");
__name2(hasProperty, "hasProperty");
function parsePath(path) {
  const str2 = path.replace(/([^\\])\[/g, "$1.[");
  const parts = str2.match(/(\\\.|[^.]+?)+/g);
  return parts.map((value) => {
    if (value === "constructor" || value === "__proto__" || value === "prototype") {
      return {};
    }
    const regexp = /^\[(\d+)\]$/;
    const mArr = regexp.exec(value);
    let parsed = null;
    if (mArr) {
      parsed = { i: parseFloat(mArr[1]) };
    } else {
      parsed = { p: value.replace(/\\([.[\]])/g, "$1") };
    }
    return parsed;
  });
}
__name(parsePath, "parsePath");
__name2(parsePath, "parsePath");
function internalGetPathValue(obj, parsed, pathDepth) {
  let temporaryValue = obj;
  let res = null;
  pathDepth = typeof pathDepth === "undefined" ? parsed.length : pathDepth;
  for (let i2 = 0; i2 < pathDepth; i2++) {
    const part = parsed[i2];
    if (temporaryValue) {
      if (typeof part.p === "undefined") {
        temporaryValue = temporaryValue[part.i];
      } else {
        temporaryValue = temporaryValue[part.p];
      }
      if (i2 === pathDepth - 1) {
        res = temporaryValue;
      }
    }
  }
  return res;
}
__name(internalGetPathValue, "internalGetPathValue");
__name2(internalGetPathValue, "internalGetPathValue");
function getPathInfo(obj, path) {
  const parsed = parsePath(path);
  const last = parsed[parsed.length - 1];
  const info = {
    parent: parsed.length > 1 ? internalGetPathValue(obj, parsed, parsed.length - 1) : obj,
    name: last.p || last.i,
    value: internalGetPathValue(obj, parsed)
  };
  info.exists = hasProperty(info.parent, info.name);
  return info;
}
__name(getPathInfo, "getPathInfo");
__name2(getPathInfo, "getPathInfo");
var _a2;
var Assertion = (_a2 = class {
  /** @type {{}} */
  __flags = {};
  /**
   * Creates object for chaining.
   * `Assertion` objects contain metadata in the form of flags. Three flags can
   * be assigned during instantiation by passing arguments to this constructor:
   *
   * - `object`: This flag contains the target of the assertion. For example, in
   * the assertion `expect(numKittens).to.equal(7);`, the `object` flag will
   * contain `numKittens` so that the `equal` assertion can reference it when
   * needed.
   *
   * - `message`: This flag contains an optional custom error message to be
   * prepended to the error message that's generated by the assertion when it
   * fails.
   *
   * - `ssfi`: This flag stands for "start stack function indicator". It
   * contains a function reference that serves as the starting point for
   * removing frames from the stack trace of the error that's created by the
   * assertion when it fails. The goal is to provide a cleaner stack trace to
   * end users by removing Chai's internal functions. Note that it only works
   * in environments that support `Error.captureStackTrace`, and only when
   * `Chai.config.includeStack` hasn't been set to `false`.
   *
   * - `lockSsfi`: This flag controls whether or not the given `ssfi` flag
   * should retain its current value, even as assertions are chained off of
   * this object. This is usually set to `true` when creating a new assertion
   * from within another assertion. It's also temporarily set to `true` before
   * an overwritten assertion gets called by the overwriting assertion.
   *
   * - `eql`: This flag contains the deepEqual function to be used by the assertion.
   *
   * @param {unknown} obj target of the assertion
   * @param {string} [msg] (optional) custom error message
   * @param {Function} [ssfi] (optional) starting point for removing stack frames
   * @param {boolean} [lockSsfi] (optional) whether or not the ssfi flag is locked
   */
  constructor(obj, msg, ssfi, lockSsfi) {
    flag(this, "ssfi", ssfi || _a2);
    flag(this, "lockSsfi", lockSsfi);
    flag(this, "object", obj);
    flag(this, "message", msg);
    flag(this, "eql", config.deepEqual || deep_eql_default);
    return proxify(this);
  }
  /** @returns {boolean} */
  static get includeStack() {
    console.warn(
      "Assertion.includeStack is deprecated, use chai.config.includeStack instead."
    );
    return config.includeStack;
  }
  /** @param {boolean} value */
  static set includeStack(value) {
    console.warn(
      "Assertion.includeStack is deprecated, use chai.config.includeStack instead."
    );
    config.includeStack = value;
  }
  /** @returns {boolean} */
  static get showDiff() {
    console.warn(
      "Assertion.showDiff is deprecated, use chai.config.showDiff instead."
    );
    return config.showDiff;
  }
  /** @param {boolean} value */
  static set showDiff(value) {
    console.warn(
      "Assertion.showDiff is deprecated, use chai.config.showDiff instead."
    );
    config.showDiff = value;
  }
  /**
   * @param {string} name
   * @param {Function} fn
   */
  static addProperty(name, fn3) {
    addProperty(this.prototype, name, fn3);
  }
  /**
   * @param {string} name
   * @param {Function} fn
   */
  static addMethod(name, fn3) {
    addMethod(this.prototype, name, fn3);
  }
  /**
   * @param {string} name
   * @param {Function} fn
   * @param {Function} chainingBehavior
   */
  static addChainableMethod(name, fn3, chainingBehavior) {
    addChainableMethod(this.prototype, name, fn3, chainingBehavior);
  }
  /**
   * @param {string} name
   * @param {Function} fn
   */
  static overwriteProperty(name, fn3) {
    overwriteProperty(this.prototype, name, fn3);
  }
  /**
   * @param {string} name
   * @param {Function} fn
   */
  static overwriteMethod(name, fn3) {
    overwriteMethod(this.prototype, name, fn3);
  }
  /**
   * @param {string} name
   * @param {Function} fn
   * @param {Function} chainingBehavior
   */
  static overwriteChainableMethod(name, fn3, chainingBehavior) {
    overwriteChainableMethod(this.prototype, name, fn3, chainingBehavior);
  }
  /**
   * ### .assert(expression, message, negateMessage, expected, actual, showDiff)
   *
   * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.
   *
   * @name assert
   * @param {unknown} _expr to be tested
   * @param {string | Function} msg or function that returns message to display if expression fails
   * @param {string | Function} _negateMsg or function that returns negatedMessage to display if negated expression fails
   * @param {unknown} expected value (remember to check for negation)
   * @param {unknown} _actual (optional) will default to `this.obj`
   * @param {boolean} showDiff (optional) when set to `true`, assert will display a diff in addition to the message if expression fails
   * @returns {void}
   */
  assert(_expr, msg, _negateMsg, expected, _actual, showDiff) {
    const ok = test2(this, arguments);
    if (false !== showDiff) showDiff = true;
    if (void 0 === expected && void 0 === _actual) showDiff = false;
    if (true !== config.showDiff) showDiff = false;
    if (!ok) {
      msg = getMessage2(this, arguments);
      const actual = getActual(this, arguments);
      const assertionErrorObjectProperties = {
        actual,
        expected,
        showDiff
      };
      const operator = getOperator(this, arguments);
      if (operator) {
        assertionErrorObjectProperties.operator = operator;
      }
      throw new AssertionError(
        msg,
        assertionErrorObjectProperties,
        // @ts-expect-error Not sure what to do about these types yet
        config.includeStack ? this.assert : flag(this, "ssfi")
      );
    }
  }
  /**
   * Quick reference to stored `actual` value for plugin developers.
   *
   * @returns {unknown}
   */
  get _obj() {
    return flag(this, "object");
  }
  /**
   * Quick reference to stored `actual` value for plugin developers.
   *
   * @param {unknown} val
   */
  set _obj(val) {
    flag(this, "object", val);
  }
}, __name(_a2, "_Assertion"), __name2(_a2, "Assertion"), _a2);
function isProxyEnabled() {
  return config.useProxy && typeof Proxy !== "undefined" && typeof Reflect !== "undefined";
}
__name(isProxyEnabled, "isProxyEnabled");
__name2(isProxyEnabled, "isProxyEnabled");
function addProperty(ctx, name, getter) {
  getter = getter === void 0 ? function() {
  } : getter;
  Object.defineProperty(ctx, name, {
    get: __name2(/* @__PURE__ */ __name(function propertyGetter() {
      if (!isProxyEnabled() && !flag(this, "lockSsfi")) {
        flag(this, "ssfi", propertyGetter);
      }
      let result = getter.call(this);
      if (result !== void 0) return result;
      let newAssertion = new Assertion();
      transferFlags(this, newAssertion);
      return newAssertion;
    }, "propertyGetter"), "propertyGetter"),
    configurable: true
  });
}
__name(addProperty, "addProperty");
__name2(addProperty, "addProperty");
var fnLengthDesc = Object.getOwnPropertyDescriptor(function() {
}, "length");
function addLengthGuard(fn3, assertionName, isChainable) {
  if (!fnLengthDesc.configurable) return fn3;
  Object.defineProperty(fn3, "length", {
    get: __name2(function() {
      if (isChainable) {
        throw Error(
          "Invalid Chai property: " + assertionName + '.length. Due to a compatibility issue, "length" cannot directly follow "' + assertionName + '". Use "' + assertionName + '.lengthOf" instead.'
        );
      }
      throw Error(
        "Invalid Chai property: " + assertionName + '.length. See docs for proper usage of "' + assertionName + '".'
      );
    }, "get")
  });
  return fn3;
}
__name(addLengthGuard, "addLengthGuard");
__name2(addLengthGuard, "addLengthGuard");
function getProperties(object) {
  let result = Object.getOwnPropertyNames(object);
  function addProperty2(property) {
    if (result.indexOf(property) === -1) {
      result.push(property);
    }
  }
  __name(addProperty2, "addProperty2");
  __name2(addProperty2, "addProperty");
  let proto = Object.getPrototypeOf(object);
  while (proto !== null) {
    Object.getOwnPropertyNames(proto).forEach(addProperty2);
    proto = Object.getPrototypeOf(proto);
  }
  return result;
}
__name(getProperties, "getProperties");
__name2(getProperties, "getProperties");
var builtins = ["__flags", "__methods", "_obj", "assert"];
function proxify(obj, nonChainableMethodName) {
  if (!isProxyEnabled()) return obj;
  return new Proxy(obj, {
    get: __name2(/* @__PURE__ */ __name(function proxyGetter(target, property) {
      if (typeof property === "string" && config.proxyExcludedKeys.indexOf(property) === -1 && !Reflect.has(target, property)) {
        if (nonChainableMethodName) {
          throw Error(
            "Invalid Chai property: " + nonChainableMethodName + "." + property + '. See docs for proper usage of "' + nonChainableMethodName + '".'
          );
        }
        let suggestion = null;
        let suggestionDistance = 4;
        getProperties(target).forEach(function(prop) {
          if (
            // we actually mean to check `Object.prototype` here
            // eslint-disable-next-line no-prototype-builtins
            !Object.prototype.hasOwnProperty(prop) && builtins.indexOf(prop) === -1
          ) {
            let dist = stringDistanceCapped(property, prop, suggestionDistance);
            if (dist < suggestionDistance) {
              suggestion = prop;
              suggestionDistance = dist;
            }
          }
        });
        if (suggestion !== null) {
          throw Error(
            "Invalid Chai property: " + property + '. Did you mean "' + suggestion + '"?'
          );
        } else {
          throw Error("Invalid Chai property: " + property);
        }
      }
      if (builtins.indexOf(property) === -1 && !flag(target, "lockSsfi")) {
        flag(target, "ssfi", proxyGetter);
      }
      return Reflect.get(target, property);
    }, "proxyGetter"), "proxyGetter")
  });
}
__name(proxify, "proxify");
__name2(proxify, "proxify");
function stringDistanceCapped(strA, strB, cap) {
  if (Math.abs(strA.length - strB.length) >= cap) {
    return cap;
  }
  let memo = [];
  for (let i2 = 0; i2 <= strA.length; i2++) {
    memo[i2] = Array(strB.length + 1).fill(0);
    memo[i2][0] = i2;
  }
  for (let j2 = 0; j2 < strB.length; j2++) {
    memo[0][j2] = j2;
  }
  for (let i2 = 1; i2 <= strA.length; i2++) {
    let ch = strA.charCodeAt(i2 - 1);
    for (let j2 = 1; j2 <= strB.length; j2++) {
      if (Math.abs(i2 - j2) >= cap) {
        memo[i2][j2] = cap;
        continue;
      }
      memo[i2][j2] = Math.min(
        memo[i2 - 1][j2] + 1,
        memo[i2][j2 - 1] + 1,
        memo[i2 - 1][j2 - 1] + (ch === strB.charCodeAt(j2 - 1) ? 0 : 1)
      );
    }
  }
  return memo[strA.length][strB.length];
}
__name(stringDistanceCapped, "stringDistanceCapped");
__name2(stringDistanceCapped, "stringDistanceCapped");
function addMethod(ctx, name, method) {
  let methodWrapper = __name2(function() {
    if (!flag(this, "lockSsfi")) {
      flag(this, "ssfi", methodWrapper);
    }
    let result = method.apply(this, arguments);
    if (result !== void 0) return result;
    let newAssertion = new Assertion();
    transferFlags(this, newAssertion);
    return newAssertion;
  }, "methodWrapper");
  addLengthGuard(methodWrapper, name, false);
  ctx[name] = proxify(methodWrapper, name);
}
__name(addMethod, "addMethod");
__name2(addMethod, "addMethod");
function overwriteProperty(ctx, name, getter) {
  let _get = Object.getOwnPropertyDescriptor(ctx, name), _super = __name2(function() {
  }, "_super");
  if (_get && "function" === typeof _get.get) _super = _get.get;
  Object.defineProperty(ctx, name, {
    get: __name2(/* @__PURE__ */ __name(function overwritingPropertyGetter() {
      if (!isProxyEnabled() && !flag(this, "lockSsfi")) {
        flag(this, "ssfi", overwritingPropertyGetter);
      }
      let origLockSsfi = flag(this, "lockSsfi");
      flag(this, "lockSsfi", true);
      let result = getter(_super).call(this);
      flag(this, "lockSsfi", origLockSsfi);
      if (result !== void 0) {
        return result;
      }
      let newAssertion = new Assertion();
      transferFlags(this, newAssertion);
      return newAssertion;
    }, "overwritingPropertyGetter"), "overwritingPropertyGetter"),
    configurable: true
  });
}
__name(overwriteProperty, "overwriteProperty");
__name2(overwriteProperty, "overwriteProperty");
function overwriteMethod(ctx, name, method) {
  let _method = ctx[name], _super = __name2(function() {
    throw new Error(name + " is not a function");
  }, "_super");
  if (_method && "function" === typeof _method) _super = _method;
  let overwritingMethodWrapper = __name2(function() {
    if (!flag(this, "lockSsfi")) {
      flag(this, "ssfi", overwritingMethodWrapper);
    }
    let origLockSsfi = flag(this, "lockSsfi");
    flag(this, "lockSsfi", true);
    let result = method(_super).apply(this, arguments);
    flag(this, "lockSsfi", origLockSsfi);
    if (result !== void 0) {
      return result;
    }
    let newAssertion = new Assertion();
    transferFlags(this, newAssertion);
    return newAssertion;
  }, "overwritingMethodWrapper");
  addLengthGuard(overwritingMethodWrapper, name, false);
  ctx[name] = proxify(overwritingMethodWrapper, name);
}
__name(overwriteMethod, "overwriteMethod");
__name2(overwriteMethod, "overwriteMethod");
var canSetPrototype = typeof Object.setPrototypeOf === "function";
var testFn = __name2(function() {
}, "testFn");
var excludeNames = Object.getOwnPropertyNames(testFn).filter(function(name) {
  let propDesc = Object.getOwnPropertyDescriptor(testFn, name);
  if (typeof propDesc !== "object") return true;
  return !propDesc.configurable;
});
var call = Function.prototype.call;
var apply = Function.prototype.apply;
function addChainableMethod(ctx, name, method, chainingBehavior) {
  if (typeof chainingBehavior !== "function") {
    chainingBehavior = __name2(function() {
    }, "chainingBehavior");
  }
  let chainableBehavior = {
    method,
    chainingBehavior
  };
  if (!ctx.__methods) {
    ctx.__methods = {};
  }
  ctx.__methods[name] = chainableBehavior;
  Object.defineProperty(ctx, name, {
    get: __name2(/* @__PURE__ */ __name(function chainableMethodGetter() {
      chainableBehavior.chainingBehavior.call(this);
      let chainableMethodWrapper = __name2(function() {
        if (!flag(this, "lockSsfi")) {
          flag(this, "ssfi", chainableMethodWrapper);
        }
        let result = chainableBehavior.method.apply(this, arguments);
        if (result !== void 0) {
          return result;
        }
        let newAssertion = new Assertion();
        transferFlags(this, newAssertion);
        return newAssertion;
      }, "chainableMethodWrapper");
      addLengthGuard(chainableMethodWrapper, name, true);
      if (canSetPrototype) {
        let prototype = Object.create(this);
        prototype.call = call;
        prototype.apply = apply;
        Object.setPrototypeOf(chainableMethodWrapper, prototype);
      } else {
        let asserterNames = Object.getOwnPropertyNames(ctx);
        asserterNames.forEach(function(asserterName) {
          if (excludeNames.indexOf(asserterName) !== -1) {
            return;
          }
          let pd = Object.getOwnPropertyDescriptor(ctx, asserterName);
          Object.defineProperty(chainableMethodWrapper, asserterName, pd);
        });
      }
      transferFlags(this, chainableMethodWrapper);
      return proxify(chainableMethodWrapper);
    }, "chainableMethodGetter"), "chainableMethodGetter"),
    configurable: true
  });
}
__name(addChainableMethod, "addChainableMethod");
__name2(addChainableMethod, "addChainableMethod");
function overwriteChainableMethod(ctx, name, method, chainingBehavior) {
  let chainableBehavior = ctx.__methods[name];
  let _chainingBehavior = chainableBehavior.chainingBehavior;
  chainableBehavior.chainingBehavior = __name2(/* @__PURE__ */ __name(function overwritingChainableMethodGetter() {
    let result = chainingBehavior(_chainingBehavior).call(this);
    if (result !== void 0) {
      return result;
    }
    let newAssertion = new Assertion();
    transferFlags(this, newAssertion);
    return newAssertion;
  }, "overwritingChainableMethodGetter"), "overwritingChainableMethodGetter");
  let _method = chainableBehavior.method;
  chainableBehavior.method = __name2(/* @__PURE__ */ __name(function overwritingChainableMethodWrapper() {
    let result = method(_method).apply(this, arguments);
    if (result !== void 0) {
      return result;
    }
    let newAssertion = new Assertion();
    transferFlags(this, newAssertion);
    return newAssertion;
  }, "overwritingChainableMethodWrapper"), "overwritingChainableMethodWrapper");
}
__name(overwriteChainableMethod, "overwriteChainableMethod");
__name2(overwriteChainableMethod, "overwriteChainableMethod");
function compareByInspect(a2, b2) {
  return inspect22(a2) < inspect22(b2) ? -1 : 1;
}
__name(compareByInspect, "compareByInspect");
__name2(compareByInspect, "compareByInspect");
function getOwnEnumerablePropertySymbols(obj) {
  if (typeof Object.getOwnPropertySymbols !== "function") return [];
  return Object.getOwnPropertySymbols(obj).filter(function(sym) {
    return Object.getOwnPropertyDescriptor(obj, sym).enumerable;
  });
}
__name(getOwnEnumerablePropertySymbols, "getOwnEnumerablePropertySymbols");
__name2(getOwnEnumerablePropertySymbols, "getOwnEnumerablePropertySymbols");
function getOwnEnumerableProperties(obj) {
  return Object.keys(obj).concat(getOwnEnumerablePropertySymbols(obj));
}
__name(getOwnEnumerableProperties, "getOwnEnumerableProperties");
__name2(getOwnEnumerableProperties, "getOwnEnumerableProperties");
var isNaN22 = Number.isNaN;
function isObjectType(obj) {
  let objectType = type(obj);
  let objectTypes = ["Array", "Object", "Function"];
  return objectTypes.indexOf(objectType) !== -1;
}
__name(isObjectType, "isObjectType");
__name2(isObjectType, "isObjectType");
function getOperator(obj, args) {
  let operator = flag(obj, "operator");
  let negate = flag(obj, "negate");
  let expected = args[3];
  let msg = negate ? args[2] : args[1];
  if (operator) {
    return operator;
  }
  if (typeof msg === "function") msg = msg();
  msg = msg || "";
  if (!msg) {
    return void 0;
  }
  if (/\shave\s/.test(msg)) {
    return void 0;
  }
  let isObject7 = isObjectType(expected);
  if (/\snot\s/.test(msg)) {
    return isObject7 ? "notDeepStrictEqual" : "notStrictEqual";
  }
  return isObject7 ? "deepStrictEqual" : "strictEqual";
}
__name(getOperator, "getOperator");
__name2(getOperator, "getOperator");
function getName(fn3) {
  return fn3.name;
}
__name(getName, "getName");
__name2(getName, "getName");
function isRegExp2(obj) {
  return Object.prototype.toString.call(obj) === "[object RegExp]";
}
__name(isRegExp2, "isRegExp2");
__name2(isRegExp2, "isRegExp");
function isNumeric(obj) {
  return ["Number", "BigInt"].includes(type(obj));
}
__name(isNumeric, "isNumeric");
__name2(isNumeric, "isNumeric");
var { flag: flag2 } = utils_exports;
[
  "to",
  "be",
  "been",
  "is",
  "and",
  "has",
  "have",
  "with",
  "that",
  "which",
  "at",
  "of",
  "same",
  "but",
  "does",
  "still",
  "also"
].forEach(function(chain) {
  Assertion.addProperty(chain);
});
Assertion.addProperty("not", function() {
  flag2(this, "negate", true);
});
Assertion.addProperty("deep", function() {
  flag2(this, "deep", true);
});
Assertion.addProperty("nested", function() {
  flag2(this, "nested", true);
});
Assertion.addProperty("own", function() {
  flag2(this, "own", true);
});
Assertion.addProperty("ordered", function() {
  flag2(this, "ordered", true);
});
Assertion.addProperty("any", function() {
  flag2(this, "any", true);
  flag2(this, "all", false);
});
Assertion.addProperty("all", function() {
  flag2(this, "all", true);
  flag2(this, "any", false);
});
var functionTypes = {
  function: [
    "function",
    "asyncfunction",
    "generatorfunction",
    "asyncgeneratorfunction"
  ],
  asyncfunction: ["asyncfunction", "asyncgeneratorfunction"],
  generatorfunction: ["generatorfunction", "asyncgeneratorfunction"],
  asyncgeneratorfunction: ["asyncgeneratorfunction"]
};
function an(type32, msg) {
  if (msg) flag2(this, "message", msg);
  type32 = type32.toLowerCase();
  let obj = flag2(this, "object"), article = ~["a", "e", "i", "o", "u"].indexOf(type32.charAt(0)) ? "an " : "a ";
  const detectedType = type(obj).toLowerCase();
  if (functionTypes["function"].includes(type32)) {
    this.assert(
      functionTypes[type32].includes(detectedType),
      "expected #{this} to be " + article + type32,
      "expected #{this} not to be " + article + type32
    );
  } else {
    this.assert(
      type32 === detectedType,
      "expected #{this} to be " + article + type32,
      "expected #{this} not to be " + article + type32
    );
  }
}
__name(an, "an");
__name2(an, "an");
Assertion.addChainableMethod("an", an);
Assertion.addChainableMethod("a", an);
function SameValueZero(a2, b2) {
  return isNaN22(a2) && isNaN22(b2) || a2 === b2;
}
__name(SameValueZero, "SameValueZero");
__name2(SameValueZero, "SameValueZero");
function includeChainingBehavior() {
  flag2(this, "contains", true);
}
__name(includeChainingBehavior, "includeChainingBehavior");
__name2(includeChainingBehavior, "includeChainingBehavior");
function include(val, msg) {
  if (msg) flag2(this, "message", msg);
  let obj = flag2(this, "object"), objType = type(obj).toLowerCase(), flagMsg = flag2(this, "message"), negate = flag2(this, "negate"), ssfi = flag2(this, "ssfi"), isDeep = flag2(this, "deep"), descriptor = isDeep ? "deep " : "", isEql = isDeep ? flag2(this, "eql") : SameValueZero;
  flagMsg = flagMsg ? flagMsg + ": " : "";
  let included = false;
  switch (objType) {
    case "string":
      included = obj.indexOf(val) !== -1;
      break;
    case "weakset":
      if (isDeep) {
        throw new AssertionError(
          flagMsg + "unable to use .deep.include with WeakSet",
          void 0,
          ssfi
        );
      }
      included = obj.has(val);
      break;
    case "map":
      obj.forEach(function(item) {
        included = included || isEql(item, val);
      });
      break;
    case "set":
      if (isDeep) {
        obj.forEach(function(item) {
          included = included || isEql(item, val);
        });
      } else {
        included = obj.has(val);
      }
      break;
    case "array":
      if (isDeep) {
        included = obj.some(function(item) {
          return isEql(item, val);
        });
      } else {
        included = obj.indexOf(val) !== -1;
      }
      break;
    default: {
      if (val !== Object(val)) {
        throw new AssertionError(
          flagMsg + "the given combination of arguments (" + objType + " and " + type(val).toLowerCase() + ") is invalid for this assertion. You can use an array, a map, an object, a set, a string, or a weakset instead of a " + type(val).toLowerCase(),
          void 0,
          ssfi
        );
      }
      let props = Object.keys(val);
      let firstErr = null;
      let numErrs = 0;
      props.forEach(function(prop) {
        let propAssertion = new Assertion(obj);
        transferFlags(this, propAssertion, true);
        flag2(propAssertion, "lockSsfi", true);
        if (!negate || props.length === 1) {
          propAssertion.property(prop, val[prop]);
          return;
        }
        try {
          propAssertion.property(prop, val[prop]);
        } catch (err) {
          if (!check_error_exports.compatibleConstructor(err, AssertionError)) {
            throw err;
          }
          if (firstErr === null) firstErr = err;
          numErrs++;
        }
      }, this);
      if (negate && props.length > 1 && numErrs === props.length) {
        throw firstErr;
      }
      return;
    }
  }
  this.assert(
    included,
    "expected #{this} to " + descriptor + "include " + inspect22(val),
    "expected #{this} to not " + descriptor + "include " + inspect22(val)
  );
}
__name(include, "include");
__name2(include, "include");
Assertion.addChainableMethod("include", include, includeChainingBehavior);
Assertion.addChainableMethod("contain", include, includeChainingBehavior);
Assertion.addChainableMethod("contains", include, includeChainingBehavior);
Assertion.addChainableMethod("includes", include, includeChainingBehavior);
Assertion.addProperty("ok", function() {
  this.assert(
    flag2(this, "object"),
    "expected #{this} to be truthy",
    "expected #{this} to be falsy"
  );
});
Assertion.addProperty("true", function() {
  this.assert(
    true === flag2(this, "object"),
    "expected #{this} to be true",
    "expected #{this} to be false",
    flag2(this, "negate") ? false : true
  );
});
Assertion.addProperty("numeric", function() {
  const object = flag2(this, "object");
  this.assert(
    ["Number", "BigInt"].includes(type(object)),
    "expected #{this} to be numeric",
    "expected #{this} to not be numeric",
    flag2(this, "negate") ? false : true
  );
});
Assertion.addProperty("callable", function() {
  const val = flag2(this, "object");
  const ssfi = flag2(this, "ssfi");
  const message = flag2(this, "message");
  const msg = message ? `${message}: ` : "";
  const negate = flag2(this, "negate");
  const assertionMessage = negate ? `${msg}expected ${inspect22(val)} not to be a callable function` : `${msg}expected ${inspect22(val)} to be a callable function`;
  const isCallable3 = [
    "Function",
    "AsyncFunction",
    "GeneratorFunction",
    "AsyncGeneratorFunction"
  ].includes(type(val));
  if (isCallable3 && negate || !isCallable3 && !negate) {
    throw new AssertionError(assertionMessage, void 0, ssfi);
  }
});
Assertion.addProperty("false", function() {
  this.assert(
    false === flag2(this, "object"),
    "expected #{this} to be false",
    "expected #{this} to be true",
    flag2(this, "negate") ? true : false
  );
});
Assertion.addProperty("null", function() {
  this.assert(
    null === flag2(this, "object"),
    "expected #{this} to be null",
    "expected #{this} not to be null"
  );
});
Assertion.addProperty("undefined", function() {
  this.assert(
    void 0 === flag2(this, "object"),
    "expected #{this} to be undefined",
    "expected #{this} not to be undefined"
  );
});
Assertion.addProperty("NaN", function() {
  this.assert(
    isNaN22(flag2(this, "object")),
    "expected #{this} to be NaN",
    "expected #{this} not to be NaN"
  );
});
function assertExist() {
  let val = flag2(this, "object");
  this.assert(
    val !== null && val !== void 0,
    "expected #{this} to exist",
    "expected #{this} to not exist"
  );
}
__name(assertExist, "assertExist");
__name2(assertExist, "assertExist");
Assertion.addProperty("exist", assertExist);
Assertion.addProperty("exists", assertExist);
Assertion.addProperty("empty", function() {
  let val = flag2(this, "object"), ssfi = flag2(this, "ssfi"), flagMsg = flag2(this, "message"), itemsCount;
  flagMsg = flagMsg ? flagMsg + ": " : "";
  switch (type(val).toLowerCase()) {
    case "array":
    case "string":
      itemsCount = val.length;
      break;
    case "map":
    case "set":
      itemsCount = val.size;
      break;
    case "weakmap":
    case "weakset":
      throw new AssertionError(
        flagMsg + ".empty was passed a weak collection",
        void 0,
        ssfi
      );
    case "function": {
      const msg = flagMsg + ".empty was passed a function " + getName(val);
      throw new AssertionError(msg.trim(), void 0, ssfi);
    }
    default:
      if (val !== Object(val)) {
        throw new AssertionError(
          flagMsg + ".empty was passed non-string primitive " + inspect22(val),
          void 0,
          ssfi
        );
      }
      itemsCount = Object.keys(val).length;
  }
  this.assert(
    0 === itemsCount,
    "expected #{this} to be empty",
    "expected #{this} not to be empty"
  );
});
function checkArguments() {
  let obj = flag2(this, "object"), type32 = type(obj);
  this.assert(
    "Arguments" === type32,
    "expected #{this} to be arguments but got " + type32,
    "expected #{this} to not be arguments"
  );
}
__name(checkArguments, "checkArguments");
__name2(checkArguments, "checkArguments");
Assertion.addProperty("arguments", checkArguments);
Assertion.addProperty("Arguments", checkArguments);
function assertEqual(val, msg) {
  if (msg) flag2(this, "message", msg);
  let obj = flag2(this, "object");
  if (flag2(this, "deep")) {
    let prevLockSsfi = flag2(this, "lockSsfi");
    flag2(this, "lockSsfi", true);
    this.eql(val);
    flag2(this, "lockSsfi", prevLockSsfi);
  } else {
    this.assert(
      val === obj,
      "expected #{this} to equal #{exp}",
      "expected #{this} to not equal #{exp}",
      val,
      this._obj,
      true
    );
  }
}
__name(assertEqual, "assertEqual");
__name2(assertEqual, "assertEqual");
Assertion.addMethod("equal", assertEqual);
Assertion.addMethod("equals", assertEqual);
Assertion.addMethod("eq", assertEqual);
function assertEql(obj, msg) {
  if (msg) flag2(this, "message", msg);
  let eql = flag2(this, "eql");
  this.assert(
    eql(obj, flag2(this, "object")),
    "expected #{this} to deeply equal #{exp}",
    "expected #{this} to not deeply equal #{exp}",
    obj,
    this._obj,
    true
  );
}
__name(assertEql, "assertEql");
__name2(assertEql, "assertEql");
Assertion.addMethod("eql", assertEql);
Assertion.addMethod("eqls", assertEql);
function assertAbove(n2, msg) {
  if (msg) flag2(this, "message", msg);
  let obj = flag2(this, "object"), doLength = flag2(this, "doLength"), flagMsg = flag2(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag2(this, "ssfi"), objType = type(obj).toLowerCase(), nType = type(n2).toLowerCase();
  if (doLength && objType !== "map" && objType !== "set") {
    new Assertion(obj, flagMsg, ssfi, true).to.have.property("length");
  }
  if (!doLength && objType === "date" && nType !== "date") {
    throw new AssertionError(
      msgPrefix + "the argument to above must be a date",
      void 0,
      ssfi
    );
  } else if (!isNumeric(n2) && (doLength || isNumeric(obj))) {
    throw new AssertionError(
      msgPrefix + "the argument to above must be a number",
      void 0,
      ssfi
    );
  } else if (!doLength && objType !== "date" && !isNumeric(obj)) {
    let printObj = objType === "string" ? "'" + obj + "'" : obj;
    throw new AssertionError(
      msgPrefix + "expected " + printObj + " to be a number or a date",
      void 0,
      ssfi
    );
  }
  if (doLength) {
    let descriptor = "length", itemsCount;
    if (objType === "map" || objType === "set") {
      descriptor = "size";
      itemsCount = obj.size;
    } else {
      itemsCount = obj.length;
    }
    this.assert(
      itemsCount > n2,
      "expected #{this} to have a " + descriptor + " above #{exp} but got #{act}",
      "expected #{this} to not have a " + descriptor + " above #{exp}",
      n2,
      itemsCount
    );
  } else {
    this.assert(
      obj > n2,
      "expected #{this} to be above #{exp}",
      "expected #{this} to be at most #{exp}",
      n2
    );
  }
}
__name(assertAbove, "assertAbove");
__name2(assertAbove, "assertAbove");
Assertion.addMethod("above", assertAbove);
Assertion.addMethod("gt", assertAbove);
Assertion.addMethod("greaterThan", assertAbove);
function assertLeast(n2, msg) {
  if (msg) flag2(this, "message", msg);
  let obj = flag2(this, "object"), doLength = flag2(this, "doLength"), flagMsg = flag2(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag2(this, "ssfi"), objType = type(obj).toLowerCase(), nType = type(n2).toLowerCase(), errorMessage, shouldThrow = true;
  if (doLength && objType !== "map" && objType !== "set") {
    new Assertion(obj, flagMsg, ssfi, true).to.have.property("length");
  }
  if (!doLength && objType === "date" && nType !== "date") {
    errorMessage = msgPrefix + "the argument to least must be a date";
  } else if (!isNumeric(n2) && (doLength || isNumeric(obj))) {
    errorMessage = msgPrefix + "the argument to least must be a number";
  } else if (!doLength && objType !== "date" && !isNumeric(obj)) {
    let printObj = objType === "string" ? "'" + obj + "'" : obj;
    errorMessage = msgPrefix + "expected " + printObj + " to be a number or a date";
  } else {
    shouldThrow = false;
  }
  if (shouldThrow) {
    throw new AssertionError(errorMessage, void 0, ssfi);
  }
  if (doLength) {
    let descriptor = "length", itemsCount;
    if (objType === "map" || objType === "set") {
      descriptor = "size";
      itemsCount = obj.size;
    } else {
      itemsCount = obj.length;
    }
    this.assert(
      itemsCount >= n2,
      "expected #{this} to have a " + descriptor + " at least #{exp} but got #{act}",
      "expected #{this} to have a " + descriptor + " below #{exp}",
      n2,
      itemsCount
    );
  } else {
    this.assert(
      obj >= n2,
      "expected #{this} to be at least #{exp}",
      "expected #{this} to be below #{exp}",
      n2
    );
  }
}
__name(assertLeast, "assertLeast");
__name2(assertLeast, "assertLeast");
Assertion.addMethod("least", assertLeast);
Assertion.addMethod("gte", assertLeast);
Assertion.addMethod("greaterThanOrEqual", assertLeast);
function assertBelow(n2, msg) {
  if (msg) flag2(this, "message", msg);
  let obj = flag2(this, "object"), doLength = flag2(this, "doLength"), flagMsg = flag2(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag2(this, "ssfi"), objType = type(obj).toLowerCase(), nType = type(n2).toLowerCase(), errorMessage, shouldThrow = true;
  if (doLength && objType !== "map" && objType !== "set") {
    new Assertion(obj, flagMsg, ssfi, true).to.have.property("length");
  }
  if (!doLength && objType === "date" && nType !== "date") {
    errorMessage = msgPrefix + "the argument to below must be a date";
  } else if (!isNumeric(n2) && (doLength || isNumeric(obj))) {
    errorMessage = msgPrefix + "the argument to below must be a number";
  } else if (!doLength && objType !== "date" && !isNumeric(obj)) {
    let printObj = objType === "string" ? "'" + obj + "'" : obj;
    errorMessage = msgPrefix + "expected " + printObj + " to be a number or a date";
  } else {
    shouldThrow = false;
  }
  if (shouldThrow) {
    throw new AssertionError(errorMessage, void 0, ssfi);
  }
  if (doLength) {
    let descriptor = "length", itemsCount;
    if (objType === "map" || objType === "set") {
      descriptor = "size";
      itemsCount = obj.size;
    } else {
      itemsCount = obj.length;
    }
    this.assert(
      itemsCount < n2,
      "expected #{this} to have a " + descriptor + " below #{exp} but got #{act}",
      "expected #{this} to not have a " + descriptor + " below #{exp}",
      n2,
      itemsCount
    );
  } else {
    this.assert(
      obj < n2,
      "expected #{this} to be below #{exp}",
      "expected #{this} to be at least #{exp}",
      n2
    );
  }
}
__name(assertBelow, "assertBelow");
__name2(assertBelow, "assertBelow");
Assertion.addMethod("below", assertBelow);
Assertion.addMethod("lt", assertBelow);
Assertion.addMethod("lessThan", assertBelow);
function assertMost(n2, msg) {
  if (msg) flag2(this, "message", msg);
  let obj = flag2(this, "object"), doLength = flag2(this, "doLength"), flagMsg = flag2(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag2(this, "ssfi"), objType = type(obj).toLowerCase(), nType = type(n2).toLowerCase(), errorMessage, shouldThrow = true;
  if (doLength && objType !== "map" && objType !== "set") {
    new Assertion(obj, flagMsg, ssfi, true).to.have.property("length");
  }
  if (!doLength && objType === "date" && nType !== "date") {
    errorMessage = msgPrefix + "the argument to most must be a date";
  } else if (!isNumeric(n2) && (doLength || isNumeric(obj))) {
    errorMessage = msgPrefix + "the argument to most must be a number";
  } else if (!doLength && objType !== "date" && !isNumeric(obj)) {
    let printObj = objType === "string" ? "'" + obj + "'" : obj;
    errorMessage = msgPrefix + "expected " + printObj + " to be a number or a date";
  } else {
    shouldThrow = false;
  }
  if (shouldThrow) {
    throw new AssertionError(errorMessage, void 0, ssfi);
  }
  if (doLength) {
    let descriptor = "length", itemsCount;
    if (objType === "map" || objType === "set") {
      descriptor = "size";
      itemsCount = obj.size;
    } else {
      itemsCount = obj.length;
    }
    this.assert(
      itemsCount <= n2,
      "expected #{this} to have a " + descriptor + " at most #{exp} but got #{act}",
      "expected #{this} to have a " + descriptor + " above #{exp}",
      n2,
      itemsCount
    );
  } else {
    this.assert(
      obj <= n2,
      "expected #{this} to be at most #{exp}",
      "expected #{this} to be above #{exp}",
      n2
    );
  }
}
__name(assertMost, "assertMost");
__name2(assertMost, "assertMost");
Assertion.addMethod("most", assertMost);
Assertion.addMethod("lte", assertMost);
Assertion.addMethod("lessThanOrEqual", assertMost);
Assertion.addMethod("within", function(start, finish, msg) {
  if (msg) flag2(this, "message", msg);
  let obj = flag2(this, "object"), doLength = flag2(this, "doLength"), flagMsg = flag2(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag2(this, "ssfi"), objType = type(obj).toLowerCase(), startType = type(start).toLowerCase(), finishType = type(finish).toLowerCase(), errorMessage, shouldThrow = true, range = startType === "date" && finishType === "date" ? start.toISOString() + ".." + finish.toISOString() : start + ".." + finish;
  if (doLength && objType !== "map" && objType !== "set") {
    new Assertion(obj, flagMsg, ssfi, true).to.have.property("length");
  }
  if (!doLength && objType === "date" && (startType !== "date" || finishType !== "date")) {
    errorMessage = msgPrefix + "the arguments to within must be dates";
  } else if ((!isNumeric(start) || !isNumeric(finish)) && (doLength || isNumeric(obj))) {
    errorMessage = msgPrefix + "the arguments to within must be numbers";
  } else if (!doLength && objType !== "date" && !isNumeric(obj)) {
    let printObj = objType === "string" ? "'" + obj + "'" : obj;
    errorMessage = msgPrefix + "expected " + printObj + " to be a number or a date";
  } else {
    shouldThrow = false;
  }
  if (shouldThrow) {
    throw new AssertionError(errorMessage, void 0, ssfi);
  }
  if (doLength) {
    let descriptor = "length", itemsCount;
    if (objType === "map" || objType === "set") {
      descriptor = "size";
      itemsCount = obj.size;
    } else {
      itemsCount = obj.length;
    }
    this.assert(
      itemsCount >= start && itemsCount <= finish,
      "expected #{this} to have a " + descriptor + " within " + range,
      "expected #{this} to not have a " + descriptor + " within " + range
    );
  } else {
    this.assert(
      obj >= start && obj <= finish,
      "expected #{this} to be within " + range,
      "expected #{this} to not be within " + range
    );
  }
});
function assertInstanceOf(constructor, msg) {
  if (msg) flag2(this, "message", msg);
  let target = flag2(this, "object");
  let ssfi = flag2(this, "ssfi");
  let flagMsg = flag2(this, "message");
  let isInstanceOf;
  try {
    isInstanceOf = target instanceof constructor;
  } catch (err) {
    if (err instanceof TypeError) {
      flagMsg = flagMsg ? flagMsg + ": " : "";
      throw new AssertionError(
        flagMsg + "The instanceof assertion needs a constructor but " + type(constructor) + " was given.",
        void 0,
        ssfi
      );
    }
    throw err;
  }
  let name = getName(constructor);
  if (name == null) {
    name = "an unnamed constructor";
  }
  this.assert(
    isInstanceOf,
    "expected #{this} to be an instance of " + name,
    "expected #{this} to not be an instance of " + name
  );
}
__name(assertInstanceOf, "assertInstanceOf");
__name2(assertInstanceOf, "assertInstanceOf");
Assertion.addMethod("instanceof", assertInstanceOf);
Assertion.addMethod("instanceOf", assertInstanceOf);
function assertProperty(name, val, msg) {
  if (msg) flag2(this, "message", msg);
  let isNested = flag2(this, "nested"), isOwn = flag2(this, "own"), flagMsg = flag2(this, "message"), obj = flag2(this, "object"), ssfi = flag2(this, "ssfi"), nameType = typeof name;
  flagMsg = flagMsg ? flagMsg + ": " : "";
  if (isNested) {
    if (nameType !== "string") {
      throw new AssertionError(
        flagMsg + "the argument to property must be a string when using nested syntax",
        void 0,
        ssfi
      );
    }
  } else {
    if (nameType !== "string" && nameType !== "number" && nameType !== "symbol") {
      throw new AssertionError(
        flagMsg + "the argument to property must be a string, number, or symbol",
        void 0,
        ssfi
      );
    }
  }
  if (isNested && isOwn) {
    throw new AssertionError(
      flagMsg + 'The "nested" and "own" flags cannot be combined.',
      void 0,
      ssfi
    );
  }
  if (obj === null || obj === void 0) {
    throw new AssertionError(
      flagMsg + "Target cannot be null or undefined.",
      void 0,
      ssfi
    );
  }
  let isDeep = flag2(this, "deep"), negate = flag2(this, "negate"), pathInfo = isNested ? getPathInfo(obj, name) : null, value = isNested ? pathInfo.value : obj[name], isEql = isDeep ? flag2(this, "eql") : (val1, val2) => val1 === val2;
  let descriptor = "";
  if (isDeep) descriptor += "deep ";
  if (isOwn) descriptor += "own ";
  if (isNested) descriptor += "nested ";
  descriptor += "property ";
  let hasProperty2;
  if (isOwn) hasProperty2 = Object.prototype.hasOwnProperty.call(obj, name);
  else if (isNested) hasProperty2 = pathInfo.exists;
  else hasProperty2 = hasProperty(obj, name);
  if (!negate || arguments.length === 1) {
    this.assert(
      hasProperty2,
      "expected #{this} to have " + descriptor + inspect22(name),
      "expected #{this} to not have " + descriptor + inspect22(name)
    );
  }
  if (arguments.length > 1) {
    this.assert(
      hasProperty2 && isEql(val, value),
      "expected #{this} to have " + descriptor + inspect22(name) + " of #{exp}, but got #{act}",
      "expected #{this} to not have " + descriptor + inspect22(name) + " of #{act}",
      val,
      value
    );
  }
  flag2(this, "object", value);
}
__name(assertProperty, "assertProperty");
__name2(assertProperty, "assertProperty");
Assertion.addMethod("property", assertProperty);
function assertOwnProperty(_name, _value, _msg) {
  flag2(this, "own", true);
  assertProperty.apply(this, arguments);
}
__name(assertOwnProperty, "assertOwnProperty");
__name2(assertOwnProperty, "assertOwnProperty");
Assertion.addMethod("ownProperty", assertOwnProperty);
Assertion.addMethod("haveOwnProperty", assertOwnProperty);
function assertOwnPropertyDescriptor(name, descriptor, msg) {
  if (typeof descriptor === "string") {
    msg = descriptor;
    descriptor = null;
  }
  if (msg) flag2(this, "message", msg);
  let obj = flag2(this, "object");
  let actualDescriptor = Object.getOwnPropertyDescriptor(Object(obj), name);
  let eql = flag2(this, "eql");
  if (actualDescriptor && descriptor) {
    this.assert(
      eql(descriptor, actualDescriptor),
      "expected the own property descriptor for " + inspect22(name) + " on #{this} to match " + inspect22(descriptor) + ", got " + inspect22(actualDescriptor),
      "expected the own property descriptor for " + inspect22(name) + " on #{this} to not match " + inspect22(descriptor),
      descriptor,
      actualDescriptor,
      true
    );
  } else {
    this.assert(
      actualDescriptor,
      "expected #{this} to have an own property descriptor for " + inspect22(name),
      "expected #{this} to not have an own property descriptor for " + inspect22(name)
    );
  }
  flag2(this, "object", actualDescriptor);
}
__name(assertOwnPropertyDescriptor, "assertOwnPropertyDescriptor");
__name2(assertOwnPropertyDescriptor, "assertOwnPropertyDescriptor");
Assertion.addMethod("ownPropertyDescriptor", assertOwnPropertyDescriptor);
Assertion.addMethod("haveOwnPropertyDescriptor", assertOwnPropertyDescriptor);
function assertLengthChain() {
  flag2(this, "doLength", true);
}
__name(assertLengthChain, "assertLengthChain");
__name2(assertLengthChain, "assertLengthChain");
function assertLength(n2, msg) {
  if (msg) flag2(this, "message", msg);
  let obj = flag2(this, "object"), objType = type(obj).toLowerCase(), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi"), descriptor = "length", itemsCount;
  switch (objType) {
    case "map":
    case "set":
      descriptor = "size";
      itemsCount = obj.size;
      break;
    default:
      new Assertion(obj, flagMsg, ssfi, true).to.have.property("length");
      itemsCount = obj.length;
  }
  this.assert(
    itemsCount == n2,
    "expected #{this} to have a " + descriptor + " of #{exp} but got #{act}",
    "expected #{this} to not have a " + descriptor + " of #{act}",
    n2,
    itemsCount
  );
}
__name(assertLength, "assertLength");
__name2(assertLength, "assertLength");
Assertion.addChainableMethod("length", assertLength, assertLengthChain);
Assertion.addChainableMethod("lengthOf", assertLength, assertLengthChain);
function assertMatch(re, msg) {
  if (msg) flag2(this, "message", msg);
  let obj = flag2(this, "object");
  this.assert(
    re.exec(obj),
    "expected #{this} to match " + re,
    "expected #{this} not to match " + re
  );
}
__name(assertMatch, "assertMatch");
__name2(assertMatch, "assertMatch");
Assertion.addMethod("match", assertMatch);
Assertion.addMethod("matches", assertMatch);
Assertion.addMethod("string", function(str2, msg) {
  if (msg) flag2(this, "message", msg);
  let obj = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
  new Assertion(obj, flagMsg, ssfi, true).is.a("string");
  this.assert(
    ~obj.indexOf(str2),
    "expected #{this} to contain " + inspect22(str2),
    "expected #{this} to not contain " + inspect22(str2)
  );
});
function assertKeys(keys2) {
  let obj = flag2(this, "object"), objType = type(obj), keysType = type(keys2), ssfi = flag2(this, "ssfi"), isDeep = flag2(this, "deep"), str2, deepStr = "", actual, ok = true, flagMsg = flag2(this, "message");
  flagMsg = flagMsg ? flagMsg + ": " : "";
  let mixedArgsMsg = flagMsg + "when testing keys against an object or an array you must give a single Array|Object|String argument or multiple String arguments";
  if (objType === "Map" || objType === "Set") {
    deepStr = isDeep ? "deeply " : "";
    actual = [];
    obj.forEach(function(val, key) {
      actual.push(key);
    });
    if (keysType !== "Array") {
      keys2 = Array.prototype.slice.call(arguments);
    }
  } else {
    actual = getOwnEnumerableProperties(obj);
    switch (keysType) {
      case "Array":
        if (arguments.length > 1) {
          throw new AssertionError(mixedArgsMsg, void 0, ssfi);
        }
        break;
      case "Object":
        if (arguments.length > 1) {
          throw new AssertionError(mixedArgsMsg, void 0, ssfi);
        }
        keys2 = Object.keys(keys2);
        break;
      default:
        keys2 = Array.prototype.slice.call(arguments);
    }
    keys2 = keys2.map(function(val) {
      return typeof val === "symbol" ? val : String(val);
    });
  }
  if (!keys2.length) {
    throw new AssertionError(flagMsg + "keys required", void 0, ssfi);
  }
  let len = keys2.length, any = flag2(this, "any"), all = flag2(this, "all"), expected = keys2, isEql = isDeep ? flag2(this, "eql") : (val1, val2) => val1 === val2;
  if (!any && !all) {
    all = true;
  }
  if (any) {
    ok = expected.some(function(expectedKey) {
      return actual.some(function(actualKey) {
        return isEql(expectedKey, actualKey);
      });
    });
  }
  if (all) {
    ok = expected.every(function(expectedKey) {
      return actual.some(function(actualKey) {
        return isEql(expectedKey, actualKey);
      });
    });
    if (!flag2(this, "contains")) {
      ok = ok && keys2.length == actual.length;
    }
  }
  if (len > 1) {
    keys2 = keys2.map(function(key) {
      return inspect22(key);
    });
    let last = keys2.pop();
    if (all) {
      str2 = keys2.join(", ") + ", and " + last;
    }
    if (any) {
      str2 = keys2.join(", ") + ", or " + last;
    }
  } else {
    str2 = inspect22(keys2[0]);
  }
  str2 = (len > 1 ? "keys " : "key ") + str2;
  str2 = (flag2(this, "contains") ? "contain " : "have ") + str2;
  this.assert(
    ok,
    "expected #{this} to " + deepStr + str2,
    "expected #{this} to not " + deepStr + str2,
    expected.slice(0).sort(compareByInspect),
    actual.sort(compareByInspect),
    true
  );
}
__name(assertKeys, "assertKeys");
__name2(assertKeys, "assertKeys");
Assertion.addMethod("keys", assertKeys);
Assertion.addMethod("key", assertKeys);
function assertThrows(errorLike, errMsgMatcher, msg) {
  if (msg) flag2(this, "message", msg);
  let obj = flag2(this, "object"), ssfi = flag2(this, "ssfi"), flagMsg = flag2(this, "message"), negate = flag2(this, "negate") || false;
  new Assertion(obj, flagMsg, ssfi, true).is.a("function");
  if (isRegExp2(errorLike) || typeof errorLike === "string") {
    errMsgMatcher = errorLike;
    errorLike = null;
  }
  let caughtErr;
  let errorWasThrown = false;
  try {
    obj();
  } catch (err) {
    errorWasThrown = true;
    caughtErr = err;
  }
  let everyArgIsUndefined = errorLike === void 0 && errMsgMatcher === void 0;
  let everyArgIsDefined = Boolean(errorLike && errMsgMatcher);
  let errorLikeFail = false;
  let errMsgMatcherFail = false;
  if (everyArgIsUndefined || !everyArgIsUndefined && !negate) {
    let errorLikeString = "an error";
    if (errorLike instanceof Error) {
      errorLikeString = "#{exp}";
    } else if (errorLike) {
      errorLikeString = check_error_exports.getConstructorName(errorLike);
    }
    let actual = caughtErr;
    if (caughtErr instanceof Error) {
      actual = caughtErr.toString();
    } else if (typeof caughtErr === "string") {
      actual = caughtErr;
    } else if (caughtErr && (typeof caughtErr === "object" || typeof caughtErr === "function")) {
      try {
        actual = check_error_exports.getConstructorName(caughtErr);
      } catch (_err) {
      }
    }
    this.assert(
      errorWasThrown,
      "expected #{this} to throw " + errorLikeString,
      "expected #{this} to not throw an error but #{act} was thrown",
      errorLike && errorLike.toString(),
      actual
    );
  }
  if (errorLike && caughtErr) {
    if (errorLike instanceof Error) {
      let isCompatibleInstance = check_error_exports.compatibleInstance(
        caughtErr,
        errorLike
      );
      if (isCompatibleInstance === negate) {
        if (everyArgIsDefined && negate) {
          errorLikeFail = true;
        } else {
          this.assert(
            negate,
            "expected #{this} to throw #{exp} but #{act} was thrown",
            "expected #{this} to not throw #{exp}" + (caughtErr && !negate ? " but #{act} was thrown" : ""),
            errorLike.toString(),
            caughtErr.toString()
          );
        }
      }
    }
    let isCompatibleConstructor = check_error_exports.compatibleConstructor(
      caughtErr,
      errorLike
    );
    if (isCompatibleConstructor === negate) {
      if (everyArgIsDefined && negate) {
        errorLikeFail = true;
      } else {
        this.assert(
          negate,
          "expected #{this} to throw #{exp} but #{act} was thrown",
          "expected #{this} to not throw #{exp}" + (caughtErr ? " but #{act} was thrown" : ""),
          errorLike instanceof Error ? errorLike.toString() : errorLike && check_error_exports.getConstructorName(errorLike),
          caughtErr instanceof Error ? caughtErr.toString() : caughtErr && check_error_exports.getConstructorName(caughtErr)
        );
      }
    }
  }
  if (caughtErr && errMsgMatcher !== void 0 && errMsgMatcher !== null) {
    let placeholder = "including";
    if (isRegExp2(errMsgMatcher)) {
      placeholder = "matching";
    }
    let isCompatibleMessage = check_error_exports.compatibleMessage(
      caughtErr,
      errMsgMatcher
    );
    if (isCompatibleMessage === negate) {
      if (everyArgIsDefined && negate) {
        errMsgMatcherFail = true;
      } else {
        this.assert(
          negate,
          "expected #{this} to throw error " + placeholder + " #{exp} but got #{act}",
          "expected #{this} to throw error not " + placeholder + " #{exp}",
          errMsgMatcher,
          check_error_exports.getMessage(caughtErr)
        );
      }
    }
  }
  if (errorLikeFail && errMsgMatcherFail) {
    this.assert(
      negate,
      "expected #{this} to throw #{exp} but #{act} was thrown",
      "expected #{this} to not throw #{exp}" + (caughtErr ? " but #{act} was thrown" : ""),
      errorLike instanceof Error ? errorLike.toString() : errorLike && check_error_exports.getConstructorName(errorLike),
      caughtErr instanceof Error ? caughtErr.toString() : caughtErr && check_error_exports.getConstructorName(caughtErr)
    );
  }
  flag2(this, "object", caughtErr);
}
__name(assertThrows, "assertThrows");
__name2(assertThrows, "assertThrows");
Assertion.addMethod("throw", assertThrows);
Assertion.addMethod("throws", assertThrows);
Assertion.addMethod("Throw", assertThrows);
function respondTo(method, msg) {
  if (msg) flag2(this, "message", msg);
  let obj = flag2(this, "object"), itself = flag2(this, "itself"), context = "function" === typeof obj && !itself ? obj.prototype[method] : obj[method];
  this.assert(
    "function" === typeof context,
    "expected #{this} to respond to " + inspect22(method),
    "expected #{this} to not respond to " + inspect22(method)
  );
}
__name(respondTo, "respondTo");
__name2(respondTo, "respondTo");
Assertion.addMethod("respondTo", respondTo);
Assertion.addMethod("respondsTo", respondTo);
Assertion.addProperty("itself", function() {
  flag2(this, "itself", true);
});
function satisfy(matcher, msg) {
  if (msg) flag2(this, "message", msg);
  let obj = flag2(this, "object");
  let result = matcher(obj);
  this.assert(
    result,
    "expected #{this} to satisfy " + objDisplay(matcher),
    "expected #{this} to not satisfy" + objDisplay(matcher),
    flag2(this, "negate") ? false : true,
    result
  );
}
__name(satisfy, "satisfy");
__name2(satisfy, "satisfy");
Assertion.addMethod("satisfy", satisfy);
Assertion.addMethod("satisfies", satisfy);
function closeTo(expected, delta, msg) {
  if (msg) flag2(this, "message", msg);
  let obj = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
  new Assertion(obj, flagMsg, ssfi, true).is.numeric;
  let message = "A `delta` value is required for `closeTo`";
  if (delta == void 0) {
    throw new AssertionError(
      flagMsg ? `${flagMsg}: ${message}` : message,
      void 0,
      ssfi
    );
  }
  new Assertion(delta, flagMsg, ssfi, true).is.numeric;
  message = "A `expected` value is required for `closeTo`";
  if (expected == void 0) {
    throw new AssertionError(
      flagMsg ? `${flagMsg}: ${message}` : message,
      void 0,
      ssfi
    );
  }
  new Assertion(expected, flagMsg, ssfi, true).is.numeric;
  const abs = __name2((x2) => x2 < 0n ? -x2 : x2, "abs");
  const strip = __name2((number) => parseFloat(parseFloat(number).toPrecision(12)), "strip");
  this.assert(
    strip(abs(obj - expected)) <= delta,
    "expected #{this} to be close to " + expected + " +/- " + delta,
    "expected #{this} not to be close to " + expected + " +/- " + delta
  );
}
__name(closeTo, "closeTo");
__name2(closeTo, "closeTo");
Assertion.addMethod("closeTo", closeTo);
Assertion.addMethod("approximately", closeTo);
function isSubsetOf(_subset, _superset, cmp, contains, ordered) {
  let superset = Array.from(_superset);
  let subset = Array.from(_subset);
  if (!contains) {
    if (subset.length !== superset.length) return false;
    superset = superset.slice();
  }
  return subset.every(function(elem, idx) {
    if (ordered) return cmp ? cmp(elem, superset[idx]) : elem === superset[idx];
    if (!cmp) {
      let matchIdx = superset.indexOf(elem);
      if (matchIdx === -1) return false;
      if (!contains) superset.splice(matchIdx, 1);
      return true;
    }
    return superset.some(function(elem2, matchIdx) {
      if (!cmp(elem, elem2)) return false;
      if (!contains) superset.splice(matchIdx, 1);
      return true;
    });
  });
}
__name(isSubsetOf, "isSubsetOf");
__name2(isSubsetOf, "isSubsetOf");
Assertion.addMethod("members", function(subset, msg) {
  if (msg) flag2(this, "message", msg);
  let obj = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
  new Assertion(obj, flagMsg, ssfi, true).to.be.iterable;
  new Assertion(subset, flagMsg, ssfi, true).to.be.iterable;
  let contains = flag2(this, "contains");
  let ordered = flag2(this, "ordered");
  let subject, failMsg, failNegateMsg;
  if (contains) {
    subject = ordered ? "an ordered superset" : "a superset";
    failMsg = "expected #{this} to be " + subject + " of #{exp}";
    failNegateMsg = "expected #{this} to not be " + subject + " of #{exp}";
  } else {
    subject = ordered ? "ordered members" : "members";
    failMsg = "expected #{this} to have the same " + subject + " as #{exp}";
    failNegateMsg = "expected #{this} to not have the same " + subject + " as #{exp}";
  }
  let cmp = flag2(this, "deep") ? flag2(this, "eql") : void 0;
  this.assert(
    isSubsetOf(subset, obj, cmp, contains, ordered),
    failMsg,
    failNegateMsg,
    subset,
    obj,
    true
  );
});
Assertion.addProperty("iterable", function(msg) {
  if (msg) flag2(this, "message", msg);
  let obj = flag2(this, "object");
  this.assert(
    obj != void 0 && obj[Symbol.iterator],
    "expected #{this} to be an iterable",
    "expected #{this} to not be an iterable",
    obj
  );
});
function oneOf(list, msg) {
  if (msg) flag2(this, "message", msg);
  let expected = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi"), contains = flag2(this, "contains"), isDeep = flag2(this, "deep"), eql = flag2(this, "eql");
  new Assertion(list, flagMsg, ssfi, true).to.be.an("array");
  if (contains) {
    this.assert(
      list.some(function(possibility) {
        return expected.indexOf(possibility) > -1;
      }),
      "expected #{this} to contain one of #{exp}",
      "expected #{this} to not contain one of #{exp}",
      list,
      expected
    );
  } else {
    if (isDeep) {
      this.assert(
        list.some(function(possibility) {
          return eql(expected, possibility);
        }),
        "expected #{this} to deeply equal one of #{exp}",
        "expected #{this} to deeply equal one of #{exp}",
        list,
        expected
      );
    } else {
      this.assert(
        list.indexOf(expected) > -1,
        "expected #{this} to be one of #{exp}",
        "expected #{this} to not be one of #{exp}",
        list,
        expected
      );
    }
  }
}
__name(oneOf, "oneOf");
__name2(oneOf, "oneOf");
Assertion.addMethod("oneOf", oneOf);
function assertChanges(subject, prop, msg) {
  if (msg) flag2(this, "message", msg);
  let fn3 = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
  new Assertion(fn3, flagMsg, ssfi, true).is.a("function");
  let initial;
  if (!prop) {
    new Assertion(subject, flagMsg, ssfi, true).is.a("function");
    initial = subject();
  } else {
    new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);
    initial = subject[prop];
  }
  fn3();
  let final = prop === void 0 || prop === null ? subject() : subject[prop];
  let msgObj = prop === void 0 || prop === null ? initial : "." + prop;
  flag2(this, "deltaMsgObj", msgObj);
  flag2(this, "initialDeltaValue", initial);
  flag2(this, "finalDeltaValue", final);
  flag2(this, "deltaBehavior", "change");
  flag2(this, "realDelta", final !== initial);
  this.assert(
    initial !== final,
    "expected " + msgObj + " to change",
    "expected " + msgObj + " to not change"
  );
}
__name(assertChanges, "assertChanges");
__name2(assertChanges, "assertChanges");
Assertion.addMethod("change", assertChanges);
Assertion.addMethod("changes", assertChanges);
function assertIncreases(subject, prop, msg) {
  if (msg) flag2(this, "message", msg);
  let fn3 = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
  new Assertion(fn3, flagMsg, ssfi, true).is.a("function");
  let initial;
  if (!prop) {
    new Assertion(subject, flagMsg, ssfi, true).is.a("function");
    initial = subject();
  } else {
    new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);
    initial = subject[prop];
  }
  new Assertion(initial, flagMsg, ssfi, true).is.a("number");
  fn3();
  let final = prop === void 0 || prop === null ? subject() : subject[prop];
  let msgObj = prop === void 0 || prop === null ? initial : "." + prop;
  flag2(this, "deltaMsgObj", msgObj);
  flag2(this, "initialDeltaValue", initial);
  flag2(this, "finalDeltaValue", final);
  flag2(this, "deltaBehavior", "increase");
  flag2(this, "realDelta", final - initial);
  this.assert(
    final - initial > 0,
    "expected " + msgObj + " to increase",
    "expected " + msgObj + " to not increase"
  );
}
__name(assertIncreases, "assertIncreases");
__name2(assertIncreases, "assertIncreases");
Assertion.addMethod("increase", assertIncreases);
Assertion.addMethod("increases", assertIncreases);
function assertDecreases(subject, prop, msg) {
  if (msg) flag2(this, "message", msg);
  let fn3 = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
  new Assertion(fn3, flagMsg, ssfi, true).is.a("function");
  let initial;
  if (!prop) {
    new Assertion(subject, flagMsg, ssfi, true).is.a("function");
    initial = subject();
  } else {
    new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);
    initial = subject[prop];
  }
  new Assertion(initial, flagMsg, ssfi, true).is.a("number");
  fn3();
  let final = prop === void 0 || prop === null ? subject() : subject[prop];
  let msgObj = prop === void 0 || prop === null ? initial : "." + prop;
  flag2(this, "deltaMsgObj", msgObj);
  flag2(this, "initialDeltaValue", initial);
  flag2(this, "finalDeltaValue", final);
  flag2(this, "deltaBehavior", "decrease");
  flag2(this, "realDelta", initial - final);
  this.assert(
    final - initial < 0,
    "expected " + msgObj + " to decrease",
    "expected " + msgObj + " to not decrease"
  );
}
__name(assertDecreases, "assertDecreases");
__name2(assertDecreases, "assertDecreases");
Assertion.addMethod("decrease", assertDecreases);
Assertion.addMethod("decreases", assertDecreases);
function assertDelta(delta, msg) {
  if (msg) flag2(this, "message", msg);
  let msgObj = flag2(this, "deltaMsgObj");
  let initial = flag2(this, "initialDeltaValue");
  let final = flag2(this, "finalDeltaValue");
  let behavior2 = flag2(this, "deltaBehavior");
  let realDelta = flag2(this, "realDelta");
  let expression;
  if (behavior2 === "change") {
    expression = Math.abs(final - initial) === Math.abs(delta);
  } else {
    expression = realDelta === Math.abs(delta);
  }
  this.assert(
    expression,
    "expected " + msgObj + " to " + behavior2 + " by " + delta,
    "expected " + msgObj + " to not " + behavior2 + " by " + delta
  );
}
__name(assertDelta, "assertDelta");
__name2(assertDelta, "assertDelta");
Assertion.addMethod("by", assertDelta);
Assertion.addProperty("extensible", function() {
  let obj = flag2(this, "object");
  let isExtensible = obj === Object(obj) && Object.isExtensible(obj);
  this.assert(
    isExtensible,
    "expected #{this} to be extensible",
    "expected #{this} to not be extensible"
  );
});
Assertion.addProperty("sealed", function() {
  let obj = flag2(this, "object");
  let isSealed = obj === Object(obj) ? Object.isSealed(obj) : true;
  this.assert(
    isSealed,
    "expected #{this} to be sealed",
    "expected #{this} to not be sealed"
  );
});
Assertion.addProperty("frozen", function() {
  let obj = flag2(this, "object");
  let isFrozen = obj === Object(obj) ? Object.isFrozen(obj) : true;
  this.assert(
    isFrozen,
    "expected #{this} to be frozen",
    "expected #{this} to not be frozen"
  );
});
Assertion.addProperty("finite", function(_msg) {
  let obj = flag2(this, "object");
  this.assert(
    typeof obj === "number" && isFinite(obj),
    "expected #{this} to be a finite number",
    "expected #{this} to not be a finite number"
  );
});
function compareSubset(expected, actual) {
  if (expected === actual) {
    return true;
  }
  if (typeof actual !== typeof expected) {
    return false;
  }
  if (typeof expected !== "object" || expected === null) {
    return expected === actual;
  }
  if (!actual) {
    return false;
  }
  if (Array.isArray(expected)) {
    if (!Array.isArray(actual)) {
      return false;
    }
    return expected.every(function(exp) {
      return actual.some(function(act) {
        return compareSubset(exp, act);
      });
    });
  }
  if (expected instanceof Date) {
    if (actual instanceof Date) {
      return expected.getTime() === actual.getTime();
    } else {
      return false;
    }
  }
  return Object.keys(expected).every(function(key) {
    let expectedValue = expected[key];
    let actualValue = actual[key];
    if (typeof expectedValue === "object" && expectedValue !== null && actualValue !== null) {
      return compareSubset(expectedValue, actualValue);
    }
    if (typeof expectedValue === "function") {
      return expectedValue(actualValue);
    }
    return actualValue === expectedValue;
  });
}
__name(compareSubset, "compareSubset");
__name2(compareSubset, "compareSubset");
Assertion.addMethod("containSubset", function(expected) {
  const actual = flag(this, "object");
  const showDiff = config.showDiff;
  this.assert(
    compareSubset(expected, actual),
    "expected #{act} to contain subset #{exp}",
    "expected #{act} to not contain subset #{exp}",
    expected,
    actual,
    showDiff
  );
});
function expect(val, message) {
  return new Assertion(val, message);
}
__name(expect, "expect");
__name2(expect, "expect");
expect.fail = function(actual, expected, message, operator) {
  if (arguments.length < 2) {
    message = actual;
    actual = void 0;
  }
  message = message || "expect.fail()";
  throw new AssertionError(
    message,
    {
      actual,
      expected,
      operator
    },
    expect.fail
  );
};
var should_exports = {};
__export2(should_exports, {
  Should: /* @__PURE__ */ __name(() => Should, "Should"),
  should: /* @__PURE__ */ __name(() => should, "should")
});
function loadShould() {
  function shouldGetter() {
    if (this instanceof String || this instanceof Number || this instanceof Boolean || typeof Symbol === "function" && this instanceof Symbol || typeof BigInt === "function" && this instanceof BigInt) {
      return new Assertion(this.valueOf(), null, shouldGetter);
    }
    return new Assertion(this, null, shouldGetter);
  }
  __name(shouldGetter, "shouldGetter");
  __name2(shouldGetter, "shouldGetter");
  function shouldSetter(value) {
    Object.defineProperty(this, "should", {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  }
  __name(shouldSetter, "shouldSetter");
  __name2(shouldSetter, "shouldSetter");
  Object.defineProperty(Object.prototype, "should", {
    set: shouldSetter,
    get: shouldGetter,
    configurable: true
  });
  let should2 = {};
  should2.fail = function(actual, expected, message, operator) {
    if (arguments.length < 2) {
      message = actual;
      actual = void 0;
    }
    message = message || "should.fail()";
    throw new AssertionError(
      message,
      {
        actual,
        expected,
        operator
      },
      should2.fail
    );
  };
  should2.equal = function(actual, expected, message) {
    new Assertion(actual, message).to.equal(expected);
  };
  should2.Throw = function(fn3, errt, errs, msg) {
    new Assertion(fn3, msg).to.Throw(errt, errs);
  };
  should2.exist = function(val, msg) {
    new Assertion(val, msg).to.exist;
  };
  should2.not = {};
  should2.not.equal = function(actual, expected, msg) {
    new Assertion(actual, msg).to.not.equal(expected);
  };
  should2.not.Throw = function(fn3, errt, errs, msg) {
    new Assertion(fn3, msg).to.not.Throw(errt, errs);
  };
  should2.not.exist = function(val, msg) {
    new Assertion(val, msg).to.not.exist;
  };
  should2["throw"] = should2["Throw"];
  should2.not["throw"] = should2.not["Throw"];
  return should2;
}
__name(loadShould, "loadShould");
__name2(loadShould, "loadShould");
var should = loadShould;
var Should = loadShould;
function assert(express, errmsg) {
  let test22 = new Assertion(null, null, assert, true);
  test22.assert(express, errmsg, "[ negation message unavailable ]");
}
__name(assert, "assert");
__name2(assert, "assert");
assert.fail = function(actual, expected, message, operator) {
  if (arguments.length < 2) {
    message = actual;
    actual = void 0;
  }
  message = message || "assert.fail()";
  throw new AssertionError(
    message,
    {
      actual,
      expected,
      operator
    },
    assert.fail
  );
};
assert.isOk = function(val, msg) {
  new Assertion(val, msg, assert.isOk, true).is.ok;
};
assert.isNotOk = function(val, msg) {
  new Assertion(val, msg, assert.isNotOk, true).is.not.ok;
};
assert.equal = function(act, exp, msg) {
  let test22 = new Assertion(act, msg, assert.equal, true);
  test22.assert(
    exp == flag(test22, "object"),
    "expected #{this} to equal #{exp}",
    "expected #{this} to not equal #{act}",
    exp,
    act,
    true
  );
};
assert.notEqual = function(act, exp, msg) {
  let test22 = new Assertion(act, msg, assert.notEqual, true);
  test22.assert(
    exp != flag(test22, "object"),
    "expected #{this} to not equal #{exp}",
    "expected #{this} to equal #{act}",
    exp,
    act,
    true
  );
};
assert.strictEqual = function(act, exp, msg) {
  new Assertion(act, msg, assert.strictEqual, true).to.equal(exp);
};
assert.notStrictEqual = function(act, exp, msg) {
  new Assertion(act, msg, assert.notStrictEqual, true).to.not.equal(exp);
};
assert.deepEqual = assert.deepStrictEqual = function(act, exp, msg) {
  new Assertion(act, msg, assert.deepEqual, true).to.eql(exp);
};
assert.notDeepEqual = function(act, exp, msg) {
  new Assertion(act, msg, assert.notDeepEqual, true).to.not.eql(exp);
};
assert.isAbove = function(val, abv, msg) {
  new Assertion(val, msg, assert.isAbove, true).to.be.above(abv);
};
assert.isAtLeast = function(val, atlst, msg) {
  new Assertion(val, msg, assert.isAtLeast, true).to.be.least(atlst);
};
assert.isBelow = function(val, blw, msg) {
  new Assertion(val, msg, assert.isBelow, true).to.be.below(blw);
};
assert.isAtMost = function(val, atmst, msg) {
  new Assertion(val, msg, assert.isAtMost, true).to.be.most(atmst);
};
assert.isTrue = function(val, msg) {
  new Assertion(val, msg, assert.isTrue, true).is["true"];
};
assert.isNotTrue = function(val, msg) {
  new Assertion(val, msg, assert.isNotTrue, true).to.not.equal(true);
};
assert.isFalse = function(val, msg) {
  new Assertion(val, msg, assert.isFalse, true).is["false"];
};
assert.isNotFalse = function(val, msg) {
  new Assertion(val, msg, assert.isNotFalse, true).to.not.equal(false);
};
assert.isNull = function(val, msg) {
  new Assertion(val, msg, assert.isNull, true).to.equal(null);
};
assert.isNotNull = function(val, msg) {
  new Assertion(val, msg, assert.isNotNull, true).to.not.equal(null);
};
assert.isNaN = function(val, msg) {
  new Assertion(val, msg, assert.isNaN, true).to.be.NaN;
};
assert.isNotNaN = function(value, message) {
  new Assertion(value, message, assert.isNotNaN, true).not.to.be.NaN;
};
assert.exists = function(val, msg) {
  new Assertion(val, msg, assert.exists, true).to.exist;
};
assert.notExists = function(val, msg) {
  new Assertion(val, msg, assert.notExists, true).to.not.exist;
};
assert.isUndefined = function(val, msg) {
  new Assertion(val, msg, assert.isUndefined, true).to.equal(void 0);
};
assert.isDefined = function(val, msg) {
  new Assertion(val, msg, assert.isDefined, true).to.not.equal(void 0);
};
assert.isCallable = function(value, message) {
  new Assertion(value, message, assert.isCallable, true).is.callable;
};
assert.isNotCallable = function(value, message) {
  new Assertion(value, message, assert.isNotCallable, true).is.not.callable;
};
assert.isObject = function(val, msg) {
  new Assertion(val, msg, assert.isObject, true).to.be.a("object");
};
assert.isNotObject = function(val, msg) {
  new Assertion(val, msg, assert.isNotObject, true).to.not.be.a("object");
};
assert.isArray = function(val, msg) {
  new Assertion(val, msg, assert.isArray, true).to.be.an("array");
};
assert.isNotArray = function(val, msg) {
  new Assertion(val, msg, assert.isNotArray, true).to.not.be.an("array");
};
assert.isString = function(val, msg) {
  new Assertion(val, msg, assert.isString, true).to.be.a("string");
};
assert.isNotString = function(val, msg) {
  new Assertion(val, msg, assert.isNotString, true).to.not.be.a("string");
};
assert.isNumber = function(val, msg) {
  new Assertion(val, msg, assert.isNumber, true).to.be.a("number");
};
assert.isNotNumber = function(val, msg) {
  new Assertion(val, msg, assert.isNotNumber, true).to.not.be.a("number");
};
assert.isNumeric = function(val, msg) {
  new Assertion(val, msg, assert.isNumeric, true).is.numeric;
};
assert.isNotNumeric = function(val, msg) {
  new Assertion(val, msg, assert.isNotNumeric, true).is.not.numeric;
};
assert.isFinite = function(val, msg) {
  new Assertion(val, msg, assert.isFinite, true).to.be.finite;
};
assert.isBoolean = function(val, msg) {
  new Assertion(val, msg, assert.isBoolean, true).to.be.a("boolean");
};
assert.isNotBoolean = function(val, msg) {
  new Assertion(val, msg, assert.isNotBoolean, true).to.not.be.a("boolean");
};
assert.typeOf = function(val, type32, msg) {
  new Assertion(val, msg, assert.typeOf, true).to.be.a(type32);
};
assert.notTypeOf = function(value, type32, message) {
  new Assertion(value, message, assert.notTypeOf, true).to.not.be.a(type32);
};
assert.instanceOf = function(val, type32, msg) {
  new Assertion(val, msg, assert.instanceOf, true).to.be.instanceOf(type32);
};
assert.notInstanceOf = function(val, type32, msg) {
  new Assertion(val, msg, assert.notInstanceOf, true).to.not.be.instanceOf(
    type32
  );
};
assert.include = function(exp, inc, msg) {
  new Assertion(exp, msg, assert.include, true).include(inc);
};
assert.notInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert.notInclude, true).not.include(inc);
};
assert.deepInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert.deepInclude, true).deep.include(inc);
};
assert.notDeepInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert.notDeepInclude, true).not.deep.include(inc);
};
assert.nestedInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert.nestedInclude, true).nested.include(inc);
};
assert.notNestedInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert.notNestedInclude, true).not.nested.include(
    inc
  );
};
assert.deepNestedInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert.deepNestedInclude, true).deep.nested.include(
    inc
  );
};
assert.notDeepNestedInclude = function(exp, inc, msg) {
  new Assertion(
    exp,
    msg,
    assert.notDeepNestedInclude,
    true
  ).not.deep.nested.include(inc);
};
assert.ownInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert.ownInclude, true).own.include(inc);
};
assert.notOwnInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert.notOwnInclude, true).not.own.include(inc);
};
assert.deepOwnInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert.deepOwnInclude, true).deep.own.include(inc);
};
assert.notDeepOwnInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert.notDeepOwnInclude, true).not.deep.own.include(
    inc
  );
};
assert.match = function(exp, re, msg) {
  new Assertion(exp, msg, assert.match, true).to.match(re);
};
assert.notMatch = function(exp, re, msg) {
  new Assertion(exp, msg, assert.notMatch, true).to.not.match(re);
};
assert.property = function(obj, prop, msg) {
  new Assertion(obj, msg, assert.property, true).to.have.property(prop);
};
assert.notProperty = function(obj, prop, msg) {
  new Assertion(obj, msg, assert.notProperty, true).to.not.have.property(prop);
};
assert.propertyVal = function(obj, prop, val, msg) {
  new Assertion(obj, msg, assert.propertyVal, true).to.have.property(prop, val);
};
assert.notPropertyVal = function(obj, prop, val, msg) {
  new Assertion(obj, msg, assert.notPropertyVal, true).to.not.have.property(
    prop,
    val
  );
};
assert.deepPropertyVal = function(obj, prop, val, msg) {
  new Assertion(obj, msg, assert.deepPropertyVal, true).to.have.deep.property(
    prop,
    val
  );
};
assert.notDeepPropertyVal = function(obj, prop, val, msg) {
  new Assertion(
    obj,
    msg,
    assert.notDeepPropertyVal,
    true
  ).to.not.have.deep.property(prop, val);
};
assert.ownProperty = function(obj, prop, msg) {
  new Assertion(obj, msg, assert.ownProperty, true).to.have.own.property(prop);
};
assert.notOwnProperty = function(obj, prop, msg) {
  new Assertion(obj, msg, assert.notOwnProperty, true).to.not.have.own.property(
    prop
  );
};
assert.ownPropertyVal = function(obj, prop, value, msg) {
  new Assertion(obj, msg, assert.ownPropertyVal, true).to.have.own.property(
    prop,
    value
  );
};
assert.notOwnPropertyVal = function(obj, prop, value, msg) {
  new Assertion(
    obj,
    msg,
    assert.notOwnPropertyVal,
    true
  ).to.not.have.own.property(prop, value);
};
assert.deepOwnPropertyVal = function(obj, prop, value, msg) {
  new Assertion(
    obj,
    msg,
    assert.deepOwnPropertyVal,
    true
  ).to.have.deep.own.property(prop, value);
};
assert.notDeepOwnPropertyVal = function(obj, prop, value, msg) {
  new Assertion(
    obj,
    msg,
    assert.notDeepOwnPropertyVal,
    true
  ).to.not.have.deep.own.property(prop, value);
};
assert.nestedProperty = function(obj, prop, msg) {
  new Assertion(obj, msg, assert.nestedProperty, true).to.have.nested.property(
    prop
  );
};
assert.notNestedProperty = function(obj, prop, msg) {
  new Assertion(
    obj,
    msg,
    assert.notNestedProperty,
    true
  ).to.not.have.nested.property(prop);
};
assert.nestedPropertyVal = function(obj, prop, val, msg) {
  new Assertion(
    obj,
    msg,
    assert.nestedPropertyVal,
    true
  ).to.have.nested.property(prop, val);
};
assert.notNestedPropertyVal = function(obj, prop, val, msg) {
  new Assertion(
    obj,
    msg,
    assert.notNestedPropertyVal,
    true
  ).to.not.have.nested.property(prop, val);
};
assert.deepNestedPropertyVal = function(obj, prop, val, msg) {
  new Assertion(
    obj,
    msg,
    assert.deepNestedPropertyVal,
    true
  ).to.have.deep.nested.property(prop, val);
};
assert.notDeepNestedPropertyVal = function(obj, prop, val, msg) {
  new Assertion(
    obj,
    msg,
    assert.notDeepNestedPropertyVal,
    true
  ).to.not.have.deep.nested.property(prop, val);
};
assert.lengthOf = function(exp, len, msg) {
  new Assertion(exp, msg, assert.lengthOf, true).to.have.lengthOf(len);
};
assert.hasAnyKeys = function(obj, keys2, msg) {
  new Assertion(obj, msg, assert.hasAnyKeys, true).to.have.any.keys(keys2);
};
assert.hasAllKeys = function(obj, keys2, msg) {
  new Assertion(obj, msg, assert.hasAllKeys, true).to.have.all.keys(keys2);
};
assert.containsAllKeys = function(obj, keys2, msg) {
  new Assertion(obj, msg, assert.containsAllKeys, true).to.contain.all.keys(
    keys2
  );
};
assert.doesNotHaveAnyKeys = function(obj, keys2, msg) {
  new Assertion(obj, msg, assert.doesNotHaveAnyKeys, true).to.not.have.any.keys(
    keys2
  );
};
assert.doesNotHaveAllKeys = function(obj, keys2, msg) {
  new Assertion(obj, msg, assert.doesNotHaveAllKeys, true).to.not.have.all.keys(
    keys2
  );
};
assert.hasAnyDeepKeys = function(obj, keys2, msg) {
  new Assertion(obj, msg, assert.hasAnyDeepKeys, true).to.have.any.deep.keys(
    keys2
  );
};
assert.hasAllDeepKeys = function(obj, keys2, msg) {
  new Assertion(obj, msg, assert.hasAllDeepKeys, true).to.have.all.deep.keys(
    keys2
  );
};
assert.containsAllDeepKeys = function(obj, keys2, msg) {
  new Assertion(
    obj,
    msg,
    assert.containsAllDeepKeys,
    true
  ).to.contain.all.deep.keys(keys2);
};
assert.doesNotHaveAnyDeepKeys = function(obj, keys2, msg) {
  new Assertion(
    obj,
    msg,
    assert.doesNotHaveAnyDeepKeys,
    true
  ).to.not.have.any.deep.keys(keys2);
};
assert.doesNotHaveAllDeepKeys = function(obj, keys2, msg) {
  new Assertion(
    obj,
    msg,
    assert.doesNotHaveAllDeepKeys,
    true
  ).to.not.have.all.deep.keys(keys2);
};
assert.throws = function(fn3, errorLike, errMsgMatcher, msg) {
  if ("string" === typeof errorLike || errorLike instanceof RegExp) {
    errMsgMatcher = errorLike;
    errorLike = null;
  }
  let assertErr = new Assertion(fn3, msg, assert.throws, true).to.throw(
    errorLike,
    errMsgMatcher
  );
  return flag(assertErr, "object");
};
assert.doesNotThrow = function(fn3, errorLike, errMsgMatcher, message) {
  if ("string" === typeof errorLike || errorLike instanceof RegExp) {
    errMsgMatcher = errorLike;
    errorLike = null;
  }
  new Assertion(fn3, message, assert.doesNotThrow, true).to.not.throw(
    errorLike,
    errMsgMatcher
  );
};
assert.operator = function(val, operator, val2, msg) {
  let ok;
  switch (operator) {
    case "==":
      ok = val == val2;
      break;
    case "===":
      ok = val === val2;
      break;
    case ">":
      ok = val > val2;
      break;
    case ">=":
      ok = val >= val2;
      break;
    case "<":
      ok = val < val2;
      break;
    case "<=":
      ok = val <= val2;
      break;
    case "!=":
      ok = val != val2;
      break;
    case "!==":
      ok = val !== val2;
      break;
    default:
      msg = msg ? msg + ": " : msg;
      throw new AssertionError(
        msg + 'Invalid operator "' + operator + '"',
        void 0,
        assert.operator
      );
  }
  let test22 = new Assertion(ok, msg, assert.operator, true);
  test22.assert(
    true === flag(test22, "object"),
    "expected " + inspect22(val) + " to be " + operator + " " + inspect22(val2),
    "expected " + inspect22(val) + " to not be " + operator + " " + inspect22(val2)
  );
};
assert.closeTo = function(act, exp, delta, msg) {
  new Assertion(act, msg, assert.closeTo, true).to.be.closeTo(exp, delta);
};
assert.approximately = function(act, exp, delta, msg) {
  new Assertion(act, msg, assert.approximately, true).to.be.approximately(
    exp,
    delta
  );
};
assert.sameMembers = function(set1, set2, msg) {
  new Assertion(set1, msg, assert.sameMembers, true).to.have.same.members(set2);
};
assert.notSameMembers = function(set1, set2, msg) {
  new Assertion(
    set1,
    msg,
    assert.notSameMembers,
    true
  ).to.not.have.same.members(set2);
};
assert.sameDeepMembers = function(set1, set2, msg) {
  new Assertion(
    set1,
    msg,
    assert.sameDeepMembers,
    true
  ).to.have.same.deep.members(set2);
};
assert.notSameDeepMembers = function(set1, set2, msg) {
  new Assertion(
    set1,
    msg,
    assert.notSameDeepMembers,
    true
  ).to.not.have.same.deep.members(set2);
};
assert.sameOrderedMembers = function(set1, set2, msg) {
  new Assertion(
    set1,
    msg,
    assert.sameOrderedMembers,
    true
  ).to.have.same.ordered.members(set2);
};
assert.notSameOrderedMembers = function(set1, set2, msg) {
  new Assertion(
    set1,
    msg,
    assert.notSameOrderedMembers,
    true
  ).to.not.have.same.ordered.members(set2);
};
assert.sameDeepOrderedMembers = function(set1, set2, msg) {
  new Assertion(
    set1,
    msg,
    assert.sameDeepOrderedMembers,
    true
  ).to.have.same.deep.ordered.members(set2);
};
assert.notSameDeepOrderedMembers = function(set1, set2, msg) {
  new Assertion(
    set1,
    msg,
    assert.notSameDeepOrderedMembers,
    true
  ).to.not.have.same.deep.ordered.members(set2);
};
assert.includeMembers = function(superset, subset, msg) {
  new Assertion(superset, msg, assert.includeMembers, true).to.include.members(
    subset
  );
};
assert.notIncludeMembers = function(superset, subset, msg) {
  new Assertion(
    superset,
    msg,
    assert.notIncludeMembers,
    true
  ).to.not.include.members(subset);
};
assert.includeDeepMembers = function(superset, subset, msg) {
  new Assertion(
    superset,
    msg,
    assert.includeDeepMembers,
    true
  ).to.include.deep.members(subset);
};
assert.notIncludeDeepMembers = function(superset, subset, msg) {
  new Assertion(
    superset,
    msg,
    assert.notIncludeDeepMembers,
    true
  ).to.not.include.deep.members(subset);
};
assert.includeOrderedMembers = function(superset, subset, msg) {
  new Assertion(
    superset,
    msg,
    assert.includeOrderedMembers,
    true
  ).to.include.ordered.members(subset);
};
assert.notIncludeOrderedMembers = function(superset, subset, msg) {
  new Assertion(
    superset,
    msg,
    assert.notIncludeOrderedMembers,
    true
  ).to.not.include.ordered.members(subset);
};
assert.includeDeepOrderedMembers = function(superset, subset, msg) {
  new Assertion(
    superset,
    msg,
    assert.includeDeepOrderedMembers,
    true
  ).to.include.deep.ordered.members(subset);
};
assert.notIncludeDeepOrderedMembers = function(superset, subset, msg) {
  new Assertion(
    superset,
    msg,
    assert.notIncludeDeepOrderedMembers,
    true
  ).to.not.include.deep.ordered.members(subset);
};
assert.oneOf = function(inList, list, msg) {
  new Assertion(inList, msg, assert.oneOf, true).to.be.oneOf(list);
};
assert.isIterable = function(obj, msg) {
  if (obj == void 0 || !obj[Symbol.iterator]) {
    msg = msg ? `${msg} expected ${inspect22(obj)} to be an iterable` : `expected ${inspect22(obj)} to be an iterable`;
    throw new AssertionError(msg, void 0, assert.isIterable);
  }
};
assert.changes = function(fn3, obj, prop, msg) {
  if (arguments.length === 3 && typeof obj === "function") {
    msg = prop;
    prop = null;
  }
  new Assertion(fn3, msg, assert.changes, true).to.change(obj, prop);
};
assert.changesBy = function(fn3, obj, prop, delta, msg) {
  if (arguments.length === 4 && typeof obj === "function") {
    let tmpMsg = delta;
    delta = prop;
    msg = tmpMsg;
  } else if (arguments.length === 3) {
    delta = prop;
    prop = null;
  }
  new Assertion(fn3, msg, assert.changesBy, true).to.change(obj, prop).by(delta);
};
assert.doesNotChange = function(fn3, obj, prop, msg) {
  if (arguments.length === 3 && typeof obj === "function") {
    msg = prop;
    prop = null;
  }
  return new Assertion(fn3, msg, assert.doesNotChange, true).to.not.change(
    obj,
    prop
  );
};
assert.changesButNotBy = function(fn3, obj, prop, delta, msg) {
  if (arguments.length === 4 && typeof obj === "function") {
    let tmpMsg = delta;
    delta = prop;
    msg = tmpMsg;
  } else if (arguments.length === 3) {
    delta = prop;
    prop = null;
  }
  new Assertion(fn3, msg, assert.changesButNotBy, true).to.change(obj, prop).but.not.by(delta);
};
assert.increases = function(fn3, obj, prop, msg) {
  if (arguments.length === 3 && typeof obj === "function") {
    msg = prop;
    prop = null;
  }
  return new Assertion(fn3, msg, assert.increases, true).to.increase(obj, prop);
};
assert.increasesBy = function(fn3, obj, prop, delta, msg) {
  if (arguments.length === 4 && typeof obj === "function") {
    let tmpMsg = delta;
    delta = prop;
    msg = tmpMsg;
  } else if (arguments.length === 3) {
    delta = prop;
    prop = null;
  }
  new Assertion(fn3, msg, assert.increasesBy, true).to.increase(obj, prop).by(delta);
};
assert.doesNotIncrease = function(fn3, obj, prop, msg) {
  if (arguments.length === 3 && typeof obj === "function") {
    msg = prop;
    prop = null;
  }
  return new Assertion(fn3, msg, assert.doesNotIncrease, true).to.not.increase(
    obj,
    prop
  );
};
assert.increasesButNotBy = function(fn3, obj, prop, delta, msg) {
  if (arguments.length === 4 && typeof obj === "function") {
    let tmpMsg = delta;
    delta = prop;
    msg = tmpMsg;
  } else if (arguments.length === 3) {
    delta = prop;
    prop = null;
  }
  new Assertion(fn3, msg, assert.increasesButNotBy, true).to.increase(obj, prop).but.not.by(delta);
};
assert.decreases = function(fn3, obj, prop, msg) {
  if (arguments.length === 3 && typeof obj === "function") {
    msg = prop;
    prop = null;
  }
  return new Assertion(fn3, msg, assert.decreases, true).to.decrease(obj, prop);
};
assert.decreasesBy = function(fn3, obj, prop, delta, msg) {
  if (arguments.length === 4 && typeof obj === "function") {
    let tmpMsg = delta;
    delta = prop;
    msg = tmpMsg;
  } else if (arguments.length === 3) {
    delta = prop;
    prop = null;
  }
  new Assertion(fn3, msg, assert.decreasesBy, true).to.decrease(obj, prop).by(delta);
};
assert.doesNotDecrease = function(fn3, obj, prop, msg) {
  if (arguments.length === 3 && typeof obj === "function") {
    msg = prop;
    prop = null;
  }
  return new Assertion(fn3, msg, assert.doesNotDecrease, true).to.not.decrease(
    obj,
    prop
  );
};
assert.doesNotDecreaseBy = function(fn3, obj, prop, delta, msg) {
  if (arguments.length === 4 && typeof obj === "function") {
    let tmpMsg = delta;
    delta = prop;
    msg = tmpMsg;
  } else if (arguments.length === 3) {
    delta = prop;
    prop = null;
  }
  return new Assertion(fn3, msg, assert.doesNotDecreaseBy, true).to.not.decrease(obj, prop).by(delta);
};
assert.decreasesButNotBy = function(fn3, obj, prop, delta, msg) {
  if (arguments.length === 4 && typeof obj === "function") {
    let tmpMsg = delta;
    delta = prop;
    msg = tmpMsg;
  } else if (arguments.length === 3) {
    delta = prop;
    prop = null;
  }
  new Assertion(fn3, msg, assert.decreasesButNotBy, true).to.decrease(obj, prop).but.not.by(delta);
};
assert.ifError = function(val) {
  if (val) {
    throw val;
  }
};
assert.isExtensible = function(obj, msg) {
  new Assertion(obj, msg, assert.isExtensible, true).to.be.extensible;
};
assert.isNotExtensible = function(obj, msg) {
  new Assertion(obj, msg, assert.isNotExtensible, true).to.not.be.extensible;
};
assert.isSealed = function(obj, msg) {
  new Assertion(obj, msg, assert.isSealed, true).to.be.sealed;
};
assert.isNotSealed = function(obj, msg) {
  new Assertion(obj, msg, assert.isNotSealed, true).to.not.be.sealed;
};
assert.isFrozen = function(obj, msg) {
  new Assertion(obj, msg, assert.isFrozen, true).to.be.frozen;
};
assert.isNotFrozen = function(obj, msg) {
  new Assertion(obj, msg, assert.isNotFrozen, true).to.not.be.frozen;
};
assert.isEmpty = function(val, msg) {
  new Assertion(val, msg, assert.isEmpty, true).to.be.empty;
};
assert.isNotEmpty = function(val, msg) {
  new Assertion(val, msg, assert.isNotEmpty, true).to.not.be.empty;
};
assert.containsSubset = function(val, exp, msg) {
  new Assertion(val, msg).to.containSubset(exp);
};
assert.doesNotContainSubset = function(val, exp, msg) {
  new Assertion(val, msg).to.not.containSubset(exp);
};
var aliases = [
  ["isOk", "ok"],
  ["isNotOk", "notOk"],
  ["throws", "throw"],
  ["throws", "Throw"],
  ["isExtensible", "extensible"],
  ["isNotExtensible", "notExtensible"],
  ["isSealed", "sealed"],
  ["isNotSealed", "notSealed"],
  ["isFrozen", "frozen"],
  ["isNotFrozen", "notFrozen"],
  ["isEmpty", "empty"],
  ["isNotEmpty", "notEmpty"],
  ["isCallable", "isFunction"],
  ["isNotCallable", "isNotFunction"],
  ["containsSubset", "containSubset"]
];
for (const [name, as] of aliases) {
  assert[as] = assert[name];
}
var used = [];
function use(fn3) {
  const exports = {
    use,
    AssertionError,
    util: utils_exports,
    config,
    expect,
    assert,
    Assertion,
    ...should_exports
  };
  if (!~used.indexOf(fn3)) {
    fn3(exports, utils_exports);
    used.push(fn3);
  }
  return exports;
}
__name(use, "use");
__name2(use, "use");

// ../node_modules/@testing-library/jest-dom/dist/matchers.mjs
var matchers_exports = {};
__export(matchers_exports, {
  toAppearAfter: () => toAppearAfter,
  toAppearBefore: () => toAppearBefore,
  toBeChecked: () => toBeChecked,
  toBeDisabled: () => toBeDisabled,
  toBeEmpty: () => toBeEmpty,
  toBeEmptyDOMElement: () => toBeEmptyDOMElement,
  toBeEnabled: () => toBeEnabled,
  toBeInTheDOM: () => toBeInTheDOM,
  toBeInTheDocument: () => toBeInTheDocument,
  toBeInvalid: () => toBeInvalid,
  toBePartiallyChecked: () => toBePartiallyChecked,
  toBePartiallyPressed: () => toBePartiallyPressed,
  toBePressed: () => toBePressed,
  toBeRequired: () => toBeRequired,
  toBeValid: () => toBeValid,
  toBeVisible: () => toBeVisible,
  toContainElement: () => toContainElement,
  toContainHTML: () => toContainHTML,
  toHaveAccessibleDescription: () => toHaveAccessibleDescription,
  toHaveAccessibleErrorMessage: () => toHaveAccessibleErrorMessage,
  toHaveAccessibleName: () => toHaveAccessibleName,
  toHaveAttribute: () => toHaveAttribute,
  toHaveClass: () => toHaveClass,
  toHaveDescription: () => toHaveDescription,
  toHaveDisplayValue: () => toHaveDisplayValue,
  toHaveErrorMessage: () => toHaveErrorMessage,
  toHaveFocus: () => toHaveFocus,
  toHaveFormValues: () => toHaveFormValues,
  toHaveRole: () => toHaveRole,
  toHaveSelection: () => toHaveSelection,
  toHaveStyle: () => toHaveStyle,
  toHaveTextContent: () => toHaveTextContent,
  toHaveValue: () => toHaveValue
});

// ../node_modules/@testing-library/jest-dom/dist/matchers-35e4d3bd.mjs
var import_redent = __toESM(require_redent(), 1);

// ../node_modules/@adobe/css-tools/dist/esm/adobe-css-tools.mjs
var _t = class _t extends Error {
  reason;
  filename;
  line;
  column;
  source;
  constructor(t2, e2, i2, s3, n2) {
    super(`${t2}:${i2}:${s3}: ${e2}`), this.reason = e2, this.filename = t2, this.line = i2, this.column = s3, this.source = n2;
  }
};
__name(_t, "t");
var t = _t;
var _e = class _e {
  start;
  end;
  source;
  constructor(t2, e2, i2) {
    this.start = t2, this.end = e2, this.source = i2;
  }
};
__name(_e, "e");
var e = _e;
var i;
!function(t2) {
  t2.stylesheet = "stylesheet", t2.rule = "rule", t2.declaration = "declaration", t2.comment = "comment", t2.container = "container", t2.charset = "charset", t2.document = "document", t2.customMedia = "custom-media", t2.fontFace = "font-face", t2.host = "host", t2.import = "import", t2.keyframes = "keyframes", t2.keyframe = "keyframe", t2.layer = "layer", t2.media = "media", t2.namespace = "namespace", t2.page = "page", t2.startingStyle = "starting-style", t2.supports = "supports";
}(i || (i = {}));
var s2 = /* @__PURE__ */ __name((t2, e2, i2) => {
  let s3 = i2, n2 = 1e4;
  do {
    const i3 = e2.map((e3) => t2.indexOf(e3, s3));
    i3.push(t2.indexOf("\\", s3));
    const r2 = i3.filter((t3) => -1 !== t3);
    if (0 === r2.length) return -1;
    const o2 = Math.min(...r2);
    if ("\\" !== t2[o2]) return o2;
    s3 = o2 + 2, n2--;
  } while (n2 > 0);
  throw new Error("Too many escaping");
}, "s");
var n = /* @__PURE__ */ __name((t2, e2, i2) => {
  let r2 = i2, o2 = 1e4;
  do {
    const i3 = e2.map((e3) => t2.indexOf(e3, r2));
    i3.push(t2.indexOf("(", r2)), i3.push(t2.indexOf('"', r2)), i3.push(t2.indexOf("'", r2)), i3.push(t2.indexOf("\\", r2));
    const c2 = i3.filter((t3) => -1 !== t3);
    if (0 === c2.length) return -1;
    const a2 = Math.min(...c2);
    switch (t2[a2]) {
      case "\\":
        r2 = a2 + 2;
        break;
      case "(":
        {
          const e3 = n(t2, [")"], a2 + 1);
          if (-1 === e3) return -1;
          r2 = e3 + 1;
        }
        break;
      case '"':
        {
          const e3 = s2(t2, ['"'], a2 + 1);
          if (-1 === e3) return -1;
          r2 = e3 + 1;
        }
        break;
      case "'":
        {
          const e3 = s2(t2, ["'"], a2 + 1);
          if (-1 === e3) return -1;
          r2 = e3 + 1;
        }
        break;
      default:
        return a2;
    }
    o2--;
  } while (o2 > 0);
  throw new Error("Too many escaping");
}, "n");
var r = /\/\*[^]*?(?:\*\/|$)/g;
function o(t2) {
  return t2 ? t2.trim() : "";
}
__name(o, "o");
function c(t2, e2) {
  const i2 = t2 && "string" == typeof t2.type, s3 = i2 ? t2 : e2;
  for (const e3 in t2) {
    const i3 = t2[e3];
    Array.isArray(i3) ? i3.forEach((t3) => {
      c(t3, s3);
    }) : i3 && "object" == typeof i3 && c(i3, s3);
  }
  return i2 && Object.defineProperty(t2, "parent", { configurable: true, writable: true, enumerable: false, value: e2 || null }), t2;
}
__name(c, "c");
var m2 = /* @__PURE__ */ __name((s3, a2) => {
  a2 = a2 || {};
  let m3 = 1, h3 = 1;
  function u3() {
    const t2 = { line: m3, column: h3 };
    return (i2) => (i2.position = new e(t2, { line: m3, column: h3 }, a2?.source || ""), $(), i2);
  }
  __name(u3, "u");
  const p2 = [];
  function l2(e2) {
    const i2 = new t(a2?.source || "", e2, m3, h3, s3);
    if (!a2?.silent) throw i2;
    p2.push(i2);
  }
  __name(l2, "l");
  function f4() {
    const t2 = /^{\s*/.exec(s3);
    return !!t2 && (g2(t2), true);
  }
  __name(f4, "f");
  function d() {
    const t2 = /^}/.exec(s3);
    return !!t2 && (g2(t2), true);
  }
  __name(d, "d");
  function y2() {
    let t2;
    const e2 = [];
    for ($(), x2(e2); s3.length && "}" !== s3.charAt(0) && (t2 = A() || S2(), t2); ) e2.push(t2), x2(e2);
    return e2;
  }
  __name(y2, "y");
  function g2(t2) {
    const e2 = t2[0];
    return function(t3) {
      const e3 = t3.match(/\n/g);
      e3 && (m3 += e3.length);
      const i2 = t3.lastIndexOf("\n");
      h3 = ~i2 ? t3.length - i2 : h3 + t3.length;
    }(e2), s3 = s3.slice(e2.length), t2;
  }
  __name(g2, "g");
  function $() {
    const t2 = /^\s*/.exec(s3);
    t2 && g2(t2);
  }
  __name($, "$");
  function x2(t2) {
    t2 = t2 || [];
    let e2 = V();
    for (; e2; ) t2.push(e2), e2 = V();
    return t2;
  }
  __name(x2, "x");
  function V() {
    const t2 = u3();
    if ("/" !== s3.charAt(0) || "*" !== s3.charAt(1)) return;
    const e2 = /^\/\*[^]*?\*\//.exec(s3);
    return e2 ? (g2(e2), t2({ type: i.comment, comment: e2[0].slice(2, -2) })) : l2("End of comment missing");
  }
  __name(V, "V");
  function k2() {
    const t2 = /^([^{]+)/.exec(s3);
    if (!t2) return;
    g2(t2);
    return ((t3, e2) => {
      const i2 = [];
      let s4 = 0;
      for (; s4 < t3.length; ) {
        const r2 = n(t3, e2, s4);
        if (-1 === r2) return i2.push(t3.substring(s4)), i2;
        i2.push(t3.substring(s4, r2)), s4 = r2 + 1;
      }
      return i2;
    })(o(t2[0]).replace(r, ""), [","]).map((t3) => o(t3));
  }
  __name(k2, "k");
  function v2() {
    const t2 = u3(), e2 = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/.exec(s3);
    if (!e2) return;
    g2(e2);
    const c2 = o(e2[0]), a3 = /^:\s*/.exec(s3);
    if (!a3) return l2("property missing ':'");
    g2(a3);
    let m4 = "";
    const h4 = n(s3, [";", "}"]);
    if (-1 !== h4) {
      m4 = s3.substring(0, h4);
      g2([m4]), m4 = o(m4).replace(r, "");
    }
    const p3 = t2({ type: i.declaration, property: c2.replace(r, ""), value: m4 }), f5 = /^[;\s]*/.exec(s3);
    return f5 && g2(f5), p3;
  }
  __name(v2, "v");
  function w2() {
    const t2 = [];
    if (!f4()) return l2("missing '{'");
    x2(t2);
    let e2 = v2();
    for (; e2; ) t2.push(e2), x2(t2), e2 = v2();
    return d() ? t2 : l2("missing '}'");
  }
  __name(w2, "w");
  function b2() {
    const t2 = [], e2 = u3();
    let n2 = /^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/.exec(s3);
    for (; n2; ) {
      const e3 = g2(n2);
      t2.push(e3[1]);
      const i2 = /^,\s*/.exec(s3);
      i2 && g2(i2), n2 = /^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/.exec(s3);
    }
    if (t2.length) return e2({ type: i.keyframe, values: t2, declarations: w2() || [] });
  }
  __name(b2, "b");
  const j2 = M2("import"), O = M2("charset"), E2 = M2("namespace");
  function M2(t2) {
    const e2 = new RegExp("^@" + t2 + `\\s*((?::?[^;'"]|"(?:\\\\"|[^"])*?"|'(?:\\\\'|[^'])*?')+)(?:;|$)`);
    return () => {
      const i2 = u3(), n2 = e2.exec(s3);
      if (!n2) return;
      const r2 = g2(n2), o2 = { type: t2 };
      return o2[t2] = r2[1].trim(), i2(o2);
    };
  }
  __name(M2, "M");
  function A() {
    if ("@" === s3[0]) return function() {
      const t2 = u3(), e2 = /^@([-\w]+)?keyframes\s*/.exec(s3);
      if (!e2) return;
      const n2 = g2(e2)[1], r2 = /^([-\w]+)\s*/.exec(s3);
      if (!r2) return l2("@keyframes missing name");
      const o2 = g2(r2)[1];
      if (!f4()) return l2("@keyframes missing '{'");
      let c2 = x2(), a3 = b2();
      for (; a3; ) c2.push(a3), c2 = c2.concat(x2()), a3 = b2();
      return d() ? t2({ type: i.keyframes, name: o2, vendor: n2, keyframes: c2 }) : l2("@keyframes missing '}'");
    }() || function() {
      const t2 = u3(), e2 = /^@media *([^{]+)/.exec(s3);
      if (!e2) return;
      const n2 = o(g2(e2)[1]);
      if (!f4()) return l2("@media missing '{'");
      const r2 = x2().concat(y2());
      return d() ? t2({ type: i.media, media: n2, rules: r2 }) : l2("@media missing '}'");
    }() || function() {
      const t2 = u3(), e2 = /^@custom-media\s+(--\S+)\s+([^{;\s][^{;]*);/.exec(s3);
      if (!e2) return;
      const n2 = g2(e2);
      return t2({ type: i.customMedia, name: o(n2[1]), media: o(n2[2]) });
    }() || function() {
      const t2 = u3(), e2 = /^@supports *([^{]+)/.exec(s3);
      if (!e2) return;
      const n2 = o(g2(e2)[1]);
      if (!f4()) return l2("@supports missing '{'");
      const r2 = x2().concat(y2());
      return d() ? t2({ type: i.supports, supports: n2, rules: r2 }) : l2("@supports missing '}'");
    }() || j2() || O() || E2() || function() {
      const t2 = u3(), e2 = /^@([-\w]+)?document *([^{]+)/.exec(s3);
      if (!e2) return;
      const n2 = g2(e2), r2 = o(n2[1]), c2 = o(n2[2]);
      if (!f4()) return l2("@document missing '{'");
      const a3 = x2().concat(y2());
      return d() ? t2({ type: i.document, document: c2, vendor: r2, rules: a3 }) : l2("@document missing '}'");
    }() || function() {
      const t2 = u3(), e2 = /^@page */.exec(s3);
      if (!e2) return;
      g2(e2);
      const n2 = k2() || [];
      if (!f4()) return l2("@page missing '{'");
      let r2 = x2(), o2 = v2();
      for (; o2; ) r2.push(o2), r2 = r2.concat(x2()), o2 = v2();
      return d() ? t2({ type: i.page, selectors: n2, declarations: r2 }) : l2("@page missing '}'");
    }() || function() {
      const t2 = u3(), e2 = /^@host\s*/.exec(s3);
      if (!e2) return;
      if (g2(e2), !f4()) return l2("@host missing '{'");
      const n2 = x2().concat(y2());
      return d() ? t2({ type: i.host, rules: n2 }) : l2("@host missing '}'");
    }() || function() {
      const t2 = u3(), e2 = /^@font-face\s*/.exec(s3);
      if (!e2) return;
      if (g2(e2), !f4()) return l2("@font-face missing '{'");
      let n2 = x2(), r2 = v2();
      for (; r2; ) n2.push(r2), n2 = n2.concat(x2()), r2 = v2();
      return d() ? t2({ type: i.fontFace, declarations: n2 }) : l2("@font-face missing '}'");
    }() || function() {
      const t2 = u3(), e2 = /^@container *([^{]+)/.exec(s3);
      if (!e2) return;
      const n2 = o(g2(e2)[1]);
      if (!f4()) return l2("@container missing '{'");
      const r2 = x2().concat(y2());
      return d() ? t2({ type: i.container, container: n2, rules: r2 }) : l2("@container missing '}'");
    }() || function() {
      const t2 = u3(), e2 = /^@starting-style\s*/.exec(s3);
      if (!e2) return;
      if (g2(e2), !f4()) return l2("@starting-style missing '{'");
      const n2 = x2().concat(y2());
      return d() ? t2({ type: i.startingStyle, rules: n2 }) : l2("@starting-style missing '}'");
    }() || function() {
      const t2 = u3(), e2 = /^@layer *([^{;@]+)/.exec(s3);
      if (!e2) return;
      const n2 = o(g2(e2)[1]);
      if (!f4()) {
        const e3 = /^[;\s]*/.exec(s3);
        return e3 && g2(e3), t2({ type: i.layer, layer: n2 });
      }
      const r2 = x2().concat(y2());
      return d() ? t2({ type: i.layer, layer: n2, rules: r2 }) : l2("@layer missing '}'");
    }();
  }
  __name(A, "A");
  function S2() {
    const t2 = u3(), e2 = k2();
    return e2 ? (x2(), t2({ type: i.rule, selectors: e2, declarations: w2() || [] })) : l2("selector missing");
  }
  __name(S2, "S");
  return c(function() {
    const t2 = y2();
    return { type: i.stylesheet, stylesheet: { source: a2?.source, rules: t2, parsingErrors: p2 } };
  }());
}, "m");

// ../node_modules/@testing-library/jest-dom/node_modules/dom-accessibility-api/dist/polyfills/array.from.mjs
var toStr = Object.prototype.toString;
function isCallable(fn3) {
  return typeof fn3 === "function" || toStr.call(fn3) === "[object Function]";
}
__name(isCallable, "isCallable");
function toInteger(value) {
  var number = Number(value);
  if (isNaN(number)) {
    return 0;
  }
  if (number === 0 || !isFinite(number)) {
    return number;
  }
  return (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));
}
__name(toInteger, "toInteger");
var maxSafeInteger = Math.pow(2, 53) - 1;
function toLength(value) {
  var len = toInteger(value);
  return Math.min(Math.max(len, 0), maxSafeInteger);
}
__name(toLength, "toLength");
function arrayFrom(arrayLike, mapFn) {
  var C2 = Array;
  var items = Object(arrayLike);
  if (arrayLike == null) {
    throw new TypeError("Array.from requires an array-like object - not null or undefined");
  }
  if (typeof mapFn !== "undefined") {
    if (!isCallable(mapFn)) {
      throw new TypeError("Array.from: when provided, the second argument must be a function");
    }
  }
  var len = toLength(items.length);
  var A = isCallable(C2) ? Object(new C2(len)) : new Array(len);
  var k2 = 0;
  var kValue;
  while (k2 < len) {
    kValue = items[k2];
    if (mapFn) {
      A[k2] = mapFn(kValue, k2);
    } else {
      A[k2] = kValue;
    }
    k2 += 1;
  }
  A.length = len;
  return A;
}
__name(arrayFrom, "arrayFrom");

// ../node_modules/@testing-library/jest-dom/node_modules/dom-accessibility-api/dist/polyfills/SetLike.mjs
function _typeof(o2) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof(o2);
}
__name(_typeof, "_typeof");
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
__name(_classCallCheck, "_classCallCheck");
function _defineProperties(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
__name(_defineProperties, "_defineProperties");
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
__name(_createClass, "_createClass");
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
__name(_defineProperty, "_defineProperty");
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
__name(_toPropertyKey, "_toPropertyKey");
function _toPrimitive(input2, hint) {
  if (_typeof(input2) !== "object" || input2 === null) return input2;
  var prim = input2[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input2, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input2);
}
__name(_toPrimitive, "_toPrimitive");
var SetLike = function() {
  function SetLike3() {
    var items = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    _classCallCheck(this, SetLike3);
    _defineProperty(this, "items", void 0);
    this.items = items;
  }
  __name(SetLike3, "SetLike");
  _createClass(SetLike3, [{
    key: "add",
    value: /* @__PURE__ */ __name(function add(value) {
      if (this.has(value) === false) {
        this.items.push(value);
      }
      return this;
    }, "add")
  }, {
    key: "clear",
    value: /* @__PURE__ */ __name(function clear4() {
      this.items = [];
    }, "clear")
  }, {
    key: "delete",
    value: /* @__PURE__ */ __name(function _delete(value) {
      var previousLength = this.items.length;
      this.items = this.items.filter(function(item) {
        return item !== value;
      });
      return previousLength !== this.items.length;
    }, "_delete")
  }, {
    key: "forEach",
    value: /* @__PURE__ */ __name(function forEach(callbackfn) {
      var _this = this;
      this.items.forEach(function(item) {
        callbackfn(item, item, _this);
      });
    }, "forEach")
  }, {
    key: "has",
    value: /* @__PURE__ */ __name(function has(value) {
      return this.items.indexOf(value) !== -1;
    }, "has")
  }, {
    key: "size",
    get: /* @__PURE__ */ __name(function get3() {
      return this.items.length;
    }, "get")
  }]);
  return SetLike3;
}();
var SetLike_default = typeof Set === "undefined" ? Set : SetLike;

// ../node_modules/@testing-library/jest-dom/node_modules/dom-accessibility-api/dist/getRole.mjs
function getLocalName(element) {
  var _element$localName;
  return (
    // eslint-disable-next-line no-restricted-properties -- actual guard for environments without localName
    (_element$localName = element.localName) !== null && _element$localName !== void 0 ? _element$localName : (
      // eslint-disable-next-line no-restricted-properties -- required for the fallback
      element.tagName.toLowerCase()
    )
  );
}
__name(getLocalName, "getLocalName");
var localNameToRoleMappings = {
  article: "article",
  aside: "complementary",
  button: "button",
  datalist: "listbox",
  dd: "definition",
  details: "group",
  dialog: "dialog",
  dt: "term",
  fieldset: "group",
  figure: "figure",
  // WARNING: Only with an accessible name
  form: "form",
  footer: "contentinfo",
  h1: "heading",
  h2: "heading",
  h3: "heading",
  h4: "heading",
  h5: "heading",
  h6: "heading",
  header: "banner",
  hr: "separator",
  html: "document",
  legend: "legend",
  li: "listitem",
  math: "math",
  main: "main",
  menu: "list",
  nav: "navigation",
  ol: "list",
  optgroup: "group",
  // WARNING: Only in certain context
  option: "option",
  output: "status",
  progress: "progressbar",
  // WARNING: Only with an accessible name
  section: "region",
  summary: "button",
  table: "table",
  tbody: "rowgroup",
  textarea: "textbox",
  tfoot: "rowgroup",
  // WARNING: Only in certain context
  td: "cell",
  th: "columnheader",
  thead: "rowgroup",
  tr: "row",
  ul: "list"
};
var prohibitedAttributes = {
  caption: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  code: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  deletion: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  emphasis: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  generic: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby", "aria-roledescription"]),
  insertion: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  none: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  paragraph: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  presentation: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  strong: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  subscript: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  superscript: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"])
};
function hasGlobalAriaAttributes(element, role) {
  return [
    "aria-atomic",
    "aria-busy",
    "aria-controls",
    "aria-current",
    "aria-description",
    "aria-describedby",
    "aria-details",
    // "disabled",
    "aria-dropeffect",
    // "errormessage",
    "aria-flowto",
    "aria-grabbed",
    // "haspopup",
    "aria-hidden",
    // "invalid",
    "aria-keyshortcuts",
    "aria-label",
    "aria-labelledby",
    "aria-live",
    "aria-owns",
    "aria-relevant",
    "aria-roledescription"
  ].some(function(attributeName) {
    var _prohibitedAttributes;
    return element.hasAttribute(attributeName) && !((_prohibitedAttributes = prohibitedAttributes[role]) !== null && _prohibitedAttributes !== void 0 && _prohibitedAttributes.has(attributeName));
  });
}
__name(hasGlobalAriaAttributes, "hasGlobalAriaAttributes");
function ignorePresentationalRole(element, implicitRole) {
  return hasGlobalAriaAttributes(element, implicitRole);
}
__name(ignorePresentationalRole, "ignorePresentationalRole");
function getRole(element) {
  var explicitRole = getExplicitRole(element);
  if (explicitRole === null || presentationRoles.indexOf(explicitRole) !== -1) {
    var implicitRole = getImplicitRole(element);
    if (presentationRoles.indexOf(explicitRole || "") === -1 || ignorePresentationalRole(element, implicitRole || "")) {
      return implicitRole;
    }
  }
  return explicitRole;
}
__name(getRole, "getRole");
function getImplicitRole(element) {
  var mappedByTag = localNameToRoleMappings[getLocalName(element)];
  if (mappedByTag !== void 0) {
    return mappedByTag;
  }
  switch (getLocalName(element)) {
    case "a":
    case "area":
    case "link":
      if (element.hasAttribute("href")) {
        return "link";
      }
      break;
    case "img":
      if (element.getAttribute("alt") === "" && !ignorePresentationalRole(element, "img")) {
        return "presentation";
      }
      return "img";
    case "input": {
      var _ref = element, type5 = _ref.type;
      switch (type5) {
        case "button":
        case "image":
        case "reset":
        case "submit":
          return "button";
        case "checkbox":
        case "radio":
          return type5;
        case "range":
          return "slider";
        case "email":
        case "tel":
        case "text":
        case "url":
          if (element.hasAttribute("list")) {
            return "combobox";
          }
          return "textbox";
        case "search":
          if (element.hasAttribute("list")) {
            return "combobox";
          }
          return "searchbox";
        case "number":
          return "spinbutton";
        default:
          return null;
      }
    }
    case "select":
      if (element.hasAttribute("multiple") || element.size > 1) {
        return "listbox";
      }
      return "combobox";
  }
  return null;
}
__name(getImplicitRole, "getImplicitRole");
function getExplicitRole(element) {
  var role = element.getAttribute("role");
  if (role !== null) {
    var explicitRole = role.trim().split(" ")[0];
    if (explicitRole.length > 0) {
      return explicitRole;
    }
  }
  return null;
}
__name(getExplicitRole, "getExplicitRole");

// ../node_modules/@testing-library/jest-dom/node_modules/dom-accessibility-api/dist/util.mjs
var presentationRoles = ["presentation", "none"];
function isElement(node) {
  return node !== null && node.nodeType === node.ELEMENT_NODE;
}
__name(isElement, "isElement");
function isHTMLTableCaptionElement(node) {
  return isElement(node) && getLocalName(node) === "caption";
}
__name(isHTMLTableCaptionElement, "isHTMLTableCaptionElement");
function isHTMLInputElement(node) {
  return isElement(node) && getLocalName(node) === "input";
}
__name(isHTMLInputElement, "isHTMLInputElement");
function isHTMLOptGroupElement(node) {
  return isElement(node) && getLocalName(node) === "optgroup";
}
__name(isHTMLOptGroupElement, "isHTMLOptGroupElement");
function isHTMLSelectElement(node) {
  return isElement(node) && getLocalName(node) === "select";
}
__name(isHTMLSelectElement, "isHTMLSelectElement");
function isHTMLTableElement(node) {
  return isElement(node) && getLocalName(node) === "table";
}
__name(isHTMLTableElement, "isHTMLTableElement");
function isHTMLTextAreaElement(node) {
  return isElement(node) && getLocalName(node) === "textarea";
}
__name(isHTMLTextAreaElement, "isHTMLTextAreaElement");
function safeWindow(node) {
  var _ref = node.ownerDocument === null ? node : node.ownerDocument, defaultView = _ref.defaultView;
  if (defaultView === null) {
    throw new TypeError("no window available");
  }
  return defaultView;
}
__name(safeWindow, "safeWindow");
function isHTMLFieldSetElement(node) {
  return isElement(node) && getLocalName(node) === "fieldset";
}
__name(isHTMLFieldSetElement, "isHTMLFieldSetElement");
function isHTMLLegendElement(node) {
  return isElement(node) && getLocalName(node) === "legend";
}
__name(isHTMLLegendElement, "isHTMLLegendElement");
function isHTMLSlotElement(node) {
  return isElement(node) && getLocalName(node) === "slot";
}
__name(isHTMLSlotElement, "isHTMLSlotElement");
function isSVGElement(node) {
  return isElement(node) && node.ownerSVGElement !== void 0;
}
__name(isSVGElement, "isSVGElement");
function isSVGSVGElement(node) {
  return isElement(node) && getLocalName(node) === "svg";
}
__name(isSVGSVGElement, "isSVGSVGElement");
function isSVGTitleElement(node) {
  return isSVGElement(node) && getLocalName(node) === "title";
}
__name(isSVGTitleElement, "isSVGTitleElement");
function queryIdRefs(node, attributeName) {
  if (isElement(node) && node.hasAttribute(attributeName)) {
    var ids = node.getAttribute(attributeName).split(" ");
    var root2 = node.getRootNode ? node.getRootNode() : node.ownerDocument;
    return ids.map(function(id) {
      return root2.getElementById(id);
    }).filter(
      function(element) {
        return element !== null;
      }
      // TODO: why does this not narrow?
    );
  }
  return [];
}
__name(queryIdRefs, "queryIdRefs");
function hasAnyConcreteRoles(node, roles3) {
  if (isElement(node)) {
    return roles3.indexOf(getRole(node)) !== -1;
  }
  return false;
}
__name(hasAnyConcreteRoles, "hasAnyConcreteRoles");

// ../node_modules/@testing-library/jest-dom/node_modules/dom-accessibility-api/dist/accessible-name-and-description.mjs
function asFlatString(s3) {
  return s3.trim().replace(/\s\s+/g, " ");
}
__name(asFlatString, "asFlatString");
function isHidden(node, getComputedStyleImplementation) {
  if (!isElement(node)) {
    return false;
  }
  if (node.hasAttribute("hidden") || node.getAttribute("aria-hidden") === "true") {
    return true;
  }
  var style = getComputedStyleImplementation(node);
  return style.getPropertyValue("display") === "none" || style.getPropertyValue("visibility") === "hidden";
}
__name(isHidden, "isHidden");
function isControl(node) {
  return hasAnyConcreteRoles(node, ["button", "combobox", "listbox", "textbox"]) || hasAbstractRole(node, "range");
}
__name(isControl, "isControl");
function hasAbstractRole(node, role) {
  if (!isElement(node)) {
    return false;
  }
  switch (role) {
    case "range":
      return hasAnyConcreteRoles(node, ["meter", "progressbar", "scrollbar", "slider", "spinbutton"]);
    default:
      throw new TypeError("No knowledge about abstract role '".concat(role, "'. This is likely a bug :("));
  }
}
__name(hasAbstractRole, "hasAbstractRole");
function querySelectorAllSubtree(element, selectors) {
  var elements = arrayFrom(element.querySelectorAll(selectors));
  queryIdRefs(element, "aria-owns").forEach(function(root2) {
    elements.push.apply(elements, arrayFrom(root2.querySelectorAll(selectors)));
  });
  return elements;
}
__name(querySelectorAllSubtree, "querySelectorAllSubtree");
function querySelectedOptions(listbox) {
  if (isHTMLSelectElement(listbox)) {
    return listbox.selectedOptions || querySelectorAllSubtree(listbox, "[selected]");
  }
  return querySelectorAllSubtree(listbox, '[aria-selected="true"]');
}
__name(querySelectedOptions, "querySelectedOptions");
function isMarkedPresentational(node) {
  return hasAnyConcreteRoles(node, presentationRoles);
}
__name(isMarkedPresentational, "isMarkedPresentational");
function isNativeHostLanguageTextAlternativeElement(node) {
  return isHTMLTableCaptionElement(node);
}
__name(isNativeHostLanguageTextAlternativeElement, "isNativeHostLanguageTextAlternativeElement");
function allowsNameFromContent(node) {
  return hasAnyConcreteRoles(node, ["button", "cell", "checkbox", "columnheader", "gridcell", "heading", "label", "legend", "link", "menuitem", "menuitemcheckbox", "menuitemradio", "option", "radio", "row", "rowheader", "switch", "tab", "tooltip", "treeitem"]);
}
__name(allowsNameFromContent, "allowsNameFromContent");
function isDescendantOfNativeHostLanguageTextAlternativeElement(node) {
  return false;
}
__name(isDescendantOfNativeHostLanguageTextAlternativeElement, "isDescendantOfNativeHostLanguageTextAlternativeElement");
function getValueOfTextbox(element) {
  if (isHTMLInputElement(element) || isHTMLTextAreaElement(element)) {
    return element.value;
  }
  return element.textContent || "";
}
__name(getValueOfTextbox, "getValueOfTextbox");
function getTextualContent(declaration) {
  var content = declaration.getPropertyValue("content");
  if (/^["'].*["']$/.test(content)) {
    return content.slice(1, -1);
  }
  return "";
}
__name(getTextualContent, "getTextualContent");
function isLabelableElement(element) {
  var localName = getLocalName(element);
  return localName === "button" || localName === "input" && element.getAttribute("type") !== "hidden" || localName === "meter" || localName === "output" || localName === "progress" || localName === "select" || localName === "textarea";
}
__name(isLabelableElement, "isLabelableElement");
function findLabelableElement(element) {
  if (isLabelableElement(element)) {
    return element;
  }
  var labelableElement = null;
  element.childNodes.forEach(function(childNode) {
    if (labelableElement === null && isElement(childNode)) {
      var descendantLabelableElement = findLabelableElement(childNode);
      if (descendantLabelableElement !== null) {
        labelableElement = descendantLabelableElement;
      }
    }
  });
  return labelableElement;
}
__name(findLabelableElement, "findLabelableElement");
function getControlOfLabel(label) {
  if (label.control !== void 0) {
    return label.control;
  }
  var htmlFor = label.getAttribute("for");
  if (htmlFor !== null) {
    return label.ownerDocument.getElementById(htmlFor);
  }
  return findLabelableElement(label);
}
__name(getControlOfLabel, "getControlOfLabel");
function getLabels(element) {
  var labelsProperty = element.labels;
  if (labelsProperty === null) {
    return labelsProperty;
  }
  if (labelsProperty !== void 0) {
    return arrayFrom(labelsProperty);
  }
  if (!isLabelableElement(element)) {
    return null;
  }
  var document7 = element.ownerDocument;
  return arrayFrom(document7.querySelectorAll("label")).filter(function(label) {
    return getControlOfLabel(label) === element;
  });
}
__name(getLabels, "getLabels");
function getSlotContents(slot) {
  var assignedNodes = slot.assignedNodes();
  if (assignedNodes.length === 0) {
    return arrayFrom(slot.childNodes);
  }
  return assignedNodes;
}
__name(getSlotContents, "getSlotContents");
function computeTextAlternative(root2) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var consultedNodes = new SetLike_default();
  var window2 = safeWindow(root2);
  var _options$compute = options.compute, compute = _options$compute === void 0 ? "name" : _options$compute, _options$computedStyl = options.computedStyleSupportsPseudoElements, computedStyleSupportsPseudoElements = _options$computedStyl === void 0 ? options.getComputedStyle !== void 0 : _options$computedStyl, _options$getComputedS = options.getComputedStyle, getComputedStyle2 = _options$getComputedS === void 0 ? window2.getComputedStyle.bind(window2) : _options$getComputedS, _options$hidden = options.hidden, hidden = _options$hidden === void 0 ? false : _options$hidden;
  function computeMiscTextAlternative(node, context) {
    var accumulatedText = "";
    if (isElement(node) && computedStyleSupportsPseudoElements) {
      var pseudoBefore = getComputedStyle2(node, "::before");
      var beforeContent = getTextualContent(pseudoBefore);
      accumulatedText = "".concat(beforeContent, " ").concat(accumulatedText);
    }
    var childNodes = isHTMLSlotElement(node) ? getSlotContents(node) : arrayFrom(node.childNodes).concat(queryIdRefs(node, "aria-owns"));
    childNodes.forEach(function(child) {
      var result = computeTextAlternative3(child, {
        isEmbeddedInLabel: context.isEmbeddedInLabel,
        isReferenced: false,
        recursion: true
      });
      var display2 = isElement(child) ? getComputedStyle2(child).getPropertyValue("display") : "inline";
      var separator = display2 !== "inline" ? " " : "";
      accumulatedText += "".concat(separator).concat(result).concat(separator);
    });
    if (isElement(node) && computedStyleSupportsPseudoElements) {
      var pseudoAfter = getComputedStyle2(node, "::after");
      var afterContent = getTextualContent(pseudoAfter);
      accumulatedText = "".concat(accumulatedText, " ").concat(afterContent);
    }
    return accumulatedText.trim();
  }
  __name(computeMiscTextAlternative, "computeMiscTextAlternative");
  function useAttribute(element, attributeName) {
    var attribute = element.getAttributeNode(attributeName);
    if (attribute !== null && !consultedNodes.has(attribute) && attribute.value.trim() !== "") {
      consultedNodes.add(attribute);
      return attribute.value;
    }
    return null;
  }
  __name(useAttribute, "useAttribute");
  function computeTooltipAttributeValue(node) {
    if (!isElement(node)) {
      return null;
    }
    return useAttribute(node, "title");
  }
  __name(computeTooltipAttributeValue, "computeTooltipAttributeValue");
  function computeElementTextAlternative(node) {
    if (!isElement(node)) {
      return null;
    }
    if (isHTMLFieldSetElement(node)) {
      consultedNodes.add(node);
      var children = arrayFrom(node.childNodes);
      for (var i2 = 0; i2 < children.length; i2 += 1) {
        var child = children[i2];
        if (isHTMLLegendElement(child)) {
          return computeTextAlternative3(child, {
            isEmbeddedInLabel: false,
            isReferenced: false,
            recursion: false
          });
        }
      }
    } else if (isHTMLTableElement(node)) {
      consultedNodes.add(node);
      var _children = arrayFrom(node.childNodes);
      for (var _i = 0; _i < _children.length; _i += 1) {
        var _child = _children[_i];
        if (isHTMLTableCaptionElement(_child)) {
          return computeTextAlternative3(_child, {
            isEmbeddedInLabel: false,
            isReferenced: false,
            recursion: false
          });
        }
      }
    } else if (isSVGSVGElement(node)) {
      consultedNodes.add(node);
      var _children2 = arrayFrom(node.childNodes);
      for (var _i2 = 0; _i2 < _children2.length; _i2 += 1) {
        var _child2 = _children2[_i2];
        if (isSVGTitleElement(_child2)) {
          return _child2.textContent;
        }
      }
      return null;
    } else if (getLocalName(node) === "img" || getLocalName(node) === "area") {
      var nameFromAlt = useAttribute(node, "alt");
      if (nameFromAlt !== null) {
        return nameFromAlt;
      }
    } else if (isHTMLOptGroupElement(node)) {
      var nameFromLabel = useAttribute(node, "label");
      if (nameFromLabel !== null) {
        return nameFromLabel;
      }
    }
    if (isHTMLInputElement(node) && (node.type === "button" || node.type === "submit" || node.type === "reset")) {
      var nameFromValue = useAttribute(node, "value");
      if (nameFromValue !== null) {
        return nameFromValue;
      }
      if (node.type === "submit") {
        return "Submit";
      }
      if (node.type === "reset") {
        return "Reset";
      }
    }
    var labels = getLabels(node);
    if (labels !== null && labels.length !== 0) {
      consultedNodes.add(node);
      return arrayFrom(labels).map(function(element) {
        return computeTextAlternative3(element, {
          isEmbeddedInLabel: true,
          isReferenced: false,
          recursion: true
        });
      }).filter(function(label) {
        return label.length > 0;
      }).join(" ");
    }
    if (isHTMLInputElement(node) && node.type === "image") {
      var _nameFromAlt = useAttribute(node, "alt");
      if (_nameFromAlt !== null) {
        return _nameFromAlt;
      }
      var nameFromTitle = useAttribute(node, "title");
      if (nameFromTitle !== null) {
        return nameFromTitle;
      }
      return "Submit Query";
    }
    if (hasAnyConcreteRoles(node, ["button"])) {
      var nameFromSubTree = computeMiscTextAlternative(node, {
        isEmbeddedInLabel: false,
        isReferenced: false
      });
      if (nameFromSubTree !== "") {
        return nameFromSubTree;
      }
    }
    return null;
  }
  __name(computeElementTextAlternative, "computeElementTextAlternative");
  function computeTextAlternative3(current, context) {
    if (consultedNodes.has(current)) {
      return "";
    }
    if (!hidden && isHidden(current, getComputedStyle2) && !context.isReferenced) {
      consultedNodes.add(current);
      return "";
    }
    var labelAttributeNode = isElement(current) ? current.getAttributeNode("aria-labelledby") : null;
    var labelElements = labelAttributeNode !== null && !consultedNodes.has(labelAttributeNode) ? queryIdRefs(current, "aria-labelledby") : [];
    if (compute === "name" && !context.isReferenced && labelElements.length > 0) {
      consultedNodes.add(labelAttributeNode);
      return labelElements.map(function(element) {
        return computeTextAlternative3(element, {
          isEmbeddedInLabel: context.isEmbeddedInLabel,
          isReferenced: true,
          // this isn't recursion as specified, otherwise we would skip
          // `aria-label` in
          // <input id="myself" aria-label="foo" aria-labelledby="myself"
          recursion: false
        });
      }).join(" ");
    }
    var skipToStep2E = context.recursion && isControl(current) && compute === "name";
    if (!skipToStep2E) {
      var ariaLabel = (isElement(current) && current.getAttribute("aria-label") || "").trim();
      if (ariaLabel !== "" && compute === "name") {
        consultedNodes.add(current);
        return ariaLabel;
      }
      if (!isMarkedPresentational(current)) {
        var elementTextAlternative = computeElementTextAlternative(current);
        if (elementTextAlternative !== null) {
          consultedNodes.add(current);
          return elementTextAlternative;
        }
      }
    }
    if (hasAnyConcreteRoles(current, ["menu"])) {
      consultedNodes.add(current);
      return "";
    }
    if (skipToStep2E || context.isEmbeddedInLabel || context.isReferenced) {
      if (hasAnyConcreteRoles(current, ["combobox", "listbox"])) {
        consultedNodes.add(current);
        var selectedOptions = querySelectedOptions(current);
        if (selectedOptions.length === 0) {
          return isHTMLInputElement(current) ? current.value : "";
        }
        return arrayFrom(selectedOptions).map(function(selectedOption) {
          return computeTextAlternative3(selectedOption, {
            isEmbeddedInLabel: context.isEmbeddedInLabel,
            isReferenced: false,
            recursion: true
          });
        }).join(" ");
      }
      if (hasAbstractRole(current, "range")) {
        consultedNodes.add(current);
        if (current.hasAttribute("aria-valuetext")) {
          return current.getAttribute("aria-valuetext");
        }
        if (current.hasAttribute("aria-valuenow")) {
          return current.getAttribute("aria-valuenow");
        }
        return current.getAttribute("value") || "";
      }
      if (hasAnyConcreteRoles(current, ["textbox"])) {
        consultedNodes.add(current);
        return getValueOfTextbox(current);
      }
    }
    if (allowsNameFromContent(current) || isElement(current) && context.isReferenced || isNativeHostLanguageTextAlternativeElement(current) || isDescendantOfNativeHostLanguageTextAlternativeElement(current)) {
      var accumulatedText2F = computeMiscTextAlternative(current, {
        isEmbeddedInLabel: context.isEmbeddedInLabel,
        isReferenced: false
      });
      if (accumulatedText2F !== "") {
        consultedNodes.add(current);
        return accumulatedText2F;
      }
    }
    if (current.nodeType === current.TEXT_NODE) {
      consultedNodes.add(current);
      return current.textContent || "";
    }
    if (context.recursion) {
      consultedNodes.add(current);
      return computeMiscTextAlternative(current, {
        isEmbeddedInLabel: context.isEmbeddedInLabel,
        isReferenced: false
      });
    }
    var tooltipAttributeValue = computeTooltipAttributeValue(current);
    if (tooltipAttributeValue !== null) {
      consultedNodes.add(current);
      return tooltipAttributeValue;
    }
    consultedNodes.add(current);
    return "";
  }
  __name(computeTextAlternative3, "computeTextAlternative");
  return asFlatString(computeTextAlternative3(root2, {
    isEmbeddedInLabel: false,
    // by spec computeAccessibleDescription starts with the referenced elements as roots
    isReferenced: compute === "description",
    recursion: false
  }));
}
__name(computeTextAlternative, "computeTextAlternative");

// ../node_modules/@testing-library/jest-dom/node_modules/dom-accessibility-api/dist/accessible-description.mjs
function _typeof2(o2) {
  "@babel/helpers - typeof";
  return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof2(o2);
}
__name(_typeof2, "_typeof");
function ownKeys(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e2);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
__name(ownKeys, "ownKeys");
function _objectSpread(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys(Object(t2), true).forEach(function(r3) {
      _defineProperty2(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
__name(_objectSpread, "_objectSpread");
function _defineProperty2(obj, key, value) {
  key = _toPropertyKey2(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
__name(_defineProperty2, "_defineProperty");
function _toPropertyKey2(arg) {
  var key = _toPrimitive2(arg, "string");
  return _typeof2(key) === "symbol" ? key : String(key);
}
__name(_toPropertyKey2, "_toPropertyKey");
function _toPrimitive2(input2, hint) {
  if (_typeof2(input2) !== "object" || input2 === null) return input2;
  var prim = input2[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input2, hint || "default");
    if (_typeof2(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input2);
}
__name(_toPrimitive2, "_toPrimitive");
function computeAccessibleDescription(root2) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var description = queryIdRefs(root2, "aria-describedby").map(function(element) {
    return computeTextAlternative(element, _objectSpread(_objectSpread({}, options), {}, {
      compute: "description"
    }));
  }).join(" ");
  if (description === "") {
    var ariaDescription = root2.getAttribute("aria-description");
    description = ariaDescription === null ? "" : ariaDescription;
  }
  if (description === "") {
    var title = root2.getAttribute("title");
    description = title === null ? "" : title;
  }
  return description;
}
__name(computeAccessibleDescription, "computeAccessibleDescription");

// ../node_modules/@testing-library/jest-dom/node_modules/dom-accessibility-api/dist/accessible-name.mjs
function prohibitsNaming(node) {
  return hasAnyConcreteRoles(node, ["caption", "code", "deletion", "emphasis", "generic", "insertion", "none", "paragraph", "presentation", "strong", "subscript", "superscript"]);
}
__name(prohibitsNaming, "prohibitsNaming");
function computeAccessibleName(root2) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (prohibitsNaming(root2)) {
    return "";
  }
  return computeTextAlternative(root2, options);
}
__name(computeAccessibleName, "computeAccessibleName");

// ../node_modules/@testing-library/jest-dom/dist/matchers-35e4d3bd.mjs
var import_aria_query = __toESM(require_lib(), 1);
var import_picocolors = __toESM(require_picocolors_browser(), 1);
var import_css = __toESM(require_css_escape(), 1);
var _GenericTypeError = class _GenericTypeError extends Error {
  constructor(expectedString, received, matcherFn, context) {
    super();
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, matcherFn);
    }
    let withType = "";
    try {
      withType = context.utils.printWithType(
        "Received",
        received,
        context.utils.printReceived
      );
    } catch (e2) {
    }
    this.message = [
      context.utils.matcherHint(
        `${context.isNot ? ".not" : ""}.${matcherFn.name}`,
        "received",
        ""
      ),
      "",
      // eslint-disable-next-line new-cap
      `${context.utils.RECEIVED_COLOR(
        "received"
      )} value must ${expectedString}.`,
      withType
    ].join("\n");
  }
};
__name(_GenericTypeError, "GenericTypeError");
var GenericTypeError = _GenericTypeError;
var _HtmlElementTypeError = class _HtmlElementTypeError extends GenericTypeError {
  constructor(...args) {
    super("be an HTMLElement or an SVGElement", ...args);
  }
};
__name(_HtmlElementTypeError, "HtmlElementTypeError");
var HtmlElementTypeError = _HtmlElementTypeError;
var _NodeTypeError = class _NodeTypeError extends GenericTypeError {
  constructor(...args) {
    super("be a Node", ...args);
  }
};
__name(_NodeTypeError, "NodeTypeError");
var NodeTypeError = _NodeTypeError;
function checkHasWindow(htmlElement, ErrorClass, ...args) {
  if (!htmlElement || !htmlElement.ownerDocument || !htmlElement.ownerDocument.defaultView) {
    throw new ErrorClass(htmlElement, ...args);
  }
}
__name(checkHasWindow, "checkHasWindow");
function checkNode(node, ...args) {
  checkHasWindow(node, NodeTypeError, ...args);
  const window2 = node.ownerDocument.defaultView;
  if (!(node instanceof window2.Node)) {
    throw new NodeTypeError(node, ...args);
  }
}
__name(checkNode, "checkNode");
function checkHtmlElement(htmlElement, ...args) {
  checkHasWindow(htmlElement, HtmlElementTypeError, ...args);
  const window2 = htmlElement.ownerDocument.defaultView;
  if (!(htmlElement instanceof window2.HTMLElement) && !(htmlElement instanceof window2.SVGElement)) {
    throw new HtmlElementTypeError(htmlElement, ...args);
  }
}
__name(checkHtmlElement, "checkHtmlElement");
var _InvalidCSSError = class _InvalidCSSError extends Error {
  constructor(received, matcherFn, context) {
    super();
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, matcherFn);
    }
    this.message = [
      received.message,
      "",
      // eslint-disable-next-line new-cap
      context.utils.RECEIVED_COLOR(`Failing css:`),
      // eslint-disable-next-line new-cap
      context.utils.RECEIVED_COLOR(`${received.css}`)
    ].join("\n");
  }
};
__name(_InvalidCSSError, "InvalidCSSError");
var InvalidCSSError = _InvalidCSSError;
function parseCSS(css, ...args) {
  const ast = m2(`selector { ${css} }`, { silent: true }).stylesheet;
  if (ast.parsingErrors && ast.parsingErrors.length > 0) {
    const { reason, line } = ast.parsingErrors[0];
    throw new InvalidCSSError(
      {
        css,
        message: `Syntax error parsing expected css: ${reason} on line: ${line}`
      },
      ...args
    );
  }
  const parsedRules = ast.rules[0].declarations.filter((d) => d.type === "declaration").reduce(
    (obj, { property, value }) => Object.assign(obj, { [property]: value }),
    {}
  );
  return parsedRules;
}
__name(parseCSS, "parseCSS");
function display(context, value) {
  return typeof value === "string" ? value : context.utils.stringify(value);
}
__name(display, "display");
function getMessage3(context, matcher, expectedLabel, expectedValue, receivedLabel, receivedValue) {
  return [
    `${matcher}
`,
    // eslint-disable-next-line new-cap
    `${expectedLabel}:
${context.utils.EXPECTED_COLOR(
      (0, import_redent.default)(display(context, expectedValue), 2)
    )}`,
    // eslint-disable-next-line new-cap
    `${receivedLabel}:
${context.utils.RECEIVED_COLOR(
      (0, import_redent.default)(display(context, receivedValue), 2)
    )}`
  ].join("\n");
}
__name(getMessage3, "getMessage");
function matches(textToMatch, matcher) {
  if (matcher instanceof RegExp) {
    return matcher.test(textToMatch);
  } else {
    return textToMatch.includes(String(matcher));
  }
}
__name(matches, "matches");
function deprecate2(name, replacementText) {
  console.warn(
    `Warning: ${name} has been deprecated and will be removed in future updates.`,
    replacementText
  );
}
__name(deprecate2, "deprecate");
function normalize(text) {
  return text.replace(/\s+/g, " ").trim();
}
__name(normalize, "normalize");
function getTag(element) {
  return element.tagName && element.tagName.toLowerCase();
}
__name(getTag, "getTag");
function getSelectValue({ multiple, options }) {
  const selectedOptions = [...options].filter((option) => option.selected);
  if (multiple) {
    return [...selectedOptions].map((opt) => opt.value);
  }
  if (selectedOptions.length === 0) {
    return void 0;
  }
  return selectedOptions[0].value;
}
__name(getSelectValue, "getSelectValue");
function getInputValue(inputElement) {
  switch (inputElement.type) {
    case "number":
      return inputElement.value === "" ? null : Number(inputElement.value);
    case "checkbox":
      return inputElement.checked;
    default:
      return inputElement.value;
  }
}
__name(getInputValue, "getInputValue");
var rolesSupportingValues = ["meter", "progressbar", "slider", "spinbutton"];
function getAccessibleValue(element) {
  if (!rolesSupportingValues.includes(element.getAttribute("role"))) {
    return void 0;
  }
  return Number(element.getAttribute("aria-valuenow"));
}
__name(getAccessibleValue, "getAccessibleValue");
function getSingleElementValue(element) {
  if (!element) {
    return void 0;
  }
  switch (element.tagName.toLowerCase()) {
    case "input":
      return getInputValue(element);
    case "select":
      return getSelectValue(element);
    default: {
      return element.value ?? getAccessibleValue(element);
    }
  }
}
__name(getSingleElementValue, "getSingleElementValue");
function toSentence(array, { wordConnector = ", ", lastWordConnector = " and " } = {}) {
  return [array.slice(0, -1).join(wordConnector), array[array.length - 1]].join(
    array.length > 1 ? lastWordConnector : ""
  );
}
__name(toSentence, "toSentence");
function compareAsSet(val1, val2) {
  if (Array.isArray(val1) && Array.isArray(val2)) {
    return [...new Set(val1)].every((v2) => new Set(val2).has(v2));
  }
  return val1 === val2;
}
__name(compareAsSet, "compareAsSet");
function toBeInTheDOM(element, container) {
  deprecate2(
    "toBeInTheDOM",
    "Please use toBeInTheDocument for searching the entire document and toContainElement for searching a specific container."
  );
  if (element) {
    checkHtmlElement(element, toBeInTheDOM, this);
  }
  if (container) {
    checkHtmlElement(container, toBeInTheDOM, this);
  }
  return {
    pass: container ? container.contains(element) : !!element,
    message: /* @__PURE__ */ __name(() => {
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBeInTheDOM`,
          "element",
          ""
        ),
        "",
        "Received:",
        `  ${this.utils.printReceived(
          element ? element.cloneNode(false) : element
        )}`
      ].join("\n");
    }, "message")
  };
}
__name(toBeInTheDOM, "toBeInTheDOM");
function toBeInTheDocument(element) {
  if (element !== null || !this.isNot) {
    checkHtmlElement(element, toBeInTheDocument, this);
  }
  const pass = element === null ? false : element.ownerDocument === element.getRootNode({ composed: true });
  const errorFound = /* @__PURE__ */ __name(() => {
    return `expected document not to contain element, found ${this.utils.stringify(
      element.cloneNode(true)
    )} instead`;
  }, "errorFound");
  const errorNotFound = /* @__PURE__ */ __name(() => {
    return `element could not be found in the document`;
  }, "errorNotFound");
  return {
    pass,
    message: /* @__PURE__ */ __name(() => {
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBeInTheDocument`,
          "element",
          ""
        ),
        "",
        // eslint-disable-next-line new-cap
        this.utils.RECEIVED_COLOR(this.isNot ? errorFound() : errorNotFound())
      ].join("\n");
    }, "message")
  };
}
__name(toBeInTheDocument, "toBeInTheDocument");
function toBeEmpty(element) {
  deprecate2(
    "toBeEmpty",
    "Please use instead toBeEmptyDOMElement for finding empty nodes in the DOM."
  );
  checkHtmlElement(element, toBeEmpty, this);
  return {
    pass: element.innerHTML === "",
    message: /* @__PURE__ */ __name(() => {
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBeEmpty`,
          "element",
          ""
        ),
        "",
        "Received:",
        `  ${this.utils.printReceived(element.innerHTML)}`
      ].join("\n");
    }, "message")
  };
}
__name(toBeEmpty, "toBeEmpty");
function toBeEmptyDOMElement(element) {
  checkHtmlElement(element, toBeEmptyDOMElement, this);
  return {
    pass: isEmptyElement(element),
    message: /* @__PURE__ */ __name(() => {
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBeEmptyDOMElement`,
          "element",
          ""
        ),
        "",
        "Received:",
        `  ${this.utils.printReceived(element.innerHTML)}`
      ].join("\n");
    }, "message")
  };
}
__name(toBeEmptyDOMElement, "toBeEmptyDOMElement");
function isEmptyElement(element) {
  const nonCommentChildNodes = [...element.childNodes].filter((node) => node.nodeType !== 8);
  return nonCommentChildNodes.length === 0;
}
__name(isEmptyElement, "isEmptyElement");
function toContainElement(container, element) {
  checkHtmlElement(container, toContainElement, this);
  if (element !== null) {
    checkHtmlElement(element, toContainElement, this);
  }
  return {
    pass: container.contains(element),
    message: /* @__PURE__ */ __name(() => {
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toContainElement`,
          "element",
          "element"
        ),
        "",
        // eslint-disable-next-line new-cap
        this.utils.RECEIVED_COLOR(`${this.utils.stringify(
          container.cloneNode(false)
        )} ${this.isNot ? "contains:" : "does not contain:"} ${this.utils.stringify(element ? element.cloneNode(false) : element)}
        `)
      ].join("\n");
    }, "message")
  };
}
__name(toContainElement, "toContainElement");
function getNormalizedHtml(container, htmlText) {
  const div = container.ownerDocument.createElement("div");
  div.innerHTML = htmlText;
  return div.innerHTML;
}
__name(getNormalizedHtml, "getNormalizedHtml");
function toContainHTML(container, htmlText) {
  checkHtmlElement(container, toContainHTML, this);
  if (typeof htmlText !== "string") {
    throw new Error(`.toContainHTML() expects a string value, got ${htmlText}`);
  }
  return {
    pass: container.outerHTML.includes(getNormalizedHtml(container, htmlText)),
    message: /* @__PURE__ */ __name(() => {
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toContainHTML`,
          "element",
          ""
        ),
        "Expected:",
        // eslint-disable-next-line new-cap
        `  ${this.utils.EXPECTED_COLOR(htmlText)}`,
        "Received:",
        `  ${this.utils.printReceived(container.cloneNode(true))}`
      ].join("\n");
    }, "message")
  };
}
__name(toContainHTML, "toContainHTML");
function toHaveTextContent(node, checkWith, options = { normalizeWhitespace: true }) {
  checkNode(node, toHaveTextContent, this);
  const textContent = options.normalizeWhitespace ? normalize(node.textContent) : node.textContent.replace(/\u00a0/g, " ");
  const checkingWithEmptyString = textContent !== "" && checkWith === "";
  return {
    pass: !checkingWithEmptyString && matches(textContent, checkWith),
    message: /* @__PURE__ */ __name(() => {
      const to = this.isNot ? "not to" : "to";
      return getMessage3(
        this,
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toHaveTextContent`,
          "element",
          ""
        ),
        checkingWithEmptyString ? `Checking with empty string will always match, use .toBeEmptyDOMElement() instead` : `Expected element ${to} have text content`,
        checkWith,
        "Received",
        textContent
      );
    }, "message")
  };
}
__name(toHaveTextContent, "toHaveTextContent");
function toHaveAccessibleDescription(htmlElement, expectedAccessibleDescription) {
  checkHtmlElement(htmlElement, toHaveAccessibleDescription, this);
  const actualAccessibleDescription = computeAccessibleDescription(htmlElement);
  const missingExpectedValue = arguments.length === 1;
  let pass = false;
  if (missingExpectedValue) {
    pass = actualAccessibleDescription !== "";
  } else {
    pass = expectedAccessibleDescription instanceof RegExp ? expectedAccessibleDescription.test(actualAccessibleDescription) : this.equals(
      actualAccessibleDescription,
      expectedAccessibleDescription
    );
  }
  return {
    pass,
    message: /* @__PURE__ */ __name(() => {
      const to = this.isNot ? "not to" : "to";
      return getMessage3(
        this,
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.${toHaveAccessibleDescription.name}`,
          "element",
          ""
        ),
        `Expected element ${to} have accessible description`,
        expectedAccessibleDescription,
        "Received",
        actualAccessibleDescription
      );
    }, "message")
  };
}
__name(toHaveAccessibleDescription, "toHaveAccessibleDescription");
var ariaInvalidName = "aria-invalid";
var validStates = ["false"];
function toHaveAccessibleErrorMessage(htmlElement, expectedAccessibleErrorMessage) {
  checkHtmlElement(htmlElement, toHaveAccessibleErrorMessage, this);
  const to = this.isNot ? "not to" : "to";
  const method = this.isNot ? ".not.toHaveAccessibleErrorMessage" : ".toHaveAccessibleErrorMessage";
  const errormessageId = htmlElement.getAttribute("aria-errormessage");
  const errormessageIdInvalid = !!errormessageId && /\s+/.test(errormessageId);
  if (errormessageIdInvalid) {
    return {
      pass: false,
      message: /* @__PURE__ */ __name(() => {
        return getMessage3(
          this,
          this.utils.matcherHint(method, "element"),
          "Expected element's `aria-errormessage` attribute to be empty or a single, valid ID",
          "",
          "Received",
          `aria-errormessage="${errormessageId}"`
        );
      }, "message")
    };
  }
  const ariaInvalidVal = htmlElement.getAttribute(ariaInvalidName);
  const fieldValid = !htmlElement.hasAttribute(ariaInvalidName) || validStates.includes(ariaInvalidVal);
  if (fieldValid) {
    return {
      pass: false,
      message: /* @__PURE__ */ __name(() => {
        return getMessage3(
          this,
          this.utils.matcherHint(method, "element"),
          "Expected element to be marked as invalid with attribute",
          `${ariaInvalidName}="${String(true)}"`,
          "Received",
          htmlElement.hasAttribute("aria-invalid") ? `${ariaInvalidName}="${htmlElement.getAttribute(ariaInvalidName)}` : null
        );
      }, "message")
    };
  }
  const error = normalize(
    htmlElement.ownerDocument.getElementById(errormessageId)?.textContent ?? ""
  );
  return {
    pass: expectedAccessibleErrorMessage === void 0 ? Boolean(error) : expectedAccessibleErrorMessage instanceof RegExp ? expectedAccessibleErrorMessage.test(error) : this.equals(error, expectedAccessibleErrorMessage),
    message: /* @__PURE__ */ __name(() => {
      return getMessage3(
        this,
        this.utils.matcherHint(method, "element"),
        `Expected element ${to} have accessible error message`,
        expectedAccessibleErrorMessage ?? "",
        "Received",
        error
      );
    }, "message")
  };
}
__name(toHaveAccessibleErrorMessage, "toHaveAccessibleErrorMessage");
var elementRoleList = buildElementRoleList(import_aria_query.elementRoles);
function toHaveRole(htmlElement, expectedRole) {
  checkHtmlElement(htmlElement, toHaveRole, this);
  const actualRoles = getExplicitOrImplicitRoles(htmlElement);
  const pass = actualRoles.some((el) => el === expectedRole);
  return {
    pass,
    message: /* @__PURE__ */ __name(() => {
      const to = this.isNot ? "not to" : "to";
      return getMessage3(
        this,
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.${toHaveRole.name}`,
          "element",
          ""
        ),
        `Expected element ${to} have role`,
        expectedRole,
        "Received",
        actualRoles.join(", ")
      );
    }, "message")
  };
}
__name(toHaveRole, "toHaveRole");
function getExplicitOrImplicitRoles(htmlElement) {
  const hasExplicitRole = htmlElement.hasAttribute("role");
  if (hasExplicitRole) {
    const roleValue = htmlElement.getAttribute("role");
    return roleValue.split(" ").filter(Boolean);
  }
  const implicitRoles = getImplicitAriaRoles(htmlElement);
  return implicitRoles;
}
__name(getExplicitOrImplicitRoles, "getExplicitOrImplicitRoles");
function getImplicitAriaRoles(currentNode) {
  for (const { match, roles: roles3 } of elementRoleList) {
    if (match(currentNode)) {
      return [...roles3];
    }
  }
  return [];
}
__name(getImplicitAriaRoles, "getImplicitAriaRoles");
function buildElementRoleList(elementRolesMap) {
  function makeElementSelector({ name, attributes }) {
    return `${name}${attributes.map(({ name: attributeName, value, constraints = [] }) => {
      const shouldNotExist = constraints.indexOf("undefined") !== -1;
      if (shouldNotExist) {
        return `:not([${attributeName}])`;
      } else if (value) {
        return `[${attributeName}="${value}"]`;
      } else {
        return `[${attributeName}]`;
      }
    }).join("")}`;
  }
  __name(makeElementSelector, "makeElementSelector");
  function getSelectorSpecificity({ attributes = [] }) {
    return attributes.length;
  }
  __name(getSelectorSpecificity, "getSelectorSpecificity");
  function bySelectorSpecificity({ specificity: leftSpecificity }, { specificity: rightSpecificity }) {
    return rightSpecificity - leftSpecificity;
  }
  __name(bySelectorSpecificity, "bySelectorSpecificity");
  function match(element) {
    let { attributes = [] } = element;
    const typeTextIndex = attributes.findIndex(
      (attribute) => attribute.value && attribute.name === "type" && attribute.value === "text"
    );
    if (typeTextIndex >= 0) {
      attributes = [
        ...attributes.slice(0, typeTextIndex),
        ...attributes.slice(typeTextIndex + 1)
      ];
    }
    const selector = makeElementSelector({ ...element, attributes });
    return (node) => {
      if (typeTextIndex >= 0 && node.type !== "text") {
        return false;
      }
      return node.matches(selector);
    };
  }
  __name(match, "match");
  let result = [];
  for (const [element, roles3] of elementRolesMap.entries()) {
    result = [
      ...result,
      {
        match: match(element),
        roles: Array.from(roles3),
        specificity: getSelectorSpecificity(element)
      }
    ];
  }
  return result.sort(bySelectorSpecificity);
}
__name(buildElementRoleList, "buildElementRoleList");
function toHaveAccessibleName(htmlElement, expectedAccessibleName) {
  checkHtmlElement(htmlElement, toHaveAccessibleName, this);
  const actualAccessibleName = computeAccessibleName(htmlElement);
  const missingExpectedValue = arguments.length === 1;
  let pass = false;
  if (missingExpectedValue) {
    pass = actualAccessibleName !== "";
  } else {
    pass = expectedAccessibleName instanceof RegExp ? expectedAccessibleName.test(actualAccessibleName) : this.equals(actualAccessibleName, expectedAccessibleName);
  }
  return {
    pass,
    message: /* @__PURE__ */ __name(() => {
      const to = this.isNot ? "not to" : "to";
      return getMessage3(
        this,
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.${toHaveAccessibleName.name}`,
          "element",
          ""
        ),
        `Expected element ${to} have accessible name`,
        expectedAccessibleName,
        "Received",
        actualAccessibleName
      );
    }, "message")
  };
}
__name(toHaveAccessibleName, "toHaveAccessibleName");
function printAttribute(stringify5, name, value) {
  return value === void 0 ? name : `${name}=${stringify5(value)}`;
}
__name(printAttribute, "printAttribute");
function getAttributeComment(stringify5, name, value) {
  return value === void 0 ? `element.hasAttribute(${stringify5(name)})` : `element.getAttribute(${stringify5(name)}) === ${stringify5(value)}`;
}
__name(getAttributeComment, "getAttributeComment");
function toHaveAttribute(htmlElement, name, expectedValue) {
  checkHtmlElement(htmlElement, toHaveAttribute, this);
  const isExpectedValuePresent = expectedValue !== void 0;
  const hasAttribute = htmlElement.hasAttribute(name);
  const receivedValue = htmlElement.getAttribute(name);
  return {
    pass: isExpectedValuePresent ? hasAttribute && this.equals(receivedValue, expectedValue) : hasAttribute,
    message: /* @__PURE__ */ __name(() => {
      const to = this.isNot ? "not to" : "to";
      const receivedAttribute = hasAttribute ? printAttribute(this.utils.stringify, name, receivedValue) : null;
      const matcher = this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toHaveAttribute`,
        "element",
        this.utils.printExpected(name),
        {
          secondArgument: isExpectedValuePresent ? this.utils.printExpected(expectedValue) : void 0,
          comment: getAttributeComment(
            this.utils.stringify,
            name,
            expectedValue
          )
        }
      );
      return getMessage3(
        this,
        matcher,
        `Expected the element ${to} have attribute`,
        printAttribute(this.utils.stringify, name, expectedValue),
        "Received",
        receivedAttribute
      );
    }, "message")
  };
}
__name(toHaveAttribute, "toHaveAttribute");
function getExpectedClassNamesAndOptions(params) {
  const lastParam = params.pop();
  let expectedClassNames, options;
  if (typeof lastParam === "object" && !(lastParam instanceof RegExp)) {
    expectedClassNames = params;
    options = lastParam;
  } else {
    expectedClassNames = params.concat(lastParam);
    options = { exact: false };
  }
  return { expectedClassNames, options };
}
__name(getExpectedClassNamesAndOptions, "getExpectedClassNamesAndOptions");
function splitClassNames(str2) {
  if (!str2) return [];
  return str2.split(/\s+/).filter((s3) => s3.length > 0);
}
__name(splitClassNames, "splitClassNames");
function isSubset$1(subset, superset) {
  return subset.every(
    (strOrRegexp) => typeof strOrRegexp === "string" ? superset.includes(strOrRegexp) : superset.some((className) => strOrRegexp.test(className))
  );
}
__name(isSubset$1, "isSubset$1");
function toHaveClass(htmlElement, ...params) {
  checkHtmlElement(htmlElement, toHaveClass, this);
  const { expectedClassNames, options } = getExpectedClassNamesAndOptions(params);
  const received = splitClassNames(htmlElement.getAttribute("class"));
  const expected = expectedClassNames.reduce(
    (acc, className) => acc.concat(
      typeof className === "string" || !className ? splitClassNames(className) : className
    ),
    []
  );
  const hasRegExp = expected.some((className) => className instanceof RegExp);
  if (options.exact && hasRegExp) {
    throw new Error("Exact option does not support RegExp expected class names");
  }
  if (options.exact) {
    return {
      pass: isSubset$1(expected, received) && expected.length === received.length,
      message: /* @__PURE__ */ __name(() => {
        const to = this.isNot ? "not to" : "to";
        return getMessage3(
          this,
          this.utils.matcherHint(
            `${this.isNot ? ".not" : ""}.toHaveClass`,
            "element",
            this.utils.printExpected(expected.join(" "))
          ),
          `Expected the element ${to} have EXACTLY defined classes`,
          expected.join(" "),
          "Received",
          received.join(" ")
        );
      }, "message")
    };
  }
  return expected.length > 0 ? {
    pass: isSubset$1(expected, received),
    message: /* @__PURE__ */ __name(() => {
      const to = this.isNot ? "not to" : "to";
      return getMessage3(
        this,
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toHaveClass`,
          "element",
          this.utils.printExpected(expected.join(" "))
        ),
        `Expected the element ${to} have class`,
        expected.join(" "),
        "Received",
        received.join(" ")
      );
    }, "message")
  } : {
    pass: this.isNot ? received.length > 0 : false,
    message: /* @__PURE__ */ __name(() => this.isNot ? getMessage3(
      this,
      this.utils.matcherHint(".not.toHaveClass", "element", ""),
      "Expected the element to have classes",
      "(none)",
      "Received",
      received.join(" ")
    ) : [
      this.utils.matcherHint(`.toHaveClass`, "element"),
      "At least one expected class must be provided."
    ].join("\n"), "message")
  };
}
__name(toHaveClass, "toHaveClass");
function getStyleDeclaration(document7, css) {
  const styles3 = {};
  const copy3 = document7.createElement("div");
  Object.keys(css).forEach((property) => {
    copy3.style[property] = css[property];
    styles3[property] = copy3.style[property];
  });
  return styles3;
}
__name(getStyleDeclaration, "getStyleDeclaration");
function isSubset(styles3, computedStyle) {
  return !!Object.keys(styles3).length && Object.entries(styles3).every(([prop, value]) => {
    const isCustomProperty = prop.startsWith("--");
    const spellingVariants = [prop];
    if (!isCustomProperty) spellingVariants.push(prop.toLowerCase());
    return spellingVariants.some(
      (name) => computedStyle[name] === value || computedStyle.getPropertyValue(name) === value
    );
  });
}
__name(isSubset, "isSubset");
function printoutStyles(styles3) {
  return Object.keys(styles3).sort().map((prop) => `${prop}: ${styles3[prop]};`).join("\n");
}
__name(printoutStyles, "printoutStyles");
function expectedDiff(diffFn, expected, computedStyles) {
  const received = Array.from(computedStyles).filter((prop) => expected[prop] !== void 0).reduce(
    (obj, prop) => Object.assign(obj, { [prop]: computedStyles.getPropertyValue(prop) }),
    {}
  );
  const diffOutput = diffFn(printoutStyles(expected), printoutStyles(received));
  return diffOutput.replace(`${import_picocolors.default.red("+ Received")}
`, "");
}
__name(expectedDiff, "expectedDiff");
function toHaveStyle(htmlElement, css) {
  checkHtmlElement(htmlElement, toHaveStyle, this);
  const parsedCSS = typeof css === "object" ? css : parseCSS(css, toHaveStyle, this);
  const { getComputedStyle: getComputedStyle2 } = htmlElement.ownerDocument.defaultView;
  const expected = getStyleDeclaration(htmlElement.ownerDocument, parsedCSS);
  const received = getComputedStyle2(htmlElement);
  return {
    pass: isSubset(expected, received),
    message: /* @__PURE__ */ __name(() => {
      const matcher = `${this.isNot ? ".not" : ""}.toHaveStyle`;
      return [
        this.utils.matcherHint(matcher, "element", ""),
        expectedDiff(this.utils.diff, expected, received)
      ].join("\n\n");
    }, "message")
  };
}
__name(toHaveStyle, "toHaveStyle");
function toHaveFocus(element) {
  checkHtmlElement(element, toHaveFocus, this);
  return {
    pass: element.ownerDocument.activeElement === element,
    message: /* @__PURE__ */ __name(() => {
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toHaveFocus`,
          "element",
          ""
        ),
        "",
        ...this.isNot ? [
          "Received element is focused:",
          `  ${this.utils.printReceived(element)}`
        ] : [
          "Expected element with focus:",
          `  ${this.utils.printExpected(element)}`,
          "Received element with focus:",
          `  ${this.utils.printReceived(
            element.ownerDocument.activeElement
          )}`
        ]
      ].join("\n");
    }, "message")
  };
}
__name(toHaveFocus, "toHaveFocus");
function getMultiElementValue(elements) {
  const types = [...new Set(elements.map((element) => element.type))];
  if (types.length !== 1) {
    throw new Error(
      "Multiple form elements with the same name must be of the same type"
    );
  }
  switch (types[0]) {
    case "radio": {
      const theChosenOne = elements.find((radio) => radio.checked);
      return theChosenOne ? theChosenOne.value : void 0;
    }
    case "checkbox":
      return elements.filter((checkbox) => checkbox.checked).map((checkbox) => checkbox.value);
    default:
      return elements.map((element) => element.value);
  }
}
__name(getMultiElementValue, "getMultiElementValue");
function getFormValue(container, name) {
  const elements = [...container.querySelectorAll(`[name="${(0, import_css.default)(name)}"]`)];
  if (elements.length === 0) {
    return void 0;
  }
  switch (elements.length) {
    case 1:
      return getSingleElementValue(elements[0]);
    default:
      return getMultiElementValue(elements);
  }
}
__name(getFormValue, "getFormValue");
function getPureName(name) {
  return /\[\]$/.test(name) ? name.slice(0, -2) : name;
}
__name(getPureName, "getPureName");
function getAllFormValues(container) {
  const names = Array.from(container.elements).map((element) => element.name);
  return names.reduce(
    (obj, name) => ({
      ...obj,
      [getPureName(name)]: getFormValue(container, name)
    }),
    {}
  );
}
__name(getAllFormValues, "getAllFormValues");
function toHaveFormValues(formElement, expectedValues) {
  checkHtmlElement(formElement, toHaveFormValues, this);
  if (!formElement.elements) {
    throw new Error("toHaveFormValues must be called on a form or a fieldset");
  }
  const formValues = getAllFormValues(formElement);
  return {
    pass: Object.entries(expectedValues).every(
      ([name, expectedValue]) => compareAsSet(formValues[name], expectedValue)
    ),
    message: /* @__PURE__ */ __name(() => {
      const to = this.isNot ? "not to" : "to";
      const matcher = `${this.isNot ? ".not" : ""}.toHaveFormValues`;
      const commonKeyValues = Object.keys(formValues).filter((key) => expectedValues.hasOwnProperty(key)).reduce((obj, key) => ({ ...obj, [key]: formValues[key] }), {});
      return [
        this.utils.matcherHint(matcher, "element", ""),
        `Expected the element ${to} have form values`,
        this.utils.diff(expectedValues, commonKeyValues)
      ].join("\n\n");
    }, "message")
  };
}
__name(toHaveFormValues, "toHaveFormValues");
function isStyleVisible(element) {
  const { getComputedStyle: getComputedStyle2 } = element.ownerDocument.defaultView;
  const { display: display2, visibility, opacity } = getComputedStyle2(element);
  return display2 !== "none" && visibility !== "hidden" && visibility !== "collapse" && opacity !== "0" && opacity !== 0;
}
__name(isStyleVisible, "isStyleVisible");
function isAttributeVisible(element, previousElement) {
  let detailsVisibility;
  if (previousElement) {
    detailsVisibility = element.nodeName === "DETAILS" && previousElement.nodeName !== "SUMMARY" ? element.hasAttribute("open") : true;
  } else {
    detailsVisibility = element.nodeName === "DETAILS" ? element.hasAttribute("open") : true;
  }
  return !element.hasAttribute("hidden") && detailsVisibility;
}
__name(isAttributeVisible, "isAttributeVisible");
function isElementVisible(element, previousElement) {
  return isStyleVisible(element) && isAttributeVisible(element, previousElement) && (!element.parentElement || isElementVisible(element.parentElement, element));
}
__name(isElementVisible, "isElementVisible");
function toBeVisible(element) {
  checkHtmlElement(element, toBeVisible, this);
  const isInDocument = element.ownerDocument === element.getRootNode({ composed: true });
  const isVisible2 = isInDocument && isElementVisible(element);
  return {
    pass: isVisible2,
    message: /* @__PURE__ */ __name(() => {
      const is = isVisible2 ? "is" : "is not";
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBeVisible`,
          "element",
          ""
        ),
        "",
        `Received element ${is} visible${isInDocument ? "" : " (element is not in the document)"}:`,
        `  ${this.utils.printReceived(element.cloneNode(false))}`
      ].join("\n");
    }, "message")
  };
}
__name(toBeVisible, "toBeVisible");
var FORM_TAGS$2 = [
  "fieldset",
  "input",
  "select",
  "optgroup",
  "option",
  "button",
  "textarea"
];
function isFirstLegendChildOfFieldset(element, parent) {
  return getTag(element) === "legend" && getTag(parent) === "fieldset" && element.isSameNode(
    Array.from(parent.children).find((child) => getTag(child) === "legend")
  );
}
__name(isFirstLegendChildOfFieldset, "isFirstLegendChildOfFieldset");
function isElementDisabledByParent(element, parent) {
  return isElementDisabled(parent) && !isFirstLegendChildOfFieldset(element, parent);
}
__name(isElementDisabledByParent, "isElementDisabledByParent");
function isCustomElement(tag) {
  return tag.includes("-");
}
__name(isCustomElement, "isCustomElement");
function canElementBeDisabled(element) {
  const tag = getTag(element);
  return FORM_TAGS$2.includes(tag) || isCustomElement(tag);
}
__name(canElementBeDisabled, "canElementBeDisabled");
function isElementDisabled(element) {
  return canElementBeDisabled(element) && element.hasAttribute("disabled");
}
__name(isElementDisabled, "isElementDisabled");
function isAncestorDisabled(element) {
  const parent = element.parentElement;
  return Boolean(parent) && (isElementDisabledByParent(element, parent) || isAncestorDisabled(parent));
}
__name(isAncestorDisabled, "isAncestorDisabled");
function isElementOrAncestorDisabled(element) {
  return canElementBeDisabled(element) && (isElementDisabled(element) || isAncestorDisabled(element));
}
__name(isElementOrAncestorDisabled, "isElementOrAncestorDisabled");
function toBeDisabled(element) {
  checkHtmlElement(element, toBeDisabled, this);
  const isDisabled3 = isElementOrAncestorDisabled(element);
  return {
    pass: isDisabled3,
    message: /* @__PURE__ */ __name(() => {
      const is = isDisabled3 ? "is" : "is not";
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBeDisabled`,
          "element",
          ""
        ),
        "",
        `Received element ${is} disabled:`,
        `  ${this.utils.printReceived(element.cloneNode(false))}`
      ].join("\n");
    }, "message")
  };
}
__name(toBeDisabled, "toBeDisabled");
function toBeEnabled(element) {
  checkHtmlElement(element, toBeEnabled, this);
  const isEnabled = !isElementOrAncestorDisabled(element);
  return {
    pass: isEnabled,
    message: /* @__PURE__ */ __name(() => {
      const is = isEnabled ? "is" : "is not";
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBeEnabled`,
          "element",
          ""
        ),
        "",
        `Received element ${is} enabled:`,
        `  ${this.utils.printReceived(element.cloneNode(false))}`
      ].join("\n");
    }, "message")
  };
}
__name(toBeEnabled, "toBeEnabled");
var FORM_TAGS$1 = ["select", "textarea"];
var ARIA_FORM_TAGS = ["input", "select", "textarea"];
var UNSUPPORTED_INPUT_TYPES = [
  "color",
  "hidden",
  "range",
  "submit",
  "image",
  "reset"
];
var SUPPORTED_ARIA_ROLES = [
  "checkbox",
  "combobox",
  "gridcell",
  "listbox",
  "radiogroup",
  "spinbutton",
  "textbox",
  "tree"
];
function isRequiredOnFormTagsExceptInput(element) {
  return FORM_TAGS$1.includes(getTag(element)) && element.hasAttribute("required");
}
__name(isRequiredOnFormTagsExceptInput, "isRequiredOnFormTagsExceptInput");
function isRequiredOnSupportedInput(element) {
  return getTag(element) === "input" && element.hasAttribute("required") && (element.hasAttribute("type") && !UNSUPPORTED_INPUT_TYPES.includes(element.getAttribute("type")) || !element.hasAttribute("type"));
}
__name(isRequiredOnSupportedInput, "isRequiredOnSupportedInput");
function isElementRequiredByARIA(element) {
  return element.hasAttribute("aria-required") && element.getAttribute("aria-required") === "true" && (ARIA_FORM_TAGS.includes(getTag(element)) || element.hasAttribute("role") && SUPPORTED_ARIA_ROLES.includes(element.getAttribute("role")));
}
__name(isElementRequiredByARIA, "isElementRequiredByARIA");
function toBeRequired(element) {
  checkHtmlElement(element, toBeRequired, this);
  const isRequired = isRequiredOnFormTagsExceptInput(element) || isRequiredOnSupportedInput(element) || isElementRequiredByARIA(element);
  return {
    pass: isRequired,
    message: /* @__PURE__ */ __name(() => {
      const is = isRequired ? "is" : "is not";
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBeRequired`,
          "element",
          ""
        ),
        "",
        `Received element ${is} required:`,
        `  ${this.utils.printReceived(element.cloneNode(false))}`
      ].join("\n");
    }, "message")
  };
}
__name(toBeRequired, "toBeRequired");
var FORM_TAGS = ["form", "input", "select", "textarea"];
function isElementHavingAriaInvalid(element) {
  return element.hasAttribute("aria-invalid") && element.getAttribute("aria-invalid") !== "false";
}
__name(isElementHavingAriaInvalid, "isElementHavingAriaInvalid");
function isSupportsValidityMethod(element) {
  return FORM_TAGS.includes(getTag(element));
}
__name(isSupportsValidityMethod, "isSupportsValidityMethod");
function isElementInvalid(element) {
  const isHaveAriaInvalid = isElementHavingAriaInvalid(element);
  if (isSupportsValidityMethod(element)) {
    return isHaveAriaInvalid || !element.checkValidity();
  } else {
    return isHaveAriaInvalid;
  }
}
__name(isElementInvalid, "isElementInvalid");
function toBeInvalid(element) {
  checkHtmlElement(element, toBeInvalid, this);
  const isInvalid = isElementInvalid(element);
  return {
    pass: isInvalid,
    message: /* @__PURE__ */ __name(() => {
      const is = isInvalid ? "is" : "is not";
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBeInvalid`,
          "element",
          ""
        ),
        "",
        `Received element ${is} currently invalid:`,
        `  ${this.utils.printReceived(element.cloneNode(false))}`
      ].join("\n");
    }, "message")
  };
}
__name(toBeInvalid, "toBeInvalid");
function toBeValid(element) {
  checkHtmlElement(element, toBeValid, this);
  const isValid = !isElementInvalid(element);
  return {
    pass: isValid,
    message: /* @__PURE__ */ __name(() => {
      const is = isValid ? "is" : "is not";
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBeValid`,
          "element",
          ""
        ),
        "",
        `Received element ${is} currently valid:`,
        `  ${this.utils.printReceived(element.cloneNode(false))}`
      ].join("\n");
    }, "message")
  };
}
__name(toBeValid, "toBeValid");
function toHaveValue(htmlElement, expectedValue) {
  checkHtmlElement(htmlElement, toHaveValue, this);
  if (htmlElement.tagName.toLowerCase() === "input" && ["checkbox", "radio"].includes(htmlElement.type)) {
    throw new Error(
      "input with type=checkbox or type=radio cannot be used with .toHaveValue(). Use .toBeChecked() for type=checkbox or .toHaveFormValues() instead"
    );
  }
  const receivedValue = getSingleElementValue(htmlElement);
  const expectsValue = expectedValue !== void 0;
  let expectedTypedValue = expectedValue;
  let receivedTypedValue = receivedValue;
  if (expectedValue == receivedValue && expectedValue !== receivedValue) {
    expectedTypedValue = `${expectedValue} (${typeof expectedValue})`;
    receivedTypedValue = `${receivedValue} (${typeof receivedValue})`;
  }
  return {
    pass: expectsValue ? compareAsSet(receivedValue, expectedValue) : Boolean(receivedValue),
    message: /* @__PURE__ */ __name(() => {
      const to = this.isNot ? "not to" : "to";
      const matcher = this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toHaveValue`,
        "element",
        expectedValue
      );
      return getMessage3(
        this,
        matcher,
        `Expected the element ${to} have value`,
        expectsValue ? expectedTypedValue : "(any)",
        "Received",
        receivedTypedValue
      );
    }, "message")
  };
}
__name(toHaveValue, "toHaveValue");
function toHaveDisplayValue(htmlElement, expectedValue) {
  checkHtmlElement(htmlElement, toHaveDisplayValue, this);
  const tagName = htmlElement.tagName.toLowerCase();
  if (!["select", "input", "textarea"].includes(tagName)) {
    throw new Error(
      ".toHaveDisplayValue() currently supports only input, textarea or select elements, try with another matcher instead."
    );
  }
  if (tagName === "input" && ["radio", "checkbox"].includes(htmlElement.type)) {
    throw new Error(
      `.toHaveDisplayValue() currently does not support input[type="${htmlElement.type}"], try with another matcher instead.`
    );
  }
  const values = getValues(tagName, htmlElement);
  const expectedValues = getExpectedValues(expectedValue);
  const numberOfMatchesWithValues = expectedValues.filter(
    (expected) => values.some(
      (value) => expected instanceof RegExp ? expected.test(value) : this.equals(value, String(expected))
    )
  ).length;
  const matchedWithAllValues = numberOfMatchesWithValues === values.length;
  const matchedWithAllExpectedValues = numberOfMatchesWithValues === expectedValues.length;
  return {
    pass: matchedWithAllValues && matchedWithAllExpectedValues,
    message: /* @__PURE__ */ __name(() => getMessage3(
      this,
      this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toHaveDisplayValue`,
        "element",
        ""
      ),
      `Expected element ${this.isNot ? "not " : ""}to have display value`,
      expectedValue,
      "Received",
      values
    ), "message")
  };
}
__name(toHaveDisplayValue, "toHaveDisplayValue");
function getValues(tagName, htmlElement) {
  return tagName === "select" ? Array.from(htmlElement).filter((option) => option.selected).map((option) => option.textContent) : [htmlElement.value];
}
__name(getValues, "getValues");
function getExpectedValues(expectedValue) {
  return expectedValue instanceof Array ? expectedValue : [expectedValue];
}
__name(getExpectedValues, "getExpectedValues");
function toBeChecked(element) {
  checkHtmlElement(element, toBeChecked, this);
  const isValidInput = /* @__PURE__ */ __name(() => {
    return element.tagName.toLowerCase() === "input" && ["checkbox", "radio"].includes(element.type);
  }, "isValidInput");
  const isValidAriaElement = /* @__PURE__ */ __name(() => {
    return roleSupportsChecked(element.getAttribute("role")) && ["true", "false"].includes(element.getAttribute("aria-checked"));
  }, "isValidAriaElement");
  if (!isValidInput() && !isValidAriaElement()) {
    return {
      pass: false,
      message: /* @__PURE__ */ __name(() => `only inputs with type="checkbox" or type="radio" or elements with ${supportedRolesSentence()} and a valid aria-checked attribute can be used with .toBeChecked(). Use .toHaveValue() instead`, "message")
    };
  }
  const isChecked = /* @__PURE__ */ __name(() => {
    if (isValidInput()) return element.checked;
    return element.getAttribute("aria-checked") === "true";
  }, "isChecked");
  return {
    pass: isChecked(),
    message: /* @__PURE__ */ __name(() => {
      const is = isChecked() ? "is" : "is not";
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBeChecked`,
          "element",
          ""
        ),
        "",
        `Received element ${is} checked:`,
        `  ${this.utils.printReceived(element.cloneNode(false))}`
      ].join("\n");
    }, "message")
  };
}
__name(toBeChecked, "toBeChecked");
function supportedRolesSentence() {
  return toSentence(
    supportedRoles().map((role) => `role="${role}"`),
    { lastWordConnector: " or " }
  );
}
__name(supportedRolesSentence, "supportedRolesSentence");
function supportedRoles() {
  return import_aria_query.roles.keys().filter(roleSupportsChecked);
}
__name(supportedRoles, "supportedRoles");
function roleSupportsChecked(role) {
  return import_aria_query.roles.get(role)?.props["aria-checked"] !== void 0;
}
__name(roleSupportsChecked, "roleSupportsChecked");
function toBePartiallyChecked(element) {
  checkHtmlElement(element, toBePartiallyChecked, this);
  const isValidInput = /* @__PURE__ */ __name(() => {
    return element.tagName.toLowerCase() === "input" && element.type === "checkbox";
  }, "isValidInput");
  const isValidAriaElement = /* @__PURE__ */ __name(() => {
    return element.getAttribute("role") === "checkbox";
  }, "isValidAriaElement");
  if (!isValidInput() && !isValidAriaElement()) {
    return {
      pass: false,
      message: /* @__PURE__ */ __name(() => 'only inputs with type="checkbox" or elements with role="checkbox" and a valid aria-checked attribute can be used with .toBePartiallyChecked(). Use .toHaveValue() instead', "message")
    };
  }
  const isPartiallyChecked = /* @__PURE__ */ __name(() => {
    const isAriaMixed = element.getAttribute("aria-checked") === "mixed";
    if (isValidInput()) {
      return element.indeterminate || isAriaMixed;
    }
    return isAriaMixed;
  }, "isPartiallyChecked");
  return {
    pass: isPartiallyChecked(),
    message: /* @__PURE__ */ __name(() => {
      const is = isPartiallyChecked() ? "is" : "is not";
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBePartiallyChecked`,
          "element",
          ""
        ),
        "",
        `Received element ${is} partially checked:`,
        `  ${this.utils.printReceived(element.cloneNode(false))}`
      ].join("\n");
    }, "message")
  };
}
__name(toBePartiallyChecked, "toBePartiallyChecked");
function toHaveDescription(htmlElement, checkWith) {
  deprecate2(
    "toHaveDescription",
    "Please use toHaveAccessibleDescription."
  );
  checkHtmlElement(htmlElement, toHaveDescription, this);
  const expectsDescription = checkWith !== void 0;
  const descriptionIDRaw = htmlElement.getAttribute("aria-describedby") || "";
  const descriptionIDs = descriptionIDRaw.split(/\s+/).filter(Boolean);
  let description = "";
  if (descriptionIDs.length > 0) {
    const document7 = htmlElement.ownerDocument;
    const descriptionEls = descriptionIDs.map((descriptionID) => document7.getElementById(descriptionID)).filter(Boolean);
    description = normalize(descriptionEls.map((el) => el.textContent).join(" "));
  }
  return {
    pass: expectsDescription ? checkWith instanceof RegExp ? checkWith.test(description) : this.equals(description, checkWith) : Boolean(description),
    message: /* @__PURE__ */ __name(() => {
      const to = this.isNot ? "not to" : "to";
      return getMessage3(
        this,
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toHaveDescription`,
          "element",
          ""
        ),
        `Expected the element ${to} have description`,
        this.utils.printExpected(checkWith),
        "Received",
        this.utils.printReceived(description)
      );
    }, "message")
  };
}
__name(toHaveDescription, "toHaveDescription");
function toHaveErrorMessage(htmlElement, checkWith) {
  deprecate2("toHaveErrorMessage", "Please use toHaveAccessibleErrorMessage.");
  checkHtmlElement(htmlElement, toHaveErrorMessage, this);
  if (!htmlElement.hasAttribute("aria-invalid") || htmlElement.getAttribute("aria-invalid") === "false") {
    const not = this.isNot ? ".not" : "";
    return {
      pass: false,
      message: /* @__PURE__ */ __name(() => {
        return getMessage3(
          this,
          this.utils.matcherHint(`${not}.toHaveErrorMessage`, "element", ""),
          `Expected the element to have invalid state indicated by`,
          'aria-invalid="true"',
          "Received",
          htmlElement.hasAttribute("aria-invalid") ? `aria-invalid="${htmlElement.getAttribute("aria-invalid")}"` : this.utils.printReceived("")
        );
      }, "message")
    };
  }
  const expectsErrorMessage = checkWith !== void 0;
  const errormessageIDRaw = htmlElement.getAttribute("aria-errormessage") || "";
  const errormessageIDs = errormessageIDRaw.split(/\s+/).filter(Boolean);
  let errormessage = "";
  if (errormessageIDs.length > 0) {
    const document7 = htmlElement.ownerDocument;
    const errormessageEls = errormessageIDs.map((errormessageID) => document7.getElementById(errormessageID)).filter(Boolean);
    errormessage = normalize(
      errormessageEls.map((el) => el.textContent).join(" ")
    );
  }
  return {
    pass: expectsErrorMessage ? checkWith instanceof RegExp ? checkWith.test(errormessage) : this.equals(errormessage, checkWith) : Boolean(errormessage),
    message: /* @__PURE__ */ __name(() => {
      const to = this.isNot ? "not to" : "to";
      return getMessage3(
        this,
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toHaveErrorMessage`,
          "element",
          ""
        ),
        `Expected the element ${to} have error message`,
        this.utils.printExpected(checkWith),
        "Received",
        this.utils.printReceived(errormessage)
      );
    }, "message")
  };
}
__name(toHaveErrorMessage, "toHaveErrorMessage");
function getSelection(element) {
  const selection = element.ownerDocument.getSelection();
  if (["input", "textarea"].includes(element.tagName.toLowerCase())) {
    if (["radio", "checkbox"].includes(element.type)) return "";
    return element.value.toString().substring(element.selectionStart, element.selectionEnd);
  }
  if (selection.anchorNode === null || selection.focusNode === null) {
    return "";
  }
  const originalRange = selection.getRangeAt(0);
  const temporaryRange = element.ownerDocument.createRange();
  if (selection.containsNode(element, false)) {
    temporaryRange.selectNodeContents(element);
    selection.removeAllRanges();
    selection.addRange(temporaryRange);
  } else if (element.contains(selection.anchorNode) && element.contains(selection.focusNode)) ;
  else {
    const selectionStartsWithinElement = element === originalRange.startContainer || element.contains(originalRange.startContainer);
    const selectionEndsWithinElement = element === originalRange.endContainer || element.contains(originalRange.endContainer);
    selection.removeAllRanges();
    if (selectionStartsWithinElement || selectionEndsWithinElement) {
      temporaryRange.selectNodeContents(element);
      if (selectionStartsWithinElement) {
        temporaryRange.setStart(
          originalRange.startContainer,
          originalRange.startOffset
        );
      }
      if (selectionEndsWithinElement) {
        temporaryRange.setEnd(
          originalRange.endContainer,
          originalRange.endOffset
        );
      }
      selection.addRange(temporaryRange);
    }
  }
  const result = selection.toString();
  selection.removeAllRanges();
  selection.addRange(originalRange);
  return result;
}
__name(getSelection, "getSelection");
function toHaveSelection(htmlElement, expectedSelection) {
  checkHtmlElement(htmlElement, toHaveSelection, this);
  const expectsSelection = expectedSelection !== void 0;
  if (expectsSelection && typeof expectedSelection !== "string") {
    throw new Error(`expected selection must be a string or undefined`);
  }
  const receivedSelection = getSelection(htmlElement);
  return {
    pass: expectsSelection ? compareAsSet(receivedSelection, expectedSelection) : Boolean(receivedSelection),
    message: /* @__PURE__ */ __name(() => {
      const to = this.isNot ? "not to" : "to";
      const matcher = this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toHaveSelection`,
        "element",
        expectedSelection
      );
      return getMessage3(
        this,
        matcher,
        `Expected the element ${to} have selection`,
        expectsSelection ? expectedSelection : "(any)",
        "Received",
        receivedSelection
      );
    }, "message")
  };
}
__name(toHaveSelection, "toHaveSelection");
function toBePressed(element) {
  checkHtmlElement(element, toBePressed, this);
  const roles3 = (element.getAttribute("role") || "").split(" ").map((role) => role.trim());
  const isButton = element.tagName.toLowerCase() === "button" || element.tagName.toLowerCase() === "input" && element.type === "button" || roles3.includes("button");
  const pressedAttribute = element.getAttribute("aria-pressed");
  const isValidAriaElement = pressedAttribute === "true" || pressedAttribute === "false";
  if (!isButton || !isValidAriaElement) {
    return {
      pass: false,
      message: /* @__PURE__ */ __name(() => `Only button or input with type="button" or element with role="button" and a valid aria-pressed attribute can be used with .toBePressed()`, "message")
    };
  }
  const isPressed = pressedAttribute === "true";
  return {
    pass: isButton && isPressed,
    message: /* @__PURE__ */ __name(() => {
      const matcher = this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toBePressed`,
        "element",
        ""
      );
      return getMessage3(
        this,
        matcher,
        `Expected element to have`,
        `aria-pressed="${this.isNot ? "false" : "true"}"`,
        `Received`,
        `aria-pressed="${pressedAttribute}"`
      );
    }, "message")
  };
}
__name(toBePressed, "toBePressed");
function toBePartiallyPressed(element) {
  checkHtmlElement(element, toBePartiallyPressed, this);
  const roles3 = (element.getAttribute("role") || "").split(" ").map((role) => role.trim());
  const isButton = element.tagName.toLowerCase() === "button" || element.tagName.toLowerCase() === "input" && element.type === "button" || roles3.includes("button");
  const pressedAttribute = element.getAttribute("aria-pressed");
  const isValidAriaElement = pressedAttribute === "true" || pressedAttribute === "false" || pressedAttribute === "mixed";
  if (!isButton || !isValidAriaElement) {
    return {
      pass: false,
      message: /* @__PURE__ */ __name(() => `Only button or input with type="button" or element with role="button" and a valid aria-pressed attribute can be used with .toBePartiallyPressed()`, "message")
    };
  }
  const isPartiallyPressed = pressedAttribute === "mixed";
  return {
    pass: isButton && isPartiallyPressed,
    message: /* @__PURE__ */ __name(() => {
      const to = this.isNot ? "not to" : "to";
      const matcher = this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toBePartiallyPressed`,
        "element",
        ""
      );
      return getMessage3(
        this,
        matcher,
        `Expected element ${to} have`,
        `aria-pressed="mixed"`,
        `Received`,
        `aria-pressed="${pressedAttribute}"`
      );
    }, "message")
  };
}
__name(toBePartiallyPressed, "toBePartiallyPressed");
var DOCUMENT_POSITION_DISCONNECTED = 1;
var DOCUMENT_POSITION_PRECEDING = 2;
var DOCUMENT_POSITION_FOLLOWING = 4;
var DOCUMENT_POSITION_CONTAINS = 8;
var DOCUMENT_POSITION_CONTAINED_BY = 16;
var DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32;
var DOCUMENT_POSITIONS_STRINGS = {
  [DOCUMENT_POSITION_DISCONNECTED]: "Node.DOCUMENT_POSITION_DISCONNECTED",
  [DOCUMENT_POSITION_PRECEDING]: "Node.DOCUMENT_POSITION_PRECEDING",
  [DOCUMENT_POSITION_FOLLOWING]: "Node.DOCUMENT_POSITION_FOLLOWING",
  [DOCUMENT_POSITION_CONTAINS]: "Node.DOCUMENT_POSITION_CONTAINS",
  [DOCUMENT_POSITION_CONTAINED_BY]: "Node.DOCUMENT_POSITION_CONTAINED_BY",
  [DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC]: "Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC"
};
function makeDocumentPositionErrorString(documentPosition) {
  if (documentPosition in DOCUMENT_POSITIONS_STRINGS) {
    return `${DOCUMENT_POSITIONS_STRINGS[documentPosition]} (${documentPosition})`;
  }
  return `Unknown document position (${documentPosition})`;
}
__name(makeDocumentPositionErrorString, "makeDocumentPositionErrorString");
function checkToAppear(methodName, targetDocumentPosition) {
  return function(element, secondElement) {
    checkHtmlElement(element, toAppearBefore, this);
    checkHtmlElement(secondElement, toAppearBefore, this);
    const documentPosition = element.compareDocumentPosition(secondElement);
    const pass = documentPosition === targetDocumentPosition;
    return {
      pass,
      message: /* @__PURE__ */ __name(() => {
        return [
          this.utils.matcherHint(
            `${this.isNot ? ".not" : ""}.${methodName}`,
            "element",
            "secondElement"
          ),
          "",
          `Received: ${makeDocumentPositionErrorString(documentPosition)}`
        ].join("\n");
      }, "message")
    };
  };
}
__name(checkToAppear, "checkToAppear");
function toAppearBefore(element, secondElement) {
  return checkToAppear("toAppearBefore", DOCUMENT_POSITION_FOLLOWING).apply(
    this,
    [element, secondElement]
  );
}
__name(toAppearBefore, "toAppearBefore");
function toAppearAfter(element, secondElement) {
  return checkToAppear("toAppearAfter", DOCUMENT_POSITION_PRECEDING).apply(
    this,
    [element, secondElement]
  );
}
__name(toAppearAfter, "toAppearAfter");
var extensions = Object.freeze({
  __proto__: null,
  toAppearAfter,
  toAppearBefore,
  toBeChecked,
  toBeDisabled,
  toBeEmpty,
  toBeEmptyDOMElement,
  toBeEnabled,
  toBeInTheDOM,
  toBeInTheDocument,
  toBeInvalid,
  toBePartiallyChecked,
  toBePartiallyPressed,
  toBePressed,
  toBeRequired,
  toBeValid,
  toBeVisible,
  toContainElement,
  toContainHTML,
  toHaveAccessibleDescription,
  toHaveAccessibleErrorMessage,
  toHaveAccessibleName,
  toHaveAttribute,
  toHaveClass,
  toHaveDescription,
  toHaveDisplayValue,
  toHaveErrorMessage,
  toHaveFocus,
  toHaveFormValues,
  toHaveRole,
  toHaveSelection,
  toHaveStyle,
  toHaveTextContent,
  toHaveValue
});

// ../node_modules/@testing-library/jest-dom/dist/matchers.mjs
var import_redent2 = __toESM(require_redent(), 1);
var import_aria_query2 = __toESM(require_lib(), 1);
var import_picocolors2 = __toESM(require_picocolors_browser(), 1);
var import_css2 = __toESM(require_css_escape(), 1);

// ../node_modules/@vitest/utils/dist/index.js
var jsTokens_1;
var hasRequiredJsTokens;
function requireJsTokens() {
  if (hasRequiredJsTokens) return jsTokens_1;
  hasRequiredJsTokens = 1;
  var Identifier, JSXIdentifier, JSXPunctuator, JSXString, JSXText, KeywordsWithExpressionAfter, KeywordsWithNoLineTerminatorAfter, LineTerminatorSequence, MultiLineComment, Newline, NumericLiteral, Punctuator, RegularExpressionLiteral, SingleLineComment, StringLiteral, Template, TokensNotPrecedingObjectLiteral, TokensPrecedingExpression, WhiteSpace;
  RegularExpressionLiteral = /\/(?![*\/])(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\\]).|\\.)*(\/[$_\u200C\u200D\p{ID_Continue}]*|\\)?/yu;
  Punctuator = /--|\+\+|=>|\.{3}|\??\.(?!\d)|(?:&&|\|\||\?\?|[+\-%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2}|\/(?![\/*]))=?|[?~,:;[\](){}]/y;
  Identifier = /(\x23?)(?=[$_\p{ID_Start}\\])(?:[$_\u200C\u200D\p{ID_Continue}]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+/yu;
  StringLiteral = /(['"])(?:(?!\1)[^\\\n\r]|\\(?:\r\n|[^]))*(\1)?/y;
  NumericLiteral = /(?:0[xX][\da-fA-F](?:_?[\da-fA-F])*|0[oO][0-7](?:_?[0-7])*|0[bB][01](?:_?[01])*)n?|0n|[1-9](?:_?\d)*n|(?:(?:0(?!\d)|0\d*[89]\d*|[1-9](?:_?\d)*)(?:\.(?:\d(?:_?\d)*)?)?|\.\d(?:_?\d)*)(?:[eE][+-]?\d(?:_?\d)*)?|0[0-7]+/y;
  Template = /[`}](?:[^`\\$]|\\[^]|\$(?!\{))*(`|\$\{)?/y;
  WhiteSpace = /[\t\v\f\ufeff\p{Zs}]+/yu;
  LineTerminatorSequence = /\r?\n|[\r\u2028\u2029]/y;
  MultiLineComment = /\/\*(?:[^*]|\*(?!\/))*(\*\/)?/y;
  SingleLineComment = /\/\/.*/y;
  JSXPunctuator = /[<>.:={}]|\/(?![\/*])/y;
  JSXIdentifier = /[$_\p{ID_Start}][$_\u200C\u200D\p{ID_Continue}-]*/yu;
  JSXString = /(['"])(?:(?!\1)[^])*(\1)?/y;
  JSXText = /[^<>{}]+/y;
  TokensPrecedingExpression = /^(?:[\/+-]|\.{3}|\?(?:InterpolationIn(?:JSX|Template)|NoLineTerminatorHere|NonExpressionParenEnd|UnaryIncDec))?$|[{}([,;<>=*%&|^!~?:]$/;
  TokensNotPrecedingObjectLiteral = /^(?:=>|[;\]){}]|else|\?(?:NoLineTerminatorHere|NonExpressionParenEnd))?$/;
  KeywordsWithExpressionAfter = /^(?:await|case|default|delete|do|else|instanceof|new|return|throw|typeof|void|yield)$/;
  KeywordsWithNoLineTerminatorAfter = /^(?:return|throw|yield)$/;
  Newline = RegExp(LineTerminatorSequence.source);
  jsTokens_1 = /* @__PURE__ */ __name(function* (input2, { jsx = false } = {}) {
    var braces, firstCodePoint, isExpression, lastIndex, lastSignificantToken, length, match, mode, nextLastIndex, nextLastSignificantToken, parenNesting, postfixIncDec, punctuator, stack;
    ({ length } = input2);
    lastIndex = 0;
    lastSignificantToken = "";
    stack = [
      { tag: "JS" }
    ];
    braces = [];
    parenNesting = 0;
    postfixIncDec = false;
    while (lastIndex < length) {
      mode = stack[stack.length - 1];
      switch (mode.tag) {
        case "JS":
        case "JSNonExpressionParen":
        case "InterpolationInTemplate":
        case "InterpolationInJSX":
          if (input2[lastIndex] === "/" && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken))) {
            RegularExpressionLiteral.lastIndex = lastIndex;
            if (match = RegularExpressionLiteral.exec(input2)) {
              lastIndex = RegularExpressionLiteral.lastIndex;
              lastSignificantToken = match[0];
              postfixIncDec = true;
              yield {
                type: "RegularExpressionLiteral",
                value: match[0],
                closed: match[1] !== void 0 && match[1] !== "\\"
              };
              continue;
            }
          }
          Punctuator.lastIndex = lastIndex;
          if (match = Punctuator.exec(input2)) {
            punctuator = match[0];
            nextLastIndex = Punctuator.lastIndex;
            nextLastSignificantToken = punctuator;
            switch (punctuator) {
              case "(":
                if (lastSignificantToken === "?NonExpressionParenKeyword") {
                  stack.push({
                    tag: "JSNonExpressionParen",
                    nesting: parenNesting
                  });
                }
                parenNesting++;
                postfixIncDec = false;
                break;
              case ")":
                parenNesting--;
                postfixIncDec = true;
                if (mode.tag === "JSNonExpressionParen" && parenNesting === mode.nesting) {
                  stack.pop();
                  nextLastSignificantToken = "?NonExpressionParenEnd";
                  postfixIncDec = false;
                }
                break;
              case "{":
                Punctuator.lastIndex = 0;
                isExpression = !TokensNotPrecedingObjectLiteral.test(lastSignificantToken) && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken));
                braces.push(isExpression);
                postfixIncDec = false;
                break;
              case "}":
                switch (mode.tag) {
                  case "InterpolationInTemplate":
                    if (braces.length === mode.nesting) {
                      Template.lastIndex = lastIndex;
                      match = Template.exec(input2);
                      lastIndex = Template.lastIndex;
                      lastSignificantToken = match[0];
                      if (match[1] === "${") {
                        lastSignificantToken = "?InterpolationInTemplate";
                        postfixIncDec = false;
                        yield {
                          type: "TemplateMiddle",
                          value: match[0]
                        };
                      } else {
                        stack.pop();
                        postfixIncDec = true;
                        yield {
                          type: "TemplateTail",
                          value: match[0],
                          closed: match[1] === "`"
                        };
                      }
                      continue;
                    }
                    break;
                  case "InterpolationInJSX":
                    if (braces.length === mode.nesting) {
                      stack.pop();
                      lastIndex += 1;
                      lastSignificantToken = "}";
                      yield {
                        type: "JSXPunctuator",
                        value: "}"
                      };
                      continue;
                    }
                }
                postfixIncDec = braces.pop();
                nextLastSignificantToken = postfixIncDec ? "?ExpressionBraceEnd" : "}";
                break;
              case "]":
                postfixIncDec = true;
                break;
              case "++":
              case "--":
                nextLastSignificantToken = postfixIncDec ? "?PostfixIncDec" : "?UnaryIncDec";
                break;
              case "<":
                if (jsx && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken))) {
                  stack.push({ tag: "JSXTag" });
                  lastIndex += 1;
                  lastSignificantToken = "<";
                  yield {
                    type: "JSXPunctuator",
                    value: punctuator
                  };
                  continue;
                }
                postfixIncDec = false;
                break;
              default:
                postfixIncDec = false;
            }
            lastIndex = nextLastIndex;
            lastSignificantToken = nextLastSignificantToken;
            yield {
              type: "Punctuator",
              value: punctuator
            };
            continue;
          }
          Identifier.lastIndex = lastIndex;
          if (match = Identifier.exec(input2)) {
            lastIndex = Identifier.lastIndex;
            nextLastSignificantToken = match[0];
            switch (match[0]) {
              case "for":
              case "if":
              case "while":
              case "with":
                if (lastSignificantToken !== "." && lastSignificantToken !== "?.") {
                  nextLastSignificantToken = "?NonExpressionParenKeyword";
                }
            }
            lastSignificantToken = nextLastSignificantToken;
            postfixIncDec = !KeywordsWithExpressionAfter.test(match[0]);
            yield {
              type: match[1] === "#" ? "PrivateIdentifier" : "IdentifierName",
              value: match[0]
            };
            continue;
          }
          StringLiteral.lastIndex = lastIndex;
          if (match = StringLiteral.exec(input2)) {
            lastIndex = StringLiteral.lastIndex;
            lastSignificantToken = match[0];
            postfixIncDec = true;
            yield {
              type: "StringLiteral",
              value: match[0],
              closed: match[2] !== void 0
            };
            continue;
          }
          NumericLiteral.lastIndex = lastIndex;
          if (match = NumericLiteral.exec(input2)) {
            lastIndex = NumericLiteral.lastIndex;
            lastSignificantToken = match[0];
            postfixIncDec = true;
            yield {
              type: "NumericLiteral",
              value: match[0]
            };
            continue;
          }
          Template.lastIndex = lastIndex;
          if (match = Template.exec(input2)) {
            lastIndex = Template.lastIndex;
            lastSignificantToken = match[0];
            if (match[1] === "${") {
              lastSignificantToken = "?InterpolationInTemplate";
              stack.push({
                tag: "InterpolationInTemplate",
                nesting: braces.length
              });
              postfixIncDec = false;
              yield {
                type: "TemplateHead",
                value: match[0]
              };
            } else {
              postfixIncDec = true;
              yield {
                type: "NoSubstitutionTemplate",
                value: match[0],
                closed: match[1] === "`"
              };
            }
            continue;
          }
          break;
        case "JSXTag":
        case "JSXTagEnd":
          JSXPunctuator.lastIndex = lastIndex;
          if (match = JSXPunctuator.exec(input2)) {
            lastIndex = JSXPunctuator.lastIndex;
            nextLastSignificantToken = match[0];
            switch (match[0]) {
              case "<":
                stack.push({ tag: "JSXTag" });
                break;
              case ">":
                stack.pop();
                if (lastSignificantToken === "/" || mode.tag === "JSXTagEnd") {
                  nextLastSignificantToken = "?JSX";
                  postfixIncDec = true;
                } else {
                  stack.push({ tag: "JSXChildren" });
                }
                break;
              case "{":
                stack.push({
                  tag: "InterpolationInJSX",
                  nesting: braces.length
                });
                nextLastSignificantToken = "?InterpolationInJSX";
                postfixIncDec = false;
                break;
              case "/":
                if (lastSignificantToken === "<") {
                  stack.pop();
                  if (stack[stack.length - 1].tag === "JSXChildren") {
                    stack.pop();
                  }
                  stack.push({ tag: "JSXTagEnd" });
                }
            }
            lastSignificantToken = nextLastSignificantToken;
            yield {
              type: "JSXPunctuator",
              value: match[0]
            };
            continue;
          }
          JSXIdentifier.lastIndex = lastIndex;
          if (match = JSXIdentifier.exec(input2)) {
            lastIndex = JSXIdentifier.lastIndex;
            lastSignificantToken = match[0];
            yield {
              type: "JSXIdentifier",
              value: match[0]
            };
            continue;
          }
          JSXString.lastIndex = lastIndex;
          if (match = JSXString.exec(input2)) {
            lastIndex = JSXString.lastIndex;
            lastSignificantToken = match[0];
            yield {
              type: "JSXString",
              value: match[0],
              closed: match[2] !== void 0
            };
            continue;
          }
          break;
        case "JSXChildren":
          JSXText.lastIndex = lastIndex;
          if (match = JSXText.exec(input2)) {
            lastIndex = JSXText.lastIndex;
            lastSignificantToken = match[0];
            yield {
              type: "JSXText",
              value: match[0]
            };
            continue;
          }
          switch (input2[lastIndex]) {
            case "<":
              stack.push({ tag: "JSXTag" });
              lastIndex++;
              lastSignificantToken = "<";
              yield {
                type: "JSXPunctuator",
                value: "<"
              };
              continue;
            case "{":
              stack.push({
                tag: "InterpolationInJSX",
                nesting: braces.length
              });
              lastIndex++;
              lastSignificantToken = "?InterpolationInJSX";
              postfixIncDec = false;
              yield {
                type: "JSXPunctuator",
                value: "{"
              };
              continue;
          }
      }
      WhiteSpace.lastIndex = lastIndex;
      if (match = WhiteSpace.exec(input2)) {
        lastIndex = WhiteSpace.lastIndex;
        yield {
          type: "WhiteSpace",
          value: match[0]
        };
        continue;
      }
      LineTerminatorSequence.lastIndex = lastIndex;
      if (match = LineTerminatorSequence.exec(input2)) {
        lastIndex = LineTerminatorSequence.lastIndex;
        postfixIncDec = false;
        if (KeywordsWithNoLineTerminatorAfter.test(lastSignificantToken)) {
          lastSignificantToken = "?NoLineTerminatorHere";
        }
        yield {
          type: "LineTerminatorSequence",
          value: match[0]
        };
        continue;
      }
      MultiLineComment.lastIndex = lastIndex;
      if (match = MultiLineComment.exec(input2)) {
        lastIndex = MultiLineComment.lastIndex;
        if (Newline.test(match[0])) {
          postfixIncDec = false;
          if (KeywordsWithNoLineTerminatorAfter.test(lastSignificantToken)) {
            lastSignificantToken = "?NoLineTerminatorHere";
          }
        }
        yield {
          type: "MultiLineComment",
          value: match[0],
          closed: match[1] !== void 0
        };
        continue;
      }
      SingleLineComment.lastIndex = lastIndex;
      if (match = SingleLineComment.exec(input2)) {
        lastIndex = SingleLineComment.lastIndex;
        postfixIncDec = false;
        yield {
          type: "SingleLineComment",
          value: match[0]
        };
        continue;
      }
      firstCodePoint = String.fromCodePoint(input2.codePointAt(lastIndex));
      lastIndex += firstCodePoint.length;
      lastSignificantToken = firstCodePoint;
      postfixIncDec = false;
      yield {
        type: mode.tag.startsWith("JSX") ? "JSXInvalid" : "Invalid",
        value: firstCodePoint
      };
    }
    return void 0;
  }, "jsTokens_1");
  return jsTokens_1;
}
__name(requireJsTokens, "requireJsTokens");
var jsTokensExports = requireJsTokens();
var jsTokens = getDefaultExportFromCjs2(jsTokensExports);
var reservedWords = {
  keyword: [
    "break",
    "case",
    "catch",
    "continue",
    "debugger",
    "default",
    "do",
    "else",
    "finally",
    "for",
    "function",
    "if",
    "return",
    "switch",
    "throw",
    "try",
    "var",
    "const",
    "while",
    "with",
    "new",
    "this",
    "super",
    "class",
    "extends",
    "export",
    "import",
    "null",
    "true",
    "false",
    "in",
    "instanceof",
    "typeof",
    "void",
    "delete"
  ],
  strict: [
    "implements",
    "interface",
    "let",
    "package",
    "private",
    "protected",
    "public",
    "static",
    "yield"
  ]
};
var keywords = new Set(reservedWords.keyword);
var reservedWordsStrictSet = new Set(reservedWords.strict);
var SAFE_TIMERS_SYMBOL = Symbol("vitest:SAFE_TIMERS");

// ../node_modules/@vitest/spy/node_modules/tinyspy/dist/index.js
function S(e2, t2) {
  if (!e2)
    throw new Error(t2);
}
__name(S, "S");
function f2(e2, t2) {
  return typeof t2 === e2;
}
__name(f2, "f");
function w(e2) {
  return e2 instanceof Promise;
}
__name(w, "w");
function u(e2, t2, r2) {
  Object.defineProperty(e2, t2, r2);
}
__name(u, "u");
function l(e2, t2, r2) {
  u(e2, t2, { value: r2, configurable: true, writable: true });
}
__name(l, "l");
var y = Symbol.for("tinyspy:spy");
var x = /* @__PURE__ */ new Set();
var h2 = /* @__PURE__ */ __name((e2) => {
  e2.called = false, e2.callCount = 0, e2.calls = [], e2.results = [], e2.resolves = [], e2.next = [];
}, "h");
var k = /* @__PURE__ */ __name((e2) => (u(e2, y, {
  value: { reset: /* @__PURE__ */ __name(() => h2(e2[y]), "reset") }
}), e2[y]), "k");
var T = /* @__PURE__ */ __name((e2) => e2[y] || k(e2), "T");
function R(e2) {
  S(
    f2("function", e2) || f2("undefined", e2),
    "cannot spy on a non-function value"
  );
  let t2 = /* @__PURE__ */ __name(function(...s3) {
    let n2 = T(t2);
    n2.called = true, n2.callCount++, n2.calls.push(s3);
    let d = n2.next.shift();
    if (d) {
      n2.results.push(d);
      let [a2, i2] = d;
      if (a2 === "ok")
        return i2;
      throw i2;
    }
    let o2, c2 = "ok", p2 = n2.results.length;
    if (n2.impl)
      try {
        new.target ? o2 = Reflect.construct(n2.impl, s3, new.target) : o2 = n2.impl.apply(this, s3), c2 = "ok";
      } catch (a2) {
        throw o2 = a2, c2 = "error", n2.results.push([c2, a2]), a2;
      }
    let g2 = [c2, o2];
    return w(o2) && o2.then(
      (a2) => n2.resolves[p2] = ["ok", a2],
      (a2) => n2.resolves[p2] = ["error", a2]
    ), n2.results.push(g2), o2;
  }, "t");
  l(t2, "_isMockFunction", true), l(t2, "length", e2 ? e2.length : 0), l(t2, "name", e2 && e2.name || "spy");
  let r2 = T(t2);
  return r2.reset(), r2.impl = e2, t2;
}
__name(R, "R");
function v(e2) {
  return !!e2 && e2._isMockFunction === true;
}
__name(v, "v");
var b = /* @__PURE__ */ __name((e2, t2) => {
  let r2 = Object.getOwnPropertyDescriptor(e2, t2);
  if (r2)
    return [e2, r2];
  let s3 = Object.getPrototypeOf(e2);
  for (; s3 !== null; ) {
    let n2 = Object.getOwnPropertyDescriptor(s3, t2);
    if (n2)
      return [s3, n2];
    s3 = Object.getPrototypeOf(s3);
  }
}, "b");
var P = /* @__PURE__ */ __name((e2, t2) => {
  t2 != null && typeof t2 == "function" && t2.prototype != null && Object.setPrototypeOf(e2.prototype, t2.prototype);
}, "P");
function M(e2, t2, r2) {
  S(
    !f2("undefined", e2),
    "spyOn could not find an object to spy upon"
  ), S(
    f2("object", e2) || f2("function", e2),
    "cannot spyOn on a primitive value"
  );
  let [s3, n2] = (() => {
    if (!f2("object", t2))
      return [t2, "value"];
    if ("getter" in t2 && "setter" in t2)
      throw new Error("cannot spy on both getter and setter");
    if ("getter" in t2)
      return [t2.getter, "get"];
    if ("setter" in t2)
      return [t2.setter, "set"];
    throw new Error("specify getter or setter to spy on");
  })(), [d, o2] = b(e2, s3) || [];
  S(
    o2 || s3 in e2,
    `${String(s3)} does not exist`
  );
  let c2 = false;
  n2 === "value" && o2 && !o2.value && o2.get && (n2 = "get", c2 = true, r2 = o2.get());
  let p2;
  o2 ? p2 = o2[n2] : n2 !== "value" ? p2 = /* @__PURE__ */ __name(() => e2[s3], "p") : p2 = e2[s3], p2 && j(p2) && (p2 = p2[y].getOriginal());
  let g2 = /* @__PURE__ */ __name((I) => {
    let { value: F, ...O } = o2 || {
      configurable: true,
      writable: true
    };
    n2 !== "value" && delete O.writable, O[n2] = I, u(e2, s3, O);
  }, "g"), a2 = /* @__PURE__ */ __name(() => {
    d !== e2 ? Reflect.deleteProperty(e2, s3) : o2 && !p2 ? u(e2, s3, o2) : g2(p2);
  }, "a");
  r2 || (r2 = p2);
  let i2 = E(R(r2), r2);
  n2 === "value" && P(i2, p2);
  let m3 = i2[y];
  return l(m3, "restore", a2), l(m3, "getOriginal", () => c2 ? p2() : p2), l(m3, "willCall", (I) => (m3.impl = I, i2)), g2(
    c2 ? () => (P(i2, r2), i2) : i2
  ), x.add(i2), i2;
}
__name(M, "M");
var K = /* @__PURE__ */ new Set([
  "length",
  "name",
  "prototype"
]);
function D(e2) {
  let t2 = /* @__PURE__ */ new Set(), r2 = {};
  for (; e2 && e2 !== Object.prototype && e2 !== Function.prototype; ) {
    let s3 = [
      ...Object.getOwnPropertyNames(e2),
      ...Object.getOwnPropertySymbols(e2)
    ];
    for (let n2 of s3)
      r2[n2] || K.has(n2) || (t2.add(n2), r2[n2] = Object.getOwnPropertyDescriptor(e2, n2));
    e2 = Object.getPrototypeOf(e2);
  }
  return {
    properties: t2,
    descriptors: r2
  };
}
__name(D, "D");
function E(e2, t2) {
  if (!t2 || // the original is already a spy, so it has all the properties
  y in t2)
    return e2;
  let { properties: r2, descriptors: s3 } = D(t2);
  for (let n2 of r2) {
    let d = s3[n2];
    b(e2, n2) || u(e2, n2, d);
  }
  return e2;
}
__name(E, "E");
function j(e2) {
  return v(e2) && "getOriginal" in e2[y];
}
__name(j, "j");

// ../node_modules/@vitest/spy/dist/index.js
var mocks = /* @__PURE__ */ new Set();
function isMockFunction(fn3) {
  return typeof fn3 === "function" && "_isMockFunction" in fn3 && fn3._isMockFunction;
}
__name(isMockFunction, "isMockFunction");
function spyOn(obj, method, accessType) {
  const dictionary = {
    get: "getter",
    set: "setter"
  };
  const objMethod = accessType ? { [dictionary[accessType]]: method } : method;
  let state3;
  const descriptor = getDescriptor(obj, method);
  const fn3 = descriptor && descriptor[accessType || "value"];
  if (isMockFunction(fn3)) {
    state3 = fn3.mock._state();
  }
  try {
    const stub = M(obj, objMethod);
    const spy = enhanceSpy(stub);
    if (state3) {
      spy.mock._state(state3);
    }
    return spy;
  } catch (error) {
    if (error instanceof TypeError && Symbol.toStringTag && obj[Symbol.toStringTag] === "Module" && (error.message.includes("Cannot redefine property") || error.message.includes("Cannot replace module namespace") || error.message.includes("can't redefine non-configurable property"))) {
      throw new TypeError(`Cannot spy on export "${String(objMethod)}". Module namespace is not configurable in ESM. See: https://vitest.dev/guide/browser/#limitations`, { cause: error });
    }
    throw error;
  }
}
__name(spyOn, "spyOn");
var callOrder = 0;
function enhanceSpy(spy) {
  const stub = spy;
  let implementation;
  let onceImplementations = [];
  let implementationChangedTemporarily = false;
  let instances2 = [];
  let contexts = [];
  let invocations = [];
  const state3 = T(spy);
  const mockContext = {
    get calls() {
      return state3.calls;
    },
    get contexts() {
      return contexts;
    },
    get instances() {
      return instances2;
    },
    get invocationCallOrder() {
      return invocations;
    },
    get results() {
      return state3.results.map(([callType, value]) => {
        const type5 = callType === "error" ? "throw" : "return";
        return {
          type: type5,
          value
        };
      });
    },
    get settledResults() {
      return state3.resolves.map(([callType, value]) => {
        const type5 = callType === "error" ? "rejected" : "fulfilled";
        return {
          type: type5,
          value
        };
      });
    },
    get lastCall() {
      return state3.calls[state3.calls.length - 1];
    },
    _state(state4) {
      if (state4) {
        implementation = state4.implementation;
        onceImplementations = state4.onceImplementations;
        implementationChangedTemporarily = state4.implementationChangedTemporarily;
      }
      return {
        implementation,
        onceImplementations,
        implementationChangedTemporarily
      };
    }
  };
  function mockCall(...args) {
    instances2.push(this);
    contexts.push(this);
    invocations.push(++callOrder);
    const impl = implementationChangedTemporarily ? implementation : onceImplementations.shift() || implementation || state3.getOriginal() || (() => {
    });
    return impl.apply(this, args);
  }
  __name(mockCall, "mockCall");
  let name = stub.name;
  stub.getMockName = () => name || "vi.fn()";
  stub.mockName = (n2) => {
    name = n2;
    return stub;
  };
  stub.mockClear = () => {
    state3.reset();
    instances2 = [];
    contexts = [];
    invocations = [];
    return stub;
  };
  stub.mockReset = () => {
    stub.mockClear();
    implementation = void 0;
    onceImplementations = [];
    return stub;
  };
  stub.mockRestore = () => {
    stub.mockReset();
    state3.restore();
    return stub;
  };
  if (Symbol.dispose) {
    stub[Symbol.dispose] = () => stub.mockRestore();
  }
  stub.getMockImplementation = () => implementationChangedTemporarily ? implementation : onceImplementations.at(0) || implementation;
  stub.mockImplementation = (fn3) => {
    implementation = fn3;
    state3.willCall(mockCall);
    return stub;
  };
  stub.mockImplementationOnce = (fn3) => {
    onceImplementations.push(fn3);
    return stub;
  };
  function withImplementation(fn3, cb) {
    const originalImplementation = implementation;
    implementation = fn3;
    state3.willCall(mockCall);
    implementationChangedTemporarily = true;
    const reset = /* @__PURE__ */ __name(() => {
      implementation = originalImplementation;
      implementationChangedTemporarily = false;
    }, "reset");
    const result = cb();
    if (typeof result === "object" && result && typeof result.then === "function") {
      return result.then(() => {
        reset();
        return stub;
      });
    }
    reset();
    return stub;
  }
  __name(withImplementation, "withImplementation");
  stub.withImplementation = withImplementation;
  stub.mockReturnThis = () => stub.mockImplementation(function() {
    return this;
  });
  stub.mockReturnValue = (val) => stub.mockImplementation(() => val);
  stub.mockReturnValueOnce = (val) => stub.mockImplementationOnce(() => val);
  stub.mockResolvedValue = (val) => stub.mockImplementation(() => Promise.resolve(val));
  stub.mockResolvedValueOnce = (val) => stub.mockImplementationOnce(() => Promise.resolve(val));
  stub.mockRejectedValue = (val) => stub.mockImplementation(() => Promise.reject(val));
  stub.mockRejectedValueOnce = (val) => stub.mockImplementationOnce(() => Promise.reject(val));
  Object.defineProperty(stub, "mock", { get: /* @__PURE__ */ __name(() => mockContext, "get") });
  state3.willCall(mockCall);
  mocks.add(stub);
  return stub;
}
__name(enhanceSpy, "enhanceSpy");
function fn(implementation) {
  const enhancedSpy = enhanceSpy(M({ spy: implementation || function() {
  } }, "spy"));
  if (implementation) {
    enhancedSpy.mockImplementation(implementation);
  }
  return enhancedSpy;
}
__name(fn, "fn");
function getDescriptor(obj, method) {
  const objDescriptor = Object.getOwnPropertyDescriptor(obj, method);
  if (objDescriptor) {
    return objDescriptor;
  }
  let currentProto = Object.getPrototypeOf(obj);
  while (currentProto !== null) {
    const descriptor = Object.getOwnPropertyDescriptor(currentProto, method);
    if (descriptor) {
      return descriptor;
    }
    currentProto = Object.getPrototypeOf(currentProto);
  }
}
__name(getDescriptor, "getDescriptor");

// ../node_modules/@vitest/expect/dist/index.js
var MATCHERS_OBJECT = Symbol.for("matchers-object");
var JEST_MATCHERS_OBJECT = Symbol.for("$$jest-matchers-object-storybook");
var GLOBAL_EXPECT = Symbol.for("expect-global");
var ASYMMETRIC_MATCHERS_OBJECT = Symbol.for("asymmetric-matchers-object");
var customMatchers = {
  toSatisfy(actual, expected, message) {
    const { printReceived: printReceived3, printExpected: printExpected3, matcherHint: matcherHint2 } = this.utils;
    const pass = expected(actual);
    return {
      pass,
      message: /* @__PURE__ */ __name(() => pass ? `${matcherHint2(".not.toSatisfy", "received", "")}

Expected value to not satisfy:
${message || printExpected3(expected)}
Received:
${printReceived3(actual)}` : `${matcherHint2(".toSatisfy", "received", "")}

Expected value to satisfy:
${message || printExpected3(expected)}

Received:
${printReceived3(actual)}`, "message")
    };
  },
  toBeOneOf(actual, expected) {
    const { equals: equals2, customTesters } = this;
    const { printReceived: printReceived3, printExpected: printExpected3, matcherHint: matcherHint2 } = this.utils;
    if (!Array.isArray(expected)) {
      throw new TypeError(`You must provide an array to ${matcherHint2(".toBeOneOf")}, not '${typeof expected}'.`);
    }
    const pass = expected.length === 0 || expected.some((item) => equals2(item, actual, customTesters));
    return {
      pass,
      message: /* @__PURE__ */ __name(() => pass ? `${matcherHint2(".not.toBeOneOf", "received", "")}

Expected value to not be one of:
${printExpected3(expected)}
Received:
${printReceived3(actual)}` : `${matcherHint2(".toBeOneOf", "received", "")}

Expected value to be one of:
${printExpected3(expected)}

Received:
${printReceived3(actual)}`, "message")
    };
  }
};
var EXPECTED_COLOR = s.green;
var RECEIVED_COLOR = s.red;
var INVERTED_COLOR = s.inverse;
var BOLD_WEIGHT = s.bold;
var DIM_COLOR = s.dim;
function matcherHint(matcherName, received = "received", expected = "expected", options = {}) {
  const { comment = "", isDirectExpectCall = false, isNot = false, promise = "", secondArgument = "", expectedColor = EXPECTED_COLOR, receivedColor = RECEIVED_COLOR, secondArgumentColor = EXPECTED_COLOR } = options;
  let hint = "";
  let dimString = "expect";
  if (!isDirectExpectCall && received !== "") {
    hint += DIM_COLOR(`${dimString}(`) + receivedColor(received);
    dimString = ")";
  }
  if (promise !== "") {
    hint += DIM_COLOR(`${dimString}.`) + promise;
    dimString = "";
  }
  if (isNot) {
    hint += `${DIM_COLOR(`${dimString}.`)}not`;
    dimString = "";
  }
  if (matcherName.includes(".")) {
    dimString += matcherName;
  } else {
    hint += DIM_COLOR(`${dimString}.`) + matcherName;
    dimString = "";
  }
  if (expected === "") {
    dimString += "()";
  } else {
    hint += DIM_COLOR(`${dimString}(`) + expectedColor(expected);
    if (secondArgument) {
      hint += DIM_COLOR(", ") + secondArgumentColor(secondArgument);
    }
    dimString = ")";
  }
  if (comment !== "") {
    dimString += ` // ${comment}`;
  }
  if (dimString !== "") {
    hint += DIM_COLOR(dimString);
  }
  return hint;
}
__name(matcherHint, "matcherHint");
var SPACE_SYMBOL2 = "\xB7";
function replaceTrailingSpaces2(text) {
  return text.replace(/\s+$/gm, (spaces) => SPACE_SYMBOL2.repeat(spaces.length));
}
__name(replaceTrailingSpaces2, "replaceTrailingSpaces");
function printReceived2(object) {
  return RECEIVED_COLOR(replaceTrailingSpaces2(stringify2(object)));
}
__name(printReceived2, "printReceived");
function printExpected2(value) {
  return EXPECTED_COLOR(replaceTrailingSpaces2(stringify2(value)));
}
__name(printExpected2, "printExpected");
function getMatcherUtils() {
  return {
    EXPECTED_COLOR,
    RECEIVED_COLOR,
    INVERTED_COLOR,
    BOLD_WEIGHT,
    DIM_COLOR,
    diff,
    matcherHint,
    printReceived: printReceived2,
    printExpected: printExpected2,
    printDiffOrStringify,
    printWithType
  };
}
__name(getMatcherUtils, "getMatcherUtils");
function printWithType(name, value, print) {
  const type5 = getType2(value);
  const hasType = type5 !== "null" && type5 !== "undefined" ? `${name} has type:  ${type5}
` : "";
  const hasValue = `${name} has value: ${print(value)}`;
  return hasType + hasValue;
}
__name(printWithType, "printWithType");
function getCustomEqualityTesters() {
  return globalThis[JEST_MATCHERS_OBJECT].customEqualityTesters;
}
__name(getCustomEqualityTesters, "getCustomEqualityTesters");
function equals(a2, b2, customTesters, strictCheck) {
  customTesters = customTesters || [];
  return eq2(a2, b2, [], [], customTesters, strictCheck ? hasKey : hasDefinedKey);
}
__name(equals, "equals");
var functionToString = Function.prototype.toString;
function isAsymmetric(obj) {
  return !!obj && typeof obj === "object" && "asymmetricMatch" in obj && isA("Function", obj.asymmetricMatch);
}
__name(isAsymmetric, "isAsymmetric");
function asymmetricMatch(a2, b2) {
  const asymmetricA = isAsymmetric(a2);
  const asymmetricB = isAsymmetric(b2);
  if (asymmetricA && asymmetricB) {
    return void 0;
  }
  if (asymmetricA) {
    return a2.asymmetricMatch(b2);
  }
  if (asymmetricB) {
    return b2.asymmetricMatch(a2);
  }
}
__name(asymmetricMatch, "asymmetricMatch");
function eq2(a2, b2, aStack, bStack, customTesters, hasKey2) {
  let result = true;
  const asymmetricResult = asymmetricMatch(a2, b2);
  if (asymmetricResult !== void 0) {
    return asymmetricResult;
  }
  const testerContext = { equals };
  for (let i2 = 0; i2 < customTesters.length; i2++) {
    const customTesterResult = customTesters[i2].call(testerContext, a2, b2, customTesters);
    if (customTesterResult !== void 0) {
      return customTesterResult;
    }
  }
  if (typeof URL === "function" && a2 instanceof URL && b2 instanceof URL) {
    return a2.href === b2.href;
  }
  if (Object.is(a2, b2)) {
    return true;
  }
  if (a2 === null || b2 === null) {
    return a2 === b2;
  }
  const className = Object.prototype.toString.call(a2);
  if (className !== Object.prototype.toString.call(b2)) {
    return false;
  }
  switch (className) {
    case "[object Boolean]":
    case "[object String]":
    case "[object Number]":
      if (typeof a2 !== typeof b2) {
        return false;
      } else if (typeof a2 !== "object" && typeof b2 !== "object") {
        return Object.is(a2, b2);
      } else {
        return Object.is(a2.valueOf(), b2.valueOf());
      }
    case "[object Date]": {
      const numA = +a2;
      const numB = +b2;
      return numA === numB || Number.isNaN(numA) && Number.isNaN(numB);
    }
    case "[object RegExp]":
      return a2.source === b2.source && a2.flags === b2.flags;
    case "[object Temporal.Instant]":
    case "[object Temporal.ZonedDateTime]":
    case "[object Temporal.PlainDateTime]":
    case "[object Temporal.PlainDate]":
    case "[object Temporal.PlainTime]":
    case "[object Temporal.PlainYearMonth]":
    case "[object Temporal.PlainMonthDay]":
      return a2.equals(b2);
    case "[object Temporal.Duration]":
      return a2.toString() === b2.toString();
  }
  if (typeof a2 !== "object" || typeof b2 !== "object") {
    return false;
  }
  if (isDomNode(a2) && isDomNode(b2)) {
    return a2.isEqualNode(b2);
  }
  let length = aStack.length;
  while (length--) {
    if (aStack[length] === a2) {
      return bStack[length] === b2;
    } else if (bStack[length] === b2) {
      return false;
    }
  }
  aStack.push(a2);
  bStack.push(b2);
  if (className === "[object Array]" && a2.length !== b2.length) {
    return false;
  }
  if (a2 instanceof Error && b2 instanceof Error) {
    try {
      return isErrorEqual(a2, b2, aStack, bStack, customTesters, hasKey2);
    } finally {
      aStack.pop();
      bStack.pop();
    }
  }
  const aKeys = keys(a2, hasKey2);
  let key;
  let size = aKeys.length;
  if (keys(b2, hasKey2).length !== size) {
    return false;
  }
  while (size--) {
    key = aKeys[size];
    result = hasKey2(b2, key) && eq2(a2[key], b2[key], aStack, bStack, customTesters, hasKey2);
    if (!result) {
      return false;
    }
  }
  aStack.pop();
  bStack.pop();
  return result;
}
__name(eq2, "eq");
function isErrorEqual(a2, b2, aStack, bStack, customTesters, hasKey2) {
  let result = Object.getPrototypeOf(a2) === Object.getPrototypeOf(b2) && a2.name === b2.name && a2.message === b2.message;
  if (typeof b2.cause !== "undefined") {
    result && (result = eq2(a2.cause, b2.cause, aStack, bStack, customTesters, hasKey2));
  }
  if (a2 instanceof AggregateError && b2 instanceof AggregateError) {
    result && (result = eq2(a2.errors, b2.errors, aStack, bStack, customTesters, hasKey2));
  }
  result && (result = eq2({ ...a2 }, { ...b2 }, aStack, bStack, customTesters, hasKey2));
  return result;
}
__name(isErrorEqual, "isErrorEqual");
function keys(obj, hasKey2) {
  const keys2 = [];
  for (const key in obj) {
    if (hasKey2(obj, key)) {
      keys2.push(key);
    }
  }
  return keys2.concat(Object.getOwnPropertySymbols(obj).filter((symbol) => Object.getOwnPropertyDescriptor(obj, symbol).enumerable));
}
__name(keys, "keys");
function hasDefinedKey(obj, key) {
  return hasKey(obj, key) && obj[key] !== void 0;
}
__name(hasDefinedKey, "hasDefinedKey");
function hasKey(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
__name(hasKey, "hasKey");
function isA(typeName, value) {
  return Object.prototype.toString.apply(value) === `[object ${typeName}]`;
}
__name(isA, "isA");
function isDomNode(obj) {
  return obj !== null && typeof obj === "object" && "nodeType" in obj && typeof obj.nodeType === "number" && "nodeName" in obj && typeof obj.nodeName === "string" && "isEqualNode" in obj && typeof obj.isEqualNode === "function";
}
__name(isDomNode, "isDomNode");
var IS_KEYED_SENTINEL2 = "@@__IMMUTABLE_KEYED__@@";
var IS_SET_SENTINEL2 = "@@__IMMUTABLE_SET__@@";
var IS_LIST_SENTINEL2 = "@@__IMMUTABLE_LIST__@@";
var IS_ORDERED_SENTINEL2 = "@@__IMMUTABLE_ORDERED__@@";
var IS_RECORD_SYMBOL2 = "@@__IMMUTABLE_RECORD__@@";
function isImmutableUnorderedKeyed(maybeKeyed) {
  return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL2] && !maybeKeyed[IS_ORDERED_SENTINEL2]);
}
__name(isImmutableUnorderedKeyed, "isImmutableUnorderedKeyed");
function isImmutableUnorderedSet(maybeSet) {
  return !!(maybeSet && maybeSet[IS_SET_SENTINEL2] && !maybeSet[IS_ORDERED_SENTINEL2]);
}
__name(isImmutableUnorderedSet, "isImmutableUnorderedSet");
function isObjectLiteral(source) {
  return source != null && typeof source === "object" && !Array.isArray(source);
}
__name(isObjectLiteral, "isObjectLiteral");
function isImmutableList(source) {
  return Boolean(source && isObjectLiteral(source) && source[IS_LIST_SENTINEL2]);
}
__name(isImmutableList, "isImmutableList");
function isImmutableOrderedKeyed(source) {
  return Boolean(source && isObjectLiteral(source) && source[IS_KEYED_SENTINEL2] && source[IS_ORDERED_SENTINEL2]);
}
__name(isImmutableOrderedKeyed, "isImmutableOrderedKeyed");
function isImmutableOrderedSet(source) {
  return Boolean(source && isObjectLiteral(source) && source[IS_SET_SENTINEL2] && source[IS_ORDERED_SENTINEL2]);
}
__name(isImmutableOrderedSet, "isImmutableOrderedSet");
function isImmutableRecord(source) {
  return Boolean(source && isObjectLiteral(source) && source[IS_RECORD_SYMBOL2]);
}
__name(isImmutableRecord, "isImmutableRecord");
var IteratorSymbol = Symbol.iterator;
function hasIterator(object) {
  return !!(object != null && object[IteratorSymbol]);
}
__name(hasIterator, "hasIterator");
function iterableEquality(a2, b2, customTesters = [], aStack = [], bStack = []) {
  if (typeof a2 !== "object" || typeof b2 !== "object" || Array.isArray(a2) || Array.isArray(b2) || !hasIterator(a2) || !hasIterator(b2)) {
    return void 0;
  }
  if (a2.constructor !== b2.constructor) {
    return false;
  }
  let length = aStack.length;
  while (length--) {
    if (aStack[length] === a2) {
      return bStack[length] === b2;
    }
  }
  aStack.push(a2);
  bStack.push(b2);
  const filteredCustomTesters = [...customTesters.filter((t2) => t2 !== iterableEquality), iterableEqualityWithStack];
  function iterableEqualityWithStack(a3, b3) {
    return iterableEquality(a3, b3, [...customTesters], [...aStack], [...bStack]);
  }
  __name(iterableEqualityWithStack, "iterableEqualityWithStack");
  if (a2.size !== void 0) {
    if (a2.size !== b2.size) {
      return false;
    } else if (isA("Set", a2) || isImmutableUnorderedSet(a2)) {
      let allFound = true;
      for (const aValue of a2) {
        if (!b2.has(aValue)) {
          let has = false;
          for (const bValue of b2) {
            const isEqual3 = equals(aValue, bValue, filteredCustomTesters);
            if (isEqual3 === true) {
              has = true;
            }
          }
          if (has === false) {
            allFound = false;
            break;
          }
        }
      }
      aStack.pop();
      bStack.pop();
      return allFound;
    } else if (isA("Map", a2) || isImmutableUnorderedKeyed(a2)) {
      let allFound = true;
      for (const aEntry of a2) {
        if (!b2.has(aEntry[0]) || !equals(aEntry[1], b2.get(aEntry[0]), filteredCustomTesters)) {
          let has = false;
          for (const bEntry of b2) {
            const matchedKey = equals(aEntry[0], bEntry[0], filteredCustomTesters);
            let matchedValue = false;
            if (matchedKey === true) {
              matchedValue = equals(aEntry[1], bEntry[1], filteredCustomTesters);
            }
            if (matchedValue === true) {
              has = true;
            }
          }
          if (has === false) {
            allFound = false;
            break;
          }
        }
      }
      aStack.pop();
      bStack.pop();
      return allFound;
    }
  }
  const bIterator = b2[IteratorSymbol]();
  for (const aValue of a2) {
    const nextB = bIterator.next();
    if (nextB.done || !equals(aValue, nextB.value, filteredCustomTesters)) {
      return false;
    }
  }
  if (!bIterator.next().done) {
    return false;
  }
  if (!isImmutableList(a2) && !isImmutableOrderedKeyed(a2) && !isImmutableOrderedSet(a2) && !isImmutableRecord(a2)) {
    const aEntries = Object.entries(a2);
    const bEntries = Object.entries(b2);
    if (!equals(aEntries, bEntries, filteredCustomTesters)) {
      return false;
    }
  }
  aStack.pop();
  bStack.pop();
  return true;
}
__name(iterableEquality, "iterableEquality");
function hasPropertyInObject(object, key) {
  const shouldTerminate = !object || typeof object !== "object" || object === Object.prototype;
  if (shouldTerminate) {
    return false;
  }
  return Object.prototype.hasOwnProperty.call(object, key) || hasPropertyInObject(Object.getPrototypeOf(object), key);
}
__name(hasPropertyInObject, "hasPropertyInObject");
function isObjectWithKeys(a2) {
  return isObject4(a2) && !(a2 instanceof Error) && !Array.isArray(a2) && !(a2 instanceof Date);
}
__name(isObjectWithKeys, "isObjectWithKeys");
function subsetEquality(object, subset, customTesters = []) {
  const filteredCustomTesters = customTesters.filter((t2) => t2 !== subsetEquality);
  const subsetEqualityWithContext = /* @__PURE__ */ __name((seenReferences = /* @__PURE__ */ new WeakMap()) => (object2, subset2) => {
    if (!isObjectWithKeys(subset2)) {
      return void 0;
    }
    return Object.keys(subset2).every((key) => {
      if (subset2[key] != null && typeof subset2[key] === "object") {
        if (seenReferences.has(subset2[key])) {
          return equals(object2[key], subset2[key], filteredCustomTesters);
        }
        seenReferences.set(subset2[key], true);
      }
      const result = object2 != null && hasPropertyInObject(object2, key) && equals(object2[key], subset2[key], [...filteredCustomTesters, subsetEqualityWithContext(seenReferences)]);
      seenReferences.delete(subset2[key]);
      return result;
    });
  }, "subsetEqualityWithContext");
  return subsetEqualityWithContext()(object, subset);
}
__name(subsetEquality, "subsetEquality");
function typeEquality(a2, b2) {
  if (a2 == null || b2 == null || a2.constructor === b2.constructor) {
    return void 0;
  }
  return false;
}
__name(typeEquality, "typeEquality");
function arrayBufferEquality(a2, b2) {
  let dataViewA = a2;
  let dataViewB = b2;
  if (!(a2 instanceof DataView && b2 instanceof DataView)) {
    if (!(a2 instanceof ArrayBuffer) || !(b2 instanceof ArrayBuffer)) {
      return void 0;
    }
    try {
      dataViewA = new DataView(a2);
      dataViewB = new DataView(b2);
    } catch {
      return void 0;
    }
  }
  if (dataViewA.byteLength !== dataViewB.byteLength) {
    return false;
  }
  for (let i2 = 0; i2 < dataViewA.byteLength; i2++) {
    if (dataViewA.getUint8(i2) !== dataViewB.getUint8(i2)) {
      return false;
    }
  }
  return true;
}
__name(arrayBufferEquality, "arrayBufferEquality");
function sparseArrayEquality(a2, b2, customTesters = []) {
  if (!Array.isArray(a2) || !Array.isArray(b2)) {
    return void 0;
  }
  const aKeys = Object.keys(a2);
  const bKeys = Object.keys(b2);
  const filteredCustomTesters = customTesters.filter((t2) => t2 !== sparseArrayEquality);
  return equals(a2, b2, filteredCustomTesters, true) && equals(aKeys, bKeys);
}
__name(sparseArrayEquality, "sparseArrayEquality");
function generateToBeMessage(deepEqualityName, expected = "#{this}", actual = "#{exp}") {
  const toBeMessage = `expected ${expected} to be ${actual} // Object.is equality`;
  if (["toStrictEqual", "toEqual"].includes(deepEqualityName)) {
    return `${toBeMessage}

If it should pass with deep equality, replace "toBe" with "${deepEqualityName}"

Expected: ${expected}
Received: serializes to the same string
`;
  }
  return toBeMessage;
}
__name(generateToBeMessage, "generateToBeMessage");
function pluralize(word, count2) {
  return `${count2} ${word}${count2 === 1 ? "" : "s"}`;
}
__name(pluralize, "pluralize");
function getObjectKeys(object) {
  return [...Object.keys(object), ...Object.getOwnPropertySymbols(object).filter((s3) => {
    var _Object$getOwnPropert;
    return (_Object$getOwnPropert = Object.getOwnPropertyDescriptor(object, s3)) === null || _Object$getOwnPropert === void 0 ? void 0 : _Object$getOwnPropert.enumerable;
  })];
}
__name(getObjectKeys, "getObjectKeys");
function getObjectSubset(object, subset, customTesters) {
  let stripped = 0;
  const getObjectSubsetWithContext = /* @__PURE__ */ __name((seenReferences = /* @__PURE__ */ new WeakMap()) => (object2, subset2) => {
    if (Array.isArray(object2)) {
      if (Array.isArray(subset2) && subset2.length === object2.length) {
        return subset2.map((sub, i2) => getObjectSubsetWithContext(seenReferences)(object2[i2], sub));
      }
    } else if (object2 instanceof Date) {
      return object2;
    } else if (isObject4(object2) && isObject4(subset2)) {
      if (equals(object2, subset2, [
        ...customTesters,
        iterableEquality,
        subsetEquality
      ])) {
        return subset2;
      }
      const trimmed = {};
      seenReferences.set(object2, trimmed);
      if (typeof object2.constructor === "function" && typeof object2.constructor.name === "string") {
        Object.defineProperty(trimmed, "constructor", {
          enumerable: false,
          value: object2.constructor
        });
      }
      for (const key of getObjectKeys(object2)) {
        if (hasPropertyInObject(subset2, key)) {
          trimmed[key] = seenReferences.has(object2[key]) ? seenReferences.get(object2[key]) : getObjectSubsetWithContext(seenReferences)(object2[key], subset2[key]);
        } else {
          if (!seenReferences.has(object2[key])) {
            stripped += 1;
            if (isObject4(object2[key])) {
              stripped += getObjectKeys(object2[key]).length;
            }
            getObjectSubsetWithContext(seenReferences)(object2[key], subset2[key]);
          }
        }
      }
      if (getObjectKeys(trimmed).length > 0) {
        return trimmed;
      }
    }
    return object2;
  }, "getObjectSubsetWithContext");
  return {
    subset: getObjectSubsetWithContext()(object, subset),
    stripped
  };
}
__name(getObjectSubset, "getObjectSubset");
if (!Object.prototype.hasOwnProperty.call(globalThis, MATCHERS_OBJECT)) {
  const globalState = /* @__PURE__ */ new WeakMap();
  Object.defineProperty(globalThis, MATCHERS_OBJECT, { get: /* @__PURE__ */ __name(() => globalState, "get") });
}
if (!Object.prototype.hasOwnProperty.call(globalThis, JEST_MATCHERS_OBJECT)) {
  const matchers = /* @__PURE__ */ Object.create(null);
  const customEqualityTesters = [];
  Object.defineProperty(globalThis, JEST_MATCHERS_OBJECT, {
    configurable: true,
    get: /* @__PURE__ */ __name(() => ({
      state: globalThis[MATCHERS_OBJECT].get(globalThis[GLOBAL_EXPECT]),
      matchers,
      customEqualityTesters
    }), "get")
  });
}
if (!Object.prototype.hasOwnProperty.call(globalThis, ASYMMETRIC_MATCHERS_OBJECT)) {
  const asymmetricMatchers = /* @__PURE__ */ Object.create(null);
  Object.defineProperty(globalThis, ASYMMETRIC_MATCHERS_OBJECT, { get: /* @__PURE__ */ __name(() => asymmetricMatchers, "get") });
}
function getState(expect4) {
  return globalThis[MATCHERS_OBJECT].get(expect4);
}
__name(getState, "getState");
function setState(state3, expect4) {
  const map2 = globalThis[MATCHERS_OBJECT];
  const current = map2.get(expect4) || {};
  const results = Object.defineProperties(current, {
    ...Object.getOwnPropertyDescriptors(current),
    ...Object.getOwnPropertyDescriptors(state3)
  });
  map2.set(expect4, results);
}
__name(setState, "setState");
var _AsymmetricMatcher = class _AsymmetricMatcher {
  // should have "jest" to be compatible with its ecosystem
  $$typeof = Symbol.for("jest.asymmetricMatcher");
  constructor(sample, inverse = false) {
    this.sample = sample;
    this.inverse = inverse;
  }
  getMatcherContext(expect4) {
    return {
      ...getState(expect4 || globalThis[GLOBAL_EXPECT]),
      equals,
      isNot: this.inverse,
      customTesters: getCustomEqualityTesters(),
      utils: {
        ...getMatcherUtils(),
        diff,
        stringify: stringify2,
        iterableEquality,
        subsetEquality
      }
    };
  }
};
__name(_AsymmetricMatcher, "AsymmetricMatcher");
var AsymmetricMatcher3 = _AsymmetricMatcher;
AsymmetricMatcher3.prototype[Symbol.for("chai/inspect")] = function(options) {
  const result = stringify2(this, options.depth, { min: true });
  if (result.length <= options.truncate) {
    return result;
  }
  return `${this.toString()}{\u2026}`;
};
var _StringContaining = class _StringContaining extends AsymmetricMatcher3 {
  constructor(sample, inverse = false) {
    if (!isA("String", sample)) {
      throw new Error("Expected is not a string");
    }
    super(sample, inverse);
  }
  asymmetricMatch(other) {
    const result = isA("String", other) && other.includes(this.sample);
    return this.inverse ? !result : result;
  }
  toString() {
    return `String${this.inverse ? "Not" : ""}Containing`;
  }
  getExpectedType() {
    return "string";
  }
};
__name(_StringContaining, "StringContaining");
var StringContaining = _StringContaining;
var _Anything = class _Anything extends AsymmetricMatcher3 {
  asymmetricMatch(other) {
    return other != null;
  }
  toString() {
    return "Anything";
  }
  toAsymmetricMatcher() {
    return "Anything";
  }
};
__name(_Anything, "Anything");
var Anything = _Anything;
var _ObjectContaining = class _ObjectContaining extends AsymmetricMatcher3 {
  constructor(sample, inverse = false) {
    super(sample, inverse);
  }
  getPrototype(obj) {
    if (Object.getPrototypeOf) {
      return Object.getPrototypeOf(obj);
    }
    if (obj.constructor.prototype === obj) {
      return null;
    }
    return obj.constructor.prototype;
  }
  hasProperty(obj, property) {
    if (!obj) {
      return false;
    }
    if (Object.prototype.hasOwnProperty.call(obj, property)) {
      return true;
    }
    return this.hasProperty(this.getPrototype(obj), property);
  }
  asymmetricMatch(other) {
    if (typeof this.sample !== "object") {
      throw new TypeError(`You must provide an object to ${this.toString()}, not '${typeof this.sample}'.`);
    }
    let result = true;
    const matcherContext = this.getMatcherContext();
    for (const property in this.sample) {
      if (!this.hasProperty(other, property) || !equals(this.sample[property], other[property], matcherContext.customTesters)) {
        result = false;
        break;
      }
    }
    return this.inverse ? !result : result;
  }
  toString() {
    return `Object${this.inverse ? "Not" : ""}Containing`;
  }
  getExpectedType() {
    return "object";
  }
};
__name(_ObjectContaining, "ObjectContaining");
var ObjectContaining = _ObjectContaining;
var _ArrayContaining = class _ArrayContaining extends AsymmetricMatcher3 {
  constructor(sample, inverse = false) {
    super(sample, inverse);
  }
  asymmetricMatch(other) {
    if (!Array.isArray(this.sample)) {
      throw new TypeError(`You must provide an array to ${this.toString()}, not '${typeof this.sample}'.`);
    }
    const matcherContext = this.getMatcherContext();
    const result = this.sample.length === 0 || Array.isArray(other) && this.sample.every((item) => other.some((another) => equals(item, another, matcherContext.customTesters)));
    return this.inverse ? !result : result;
  }
  toString() {
    return `Array${this.inverse ? "Not" : ""}Containing`;
  }
  getExpectedType() {
    return "array";
  }
};
__name(_ArrayContaining, "ArrayContaining");
var ArrayContaining = _ArrayContaining;
var _Any = class _Any extends AsymmetricMatcher3 {
  constructor(sample) {
    if (typeof sample === "undefined") {
      throw new TypeError("any() expects to be passed a constructor function. Please pass one or use anything() to match any object.");
    }
    super(sample);
  }
  fnNameFor(func) {
    if (func.name) {
      return func.name;
    }
    const functionToString2 = Function.prototype.toString;
    const matches5 = functionToString2.call(func).match(/^(?:async)?\s*function\s*(?:\*\s*)?([\w$]+)\s*\(/);
    return matches5 ? matches5[1] : "<anonymous>";
  }
  asymmetricMatch(other) {
    if (this.sample === String) {
      return typeof other == "string" || other instanceof String;
    }
    if (this.sample === Number) {
      return typeof other == "number" || other instanceof Number;
    }
    if (this.sample === Function) {
      return typeof other == "function" || typeof other === "function";
    }
    if (this.sample === Boolean) {
      return typeof other == "boolean" || other instanceof Boolean;
    }
    if (this.sample === BigInt) {
      return typeof other == "bigint" || other instanceof BigInt;
    }
    if (this.sample === Symbol) {
      return typeof other == "symbol" || other instanceof Symbol;
    }
    if (this.sample === Object) {
      return typeof other == "object";
    }
    return other instanceof this.sample;
  }
  toString() {
    return "Any";
  }
  getExpectedType() {
    if (this.sample === String) {
      return "string";
    }
    if (this.sample === Number) {
      return "number";
    }
    if (this.sample === Function) {
      return "function";
    }
    if (this.sample === Object) {
      return "object";
    }
    if (this.sample === Boolean) {
      return "boolean";
    }
    return this.fnNameFor(this.sample);
  }
  toAsymmetricMatcher() {
    return `Any<${this.fnNameFor(this.sample)}>`;
  }
};
__name(_Any, "Any");
var Any = _Any;
var _StringMatching = class _StringMatching extends AsymmetricMatcher3 {
  constructor(sample, inverse = false) {
    if (!isA("String", sample) && !isA("RegExp", sample)) {
      throw new Error("Expected is not a String or a RegExp");
    }
    super(new RegExp(sample), inverse);
  }
  asymmetricMatch(other) {
    const result = isA("String", other) && this.sample.test(other);
    return this.inverse ? !result : result;
  }
  toString() {
    return `String${this.inverse ? "Not" : ""}Matching`;
  }
  getExpectedType() {
    return "string";
  }
};
__name(_StringMatching, "StringMatching");
var StringMatching = _StringMatching;
var _CloseTo = class _CloseTo extends AsymmetricMatcher3 {
  precision;
  constructor(sample, precision = 2, inverse = false) {
    if (!isA("Number", sample)) {
      throw new Error("Expected is not a Number");
    }
    if (!isA("Number", precision)) {
      throw new Error("Precision is not a Number");
    }
    super(sample);
    this.inverse = inverse;
    this.precision = precision;
  }
  asymmetricMatch(other) {
    if (!isA("Number", other)) {
      return false;
    }
    let result = false;
    if (other === Number.POSITIVE_INFINITY && this.sample === Number.POSITIVE_INFINITY) {
      result = true;
    } else if (other === Number.NEGATIVE_INFINITY && this.sample === Number.NEGATIVE_INFINITY) {
      result = true;
    } else {
      result = Math.abs(this.sample - other) < 10 ** -this.precision / 2;
    }
    return this.inverse ? !result : result;
  }
  toString() {
    return `Number${this.inverse ? "Not" : ""}CloseTo`;
  }
  getExpectedType() {
    return "number";
  }
  toAsymmetricMatcher() {
    return [
      this.toString(),
      this.sample,
      `(${pluralize("digit", this.precision)})`
    ].join(" ");
  }
};
__name(_CloseTo, "CloseTo");
var CloseTo = _CloseTo;
var JestAsymmetricMatchers = /* @__PURE__ */ __name((chai, utils) => {
  utils.addMethod(chai.expect, "anything", () => new Anything());
  utils.addMethod(chai.expect, "any", (expected) => new Any(expected));
  utils.addMethod(chai.expect, "stringContaining", (expected) => new StringContaining(expected));
  utils.addMethod(chai.expect, "objectContaining", (expected) => new ObjectContaining(expected));
  utils.addMethod(chai.expect, "arrayContaining", (expected) => new ArrayContaining(expected));
  utils.addMethod(chai.expect, "stringMatching", (expected) => new StringMatching(expected));
  utils.addMethod(chai.expect, "closeTo", (expected, precision) => new CloseTo(expected, precision));
  chai.expect.not = {
    stringContaining: /* @__PURE__ */ __name((expected) => new StringContaining(expected, true), "stringContaining"),
    objectContaining: /* @__PURE__ */ __name((expected) => new ObjectContaining(expected, true), "objectContaining"),
    arrayContaining: /* @__PURE__ */ __name((expected) => new ArrayContaining(expected, true), "arrayContaining"),
    stringMatching: /* @__PURE__ */ __name((expected) => new StringMatching(expected, true), "stringMatching"),
    closeTo: /* @__PURE__ */ __name((expected, precision) => new CloseTo(expected, precision, true), "closeTo")
  };
}, "JestAsymmetricMatchers");
function createAssertionMessage(util, assertion, hasArgs) {
  const not = util.flag(assertion, "negate") ? "not." : "";
  const name = `${util.flag(assertion, "_name")}(${hasArgs ? "expected" : ""})`;
  const promiseName = util.flag(assertion, "promise");
  const promise = promiseName ? `.${promiseName}` : "";
  return `expect(actual)${promise}.${not}${name}`;
}
__name(createAssertionMessage, "createAssertionMessage");
function recordAsyncExpect(_test, promise, assertion, error) {
  const test3 = _test;
  if (test3 && promise instanceof Promise) {
    promise = promise.finally(() => {
      if (!test3.promises) {
        return;
      }
      const index2 = test3.promises.indexOf(promise);
      if (index2 !== -1) {
        test3.promises.splice(index2, 1);
      }
    });
    if (!test3.promises) {
      test3.promises = [];
    }
    test3.promises.push(promise);
    let resolved = false;
    test3.onFinished ?? (test3.onFinished = []);
    test3.onFinished.push(() => {
      if (!resolved) {
        var _vitest_worker__;
        const processor = ((_vitest_worker__ = globalThis.__vitest_worker__) === null || _vitest_worker__ === void 0 ? void 0 : _vitest_worker__.onFilterStackTrace) || ((s3) => s3 || "");
        const stack = processor(error.stack);
        console.warn([
          `Promise returned by \`${assertion}\` was not awaited. `,
          "Vitest currently auto-awaits hanging assertions at the end of the test, but this will cause the test to fail in Vitest 3. ",
          "Please remember to await the assertion.\n",
          stack
        ].join(""));
      }
    });
    return {
      then(onFulfilled, onRejected) {
        resolved = true;
        return promise.then(onFulfilled, onRejected);
      },
      catch(onRejected) {
        return promise.catch(onRejected);
      },
      finally(onFinally) {
        return promise.finally(onFinally);
      },
      [Symbol.toStringTag]: "Promise"
    };
  }
  return promise;
}
__name(recordAsyncExpect, "recordAsyncExpect");
function handleTestError(test3, err) {
  var _test$result;
  test3.result || (test3.result = { state: "fail" });
  test3.result.state = "fail";
  (_test$result = test3.result).errors || (_test$result.errors = []);
  test3.result.errors.push(processError(err));
}
__name(handleTestError, "handleTestError");
function wrapAssertion(utils, name, fn3) {
  return function(...args) {
    if (name !== "withTest") {
      utils.flag(this, "_name", name);
    }
    if (!utils.flag(this, "soft")) {
      return fn3.apply(this, args);
    }
    const test3 = utils.flag(this, "vitest-test");
    if (!test3) {
      throw new Error("expect.soft() can only be used inside a test");
    }
    try {
      const result = fn3.apply(this, args);
      if (result && typeof result === "object" && typeof result.then === "function") {
        return result.then(noop, (err) => {
          handleTestError(test3, err);
        });
      }
      return result;
    } catch (err) {
      handleTestError(test3, err);
    }
  };
}
__name(wrapAssertion, "wrapAssertion");
var JestChaiExpect = /* @__PURE__ */ __name((chai, utils) => {
  const { AssertionError: AssertionError2 } = chai;
  const customTesters = getCustomEqualityTesters();
  function def(name, fn3) {
    const addMethod2 = /* @__PURE__ */ __name((n2) => {
      const softWrapper = wrapAssertion(utils, n2, fn3);
      utils.addMethod(chai.Assertion.prototype, n2, softWrapper);
      utils.addMethod(globalThis[JEST_MATCHERS_OBJECT].matchers, n2, softWrapper);
    }, "addMethod");
    if (Array.isArray(name)) {
      name.forEach((n2) => addMethod2(n2));
    } else {
      addMethod2(name);
    }
  }
  __name(def, "def");
  [
    "throw",
    "throws",
    "Throw"
  ].forEach((m3) => {
    utils.overwriteMethod(chai.Assertion.prototype, m3, (_super) => {
      return function(...args) {
        const promise = utils.flag(this, "promise");
        const object = utils.flag(this, "object");
        const isNot = utils.flag(this, "negate");
        if (promise === "rejects") {
          utils.flag(this, "object", () => {
            throw object;
          });
        } else if (promise === "resolves" && typeof object !== "function") {
          if (!isNot) {
            const message = utils.flag(this, "message") || "expected promise to throw an error, but it didn't";
            const error = { showDiff: false };
            throw new AssertionError2(message, error, utils.flag(this, "ssfi"));
          } else {
            return;
          }
        }
        _super.apply(this, args);
      };
    });
  });
  def("withTest", function(test3) {
    utils.flag(this, "vitest-test", test3);
    return this;
  });
  def("toEqual", function(expected) {
    const actual = utils.flag(this, "object");
    const equal = equals(actual, expected, [...customTesters, iterableEquality]);
    return this.assert(equal, "expected #{this} to deeply equal #{exp}", "expected #{this} to not deeply equal #{exp}", expected, actual);
  });
  def("toStrictEqual", function(expected) {
    const obj = utils.flag(this, "object");
    const equal = equals(obj, expected, [
      ...customTesters,
      iterableEquality,
      typeEquality,
      sparseArrayEquality,
      arrayBufferEquality
    ], true);
    return this.assert(equal, "expected #{this} to strictly equal #{exp}", "expected #{this} to not strictly equal #{exp}", expected, obj);
  });
  def("toBe", function(expected) {
    const actual = this._obj;
    const pass = Object.is(actual, expected);
    let deepEqualityName = "";
    if (!pass) {
      const toStrictEqualPass = equals(actual, expected, [
        ...customTesters,
        iterableEquality,
        typeEquality,
        sparseArrayEquality,
        arrayBufferEquality
      ], true);
      if (toStrictEqualPass) {
        deepEqualityName = "toStrictEqual";
      } else {
        const toEqualPass = equals(actual, expected, [...customTesters, iterableEquality]);
        if (toEqualPass) {
          deepEqualityName = "toEqual";
        }
      }
    }
    return this.assert(pass, generateToBeMessage(deepEqualityName), "expected #{this} not to be #{exp} // Object.is equality", expected, actual);
  });
  def("toMatchObject", function(expected) {
    const actual = this._obj;
    const pass = equals(actual, expected, [
      ...customTesters,
      iterableEquality,
      subsetEquality
    ]);
    const isNot = utils.flag(this, "negate");
    const { subset: actualSubset, stripped } = getObjectSubset(actual, expected, customTesters);
    if (pass && isNot || !pass && !isNot) {
      const msg = utils.getMessage(this, [
        pass,
        "expected #{this} to match object #{exp}",
        "expected #{this} to not match object #{exp}",
        expected,
        actualSubset,
        false
      ]);
      const message = stripped === 0 ? msg : `${msg}
(${stripped} matching ${stripped === 1 ? "property" : "properties"} omitted from actual)`;
      throw new AssertionError2(message, {
        showDiff: true,
        expected,
        actual: actualSubset
      });
    }
  });
  def("toMatch", function(expected) {
    const actual = this._obj;
    if (typeof actual !== "string") {
      throw new TypeError(`.toMatch() expects to receive a string, but got ${typeof actual}`);
    }
    return this.assert(typeof expected === "string" ? actual.includes(expected) : actual.match(expected), `expected #{this} to match #{exp}`, `expected #{this} not to match #{exp}`, expected, actual);
  });
  def("toContain", function(item) {
    const actual = this._obj;
    if (typeof Node !== "undefined" && actual instanceof Node) {
      if (!(item instanceof Node)) {
        throw new TypeError(`toContain() expected a DOM node as the argument, but got ${typeof item}`);
      }
      return this.assert(actual.contains(item), "expected #{this} to contain element #{exp}", "expected #{this} not to contain element #{exp}", item, actual);
    }
    if (typeof DOMTokenList !== "undefined" && actual instanceof DOMTokenList) {
      assertTypes(item, "class name", ["string"]);
      const isNot = utils.flag(this, "negate");
      const expectedClassList = isNot ? actual.value.replace(item, "").trim() : `${actual.value} ${item}`;
      return this.assert(actual.contains(item), `expected "${actual.value}" to contain "${item}"`, `expected "${actual.value}" not to contain "${item}"`, expectedClassList, actual.value);
    }
    if (typeof actual === "string" && typeof item === "string") {
      return this.assert(actual.includes(item), `expected #{this} to contain #{exp}`, `expected #{this} not to contain #{exp}`, item, actual);
    }
    if (actual != null && typeof actual !== "string") {
      utils.flag(this, "object", Array.from(actual));
    }
    return this.contain(item);
  });
  def("toContainEqual", function(expected) {
    const obj = utils.flag(this, "object");
    const index2 = Array.from(obj).findIndex((item) => {
      return equals(item, expected, customTesters);
    });
    this.assert(index2 !== -1, "expected #{this} to deep equally contain #{exp}", "expected #{this} to not deep equally contain #{exp}", expected);
  });
  def("toBeTruthy", function() {
    const obj = utils.flag(this, "object");
    this.assert(Boolean(obj), "expected #{this} to be truthy", "expected #{this} to not be truthy", true, obj);
  });
  def("toBeFalsy", function() {
    const obj = utils.flag(this, "object");
    this.assert(!obj, "expected #{this} to be falsy", "expected #{this} to not be falsy", false, obj);
  });
  def("toBeGreaterThan", function(expected) {
    const actual = this._obj;
    assertTypes(actual, "actual", ["number", "bigint"]);
    assertTypes(expected, "expected", ["number", "bigint"]);
    return this.assert(actual > expected, `expected ${actual} to be greater than ${expected}`, `expected ${actual} to be not greater than ${expected}`, expected, actual, false);
  });
  def("toBeGreaterThanOrEqual", function(expected) {
    const actual = this._obj;
    assertTypes(actual, "actual", ["number", "bigint"]);
    assertTypes(expected, "expected", ["number", "bigint"]);
    return this.assert(actual >= expected, `expected ${actual} to be greater than or equal to ${expected}`, `expected ${actual} to be not greater than or equal to ${expected}`, expected, actual, false);
  });
  def("toBeLessThan", function(expected) {
    const actual = this._obj;
    assertTypes(actual, "actual", ["number", "bigint"]);
    assertTypes(expected, "expected", ["number", "bigint"]);
    return this.assert(actual < expected, `expected ${actual} to be less than ${expected}`, `expected ${actual} to be not less than ${expected}`, expected, actual, false);
  });
  def("toBeLessThanOrEqual", function(expected) {
    const actual = this._obj;
    assertTypes(actual, "actual", ["number", "bigint"]);
    assertTypes(expected, "expected", ["number", "bigint"]);
    return this.assert(actual <= expected, `expected ${actual} to be less than or equal to ${expected}`, `expected ${actual} to be not less than or equal to ${expected}`, expected, actual, false);
  });
  def("toBeNaN", function() {
    const obj = utils.flag(this, "object");
    this.assert(Number.isNaN(obj), "expected #{this} to be NaN", "expected #{this} not to be NaN", Number.NaN, obj);
  });
  def("toBeUndefined", function() {
    const obj = utils.flag(this, "object");
    this.assert(void 0 === obj, "expected #{this} to be undefined", "expected #{this} not to be undefined", void 0, obj);
  });
  def("toBeNull", function() {
    const obj = utils.flag(this, "object");
    this.assert(obj === null, "expected #{this} to be null", "expected #{this} not to be null", null, obj);
  });
  def("toBeDefined", function() {
    const obj = utils.flag(this, "object");
    this.assert(typeof obj !== "undefined", "expected #{this} to be defined", "expected #{this} to be undefined", obj);
  });
  def("toBeTypeOf", function(expected) {
    const actual = typeof this._obj;
    const equal = expected === actual;
    return this.assert(equal, "expected #{this} to be type of #{exp}", "expected #{this} not to be type of #{exp}", expected, actual);
  });
  def("toBeInstanceOf", function(obj) {
    return this.instanceOf(obj);
  });
  def("toHaveLength", function(length) {
    return this.have.length(length);
  });
  def("toHaveProperty", function(...args) {
    if (Array.isArray(args[0])) {
      args[0] = args[0].map((key) => String(key).replace(/([.[\]])/g, "\\$1")).join(".");
    }
    const actual = this._obj;
    const [propertyName, expected] = args;
    const getValue2 = /* @__PURE__ */ __name(() => {
      const hasOwn = Object.prototype.hasOwnProperty.call(actual, propertyName);
      if (hasOwn) {
        return {
          value: actual[propertyName],
          exists: true
        };
      }
      return utils.getPathInfo(actual, propertyName);
    }, "getValue");
    const { value, exists } = getValue2();
    const pass = exists && (args.length === 1 || equals(expected, value, customTesters));
    const valueString = args.length === 1 ? "" : ` with value ${utils.objDisplay(expected)}`;
    return this.assert(pass, `expected #{this} to have property "${propertyName}"${valueString}`, `expected #{this} to not have property "${propertyName}"${valueString}`, expected, exists ? value : void 0);
  });
  def("toBeCloseTo", function(received, precision = 2) {
    const expected = this._obj;
    let pass = false;
    let expectedDiff2 = 0;
    let receivedDiff = 0;
    if (received === Number.POSITIVE_INFINITY && expected === Number.POSITIVE_INFINITY) {
      pass = true;
    } else if (received === Number.NEGATIVE_INFINITY && expected === Number.NEGATIVE_INFINITY) {
      pass = true;
    } else {
      expectedDiff2 = 10 ** -precision / 2;
      receivedDiff = Math.abs(expected - received);
      pass = receivedDiff < expectedDiff2;
    }
    return this.assert(pass, `expected #{this} to be close to #{exp}, received difference is ${receivedDiff}, but expected ${expectedDiff2}`, `expected #{this} to not be close to #{exp}, received difference is ${receivedDiff}, but expected ${expectedDiff2}`, received, expected, false);
  });
  function assertIsMock(assertion) {
    if (!isMockFunction(assertion._obj)) {
      throw new TypeError(`${utils.inspect(assertion._obj)} is not a spy or a call to a spy!`);
    }
  }
  __name(assertIsMock, "assertIsMock");
  function getSpy(assertion) {
    assertIsMock(assertion);
    return assertion._obj;
  }
  __name(getSpy, "getSpy");
  def(["toHaveBeenCalledTimes", "toBeCalledTimes"], function(number) {
    const spy = getSpy(this);
    const spyName = spy.getMockName();
    const callCount = spy.mock.calls.length;
    return this.assert(callCount === number, `expected "${spyName}" to be called #{exp} times, but got ${callCount} times`, `expected "${spyName}" to not be called #{exp} times`, number, callCount, false);
  });
  def("toHaveBeenCalledOnce", function() {
    const spy = getSpy(this);
    const spyName = spy.getMockName();
    const callCount = spy.mock.calls.length;
    return this.assert(callCount === 1, `expected "${spyName}" to be called once, but got ${callCount} times`, `expected "${spyName}" to not be called once`, 1, callCount, false);
  });
  def(["toHaveBeenCalled", "toBeCalled"], function() {
    const spy = getSpy(this);
    const spyName = spy.getMockName();
    const callCount = spy.mock.calls.length;
    const called = callCount > 0;
    const isNot = utils.flag(this, "negate");
    let msg = utils.getMessage(this, [
      called,
      `expected "${spyName}" to be called at least once`,
      `expected "${spyName}" to not be called at all, but actually been called ${callCount} times`,
      true,
      called
    ]);
    if (called && isNot) {
      msg = formatCalls(spy, msg);
    }
    if (called && isNot || !called && !isNot) {
      throw new AssertionError2(msg);
    }
  });
  function equalsArgumentArray(a2, b2) {
    return a2.length === b2.length && a2.every((aItem, i2) => equals(aItem, b2[i2], [...customTesters, iterableEquality]));
  }
  __name(equalsArgumentArray, "equalsArgumentArray");
  def(["toHaveBeenCalledWith", "toBeCalledWith"], function(...args) {
    const spy = getSpy(this);
    const spyName = spy.getMockName();
    const pass = spy.mock.calls.some((callArg) => equalsArgumentArray(callArg, args));
    const isNot = utils.flag(this, "negate");
    const msg = utils.getMessage(this, [
      pass,
      `expected "${spyName}" to be called with arguments: #{exp}`,
      `expected "${spyName}" to not be called with arguments: #{exp}`,
      args
    ]);
    if (pass && isNot || !pass && !isNot) {
      throw new AssertionError2(formatCalls(spy, msg, args));
    }
  });
  def("toHaveBeenCalledExactlyOnceWith", function(...args) {
    const spy = getSpy(this);
    const spyName = spy.getMockName();
    const callCount = spy.mock.calls.length;
    const hasCallWithArgs = spy.mock.calls.some((callArg) => equalsArgumentArray(callArg, args));
    const pass = hasCallWithArgs && callCount === 1;
    const isNot = utils.flag(this, "negate");
    const msg = utils.getMessage(this, [
      pass,
      `expected "${spyName}" to be called once with arguments: #{exp}`,
      `expected "${spyName}" to not be called once with arguments: #{exp}`,
      args
    ]);
    if (pass && isNot || !pass && !isNot) {
      throw new AssertionError2(formatCalls(spy, msg, args));
    }
  });
  def(["toHaveBeenNthCalledWith", "nthCalledWith"], function(times, ...args) {
    const spy = getSpy(this);
    const spyName = spy.getMockName();
    const nthCall = spy.mock.calls[times - 1];
    const callCount = spy.mock.calls.length;
    const isCalled = times <= callCount;
    this.assert(nthCall && equalsArgumentArray(nthCall, args), `expected ${ordinalOf(times)} "${spyName}" call to have been called with #{exp}${isCalled ? `` : `, but called only ${callCount} times`}`, `expected ${ordinalOf(times)} "${spyName}" call to not have been called with #{exp}`, args, nthCall, isCalled);
  });
  def(["toHaveBeenLastCalledWith", "lastCalledWith"], function(...args) {
    const spy = getSpy(this);
    const spyName = spy.getMockName();
    const lastCall = spy.mock.calls[spy.mock.calls.length - 1];
    this.assert(lastCall && equalsArgumentArray(lastCall, args), `expected last "${spyName}" call to have been called with #{exp}`, `expected last "${spyName}" call to not have been called with #{exp}`, args, lastCall);
  });
  function isSpyCalledBeforeAnotherSpy(beforeSpy, afterSpy, failIfNoFirstInvocation) {
    const beforeInvocationCallOrder = beforeSpy.mock.invocationCallOrder;
    const afterInvocationCallOrder = afterSpy.mock.invocationCallOrder;
    if (beforeInvocationCallOrder.length === 0) {
      return !failIfNoFirstInvocation;
    }
    if (afterInvocationCallOrder.length === 0) {
      return false;
    }
    return beforeInvocationCallOrder[0] < afterInvocationCallOrder[0];
  }
  __name(isSpyCalledBeforeAnotherSpy, "isSpyCalledBeforeAnotherSpy");
  def(["toHaveBeenCalledBefore"], function(resultSpy, failIfNoFirstInvocation = true) {
    const expectSpy = getSpy(this);
    if (!isMockFunction(resultSpy)) {
      throw new TypeError(`${utils.inspect(resultSpy)} is not a spy or a call to a spy`);
    }
    this.assert(isSpyCalledBeforeAnotherSpy(expectSpy, resultSpy, failIfNoFirstInvocation), `expected "${expectSpy.getMockName()}" to have been called before "${resultSpy.getMockName()}"`, `expected "${expectSpy.getMockName()}" to not have been called before "${resultSpy.getMockName()}"`, resultSpy, expectSpy);
  });
  def(["toHaveBeenCalledAfter"], function(resultSpy, failIfNoFirstInvocation = true) {
    const expectSpy = getSpy(this);
    if (!isMockFunction(resultSpy)) {
      throw new TypeError(`${utils.inspect(resultSpy)} is not a spy or a call to a spy`);
    }
    this.assert(isSpyCalledBeforeAnotherSpy(resultSpy, expectSpy, failIfNoFirstInvocation), `expected "${expectSpy.getMockName()}" to have been called after "${resultSpy.getMockName()}"`, `expected "${expectSpy.getMockName()}" to not have been called after "${resultSpy.getMockName()}"`, resultSpy, expectSpy);
  });
  def(["toThrow", "toThrowError"], function(expected) {
    if (typeof expected === "string" || typeof expected === "undefined" || expected instanceof RegExp) {
      return this.throws(expected === "" ? /^$/ : expected);
    }
    const obj = this._obj;
    const promise = utils.flag(this, "promise");
    const isNot = utils.flag(this, "negate");
    let thrown = null;
    if (promise === "rejects") {
      thrown = obj;
    } else if (promise === "resolves" && typeof obj !== "function") {
      if (!isNot) {
        const message = utils.flag(this, "message") || "expected promise to throw an error, but it didn't";
        const error = { showDiff: false };
        throw new AssertionError2(message, error, utils.flag(this, "ssfi"));
      } else {
        return;
      }
    } else {
      let isThrow = false;
      try {
        obj();
      } catch (err) {
        isThrow = true;
        thrown = err;
      }
      if (!isThrow && !isNot) {
        const message = utils.flag(this, "message") || "expected function to throw an error, but it didn't";
        const error = { showDiff: false };
        throw new AssertionError2(message, error, utils.flag(this, "ssfi"));
      }
    }
    if (typeof expected === "function") {
      const name = expected.name || expected.prototype.constructor.name;
      return this.assert(thrown && thrown instanceof expected, `expected error to be instance of ${name}`, `expected error not to be instance of ${name}`, expected, thrown);
    }
    if (expected instanceof Error) {
      const equal = equals(thrown, expected, [...customTesters, iterableEquality]);
      return this.assert(equal, "expected a thrown error to be #{exp}", "expected a thrown error not to be #{exp}", expected, thrown);
    }
    if (typeof expected === "object" && "asymmetricMatch" in expected && typeof expected.asymmetricMatch === "function") {
      const matcher = expected;
      return this.assert(thrown && matcher.asymmetricMatch(thrown), "expected error to match asymmetric matcher", "expected error not to match asymmetric matcher", matcher, thrown);
    }
    throw new Error(`"toThrow" expects string, RegExp, function, Error instance or asymmetric matcher, got "${typeof expected}"`);
  });
  [{
    name: "toHaveResolved",
    condition: /* @__PURE__ */ __name((spy) => spy.mock.settledResults.length > 0 && spy.mock.settledResults.some(({ type: type5 }) => type5 === "fulfilled"), "condition"),
    action: "resolved"
  }, {
    name: ["toHaveReturned", "toReturn"],
    condition: /* @__PURE__ */ __name((spy) => spy.mock.calls.length > 0 && spy.mock.results.some(({ type: type5 }) => type5 !== "throw"), "condition"),
    action: "called"
  }].forEach(({ name, condition, action: action2 }) => {
    def(name, function() {
      const spy = getSpy(this);
      const spyName = spy.getMockName();
      const pass = condition(spy);
      this.assert(pass, `expected "${spyName}" to be successfully ${action2} at least once`, `expected "${spyName}" to not be successfully ${action2}`, pass, !pass, false);
    });
  });
  [{
    name: "toHaveResolvedTimes",
    condition: /* @__PURE__ */ __name((spy, times) => spy.mock.settledResults.reduce((s3, { type: type5 }) => type5 === "fulfilled" ? ++s3 : s3, 0) === times, "condition"),
    action: "resolved"
  }, {
    name: ["toHaveReturnedTimes", "toReturnTimes"],
    condition: /* @__PURE__ */ __name((spy, times) => spy.mock.results.reduce((s3, { type: type5 }) => type5 === "throw" ? s3 : ++s3, 0) === times, "condition"),
    action: "called"
  }].forEach(({ name, condition, action: action2 }) => {
    def(name, function(times) {
      const spy = getSpy(this);
      const spyName = spy.getMockName();
      const pass = condition(spy, times);
      this.assert(pass, `expected "${spyName}" to be successfully ${action2} ${times} times`, `expected "${spyName}" to not be successfully ${action2} ${times} times`, `expected resolved times: ${times}`, `received resolved times: ${pass}`, false);
    });
  });
  [{
    name: "toHaveResolvedWith",
    condition: /* @__PURE__ */ __name((spy, value) => spy.mock.settledResults.some(({ type: type5, value: result }) => type5 === "fulfilled" && equals(value, result)), "condition"),
    action: "resolve"
  }, {
    name: ["toHaveReturnedWith", "toReturnWith"],
    condition: /* @__PURE__ */ __name((spy, value) => spy.mock.results.some(({ type: type5, value: result }) => type5 === "return" && equals(value, result)), "condition"),
    action: "return"
  }].forEach(({ name, condition, action: action2 }) => {
    def(name, function(value) {
      const spy = getSpy(this);
      const pass = condition(spy, value);
      const isNot = utils.flag(this, "negate");
      if (pass && isNot || !pass && !isNot) {
        const spyName = spy.getMockName();
        const msg = utils.getMessage(this, [
          pass,
          `expected "${spyName}" to ${action2} with: #{exp} at least once`,
          `expected "${spyName}" to not ${action2} with: #{exp}`,
          value
        ]);
        const results = action2 === "return" ? spy.mock.results : spy.mock.settledResults;
        throw new AssertionError2(formatReturns(spy, results, msg, value));
      }
    });
  });
  [{
    name: "toHaveLastResolvedWith",
    condition: /* @__PURE__ */ __name((spy, value) => {
      const result = spy.mock.settledResults[spy.mock.settledResults.length - 1];
      return result && result.type === "fulfilled" && equals(result.value, value);
    }, "condition"),
    action: "resolve"
  }, {
    name: ["toHaveLastReturnedWith", "lastReturnedWith"],
    condition: /* @__PURE__ */ __name((spy, value) => {
      const result = spy.mock.results[spy.mock.results.length - 1];
      return result && result.type === "return" && equals(result.value, value);
    }, "condition"),
    action: "return"
  }].forEach(({ name, condition, action: action2 }) => {
    def(name, function(value) {
      const spy = getSpy(this);
      const results = action2 === "return" ? spy.mock.results : spy.mock.settledResults;
      const result = results[results.length - 1];
      const spyName = spy.getMockName();
      this.assert(condition(spy, value), `expected last "${spyName}" call to ${action2} #{exp}`, `expected last "${spyName}" call to not ${action2} #{exp}`, value, result === null || result === void 0 ? void 0 : result.value);
    });
  });
  [{
    name: "toHaveNthResolvedWith",
    condition: /* @__PURE__ */ __name((spy, index2, value) => {
      const result = spy.mock.settledResults[index2 - 1];
      return result && result.type === "fulfilled" && equals(result.value, value);
    }, "condition"),
    action: "resolve"
  }, {
    name: ["toHaveNthReturnedWith", "nthReturnedWith"],
    condition: /* @__PURE__ */ __name((spy, index2, value) => {
      const result = spy.mock.results[index2 - 1];
      return result && result.type === "return" && equals(result.value, value);
    }, "condition"),
    action: "return"
  }].forEach(({ name, condition, action: action2 }) => {
    def(name, function(nthCall, value) {
      const spy = getSpy(this);
      const spyName = spy.getMockName();
      const results = action2 === "return" ? spy.mock.results : spy.mock.settledResults;
      const result = results[nthCall - 1];
      const ordinalCall = `${ordinalOf(nthCall)} call`;
      this.assert(condition(spy, nthCall, value), `expected ${ordinalCall} "${spyName}" call to ${action2} #{exp}`, `expected ${ordinalCall} "${spyName}" call to not ${action2} #{exp}`, value, result === null || result === void 0 ? void 0 : result.value);
    });
  });
  def("withContext", function(context) {
    for (const key in context) {
      utils.flag(this, key, context[key]);
    }
    return this;
  });
  utils.addProperty(chai.Assertion.prototype, "resolves", /* @__PURE__ */ __name(function __VITEST_RESOLVES__() {
    const error = new Error("resolves");
    utils.flag(this, "promise", "resolves");
    utils.flag(this, "error", error);
    const test3 = utils.flag(this, "vitest-test");
    const obj = utils.flag(this, "object");
    if (utils.flag(this, "poll")) {
      throw new SyntaxError(`expect.poll() is not supported in combination with .resolves`);
    }
    if (typeof (obj === null || obj === void 0 ? void 0 : obj.then) !== "function") {
      throw new TypeError(`You must provide a Promise to expect() when using .resolves, not '${typeof obj}'.`);
    }
    const proxy = new Proxy(this, { get: /* @__PURE__ */ __name((target, key, receiver) => {
      const result = Reflect.get(target, key, receiver);
      if (typeof result !== "function") {
        return result instanceof chai.Assertion ? proxy : result;
      }
      return (...args) => {
        utils.flag(this, "_name", key);
        const promise = obj.then((value) => {
          utils.flag(this, "object", value);
          return result.call(this, ...args);
        }, (err) => {
          const _error = new AssertionError2(`promise rejected "${utils.inspect(err)}" instead of resolving`, { showDiff: false });
          _error.cause = err;
          _error.stack = error.stack.replace(error.message, _error.message);
          throw _error;
        });
        return recordAsyncExpect(test3, promise, createAssertionMessage(utils, this, !!args.length), error);
      };
    }, "get") });
    return proxy;
  }, "__VITEST_RESOLVES__"));
  utils.addProperty(chai.Assertion.prototype, "rejects", /* @__PURE__ */ __name(function __VITEST_REJECTS__() {
    const error = new Error("rejects");
    utils.flag(this, "promise", "rejects");
    utils.flag(this, "error", error);
    const test3 = utils.flag(this, "vitest-test");
    const obj = utils.flag(this, "object");
    const wrapper = typeof obj === "function" ? obj() : obj;
    if (utils.flag(this, "poll")) {
      throw new SyntaxError(`expect.poll() is not supported in combination with .rejects`);
    }
    if (typeof (wrapper === null || wrapper === void 0 ? void 0 : wrapper.then) !== "function") {
      throw new TypeError(`You must provide a Promise to expect() when using .rejects, not '${typeof wrapper}'.`);
    }
    const proxy = new Proxy(this, { get: /* @__PURE__ */ __name((target, key, receiver) => {
      const result = Reflect.get(target, key, receiver);
      if (typeof result !== "function") {
        return result instanceof chai.Assertion ? proxy : result;
      }
      return (...args) => {
        utils.flag(this, "_name", key);
        const promise = wrapper.then((value) => {
          const _error = new AssertionError2(`promise resolved "${utils.inspect(value)}" instead of rejecting`, {
            showDiff: true,
            expected: new Error("rejected promise"),
            actual: value
          });
          _error.stack = error.stack.replace(error.message, _error.message);
          throw _error;
        }, (err) => {
          utils.flag(this, "object", err);
          return result.call(this, ...args);
        });
        return recordAsyncExpect(test3, promise, createAssertionMessage(utils, this, !!args.length), error);
      };
    }, "get") });
    return proxy;
  }, "__VITEST_REJECTS__"));
}, "JestChaiExpect");
function ordinalOf(i2) {
  const j2 = i2 % 10;
  const k2 = i2 % 100;
  if (j2 === 1 && k2 !== 11) {
    return `${i2}st`;
  }
  if (j2 === 2 && k2 !== 12) {
    return `${i2}nd`;
  }
  if (j2 === 3 && k2 !== 13) {
    return `${i2}rd`;
  }
  return `${i2}th`;
}
__name(ordinalOf, "ordinalOf");
function formatCalls(spy, msg, showActualCall) {
  if (spy.mock.calls.length) {
    msg += s.gray(`

Received: 

${spy.mock.calls.map((callArg, i2) => {
      let methodCall = s.bold(`  ${ordinalOf(i2 + 1)} ${spy.getMockName()} call:

`);
      if (showActualCall) {
        methodCall += diff(showActualCall, callArg, { omitAnnotationLines: true });
      } else {
        methodCall += stringify2(callArg).split("\n").map((line) => `    ${line}`).join("\n");
      }
      methodCall += "\n";
      return methodCall;
    }).join("\n")}`);
  }
  msg += s.gray(`

Number of calls: ${s.bold(spy.mock.calls.length)}
`);
  return msg;
}
__name(formatCalls, "formatCalls");
function formatReturns(spy, results, msg, showActualReturn) {
  if (results.length) {
    msg += s.gray(`

Received: 

${results.map((callReturn, i2) => {
      let methodCall = s.bold(`  ${ordinalOf(i2 + 1)} ${spy.getMockName()} call return:

`);
      if (showActualReturn) {
        methodCall += diff(showActualReturn, callReturn.value, { omitAnnotationLines: true });
      } else {
        methodCall += stringify2(callReturn).split("\n").map((line) => `    ${line}`).join("\n");
      }
      methodCall += "\n";
      return methodCall;
    }).join("\n")}`);
  }
  msg += s.gray(`

Number of calls: ${s.bold(spy.mock.calls.length)}
`);
  return msg;
}
__name(formatReturns, "formatReturns");
function getMatcherState(assertion, expect4) {
  const obj = assertion._obj;
  const isNot = utils_exports.flag(assertion, "negate");
  const promise = utils_exports.flag(assertion, "promise") || "";
  const jestUtils = {
    ...getMatcherUtils(),
    diff,
    stringify: stringify2,
    iterableEquality,
    subsetEquality
  };
  const matcherState = {
    ...getState(expect4),
    customTesters: getCustomEqualityTesters(),
    isNot,
    utils: jestUtils,
    promise,
    equals,
    suppressedErrors: [],
    soft: utils_exports.flag(assertion, "soft"),
    poll: utils_exports.flag(assertion, "poll")
  };
  return {
    state: matcherState,
    isNot,
    obj
  };
}
__name(getMatcherState, "getMatcherState");
var _JestExtendError = class _JestExtendError extends Error {
  constructor(message, actual, expected) {
    super(message);
    this.actual = actual;
    this.expected = expected;
  }
};
__name(_JestExtendError, "JestExtendError");
var JestExtendError = _JestExtendError;
function JestExtendPlugin(c2, expect4, matchers) {
  return (_, utils) => {
    Object.entries(matchers).forEach(([expectAssertionName, expectAssertion]) => {
      function expectWrapper(...args) {
        const { state: state3, isNot, obj } = getMatcherState(this, expect4);
        const result = expectAssertion.call(state3, obj, ...args);
        if (result && typeof result === "object" && typeof result.then === "function") {
          const thenable = result;
          return thenable.then(({ pass: pass2, message: message2, actual: actual2, expected: expected2 }) => {
            if (pass2 && isNot || !pass2 && !isNot) {
              throw new JestExtendError(message2(), actual2, expected2);
            }
          });
        }
        const { pass, message, actual, expected } = result;
        if (pass && isNot || !pass && !isNot) {
          throw new JestExtendError(message(), actual, expected);
        }
      }
      __name(expectWrapper, "expectWrapper");
      const softWrapper = wrapAssertion(utils, expectAssertionName, expectWrapper);
      utils.addMethod(globalThis[JEST_MATCHERS_OBJECT].matchers, expectAssertionName, softWrapper);
      utils.addMethod(c2.Assertion.prototype, expectAssertionName, softWrapper);
      const _CustomMatcher = class _CustomMatcher extends AsymmetricMatcher3 {
        constructor(inverse = false, ...sample) {
          super(sample, inverse);
        }
        asymmetricMatch(other) {
          const { pass } = expectAssertion.call(this.getMatcherContext(expect4), other, ...this.sample);
          return this.inverse ? !pass : pass;
        }
        toString() {
          return `${this.inverse ? "not." : ""}${expectAssertionName}`;
        }
        getExpectedType() {
          return "any";
        }
        toAsymmetricMatcher() {
          return `${this.toString()}<${this.sample.map((item) => stringify2(item)).join(", ")}>`;
        }
      };
      __name(_CustomMatcher, "CustomMatcher");
      let CustomMatcher = _CustomMatcher;
      const customMatcher = /* @__PURE__ */ __name((...sample) => new CustomMatcher(false, ...sample), "customMatcher");
      Object.defineProperty(expect4, expectAssertionName, {
        configurable: true,
        enumerable: true,
        value: customMatcher,
        writable: true
      });
      Object.defineProperty(expect4.not, expectAssertionName, {
        configurable: true,
        enumerable: true,
        value: /* @__PURE__ */ __name((...sample) => new CustomMatcher(true, ...sample), "value"),
        writable: true
      });
      Object.defineProperty(globalThis[ASYMMETRIC_MATCHERS_OBJECT], expectAssertionName, {
        configurable: true,
        enumerable: true,
        value: customMatcher,
        writable: true
      });
    });
  };
}
__name(JestExtendPlugin, "JestExtendPlugin");
var JestExtend = /* @__PURE__ */ __name((chai, utils) => {
  utils.addMethod(chai.expect, "extend", (expect4, expects) => {
    use(JestExtendPlugin(chai, expect4, expects));
  });
}, "JestExtend");

// src/test/expect.ts
function createExpect() {
  use(JestExtend);
  use(JestChaiExpect);
  use(JestAsymmetricMatchers);
  const expect4 = /* @__PURE__ */ __name((value, message) => {
    const { assertionCalls } = getState(expect4);
    setState({ assertionCalls: assertionCalls + 1, soft: false }, expect4);
    return expect(value, message);
  }, "expect");
  Object.assign(expect4, expect);
  expect4.getState = () => getState(expect4);
  expect4.setState = (state3) => setState(state3, expect4);
  expect4.extend = (expects) => expect.extend(expect4, expects);
  expect4.soft = (...args) => {
    const assert2 = expect4(...args);
    expect4.setState({
      soft: true
    });
    return assert2;
  };
  expect4.extend(customMatchers);
  expect4.unreachable = (message) => {
    assert.fail(`expected${message ? ` "${message}" ` : " "}not to be reached`);
  };
  function assertions(expected) {
    const errorGen = /* @__PURE__ */ __name(() => new Error(
      `expected number of assertions to be ${expected}, but got ${expect4.getState().assertionCalls}`
    ), "errorGen");
    if ("captureStackTrace" in Error && typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(errorGen(), assertions);
    }
    expect4.setState({
      expectedAssertionsNumber: expected,
      expectedAssertionsNumberErrorGen: errorGen
    });
  }
  __name(assertions, "assertions");
  function hasAssertions() {
    const error = new Error("expected any number of assertion, but got none");
    if ("captureStackTrace" in Error && typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(error, hasAssertions);
    }
    expect4.setState({
      isExpectingAssertions: true,
      isExpectingAssertionsError: error
    });
  }
  __name(hasAssertions, "hasAssertions");
  setState(
    {
      // this should also add "snapshotState" that is added conditionally
      assertionCalls: 0,
      isExpectingAssertions: false,
      isExpectingAssertionsError: null,
      expectedAssertionsNumber: null,
      expectedAssertionsNumberErrorGen: null
    },
    expect4
  );
  utils_exports.addMethod(expect4, "assertions", assertions);
  utils_exports.addMethod(expect4, "hasAssertions", hasAssertions);
  expect4.extend(matchers_exports);
  return expect4;
}
__name(createExpect, "createExpect");
var expect2 = createExpect();
Object.defineProperty(globalThis, GLOBAL_EXPECT, {
  value: expect2,
  writable: true,
  configurable: true
});

// ../node_modules/tinyspy/dist/index.js
function f3(e2, t2, n2) {
  Object.defineProperty(e2, t2, n2);
}
__name(f3, "f");
var u2 = Symbol.for("tinyspy:spy");
var P2 = /* @__PURE__ */ __name((e2) => {
  e2.called = false, e2.callCount = 0, e2.calls = [], e2.results = [], e2.resolves = [], e2.next = [];
}, "P");
var K2 = /* @__PURE__ */ __name((e2) => (f3(e2, u2, { value: { reset: /* @__PURE__ */ __name(() => P2(e2[u2]), "reset") } }), e2[u2]), "K");
var T2 = /* @__PURE__ */ __name((e2) => e2[u2] || K2(e2), "T");

// src/test/spy.ts
var listeners = /* @__PURE__ */ new Set();
function onMockCall(callback) {
  listeners.add(callback);
  return () => void listeners.delete(callback);
}
__name(onMockCall, "onMockCall");
var spyOn2 = /* @__PURE__ */ __name((...args) => {
  const mock = spyOn(...args);
  return reactiveMock(mock);
}, "spyOn");
function fn2(implementation) {
  const mock = implementation ? fn(implementation) : fn();
  return reactiveMock(mock);
}
__name(fn2, "fn");
function reactiveMock(mock) {
  const reactive = listenWhenCalled(mock);
  const originalMockImplementation = reactive.mockImplementation.bind(null);
  reactive.mockImplementation = (fn3) => listenWhenCalled(originalMockImplementation(fn3));
  return reactive;
}
__name(reactiveMock, "reactiveMock");
function listenWhenCalled(mock) {
  const state3 = T2(mock);
  const impl = state3.impl;
  state3.willCall(function(...args) {
    listeners.forEach((listener) => listener(mock, args));
    return impl?.apply(this, args);
  });
  return mock;
}
__name(listenWhenCalled, "listenWhenCalled");
function clearAllMocks() {
  mocks.forEach((spy) => spy.mockClear());
}
__name(clearAllMocks, "clearAllMocks");
function resetAllMocks() {
  mocks.forEach((spy) => spy.mockReset());
}
__name(resetAllMocks, "resetAllMocks");
function restoreAllMocks() {
  mocks.forEach((spy) => spy.mockRestore());
}
__name(restoreAllMocks, "restoreAllMocks");
function mocked(item, _options = {}) {
  return item;
}
__name(mocked, "mocked");

// ../node_modules/@testing-library/dom/dist/@testing-library/dom.esm.js
var dom_esm_exports = {};
__export(dom_esm_exports, {
  buildQueries: () => buildQueries,
  configure: () => configure,
  createEvent: () => createEvent,
  findAllByAltText: () => findAllByAltText,
  findAllByDisplayValue: () => findAllByDisplayValue,
  findAllByLabelText: () => findAllByLabelText,
  findAllByPlaceholderText: () => findAllByPlaceholderText,
  findAllByRole: () => findAllByRole,
  findAllByTestId: () => findAllByTestId,
  findAllByText: () => findAllByText,
  findAllByTitle: () => findAllByTitle,
  findByAltText: () => findByAltText,
  findByDisplayValue: () => findByDisplayValue,
  findByLabelText: () => findByLabelText,
  findByPlaceholderText: () => findByPlaceholderText,
  findByRole: () => findByRole,
  findByTestId: () => findByTestId,
  findByText: () => findByText,
  findByTitle: () => findByTitle,
  fireEvent: () => fireEvent,
  getAllByAltText: () => getAllByAltText,
  getAllByDisplayValue: () => getAllByDisplayValue,
  getAllByLabelText: () => getAllByLabelTextWithSuggestions,
  getAllByPlaceholderText: () => getAllByPlaceholderText,
  getAllByRole: () => getAllByRole,
  getAllByTestId: () => getAllByTestId,
  getAllByText: () => getAllByText,
  getAllByTitle: () => getAllByTitle,
  getByAltText: () => getByAltText,
  getByDisplayValue: () => getByDisplayValue,
  getByLabelText: () => getByLabelTextWithSuggestions,
  getByPlaceholderText: () => getByPlaceholderText,
  getByRole: () => getByRole,
  getByTestId: () => getByTestId,
  getByText: () => getByText,
  getByTitle: () => getByTitle,
  getConfig: () => getConfig2,
  getDefaultNormalizer: () => getDefaultNormalizer,
  getElementError: () => getElementError,
  getMultipleElementsFoundError: () => getMultipleElementsFoundError,
  getNodeText: () => getNodeText,
  getQueriesForElement: () => getQueriesForElement,
  getRoles: () => getRoles,
  getSuggestedQuery: () => getSuggestedQuery,
  isInaccessible: () => isInaccessible,
  logDOM: () => logDOM,
  logRoles: () => logRoles,
  makeFindQuery: () => makeFindQuery,
  makeGetAllQuery: () => makeGetAllQuery,
  makeSingleQuery: () => makeSingleQuery,
  prettyDOM: () => prettyDOM,
  prettyFormat: () => prettyFormat,
  queries: () => queries,
  queryAllByAltText: () => queryAllByAltTextWithSuggestions,
  queryAllByAttribute: () => queryAllByAttribute,
  queryAllByDisplayValue: () => queryAllByDisplayValueWithSuggestions,
  queryAllByLabelText: () => queryAllByLabelTextWithSuggestions,
  queryAllByPlaceholderText: () => queryAllByPlaceholderTextWithSuggestions,
  queryAllByRole: () => queryAllByRoleWithSuggestions,
  queryAllByTestId: () => queryAllByTestIdWithSuggestions,
  queryAllByText: () => queryAllByTextWithSuggestions,
  queryAllByTitle: () => queryAllByTitleWithSuggestions,
  queryByAltText: () => queryByAltText,
  queryByAttribute: () => queryByAttribute,
  queryByDisplayValue: () => queryByDisplayValue,
  queryByLabelText: () => queryByLabelText,
  queryByPlaceholderText: () => queryByPlaceholderText,
  queryByRole: () => queryByRole,
  queryByTestId: () => queryByTestId,
  queryByText: () => queryByText,
  queryByTitle: () => queryByTitle,
  queryHelpers: () => queryHelpers,
  screen: () => screen,
  waitFor: () => waitForWrapper,
  waitForElementToBeRemoved: () => waitForElementToBeRemoved,
  within: () => getQueriesForElement,
  wrapAllByQueryWithSuggestion: () => wrapAllByQueryWithSuggestion,
  wrapSingleQueryWithSuggestion: () => wrapSingleQueryWithSuggestion
});
var prettyFormat = __toESM(require_build());

// ../node_modules/dom-accessibility-api/dist/polyfills/array.from.mjs
var toStr2 = Object.prototype.toString;
function isCallable2(fn3) {
  return typeof fn3 === "function" || toStr2.call(fn3) === "[object Function]";
}
__name(isCallable2, "isCallable");
function toInteger2(value) {
  var number = Number(value);
  if (isNaN(number)) {
    return 0;
  }
  if (number === 0 || !isFinite(number)) {
    return number;
  }
  return (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));
}
__name(toInteger2, "toInteger");
var maxSafeInteger2 = Math.pow(2, 53) - 1;
function toLength2(value) {
  var len = toInteger2(value);
  return Math.min(Math.max(len, 0), maxSafeInteger2);
}
__name(toLength2, "toLength");
function arrayFrom2(arrayLike, mapFn) {
  var C2 = Array;
  var items = Object(arrayLike);
  if (arrayLike == null) {
    throw new TypeError("Array.from requires an array-like object - not null or undefined");
  }
  if (typeof mapFn !== "undefined") {
    if (!isCallable2(mapFn)) {
      throw new TypeError("Array.from: when provided, the second argument must be a function");
    }
  }
  var len = toLength2(items.length);
  var A = isCallable2(C2) ? Object(new C2(len)) : new Array(len);
  var k2 = 0;
  var kValue;
  while (k2 < len) {
    kValue = items[k2];
    if (mapFn) {
      A[k2] = mapFn(kValue, k2);
    } else {
      A[k2] = kValue;
    }
    k2 += 1;
  }
  A.length = len;
  return A;
}
__name(arrayFrom2, "arrayFrom");

// ../node_modules/dom-accessibility-api/dist/polyfills/SetLike.mjs
function _typeof3(obj) {
  "@babel/helpers - typeof";
  return _typeof3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof3(obj);
}
__name(_typeof3, "_typeof");
function _classCallCheck2(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
__name(_classCallCheck2, "_classCallCheck");
function _defineProperties2(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey3(descriptor.key), descriptor);
  }
}
__name(_defineProperties2, "_defineProperties");
function _createClass2(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties2(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties2(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
__name(_createClass2, "_createClass");
function _defineProperty3(obj, key, value) {
  key = _toPropertyKey3(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
__name(_defineProperty3, "_defineProperty");
function _toPropertyKey3(arg) {
  var key = _toPrimitive3(arg, "string");
  return _typeof3(key) === "symbol" ? key : String(key);
}
__name(_toPropertyKey3, "_toPropertyKey");
function _toPrimitive3(input2, hint) {
  if (_typeof3(input2) !== "object" || input2 === null) return input2;
  var prim = input2[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input2, hint || "default");
    if (_typeof3(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input2);
}
__name(_toPrimitive3, "_toPrimitive");
var SetLike2 = function() {
  function SetLike3() {
    var items = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    _classCallCheck2(this, SetLike3);
    _defineProperty3(this, "items", void 0);
    this.items = items;
  }
  __name(SetLike3, "SetLike");
  _createClass2(SetLike3, [{
    key: "add",
    value: /* @__PURE__ */ __name(function add(value) {
      if (this.has(value) === false) {
        this.items.push(value);
      }
      return this;
    }, "add")
  }, {
    key: "clear",
    value: /* @__PURE__ */ __name(function clear4() {
      this.items = [];
    }, "clear")
  }, {
    key: "delete",
    value: /* @__PURE__ */ __name(function _delete(value) {
      var previousLength = this.items.length;
      this.items = this.items.filter(function(item) {
        return item !== value;
      });
      return previousLength !== this.items.length;
    }, "_delete")
  }, {
    key: "forEach",
    value: /* @__PURE__ */ __name(function forEach(callbackfn) {
      var _this = this;
      this.items.forEach(function(item) {
        callbackfn(item, item, _this);
      });
    }, "forEach")
  }, {
    key: "has",
    value: /* @__PURE__ */ __name(function has(value) {
      return this.items.indexOf(value) !== -1;
    }, "has")
  }, {
    key: "size",
    get: /* @__PURE__ */ __name(function get3() {
      return this.items.length;
    }, "get")
  }]);
  return SetLike3;
}();
var SetLike_default2 = typeof Set === "undefined" ? Set : SetLike2;

// ../node_modules/dom-accessibility-api/dist/getRole.mjs
function getLocalName2(element) {
  var _element$localName;
  return (
    // eslint-disable-next-line no-restricted-properties -- actual guard for environments without localName
    (_element$localName = element.localName) !== null && _element$localName !== void 0 ? _element$localName : (
      // eslint-disable-next-line no-restricted-properties -- required for the fallback
      element.tagName.toLowerCase()
    )
  );
}
__name(getLocalName2, "getLocalName");
var localNameToRoleMappings2 = {
  article: "article",
  aside: "complementary",
  button: "button",
  datalist: "listbox",
  dd: "definition",
  details: "group",
  dialog: "dialog",
  dt: "term",
  fieldset: "group",
  figure: "figure",
  // WARNING: Only with an accessible name
  form: "form",
  footer: "contentinfo",
  h1: "heading",
  h2: "heading",
  h3: "heading",
  h4: "heading",
  h5: "heading",
  h6: "heading",
  header: "banner",
  hr: "separator",
  html: "document",
  legend: "legend",
  li: "listitem",
  math: "math",
  main: "main",
  menu: "list",
  nav: "navigation",
  ol: "list",
  optgroup: "group",
  // WARNING: Only in certain context
  option: "option",
  output: "status",
  progress: "progressbar",
  // WARNING: Only with an accessible name
  section: "region",
  summary: "button",
  table: "table",
  tbody: "rowgroup",
  textarea: "textbox",
  tfoot: "rowgroup",
  // WARNING: Only in certain context
  td: "cell",
  th: "columnheader",
  thead: "rowgroup",
  tr: "row",
  ul: "list"
};
var prohibitedAttributes2 = {
  caption: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  code: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  deletion: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  emphasis: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  generic: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby", "aria-roledescription"]),
  insertion: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  paragraph: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  presentation: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  strong: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  subscript: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  superscript: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"])
};
function hasGlobalAriaAttributes2(element, role) {
  return [
    "aria-atomic",
    "aria-busy",
    "aria-controls",
    "aria-current",
    "aria-describedby",
    "aria-details",
    // "disabled",
    "aria-dropeffect",
    // "errormessage",
    "aria-flowto",
    "aria-grabbed",
    // "haspopup",
    "aria-hidden",
    // "invalid",
    "aria-keyshortcuts",
    "aria-label",
    "aria-labelledby",
    "aria-live",
    "aria-owns",
    "aria-relevant",
    "aria-roledescription"
  ].some(function(attributeName) {
    var _prohibitedAttributes;
    return element.hasAttribute(attributeName) && !((_prohibitedAttributes = prohibitedAttributes2[role]) !== null && _prohibitedAttributes !== void 0 && _prohibitedAttributes.has(attributeName));
  });
}
__name(hasGlobalAriaAttributes2, "hasGlobalAriaAttributes");
function ignorePresentationalRole2(element, implicitRole) {
  return hasGlobalAriaAttributes2(element, implicitRole);
}
__name(ignorePresentationalRole2, "ignorePresentationalRole");
function getRole2(element) {
  var explicitRole = getExplicitRole2(element);
  if (explicitRole === null || explicitRole === "presentation") {
    var implicitRole = getImplicitRole2(element);
    if (explicitRole !== "presentation" || ignorePresentationalRole2(element, implicitRole || "")) {
      return implicitRole;
    }
  }
  return explicitRole;
}
__name(getRole2, "getRole");
function getImplicitRole2(element) {
  var mappedByTag = localNameToRoleMappings2[getLocalName2(element)];
  if (mappedByTag !== void 0) {
    return mappedByTag;
  }
  switch (getLocalName2(element)) {
    case "a":
    case "area":
    case "link":
      if (element.hasAttribute("href")) {
        return "link";
      }
      break;
    case "img":
      if (element.getAttribute("alt") === "" && !ignorePresentationalRole2(element, "img")) {
        return "presentation";
      }
      return "img";
    case "input": {
      var _ref = element, type5 = _ref.type;
      switch (type5) {
        case "button":
        case "image":
        case "reset":
        case "submit":
          return "button";
        case "checkbox":
        case "radio":
          return type5;
        case "range":
          return "slider";
        case "email":
        case "tel":
        case "text":
        case "url":
          if (element.hasAttribute("list")) {
            return "combobox";
          }
          return "textbox";
        case "search":
          if (element.hasAttribute("list")) {
            return "combobox";
          }
          return "searchbox";
        case "number":
          return "spinbutton";
        default:
          return null;
      }
    }
    case "select":
      if (element.hasAttribute("multiple") || element.size > 1) {
        return "listbox";
      }
      return "combobox";
  }
  return null;
}
__name(getImplicitRole2, "getImplicitRole");
function getExplicitRole2(element) {
  var role = element.getAttribute("role");
  if (role !== null) {
    var explicitRole = role.trim().split(" ")[0];
    if (explicitRole.length > 0) {
      return explicitRole;
    }
  }
  return null;
}
__name(getExplicitRole2, "getExplicitRole");

// ../node_modules/dom-accessibility-api/dist/util.mjs
function isElement2(node) {
  return node !== null && node.nodeType === node.ELEMENT_NODE;
}
__name(isElement2, "isElement");
function isHTMLTableCaptionElement2(node) {
  return isElement2(node) && getLocalName2(node) === "caption";
}
__name(isHTMLTableCaptionElement2, "isHTMLTableCaptionElement");
function isHTMLInputElement2(node) {
  return isElement2(node) && getLocalName2(node) === "input";
}
__name(isHTMLInputElement2, "isHTMLInputElement");
function isHTMLOptGroupElement2(node) {
  return isElement2(node) && getLocalName2(node) === "optgroup";
}
__name(isHTMLOptGroupElement2, "isHTMLOptGroupElement");
function isHTMLSelectElement2(node) {
  return isElement2(node) && getLocalName2(node) === "select";
}
__name(isHTMLSelectElement2, "isHTMLSelectElement");
function isHTMLTableElement2(node) {
  return isElement2(node) && getLocalName2(node) === "table";
}
__name(isHTMLTableElement2, "isHTMLTableElement");
function isHTMLTextAreaElement2(node) {
  return isElement2(node) && getLocalName2(node) === "textarea";
}
__name(isHTMLTextAreaElement2, "isHTMLTextAreaElement");
function safeWindow2(node) {
  var _ref = node.ownerDocument === null ? node : node.ownerDocument, defaultView = _ref.defaultView;
  if (defaultView === null) {
    throw new TypeError("no window available");
  }
  return defaultView;
}
__name(safeWindow2, "safeWindow");
function isHTMLFieldSetElement2(node) {
  return isElement2(node) && getLocalName2(node) === "fieldset";
}
__name(isHTMLFieldSetElement2, "isHTMLFieldSetElement");
function isHTMLLegendElement2(node) {
  return isElement2(node) && getLocalName2(node) === "legend";
}
__name(isHTMLLegendElement2, "isHTMLLegendElement");
function isHTMLSlotElement2(node) {
  return isElement2(node) && getLocalName2(node) === "slot";
}
__name(isHTMLSlotElement2, "isHTMLSlotElement");
function isSVGElement2(node) {
  return isElement2(node) && node.ownerSVGElement !== void 0;
}
__name(isSVGElement2, "isSVGElement");
function isSVGSVGElement2(node) {
  return isElement2(node) && getLocalName2(node) === "svg";
}
__name(isSVGSVGElement2, "isSVGSVGElement");
function isSVGTitleElement2(node) {
  return isSVGElement2(node) && getLocalName2(node) === "title";
}
__name(isSVGTitleElement2, "isSVGTitleElement");
function queryIdRefs2(node, attributeName) {
  if (isElement2(node) && node.hasAttribute(attributeName)) {
    var ids = node.getAttribute(attributeName).split(" ");
    var root2 = node.getRootNode ? node.getRootNode() : node.ownerDocument;
    return ids.map(function(id) {
      return root2.getElementById(id);
    }).filter(
      function(element) {
        return element !== null;
      }
      // TODO: why does this not narrow?
    );
  }
  return [];
}
__name(queryIdRefs2, "queryIdRefs");
function hasAnyConcreteRoles2(node, roles3) {
  if (isElement2(node)) {
    return roles3.indexOf(getRole2(node)) !== -1;
  }
  return false;
}
__name(hasAnyConcreteRoles2, "hasAnyConcreteRoles");

// ../node_modules/dom-accessibility-api/dist/accessible-name-and-description.mjs
function asFlatString2(s3) {
  return s3.trim().replace(/\s\s+/g, " ");
}
__name(asFlatString2, "asFlatString");
function isHidden2(node, getComputedStyleImplementation) {
  if (!isElement2(node)) {
    return false;
  }
  if (node.hasAttribute("hidden") || node.getAttribute("aria-hidden") === "true") {
    return true;
  }
  var style = getComputedStyleImplementation(node);
  return style.getPropertyValue("display") === "none" || style.getPropertyValue("visibility") === "hidden";
}
__name(isHidden2, "isHidden");
function isControl2(node) {
  return hasAnyConcreteRoles2(node, ["button", "combobox", "listbox", "textbox"]) || hasAbstractRole2(node, "range");
}
__name(isControl2, "isControl");
function hasAbstractRole2(node, role) {
  if (!isElement2(node)) {
    return false;
  }
  switch (role) {
    case "range":
      return hasAnyConcreteRoles2(node, ["meter", "progressbar", "scrollbar", "slider", "spinbutton"]);
    default:
      throw new TypeError("No knowledge about abstract role '".concat(role, "'. This is likely a bug :("));
  }
}
__name(hasAbstractRole2, "hasAbstractRole");
function querySelectorAllSubtree2(element, selectors) {
  var elements = arrayFrom2(element.querySelectorAll(selectors));
  queryIdRefs2(element, "aria-owns").forEach(function(root2) {
    elements.push.apply(elements, arrayFrom2(root2.querySelectorAll(selectors)));
  });
  return elements;
}
__name(querySelectorAllSubtree2, "querySelectorAllSubtree");
function querySelectedOptions2(listbox) {
  if (isHTMLSelectElement2(listbox)) {
    return listbox.selectedOptions || querySelectorAllSubtree2(listbox, "[selected]");
  }
  return querySelectorAllSubtree2(listbox, '[aria-selected="true"]');
}
__name(querySelectedOptions2, "querySelectedOptions");
function isMarkedPresentational2(node) {
  return hasAnyConcreteRoles2(node, ["none", "presentation"]);
}
__name(isMarkedPresentational2, "isMarkedPresentational");
function isNativeHostLanguageTextAlternativeElement2(node) {
  return isHTMLTableCaptionElement2(node);
}
__name(isNativeHostLanguageTextAlternativeElement2, "isNativeHostLanguageTextAlternativeElement");
function allowsNameFromContent2(node) {
  return hasAnyConcreteRoles2(node, ["button", "cell", "checkbox", "columnheader", "gridcell", "heading", "label", "legend", "link", "menuitem", "menuitemcheckbox", "menuitemradio", "option", "radio", "row", "rowheader", "switch", "tab", "tooltip", "treeitem"]);
}
__name(allowsNameFromContent2, "allowsNameFromContent");
function isDescendantOfNativeHostLanguageTextAlternativeElement2(node) {
  return false;
}
__name(isDescendantOfNativeHostLanguageTextAlternativeElement2, "isDescendantOfNativeHostLanguageTextAlternativeElement");
function getValueOfTextbox2(element) {
  if (isHTMLInputElement2(element) || isHTMLTextAreaElement2(element)) {
    return element.value;
  }
  return element.textContent || "";
}
__name(getValueOfTextbox2, "getValueOfTextbox");
function getTextualContent2(declaration) {
  var content = declaration.getPropertyValue("content");
  if (/^["'].*["']$/.test(content)) {
    return content.slice(1, -1);
  }
  return "";
}
__name(getTextualContent2, "getTextualContent");
function isLabelableElement2(element) {
  var localName = getLocalName2(element);
  return localName === "button" || localName === "input" && element.getAttribute("type") !== "hidden" || localName === "meter" || localName === "output" || localName === "progress" || localName === "select" || localName === "textarea";
}
__name(isLabelableElement2, "isLabelableElement");
function findLabelableElement2(element) {
  if (isLabelableElement2(element)) {
    return element;
  }
  var labelableElement = null;
  element.childNodes.forEach(function(childNode) {
    if (labelableElement === null && isElement2(childNode)) {
      var descendantLabelableElement = findLabelableElement2(childNode);
      if (descendantLabelableElement !== null) {
        labelableElement = descendantLabelableElement;
      }
    }
  });
  return labelableElement;
}
__name(findLabelableElement2, "findLabelableElement");
function getControlOfLabel2(label) {
  if (label.control !== void 0) {
    return label.control;
  }
  var htmlFor = label.getAttribute("for");
  if (htmlFor !== null) {
    return label.ownerDocument.getElementById(htmlFor);
  }
  return findLabelableElement2(label);
}
__name(getControlOfLabel2, "getControlOfLabel");
function getLabels2(element) {
  var labelsProperty = element.labels;
  if (labelsProperty === null) {
    return labelsProperty;
  }
  if (labelsProperty !== void 0) {
    return arrayFrom2(labelsProperty);
  }
  if (!isLabelableElement2(element)) {
    return null;
  }
  var document7 = element.ownerDocument;
  return arrayFrom2(document7.querySelectorAll("label")).filter(function(label) {
    return getControlOfLabel2(label) === element;
  });
}
__name(getLabels2, "getLabels");
function getSlotContents2(slot) {
  var assignedNodes = slot.assignedNodes();
  if (assignedNodes.length === 0) {
    return arrayFrom2(slot.childNodes);
  }
  return assignedNodes;
}
__name(getSlotContents2, "getSlotContents");
function computeTextAlternative2(root2) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var consultedNodes = new SetLike_default2();
  var window2 = safeWindow2(root2);
  var _options$compute = options.compute, compute = _options$compute === void 0 ? "name" : _options$compute, _options$computedStyl = options.computedStyleSupportsPseudoElements, computedStyleSupportsPseudoElements = _options$computedStyl === void 0 ? options.getComputedStyle !== void 0 : _options$computedStyl, _options$getComputedS = options.getComputedStyle, getComputedStyle2 = _options$getComputedS === void 0 ? window2.getComputedStyle.bind(window2) : _options$getComputedS, _options$hidden = options.hidden, hidden = _options$hidden === void 0 ? false : _options$hidden;
  function computeMiscTextAlternative(node, context) {
    var accumulatedText = "";
    if (isElement2(node) && computedStyleSupportsPseudoElements) {
      var pseudoBefore = getComputedStyle2(node, "::before");
      var beforeContent = getTextualContent2(pseudoBefore);
      accumulatedText = "".concat(beforeContent, " ").concat(accumulatedText);
    }
    var childNodes = isHTMLSlotElement2(node) ? getSlotContents2(node) : arrayFrom2(node.childNodes).concat(queryIdRefs2(node, "aria-owns"));
    childNodes.forEach(function(child) {
      var result = computeTextAlternative3(child, {
        isEmbeddedInLabel: context.isEmbeddedInLabel,
        isReferenced: false,
        recursion: true
      });
      var display2 = isElement2(child) ? getComputedStyle2(child).getPropertyValue("display") : "inline";
      var separator = display2 !== "inline" ? " " : "";
      accumulatedText += "".concat(separator).concat(result).concat(separator);
    });
    if (isElement2(node) && computedStyleSupportsPseudoElements) {
      var pseudoAfter = getComputedStyle2(node, "::after");
      var afterContent = getTextualContent2(pseudoAfter);
      accumulatedText = "".concat(accumulatedText, " ").concat(afterContent);
    }
    return accumulatedText.trim();
  }
  __name(computeMiscTextAlternative, "computeMiscTextAlternative");
  function useAttribute(element, attributeName) {
    var attribute = element.getAttributeNode(attributeName);
    if (attribute !== null && !consultedNodes.has(attribute) && attribute.value.trim() !== "") {
      consultedNodes.add(attribute);
      return attribute.value;
    }
    return null;
  }
  __name(useAttribute, "useAttribute");
  function computeTooltipAttributeValue(node) {
    if (!isElement2(node)) {
      return null;
    }
    return useAttribute(node, "title");
  }
  __name(computeTooltipAttributeValue, "computeTooltipAttributeValue");
  function computeElementTextAlternative(node) {
    if (!isElement2(node)) {
      return null;
    }
    if (isHTMLFieldSetElement2(node)) {
      consultedNodes.add(node);
      var children = arrayFrom2(node.childNodes);
      for (var i2 = 0; i2 < children.length; i2 += 1) {
        var child = children[i2];
        if (isHTMLLegendElement2(child)) {
          return computeTextAlternative3(child, {
            isEmbeddedInLabel: false,
            isReferenced: false,
            recursion: false
          });
        }
      }
    } else if (isHTMLTableElement2(node)) {
      consultedNodes.add(node);
      var _children = arrayFrom2(node.childNodes);
      for (var _i = 0; _i < _children.length; _i += 1) {
        var _child = _children[_i];
        if (isHTMLTableCaptionElement2(_child)) {
          return computeTextAlternative3(_child, {
            isEmbeddedInLabel: false,
            isReferenced: false,
            recursion: false
          });
        }
      }
    } else if (isSVGSVGElement2(node)) {
      consultedNodes.add(node);
      var _children2 = arrayFrom2(node.childNodes);
      for (var _i2 = 0; _i2 < _children2.length; _i2 += 1) {
        var _child2 = _children2[_i2];
        if (isSVGTitleElement2(_child2)) {
          return _child2.textContent;
        }
      }
      return null;
    } else if (getLocalName2(node) === "img" || getLocalName2(node) === "area") {
      var nameFromAlt = useAttribute(node, "alt");
      if (nameFromAlt !== null) {
        return nameFromAlt;
      }
    } else if (isHTMLOptGroupElement2(node)) {
      var nameFromLabel = useAttribute(node, "label");
      if (nameFromLabel !== null) {
        return nameFromLabel;
      }
    }
    if (isHTMLInputElement2(node) && (node.type === "button" || node.type === "submit" || node.type === "reset")) {
      var nameFromValue = useAttribute(node, "value");
      if (nameFromValue !== null) {
        return nameFromValue;
      }
      if (node.type === "submit") {
        return "Submit";
      }
      if (node.type === "reset") {
        return "Reset";
      }
    }
    var labels = getLabels2(node);
    if (labels !== null && labels.length !== 0) {
      consultedNodes.add(node);
      return arrayFrom2(labels).map(function(element) {
        return computeTextAlternative3(element, {
          isEmbeddedInLabel: true,
          isReferenced: false,
          recursion: true
        });
      }).filter(function(label) {
        return label.length > 0;
      }).join(" ");
    }
    if (isHTMLInputElement2(node) && node.type === "image") {
      var _nameFromAlt = useAttribute(node, "alt");
      if (_nameFromAlt !== null) {
        return _nameFromAlt;
      }
      var nameFromTitle = useAttribute(node, "title");
      if (nameFromTitle !== null) {
        return nameFromTitle;
      }
      return "Submit Query";
    }
    if (hasAnyConcreteRoles2(node, ["button"])) {
      var nameFromSubTree = computeMiscTextAlternative(node, {
        isEmbeddedInLabel: false,
        isReferenced: false
      });
      if (nameFromSubTree !== "") {
        return nameFromSubTree;
      }
    }
    return null;
  }
  __name(computeElementTextAlternative, "computeElementTextAlternative");
  function computeTextAlternative3(current, context) {
    if (consultedNodes.has(current)) {
      return "";
    }
    if (!hidden && isHidden2(current, getComputedStyle2) && !context.isReferenced) {
      consultedNodes.add(current);
      return "";
    }
    var labelAttributeNode = isElement2(current) ? current.getAttributeNode("aria-labelledby") : null;
    var labelElements = labelAttributeNode !== null && !consultedNodes.has(labelAttributeNode) ? queryIdRefs2(current, "aria-labelledby") : [];
    if (compute === "name" && !context.isReferenced && labelElements.length > 0) {
      consultedNodes.add(labelAttributeNode);
      return labelElements.map(function(element) {
        return computeTextAlternative3(element, {
          isEmbeddedInLabel: context.isEmbeddedInLabel,
          isReferenced: true,
          // this isn't recursion as specified, otherwise we would skip
          // `aria-label` in
          // <input id="myself" aria-label="foo" aria-labelledby="myself"
          recursion: false
        });
      }).join(" ");
    }
    var skipToStep2E = context.recursion && isControl2(current) && compute === "name";
    if (!skipToStep2E) {
      var ariaLabel = (isElement2(current) && current.getAttribute("aria-label") || "").trim();
      if (ariaLabel !== "" && compute === "name") {
        consultedNodes.add(current);
        return ariaLabel;
      }
      if (!isMarkedPresentational2(current)) {
        var elementTextAlternative = computeElementTextAlternative(current);
        if (elementTextAlternative !== null) {
          consultedNodes.add(current);
          return elementTextAlternative;
        }
      }
    }
    if (hasAnyConcreteRoles2(current, ["menu"])) {
      consultedNodes.add(current);
      return "";
    }
    if (skipToStep2E || context.isEmbeddedInLabel || context.isReferenced) {
      if (hasAnyConcreteRoles2(current, ["combobox", "listbox"])) {
        consultedNodes.add(current);
        var selectedOptions = querySelectedOptions2(current);
        if (selectedOptions.length === 0) {
          return isHTMLInputElement2(current) ? current.value : "";
        }
        return arrayFrom2(selectedOptions).map(function(selectedOption) {
          return computeTextAlternative3(selectedOption, {
            isEmbeddedInLabel: context.isEmbeddedInLabel,
            isReferenced: false,
            recursion: true
          });
        }).join(" ");
      }
      if (hasAbstractRole2(current, "range")) {
        consultedNodes.add(current);
        if (current.hasAttribute("aria-valuetext")) {
          return current.getAttribute("aria-valuetext");
        }
        if (current.hasAttribute("aria-valuenow")) {
          return current.getAttribute("aria-valuenow");
        }
        return current.getAttribute("value") || "";
      }
      if (hasAnyConcreteRoles2(current, ["textbox"])) {
        consultedNodes.add(current);
        return getValueOfTextbox2(current);
      }
    }
    if (allowsNameFromContent2(current) || isElement2(current) && context.isReferenced || isNativeHostLanguageTextAlternativeElement2(current) || isDescendantOfNativeHostLanguageTextAlternativeElement2(current)) {
      var accumulatedText2F = computeMiscTextAlternative(current, {
        isEmbeddedInLabel: context.isEmbeddedInLabel,
        isReferenced: false
      });
      if (accumulatedText2F !== "") {
        consultedNodes.add(current);
        return accumulatedText2F;
      }
    }
    if (current.nodeType === current.TEXT_NODE) {
      consultedNodes.add(current);
      return current.textContent || "";
    }
    if (context.recursion) {
      consultedNodes.add(current);
      return computeMiscTextAlternative(current, {
        isEmbeddedInLabel: context.isEmbeddedInLabel,
        isReferenced: false
      });
    }
    var tooltipAttributeValue = computeTooltipAttributeValue(current);
    if (tooltipAttributeValue !== null) {
      consultedNodes.add(current);
      return tooltipAttributeValue;
    }
    consultedNodes.add(current);
    return "";
  }
  __name(computeTextAlternative3, "computeTextAlternative");
  return asFlatString2(computeTextAlternative3(root2, {
    isEmbeddedInLabel: false,
    // by spec computeAccessibleDescription starts with the referenced elements as roots
    isReferenced: compute === "description",
    recursion: false
  }));
}
__name(computeTextAlternative2, "computeTextAlternative");

// ../node_modules/dom-accessibility-api/dist/accessible-description.mjs
function _typeof4(obj) {
  "@babel/helpers - typeof";
  return _typeof4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof4(obj);
}
__name(_typeof4, "_typeof");
function ownKeys2(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
__name(ownKeys2, "ownKeys");
function _objectSpread2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
      _defineProperty4(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
__name(_objectSpread2, "_objectSpread");
function _defineProperty4(obj, key, value) {
  key = _toPropertyKey4(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
__name(_defineProperty4, "_defineProperty");
function _toPropertyKey4(arg) {
  var key = _toPrimitive4(arg, "string");
  return _typeof4(key) === "symbol" ? key : String(key);
}
__name(_toPropertyKey4, "_toPropertyKey");
function _toPrimitive4(input2, hint) {
  if (_typeof4(input2) !== "object" || input2 === null) return input2;
  var prim = input2[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input2, hint || "default");
    if (_typeof4(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input2);
}
__name(_toPrimitive4, "_toPrimitive");
function computeAccessibleDescription2(root2) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var description = queryIdRefs2(root2, "aria-describedby").map(function(element) {
    return computeTextAlternative2(element, _objectSpread2(_objectSpread2({}, options), {}, {
      compute: "description"
    }));
  }).join(" ");
  if (description === "") {
    var title = root2.getAttribute("title");
    description = title === null ? "" : title;
  }
  return description;
}
__name(computeAccessibleDescription2, "computeAccessibleDescription");

// ../node_modules/dom-accessibility-api/dist/accessible-name.mjs
function prohibitsNaming2(node) {
  return hasAnyConcreteRoles2(node, ["caption", "code", "deletion", "emphasis", "generic", "insertion", "paragraph", "presentation", "strong", "subscript", "superscript"]);
}
__name(prohibitsNaming2, "prohibitsNaming");
function computeAccessibleName2(root2) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (prohibitsNaming2(root2)) {
    return "";
  }
  return computeTextAlternative2(root2, options);
}
__name(computeAccessibleName2, "computeAccessibleName");

// ../node_modules/@testing-library/dom/dist/@testing-library/dom.esm.js
var import_aria_query3 = __toESM(require_lib());
var import_lz_string = __toESM(require_lz_string());
function escapeHTML2(str2) {
  return str2.replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
__name(escapeHTML2, "escapeHTML");
var printProps2 = /* @__PURE__ */ __name((keys2, props, config4, indentation, depth, refs, printer2) => {
  const indentationNext = indentation + config4.indent;
  const colors3 = config4.colors;
  return keys2.map((key) => {
    const value = props[key];
    let printed = printer2(value, config4, indentationNext, depth, refs);
    if (typeof value !== "string") {
      if (printed.indexOf("\n") !== -1) {
        printed = config4.spacingOuter + indentationNext + printed + config4.spacingOuter + indentation;
      }
      printed = "{" + printed + "}";
    }
    return config4.spacingInner + indentation + colors3.prop.open + key + colors3.prop.close + "=" + colors3.value.open + printed + colors3.value.close;
  }).join("");
}, "printProps");
var NodeTypeTextNode = 3;
var printChildren2 = /* @__PURE__ */ __name((children, config4, indentation, depth, refs, printer2) => children.map((child) => {
  const printedChild = typeof child === "string" ? printText2(child, config4) : printer2(child, config4, indentation, depth, refs);
  if (printedChild === "" && typeof child === "object" && child !== null && child.nodeType !== NodeTypeTextNode) {
    return "";
  }
  return config4.spacingOuter + indentation + printedChild;
}).join(""), "printChildren");
var printText2 = /* @__PURE__ */ __name((text, config4) => {
  const contentColor = config4.colors.content;
  return contentColor.open + escapeHTML2(text) + contentColor.close;
}, "printText");
var printComment2 = /* @__PURE__ */ __name((comment, config4) => {
  const commentColor = config4.colors.comment;
  return commentColor.open + "<!--" + escapeHTML2(comment) + "-->" + commentColor.close;
}, "printComment");
var printElement2 = /* @__PURE__ */ __name((type5, printedProps, printedChildren, config4, indentation) => {
  const tagColor = config4.colors.tag;
  return tagColor.open + "<" + type5 + (printedProps && tagColor.close + printedProps + config4.spacingOuter + indentation + tagColor.open) + (printedChildren ? ">" + tagColor.close + printedChildren + config4.spacingOuter + indentation + tagColor.open + "</" + type5 : (printedProps && !config4.min ? "" : " ") + "/") + ">" + tagColor.close;
}, "printElement");
var printElementAsLeaf2 = /* @__PURE__ */ __name((type5, config4) => {
  const tagColor = config4.colors.tag;
  return tagColor.open + "<" + type5 + tagColor.close + " \u2026" + tagColor.open + " />" + tagColor.close;
}, "printElementAsLeaf");
var ELEMENT_NODE$1 = 1;
var TEXT_NODE$1 = 3;
var COMMENT_NODE$1 = 8;
var FRAGMENT_NODE2 = 11;
var ELEMENT_REGEXP2 = /^((HTML|SVG)\w*)?Element$/;
var isCustomElement2 = /* @__PURE__ */ __name((val) => {
  const {
    tagName
  } = val;
  return Boolean(typeof tagName === "string" && tagName.includes("-") || typeof val.hasAttribute === "function" && val.hasAttribute("is"));
}, "isCustomElement");
var testNode2 = /* @__PURE__ */ __name((val) => {
  const constructorName = val.constructor.name;
  const {
    nodeType
  } = val;
  return nodeType === ELEMENT_NODE$1 && (ELEMENT_REGEXP2.test(constructorName) || isCustomElement2(val)) || nodeType === TEXT_NODE$1 && constructorName === "Text" || nodeType === COMMENT_NODE$1 && constructorName === "Comment" || nodeType === FRAGMENT_NODE2 && constructorName === "DocumentFragment";
}, "testNode");
function nodeIsText2(node) {
  return node.nodeType === TEXT_NODE$1;
}
__name(nodeIsText2, "nodeIsText");
function nodeIsComment2(node) {
  return node.nodeType === COMMENT_NODE$1;
}
__name(nodeIsComment2, "nodeIsComment");
function nodeIsFragment2(node) {
  return node.nodeType === FRAGMENT_NODE2;
}
__name(nodeIsFragment2, "nodeIsFragment");
function createDOMElementFilter(filterNode) {
  return {
    test: /* @__PURE__ */ __name((val) => {
      var _val$constructor2;
      return ((val == null || (_val$constructor2 = val.constructor) == null ? void 0 : _val$constructor2.name) || isCustomElement2(val)) && testNode2(val);
    }, "test"),
    serialize: /* @__PURE__ */ __name((node, config4, indentation, depth, refs, printer2) => {
      if (nodeIsText2(node)) {
        return printText2(node.data, config4);
      }
      if (nodeIsComment2(node)) {
        return printComment2(node.data, config4);
      }
      const type5 = nodeIsFragment2(node) ? "DocumentFragment" : node.tagName.toLowerCase();
      if (++depth > config4.maxDepth) {
        return printElementAsLeaf2(type5, config4);
      }
      return printElement2(type5, printProps2(nodeIsFragment2(node) ? [] : Array.from(node.attributes).map((attr) => attr.name).sort(), nodeIsFragment2(node) ? {} : Array.from(node.attributes).reduce((props, attribute) => {
        props[attribute.name] = attribute.value;
        return props;
      }, {}), config4, indentation + config4.indent, depth, refs, printer2), printChildren2(Array.prototype.slice.call(node.childNodes || node.children).filter(filterNode), config4, indentation + config4.indent, depth, refs, printer2), config4, indentation);
    }, "serialize")
  };
}
__name(createDOMElementFilter, "createDOMElementFilter");
var picocolors = null;
var readFileSync = null;
var codeFrameColumns = null;
try {
  const nodeRequire = module && module.require;
  readFileSync = nodeRequire.call(module, "fs").readFileSync;
  codeFrameColumns = nodeRequire.call(module, "@babel/code-frame").codeFrameColumns;
  picocolors = nodeRequire.call(module, "picocolors");
} catch {
}
function getCodeFrame(frame) {
  const locationStart = frame.indexOf("(") + 1;
  const locationEnd = frame.indexOf(")");
  const frameLocation = frame.slice(locationStart, locationEnd);
  const frameLocationElements = frameLocation.split(":");
  const [filename, line, column] = [frameLocationElements[0], parseInt(frameLocationElements[1], 10), parseInt(frameLocationElements[2], 10)];
  let rawFileContents = "";
  try {
    rawFileContents = readFileSync(filename, "utf-8");
  } catch {
    return "";
  }
  const codeFrame = codeFrameColumns(rawFileContents, {
    start: {
      line,
      column
    }
  }, {
    highlightCode: true,
    linesBelow: 0
  });
  return picocolors.dim(frameLocation) + "\n" + codeFrame + "\n";
}
__name(getCodeFrame, "getCodeFrame");
function getUserCodeFrame() {
  if (!readFileSync || !codeFrameColumns) {
    return "";
  }
  const err = new Error();
  const firstClientCodeFrame = err.stack.split("\n").slice(1).find((frame) => !frame.includes("node_modules/"));
  return getCodeFrame(firstClientCodeFrame);
}
__name(getUserCodeFrame, "getUserCodeFrame");
var TEXT_NODE2 = 3;
function jestFakeTimersAreEnabled() {
  if (typeof jest !== "undefined" && jest !== null) {
    return (
      // legacy timers
      setTimeout._isMockFunction === true || // modern timers
      // eslint-disable-next-line prefer-object-has-own -- not supported by our support matrix
      Object.prototype.hasOwnProperty.call(setTimeout, "clock")
    );
  }
  return false;
}
__name(jestFakeTimersAreEnabled, "jestFakeTimersAreEnabled");
function getDocument() {
  if (typeof window === "undefined") {
    throw new Error("Could not find default container");
  }
  return window.document;
}
__name(getDocument, "getDocument");
function getWindowFromNode(node) {
  if (node.defaultView) {
    return node.defaultView;
  } else if (node.ownerDocument && node.ownerDocument.defaultView) {
    return node.ownerDocument.defaultView;
  } else if (node.window) {
    return node.window;
  } else if (node.ownerDocument && node.ownerDocument.defaultView === null) {
    throw new Error("It looks like the window object is not available for the provided node.");
  } else if (node.then instanceof Function) {
    throw new Error("It looks like you passed a Promise object instead of a DOM node. Did you do something like `fireEvent.click(screen.findBy...` when you meant to use a `getBy` query `fireEvent.click(screen.getBy...`, or await the findBy query `fireEvent.click(await screen.findBy...`?");
  } else if (Array.isArray(node)) {
    throw new Error("It looks like you passed an Array instead of a DOM node. Did you do something like `fireEvent.click(screen.getAllBy...` when you meant to use a `getBy` query `fireEvent.click(screen.getBy...`?");
  } else if (typeof node.debug === "function" && typeof node.logTestingPlaygroundURL === "function") {
    throw new Error("It looks like you passed a `screen` object. Did you do something like `fireEvent.click(screen, ...` when you meant to use a query, e.g. `fireEvent.click(screen.getBy..., `?");
  } else {
    throw new Error("The given node is not an Element, the node type is: " + typeof node + ".");
  }
}
__name(getWindowFromNode, "getWindowFromNode");
function checkContainerType(container) {
  if (!container || !(typeof container.querySelector === "function") || !(typeof container.querySelectorAll === "function")) {
    throw new TypeError("Expected container to be an Element, a Document or a DocumentFragment but got " + getTypeName(container) + ".");
  }
  function getTypeName(object) {
    if (typeof object === "object") {
      return object === null ? "null" : object.constructor.name;
    }
    return typeof object;
  }
  __name(getTypeName, "getTypeName");
}
__name(checkContainerType, "checkContainerType");
var shouldHighlight = /* @__PURE__ */ __name(() => {
  if (typeof process === "undefined") {
    return false;
  }
  let colors3;
  try {
    var _process$env;
    const colorsJSON = (_process$env = process.env) == null ? void 0 : _process$env.COLORS;
    if (colorsJSON) {
      colors3 = JSON.parse(colorsJSON);
    }
  } catch {
  }
  if (typeof colors3 === "boolean") {
    return colors3;
  } else {
    return process.versions !== void 0 && process.versions.node !== void 0;
  }
}, "shouldHighlight");
var {
  DOMCollection: DOMCollection3
} = prettyFormat.plugins;
var ELEMENT_NODE2 = 1;
var COMMENT_NODE2 = 8;
function filterCommentsAndDefaultIgnoreTagsTags(value) {
  return value.nodeType !== COMMENT_NODE2 && (value.nodeType !== ELEMENT_NODE2 || !value.matches(getConfig2().defaultIgnore));
}
__name(filterCommentsAndDefaultIgnoreTagsTags, "filterCommentsAndDefaultIgnoreTagsTags");
function prettyDOM(dom, maxLength, options) {
  if (options === void 0) {
    options = {};
  }
  if (!dom) {
    dom = getDocument().body;
  }
  if (typeof maxLength !== "number") {
    maxLength = typeof process !== "undefined" && typeof process.env !== "undefined" && process.env.DEBUG_PRINT_LIMIT || 7e3;
  }
  if (maxLength === 0) {
    return "";
  }
  if (dom.documentElement) {
    dom = dom.documentElement;
  }
  let domTypeName = typeof dom;
  if (domTypeName === "object") {
    domTypeName = dom.constructor.name;
  } else {
    dom = {};
  }
  if (!("outerHTML" in dom)) {
    throw new TypeError("Expected an element or document but got " + domTypeName);
  }
  const {
    filterNode = filterCommentsAndDefaultIgnoreTagsTags,
    ...prettyFormatOptions
  } = options;
  const debugContent = prettyFormat.format(dom, {
    plugins: [createDOMElementFilter(filterNode), DOMCollection3],
    printFunctionName: false,
    highlight: shouldHighlight(),
    ...prettyFormatOptions
  });
  return maxLength !== void 0 && dom.outerHTML.length > maxLength ? debugContent.slice(0, maxLength) + "..." : debugContent;
}
__name(prettyDOM, "prettyDOM");
var logDOM = /* @__PURE__ */ __name(function() {
  const userCodeFrame = getUserCodeFrame();
  if (userCodeFrame) {
    console.log(prettyDOM(...arguments) + "\n\n" + userCodeFrame);
  } else {
    console.log(prettyDOM(...arguments));
  }
}, "logDOM");
var config2 = {
  testIdAttribute: "data-testid",
  asyncUtilTimeout: 1e3,
  // asyncWrapper and advanceTimersWrapper is to support React's async `act` function.
  // forcing react-testing-library to wrap all async functions would've been
  // a total nightmare (consider wrapping every findBy* query and then also
  // updating `within` so those would be wrapped too. Total nightmare).
  // so we have this config option that's really only intended for
  // react-testing-library to use. For that reason, this feature will remain
  // undocumented.
  asyncWrapper: /* @__PURE__ */ __name((cb) => cb(), "asyncWrapper"),
  unstable_advanceTimersWrapper: /* @__PURE__ */ __name((cb) => cb(), "unstable_advanceTimersWrapper"),
  eventWrapper: /* @__PURE__ */ __name((cb) => cb(), "eventWrapper"),
  // default value for the `hidden` option in `ByRole` queries
  defaultHidden: false,
  // default value for the `ignore` option in `ByText` queries
  defaultIgnore: "script, style",
  // showOriginalStackTrace flag to show the full error stack traces for async errors
  showOriginalStackTrace: false,
  // throw errors w/ suggestions for better queries. Opt in so off by default.
  throwSuggestions: false,
  // called when getBy* queries fail. (message, container) => Error
  getElementError(message, container) {
    const prettifiedDOM = prettyDOM(container);
    const error = new Error([message, "Ignored nodes: comments, " + config2.defaultIgnore + "\n" + prettifiedDOM].filter(Boolean).join("\n\n"));
    error.name = "TestingLibraryElementError";
    return error;
  },
  _disableExpensiveErrorDiagnostics: false,
  computedStyleSupportsPseudoElements: false
};
function runWithExpensiveErrorDiagnosticsDisabled(callback) {
  try {
    config2._disableExpensiveErrorDiagnostics = true;
    return callback();
  } finally {
    config2._disableExpensiveErrorDiagnostics = false;
  }
}
__name(runWithExpensiveErrorDiagnosticsDisabled, "runWithExpensiveErrorDiagnosticsDisabled");
function configure(newConfig) {
  if (typeof newConfig === "function") {
    newConfig = newConfig(config2);
  }
  config2 = {
    ...config2,
    ...newConfig
  };
}
__name(configure, "configure");
function getConfig2() {
  return config2;
}
__name(getConfig2, "getConfig");
var labelledNodeNames = ["button", "meter", "output", "progress", "select", "textarea", "input"];
function getTextContent(node) {
  if (labelledNodeNames.includes(node.nodeName.toLowerCase())) {
    return "";
  }
  if (node.nodeType === TEXT_NODE2) return node.textContent;
  return Array.from(node.childNodes).map((childNode) => getTextContent(childNode)).join("");
}
__name(getTextContent, "getTextContent");
function getLabelContent(element) {
  let textContent;
  if (element.tagName.toLowerCase() === "label") {
    textContent = getTextContent(element);
  } else {
    textContent = element.value || element.textContent;
  }
  return textContent;
}
__name(getLabelContent, "getLabelContent");
function getRealLabels(element) {
  if (element.labels !== void 0) {
    var _labels;
    return (_labels = element.labels) != null ? _labels : [];
  }
  if (!isLabelable(element)) return [];
  const labels = element.ownerDocument.querySelectorAll("label");
  return Array.from(labels).filter((label) => label.control === element);
}
__name(getRealLabels, "getRealLabels");
function isLabelable(element) {
  return /BUTTON|METER|OUTPUT|PROGRESS|SELECT|TEXTAREA/.test(element.tagName) || element.tagName === "INPUT" && element.getAttribute("type") !== "hidden";
}
__name(isLabelable, "isLabelable");
function getLabels3(container, element, _temp) {
  let {
    selector = "*"
  } = _temp === void 0 ? {} : _temp;
  const ariaLabelledBy = element.getAttribute("aria-labelledby");
  const labelsId = ariaLabelledBy ? ariaLabelledBy.split(" ") : [];
  return labelsId.length ? labelsId.map((labelId) => {
    const labellingElement = container.querySelector('[id="' + labelId + '"]');
    return labellingElement ? {
      content: getLabelContent(labellingElement),
      formControl: null
    } : {
      content: "",
      formControl: null
    };
  }) : Array.from(getRealLabels(element)).map((label) => {
    const textToMatch = getLabelContent(label);
    const formControlSelector = "button, input, meter, output, progress, select, textarea";
    const labelledFormControl = Array.from(label.querySelectorAll(formControlSelector)).filter((formControlElement) => formControlElement.matches(selector))[0];
    return {
      content: textToMatch,
      formControl: labelledFormControl
    };
  });
}
__name(getLabels3, "getLabels");
function assertNotNullOrUndefined(matcher) {
  if (matcher === null || matcher === void 0) {
    throw new Error(
      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions -- implicitly converting `T` to `string`
      "It looks like " + matcher + " was passed instead of a matcher. Did you do something like getByText(" + matcher + ")?"
    );
  }
}
__name(assertNotNullOrUndefined, "assertNotNullOrUndefined");
function fuzzyMatches(textToMatch, node, matcher, normalizer) {
  if (typeof textToMatch !== "string") {
    return false;
  }
  assertNotNullOrUndefined(matcher);
  const normalizedText = normalizer(textToMatch);
  if (typeof matcher === "string" || typeof matcher === "number") {
    return normalizedText.toLowerCase().includes(matcher.toString().toLowerCase());
  } else if (typeof matcher === "function") {
    return matcher(normalizedText, node);
  } else {
    return matchRegExp(matcher, normalizedText);
  }
}
__name(fuzzyMatches, "fuzzyMatches");
function matches2(textToMatch, node, matcher, normalizer) {
  if (typeof textToMatch !== "string") {
    return false;
  }
  assertNotNullOrUndefined(matcher);
  const normalizedText = normalizer(textToMatch);
  if (matcher instanceof Function) {
    return matcher(normalizedText, node);
  } else if (matcher instanceof RegExp) {
    return matchRegExp(matcher, normalizedText);
  } else {
    return normalizedText === String(matcher);
  }
}
__name(matches2, "matches");
function getDefaultNormalizer(_temp) {
  let {
    trim = true,
    collapseWhitespace = true
  } = _temp === void 0 ? {} : _temp;
  return (text) => {
    let normalizedText = text;
    normalizedText = trim ? normalizedText.trim() : normalizedText;
    normalizedText = collapseWhitespace ? normalizedText.replace(/\s+/g, " ") : normalizedText;
    return normalizedText;
  };
}
__name(getDefaultNormalizer, "getDefaultNormalizer");
function makeNormalizer(_ref) {
  let {
    trim,
    collapseWhitespace,
    normalizer
  } = _ref;
  if (!normalizer) {
    return getDefaultNormalizer({
      trim,
      collapseWhitespace
    });
  }
  if (typeof trim !== "undefined" || typeof collapseWhitespace !== "undefined") {
    throw new Error('trim and collapseWhitespace are not supported with a normalizer. If you want to use the default trim and collapseWhitespace logic in your normalizer, use "getDefaultNormalizer({trim, collapseWhitespace})" and compose that into your normalizer');
  }
  return normalizer;
}
__name(makeNormalizer, "makeNormalizer");
function matchRegExp(matcher, text) {
  const match = matcher.test(text);
  if (matcher.global && matcher.lastIndex !== 0) {
    console.warn("To match all elements we had to reset the lastIndex of the RegExp because the global flag is enabled. We encourage to remove the global flag from the RegExp.");
    matcher.lastIndex = 0;
  }
  return match;
}
__name(matchRegExp, "matchRegExp");
function getNodeText(node) {
  if (node.matches("input[type=submit], input[type=button], input[type=reset]")) {
    return node.value;
  }
  return Array.from(node.childNodes).filter((child) => child.nodeType === TEXT_NODE2 && Boolean(child.textContent)).map((c2) => c2.textContent).join("");
}
__name(getNodeText, "getNodeText");
var elementRoleList2 = buildElementRoleList2(import_aria_query3.elementRoles);
function isSubtreeInaccessible(element) {
  if (element.hidden === true) {
    return true;
  }
  if (element.getAttribute("aria-hidden") === "true") {
    return true;
  }
  const window2 = element.ownerDocument.defaultView;
  if (window2.getComputedStyle(element).display === "none") {
    return true;
  }
  return false;
}
__name(isSubtreeInaccessible, "isSubtreeInaccessible");
function isInaccessible(element, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    isSubtreeInaccessible: isSubtreeInaccessibleImpl = isSubtreeInaccessible
  } = options;
  const window2 = element.ownerDocument.defaultView;
  if (window2.getComputedStyle(element).visibility === "hidden") {
    return true;
  }
  let currentElement = element;
  while (currentElement) {
    if (isSubtreeInaccessibleImpl(currentElement)) {
      return true;
    }
    currentElement = currentElement.parentElement;
  }
  return false;
}
__name(isInaccessible, "isInaccessible");
function getImplicitAriaRoles2(currentNode) {
  for (const {
    match,
    roles: roles3
  } of elementRoleList2) {
    if (match(currentNode)) {
      return [...roles3];
    }
  }
  return [];
}
__name(getImplicitAriaRoles2, "getImplicitAriaRoles");
function buildElementRoleList2(elementRolesMap) {
  function makeElementSelector(_ref) {
    let {
      name,
      attributes
    } = _ref;
    return "" + name + attributes.map((_ref2) => {
      let {
        name: attributeName,
        value,
        constraints = []
      } = _ref2;
      const shouldNotExist = constraints.indexOf("undefined") !== -1;
      const shouldBeNonEmpty = constraints.indexOf("set") !== -1;
      const hasExplicitValue = typeof value !== "undefined";
      if (hasExplicitValue) {
        return "[" + attributeName + '="' + value + '"]';
      } else if (shouldNotExist) {
        return ":not([" + attributeName + "])";
      } else if (shouldBeNonEmpty) {
        return "[" + attributeName + "]:not([" + attributeName + '=""])';
      }
      return "[" + attributeName + "]";
    }).join("");
  }
  __name(makeElementSelector, "makeElementSelector");
  function getSelectorSpecificity(_ref3) {
    let {
      attributes = []
    } = _ref3;
    return attributes.length;
  }
  __name(getSelectorSpecificity, "getSelectorSpecificity");
  function bySelectorSpecificity(_ref4, _ref5) {
    let {
      specificity: leftSpecificity
    } = _ref4;
    let {
      specificity: rightSpecificity
    } = _ref5;
    return rightSpecificity - leftSpecificity;
  }
  __name(bySelectorSpecificity, "bySelectorSpecificity");
  function match(element) {
    let {
      attributes = []
    } = element;
    const typeTextIndex = attributes.findIndex((attribute) => attribute.value && attribute.name === "type" && attribute.value === "text");
    if (typeTextIndex >= 0) {
      attributes = [...attributes.slice(0, typeTextIndex), ...attributes.slice(typeTextIndex + 1)];
    }
    const selector = makeElementSelector({
      ...element,
      attributes
    });
    return (node) => {
      if (typeTextIndex >= 0 && node.type !== "text") {
        return false;
      }
      return node.matches(selector);
    };
  }
  __name(match, "match");
  let result = [];
  for (const [element, roles3] of elementRolesMap.entries()) {
    result = [...result, {
      match: match(element),
      roles: Array.from(roles3),
      specificity: getSelectorSpecificity(element)
    }];
  }
  return result.sort(bySelectorSpecificity);
}
__name(buildElementRoleList2, "buildElementRoleList");
function getRoles(container, _temp) {
  let {
    hidden = false
  } = _temp === void 0 ? {} : _temp;
  function flattenDOM(node) {
    return [node, ...Array.from(node.children).reduce((acc, child) => [...acc, ...flattenDOM(child)], [])];
  }
  __name(flattenDOM, "flattenDOM");
  return flattenDOM(container).filter((element) => {
    return hidden === false ? isInaccessible(element) === false : true;
  }).reduce((acc, node) => {
    let roles3 = [];
    if (node.hasAttribute("role")) {
      roles3 = node.getAttribute("role").split(" ").slice(0, 1);
    } else {
      roles3 = getImplicitAriaRoles2(node);
    }
    return roles3.reduce((rolesAcc, role) => Array.isArray(rolesAcc[role]) ? {
      ...rolesAcc,
      [role]: [...rolesAcc[role], node]
    } : {
      ...rolesAcc,
      [role]: [node]
    }, acc);
  }, {});
}
__name(getRoles, "getRoles");
function prettyRoles(dom, _ref6) {
  let {
    hidden,
    includeDescription
  } = _ref6;
  const roles3 = getRoles(dom, {
    hidden
  });
  return Object.entries(roles3).filter((_ref7) => {
    let [role] = _ref7;
    return role !== "generic";
  }).map((_ref8) => {
    let [role, elements] = _ref8;
    const delimiterBar = "-".repeat(50);
    const elementsString = elements.map((el) => {
      const nameString = 'Name "' + computeAccessibleName2(el, {
        computedStyleSupportsPseudoElements: getConfig2().computedStyleSupportsPseudoElements
      }) + '":\n';
      const domString = prettyDOM(el.cloneNode(false));
      if (includeDescription) {
        const descriptionString = 'Description "' + computeAccessibleDescription2(el, {
          computedStyleSupportsPseudoElements: getConfig2().computedStyleSupportsPseudoElements
        }) + '":\n';
        return "" + nameString + descriptionString + domString;
      }
      return "" + nameString + domString;
    }).join("\n\n");
    return role + ":\n\n" + elementsString + "\n\n" + delimiterBar;
  }).join("\n");
}
__name(prettyRoles, "prettyRoles");
var logRoles = /* @__PURE__ */ __name(function(dom, _temp2) {
  let {
    hidden = false
  } = _temp2 === void 0 ? {} : _temp2;
  return console.log(prettyRoles(dom, {
    hidden
  }));
}, "logRoles");
function computeAriaSelected(element) {
  if (element.tagName === "OPTION") {
    return element.selected;
  }
  return checkBooleanAttribute(element, "aria-selected");
}
__name(computeAriaSelected, "computeAriaSelected");
function computeAriaBusy(element) {
  return element.getAttribute("aria-busy") === "true";
}
__name(computeAriaBusy, "computeAriaBusy");
function computeAriaChecked(element) {
  if ("indeterminate" in element && element.indeterminate) {
    return void 0;
  }
  if ("checked" in element) {
    return element.checked;
  }
  return checkBooleanAttribute(element, "aria-checked");
}
__name(computeAriaChecked, "computeAriaChecked");
function computeAriaPressed(element) {
  return checkBooleanAttribute(element, "aria-pressed");
}
__name(computeAriaPressed, "computeAriaPressed");
function computeAriaCurrent(element) {
  var _ref9, _checkBooleanAttribut;
  return (_ref9 = (_checkBooleanAttribut = checkBooleanAttribute(element, "aria-current")) != null ? _checkBooleanAttribut : element.getAttribute("aria-current")) != null ? _ref9 : false;
}
__name(computeAriaCurrent, "computeAriaCurrent");
function computeAriaExpanded(element) {
  return checkBooleanAttribute(element, "aria-expanded");
}
__name(computeAriaExpanded, "computeAriaExpanded");
function checkBooleanAttribute(element, attribute) {
  const attributeValue = element.getAttribute(attribute);
  if (attributeValue === "true") {
    return true;
  }
  if (attributeValue === "false") {
    return false;
  }
  return void 0;
}
__name(checkBooleanAttribute, "checkBooleanAttribute");
function computeHeadingLevel(element) {
  const implicitHeadingLevels = {
    H1: 1,
    H2: 2,
    H3: 3,
    H4: 4,
    H5: 5,
    H6: 6
  };
  const ariaLevelAttribute = element.getAttribute("aria-level") && Number(element.getAttribute("aria-level"));
  return ariaLevelAttribute || implicitHeadingLevels[element.tagName];
}
__name(computeHeadingLevel, "computeHeadingLevel");
function computeAriaValueNow(element) {
  const valueNow = element.getAttribute("aria-valuenow");
  return valueNow === null ? void 0 : +valueNow;
}
__name(computeAriaValueNow, "computeAriaValueNow");
function computeAriaValueMax(element) {
  const valueMax = element.getAttribute("aria-valuemax");
  return valueMax === null ? void 0 : +valueMax;
}
__name(computeAriaValueMax, "computeAriaValueMax");
function computeAriaValueMin(element) {
  const valueMin = element.getAttribute("aria-valuemin");
  return valueMin === null ? void 0 : +valueMin;
}
__name(computeAriaValueMin, "computeAriaValueMin");
function computeAriaValueText(element) {
  const valueText = element.getAttribute("aria-valuetext");
  return valueText === null ? void 0 : valueText;
}
__name(computeAriaValueText, "computeAriaValueText");
var normalize2 = getDefaultNormalizer();
function escapeRegExp(string) {
  return string.replace(/[.*+\-?^${}()|[\]\\]/g, "\\$&");
}
__name(escapeRegExp, "escapeRegExp");
function getRegExpMatcher(string) {
  return new RegExp(escapeRegExp(string.toLowerCase()), "i");
}
__name(getRegExpMatcher, "getRegExpMatcher");
function makeSuggestion(queryName, element, content, _ref) {
  let {
    variant,
    name
  } = _ref;
  let warning = "";
  const queryOptions = {};
  const queryArgs = [["Role", "TestId"].includes(queryName) ? content : getRegExpMatcher(content)];
  if (name) {
    queryOptions.name = getRegExpMatcher(name);
  }
  if (queryName === "Role" && isInaccessible(element)) {
    queryOptions.hidden = true;
    warning = "Element is inaccessible. This means that the element and all its children are invisible to screen readers.\n    If you are using the aria-hidden prop, make sure this is the right choice for your case.\n    ";
  }
  if (Object.keys(queryOptions).length > 0) {
    queryArgs.push(queryOptions);
  }
  const queryMethod = variant + "By" + queryName;
  return {
    queryName,
    queryMethod,
    queryArgs,
    variant,
    warning,
    toString() {
      if (warning) {
        console.warn(warning);
      }
      let [text, options] = queryArgs;
      text = typeof text === "string" ? "'" + text + "'" : text;
      options = options ? ", { " + Object.entries(options).map((_ref2) => {
        let [k2, v2] = _ref2;
        return k2 + ": " + v2;
      }).join(", ") + " }" : "";
      return queryMethod + "(" + text + options + ")";
    }
  };
}
__name(makeSuggestion, "makeSuggestion");
function canSuggest(currentMethod, requestedMethod, data) {
  return data && (!requestedMethod || requestedMethod.toLowerCase() === currentMethod.toLowerCase());
}
__name(canSuggest, "canSuggest");
function getSuggestedQuery(element, variant, method) {
  var _element$getAttribute, _getImplicitAriaRoles;
  if (variant === void 0) {
    variant = "get";
  }
  if (element.matches(getConfig2().defaultIgnore)) {
    return void 0;
  }
  const role = (_element$getAttribute = element.getAttribute("role")) != null ? _element$getAttribute : (_getImplicitAriaRoles = getImplicitAriaRoles2(element)) == null ? void 0 : _getImplicitAriaRoles[0];
  if (role !== "generic" && canSuggest("Role", method, role)) {
    return makeSuggestion("Role", element, role, {
      variant,
      name: computeAccessibleName2(element, {
        computedStyleSupportsPseudoElements: getConfig2().computedStyleSupportsPseudoElements
      })
    });
  }
  const labelText = getLabels3(document, element).map((label) => label.content).join(" ");
  if (canSuggest("LabelText", method, labelText)) {
    return makeSuggestion("LabelText", element, labelText, {
      variant
    });
  }
  const placeholderText = element.getAttribute("placeholder");
  if (canSuggest("PlaceholderText", method, placeholderText)) {
    return makeSuggestion("PlaceholderText", element, placeholderText, {
      variant
    });
  }
  const textContent = normalize2(getNodeText(element));
  if (canSuggest("Text", method, textContent)) {
    return makeSuggestion("Text", element, textContent, {
      variant
    });
  }
  if (canSuggest("DisplayValue", method, element.value)) {
    return makeSuggestion("DisplayValue", element, normalize2(element.value), {
      variant
    });
  }
  const alt = element.getAttribute("alt");
  if (canSuggest("AltText", method, alt)) {
    return makeSuggestion("AltText", element, alt, {
      variant
    });
  }
  const title = element.getAttribute("title");
  if (canSuggest("Title", method, title)) {
    return makeSuggestion("Title", element, title, {
      variant
    });
  }
  const testId = element.getAttribute(getConfig2().testIdAttribute);
  if (canSuggest("TestId", method, testId)) {
    return makeSuggestion("TestId", element, testId, {
      variant
    });
  }
  return void 0;
}
__name(getSuggestedQuery, "getSuggestedQuery");
function copyStackTrace(target, source) {
  target.stack = source.stack.replace(source.message, target.message);
}
__name(copyStackTrace, "copyStackTrace");
function waitFor(callback, _ref) {
  let {
    container = getDocument(),
    timeout = getConfig2().asyncUtilTimeout,
    showOriginalStackTrace = getConfig2().showOriginalStackTrace,
    stackTraceError,
    interval = 50,
    onTimeout = /* @__PURE__ */ __name((error) => {
      Object.defineProperty(error, "message", {
        value: getConfig2().getElementError(error.message, container).message
      });
      return error;
    }, "onTimeout"),
    mutationObserverOptions = {
      subtree: true,
      childList: true,
      attributes: true,
      characterData: true
    }
  } = _ref;
  if (typeof callback !== "function") {
    throw new TypeError("Received `callback` arg must be a function");
  }
  return new Promise(async (resolve, reject) => {
    let lastError, intervalId, observer;
    let finished = false;
    let promiseStatus = "idle";
    const overallTimeoutTimer = setTimeout(handleTimeout, timeout);
    const usingJestFakeTimers = jestFakeTimersAreEnabled();
    if (usingJestFakeTimers) {
      const {
        unstable_advanceTimersWrapper: advanceTimersWrapper
      } = getConfig2();
      checkCallback();
      while (!finished) {
        if (!jestFakeTimersAreEnabled()) {
          const error = new Error("Changed from using fake timers to real timers while using waitFor. This is not allowed and will result in very strange behavior. Please ensure you're awaiting all async things your test is doing before changing to real timers. For more info, please go to https://github.com/testing-library/dom-testing-library/issues/830");
          if (!showOriginalStackTrace) copyStackTrace(error, stackTraceError);
          reject(error);
          return;
        }
        await advanceTimersWrapper(async () => {
          jest.advanceTimersByTime(interval);
        });
        if (finished) {
          break;
        }
        checkCallback();
      }
    } else {
      try {
        checkContainerType(container);
      } catch (e2) {
        reject(e2);
        return;
      }
      intervalId = setInterval(checkRealTimersCallback, interval);
      const {
        MutationObserver: MutationObserver2
      } = getWindowFromNode(container);
      observer = new MutationObserver2(checkRealTimersCallback);
      observer.observe(container, mutationObserverOptions);
      checkCallback();
    }
    function onDone(error, result) {
      finished = true;
      clearTimeout(overallTimeoutTimer);
      if (!usingJestFakeTimers) {
        clearInterval(intervalId);
        observer.disconnect();
      }
      if (error) {
        reject(error);
      } else {
        resolve(result);
      }
    }
    __name(onDone, "onDone");
    function checkRealTimersCallback() {
      if (jestFakeTimersAreEnabled()) {
        const error = new Error("Changed from using real timers to fake timers while using waitFor. This is not allowed and will result in very strange behavior. Please ensure you're awaiting all async things your test is doing before changing to fake timers. For more info, please go to https://github.com/testing-library/dom-testing-library/issues/830");
        if (!showOriginalStackTrace) copyStackTrace(error, stackTraceError);
        return reject(error);
      } else {
        return checkCallback();
      }
    }
    __name(checkRealTimersCallback, "checkRealTimersCallback");
    function checkCallback() {
      if (promiseStatus === "pending") return;
      try {
        const result = runWithExpensiveErrorDiagnosticsDisabled(callback);
        if (typeof (result == null ? void 0 : result.then) === "function") {
          promiseStatus = "pending";
          result.then((resolvedValue) => {
            promiseStatus = "resolved";
            onDone(null, resolvedValue);
          }, (rejectedValue) => {
            promiseStatus = "rejected";
            lastError = rejectedValue;
          });
        } else {
          onDone(null, result);
        }
      } catch (error) {
        lastError = error;
      }
    }
    __name(checkCallback, "checkCallback");
    function handleTimeout() {
      let error;
      if (lastError) {
        error = lastError;
        if (!showOriginalStackTrace && error.name === "TestingLibraryElementError") {
          copyStackTrace(error, stackTraceError);
        }
      } else {
        error = new Error("Timed out in waitFor.");
        if (!showOriginalStackTrace) {
          copyStackTrace(error, stackTraceError);
        }
      }
      onDone(onTimeout(error), null);
    }
    __name(handleTimeout, "handleTimeout");
  });
}
__name(waitFor, "waitFor");
function waitForWrapper(callback, options) {
  const stackTraceError = new Error("STACK_TRACE_MESSAGE");
  return getConfig2().asyncWrapper(() => waitFor(callback, {
    stackTraceError,
    ...options
  }));
}
__name(waitForWrapper, "waitForWrapper");
function getElementError(message, container) {
  return getConfig2().getElementError(message, container);
}
__name(getElementError, "getElementError");
function getMultipleElementsFoundError(message, container) {
  return getElementError(message + "\n\n(If this is intentional, then use the `*AllBy*` variant of the query (like `queryAllByText`, `getAllByText`, or `findAllByText`)).", container);
}
__name(getMultipleElementsFoundError, "getMultipleElementsFoundError");
function queryAllByAttribute(attribute, container, text, _temp) {
  let {
    exact = true,
    collapseWhitespace,
    trim,
    normalizer
  } = _temp === void 0 ? {} : _temp;
  const matcher = exact ? matches2 : fuzzyMatches;
  const matchNormalizer = makeNormalizer({
    collapseWhitespace,
    trim,
    normalizer
  });
  return Array.from(container.querySelectorAll("[" + attribute + "]")).filter((node) => matcher(node.getAttribute(attribute), node, text, matchNormalizer));
}
__name(queryAllByAttribute, "queryAllByAttribute");
function queryByAttribute(attribute, container, text, options) {
  const els = queryAllByAttribute(attribute, container, text, options);
  if (els.length > 1) {
    throw getMultipleElementsFoundError("Found multiple elements by [" + attribute + "=" + text + "]", container);
  }
  return els[0] || null;
}
__name(queryByAttribute, "queryByAttribute");
function makeSingleQuery(allQuery, getMultipleError2) {
  return function(container) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    const els = allQuery(container, ...args);
    if (els.length > 1) {
      const elementStrings = els.map((element) => getElementError(null, element).message).join("\n\n");
      throw getMultipleElementsFoundError(getMultipleError2(container, ...args) + "\n\nHere are the matching elements:\n\n" + elementStrings, container);
    }
    return els[0] || null;
  };
}
__name(makeSingleQuery, "makeSingleQuery");
function getSuggestionError(suggestion, container) {
  return getConfig2().getElementError("A better query is available, try this:\n" + suggestion.toString() + "\n", container);
}
__name(getSuggestionError, "getSuggestionError");
function makeGetAllQuery(allQuery, getMissingError2) {
  return function(container) {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }
    const els = allQuery(container, ...args);
    if (!els.length) {
      throw getConfig2().getElementError(getMissingError2(container, ...args), container);
    }
    return els;
  };
}
__name(makeGetAllQuery, "makeGetAllQuery");
function makeFindQuery(getter) {
  return (container, text, options, waitForOptions) => {
    return waitForWrapper(() => {
      return getter(container, text, options);
    }, {
      container,
      ...waitForOptions
    });
  };
}
__name(makeFindQuery, "makeFindQuery");
var wrapSingleQueryWithSuggestion = /* @__PURE__ */ __name((query, queryAllByName, variant) => function(container) {
  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    args[_key3 - 1] = arguments[_key3];
  }
  const element = query(container, ...args);
  const [{
    suggest = getConfig2().throwSuggestions
  } = {}] = args.slice(-1);
  if (element && suggest) {
    const suggestion = getSuggestedQuery(element, variant);
    if (suggestion && !queryAllByName.endsWith(suggestion.queryName)) {
      throw getSuggestionError(suggestion.toString(), container);
    }
  }
  return element;
}, "wrapSingleQueryWithSuggestion");
var wrapAllByQueryWithSuggestion = /* @__PURE__ */ __name((query, queryAllByName, variant) => function(container) {
  for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
    args[_key4 - 1] = arguments[_key4];
  }
  const els = query(container, ...args);
  const [{
    suggest = getConfig2().throwSuggestions
  } = {}] = args.slice(-1);
  if (els.length && suggest) {
    const uniqueSuggestionMessages = [...new Set(els.map((element) => {
      var _getSuggestedQuery;
      return (_getSuggestedQuery = getSuggestedQuery(element, variant)) == null ? void 0 : _getSuggestedQuery.toString();
    }))];
    if (
      // only want to suggest if all the els have the same suggestion.
      uniqueSuggestionMessages.length === 1 && !queryAllByName.endsWith(
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- TODO: Can this be null at runtime?
        getSuggestedQuery(els[0], variant).queryName
      )
    ) {
      throw getSuggestionError(uniqueSuggestionMessages[0], container);
    }
  }
  return els;
}, "wrapAllByQueryWithSuggestion");
function buildQueries(queryAllBy, getMultipleError2, getMissingError2) {
  const queryBy = wrapSingleQueryWithSuggestion(makeSingleQuery(queryAllBy, getMultipleError2), queryAllBy.name, "query");
  const getAllBy = makeGetAllQuery(queryAllBy, getMissingError2);
  const getBy = makeSingleQuery(getAllBy, getMultipleError2);
  const getByWithSuggestions = wrapSingleQueryWithSuggestion(getBy, queryAllBy.name, "get");
  const getAllWithSuggestions = wrapAllByQueryWithSuggestion(getAllBy, queryAllBy.name.replace("query", "get"), "getAll");
  const findAllBy = makeFindQuery(wrapAllByQueryWithSuggestion(getAllBy, queryAllBy.name, "findAll"));
  const findBy = makeFindQuery(wrapSingleQueryWithSuggestion(getBy, queryAllBy.name, "find"));
  return [queryBy, getAllWithSuggestions, getByWithSuggestions, findAllBy, findBy];
}
__name(buildQueries, "buildQueries");
var queryHelpers = Object.freeze({
  __proto__: null,
  getElementError,
  wrapAllByQueryWithSuggestion,
  wrapSingleQueryWithSuggestion,
  getMultipleElementsFoundError,
  queryAllByAttribute,
  queryByAttribute,
  makeSingleQuery,
  makeGetAllQuery,
  makeFindQuery,
  buildQueries
});
function queryAllLabels(container) {
  return Array.from(container.querySelectorAll("label,input")).map((node) => {
    return {
      node,
      textToMatch: getLabelContent(node)
    };
  }).filter((_ref) => {
    let {
      textToMatch
    } = _ref;
    return textToMatch !== null;
  });
}
__name(queryAllLabels, "queryAllLabels");
var queryAllLabelsByText = /* @__PURE__ */ __name(function(container, text, _temp) {
  let {
    exact = true,
    trim,
    collapseWhitespace,
    normalizer
  } = _temp === void 0 ? {} : _temp;
  const matcher = exact ? matches2 : fuzzyMatches;
  const matchNormalizer = makeNormalizer({
    collapseWhitespace,
    trim,
    normalizer
  });
  const textToMatchByLabels = queryAllLabels(container);
  return textToMatchByLabels.filter((_ref2) => {
    let {
      node,
      textToMatch
    } = _ref2;
    return matcher(textToMatch, node, text, matchNormalizer);
  }).map((_ref3) => {
    let {
      node
    } = _ref3;
    return node;
  });
}, "queryAllLabelsByText");
var queryAllByLabelText = /* @__PURE__ */ __name(function(container, text, _temp2) {
  let {
    selector = "*",
    exact = true,
    collapseWhitespace,
    trim,
    normalizer
  } = _temp2 === void 0 ? {} : _temp2;
  checkContainerType(container);
  const matcher = exact ? matches2 : fuzzyMatches;
  const matchNormalizer = makeNormalizer({
    collapseWhitespace,
    trim,
    normalizer
  });
  const matchingLabelledElements = Array.from(container.querySelectorAll("*")).filter((element) => {
    return getRealLabels(element).length || element.hasAttribute("aria-labelledby");
  }).reduce((labelledElements, labelledElement) => {
    const labelList = getLabels3(container, labelledElement, {
      selector
    });
    labelList.filter((label) => Boolean(label.formControl)).forEach((label) => {
      if (matcher(label.content, label.formControl, text, matchNormalizer) && label.formControl) {
        labelledElements.push(label.formControl);
      }
    });
    const labelsValue = labelList.filter((label) => Boolean(label.content)).map((label) => label.content);
    if (matcher(labelsValue.join(" "), labelledElement, text, matchNormalizer)) {
      labelledElements.push(labelledElement);
    }
    if (labelsValue.length > 1) {
      labelsValue.forEach((labelValue, index2) => {
        if (matcher(labelValue, labelledElement, text, matchNormalizer)) {
          labelledElements.push(labelledElement);
        }
        const labelsFiltered = [...labelsValue];
        labelsFiltered.splice(index2, 1);
        if (labelsFiltered.length > 1) {
          if (matcher(labelsFiltered.join(" "), labelledElement, text, matchNormalizer)) {
            labelledElements.push(labelledElement);
          }
        }
      });
    }
    return labelledElements;
  }, []).concat(queryAllByAttribute("aria-label", container, text, {
    exact,
    normalizer: matchNormalizer
  }));
  return Array.from(new Set(matchingLabelledElements)).filter((element) => element.matches(selector));
}, "queryAllByLabelText");
var getAllByLabelText = /* @__PURE__ */ __name(function(container, text) {
  for (var _len = arguments.length, rest = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    rest[_key - 2] = arguments[_key];
  }
  const els = queryAllByLabelText(container, text, ...rest);
  if (!els.length) {
    const labels = queryAllLabelsByText(container, text, ...rest);
    if (labels.length) {
      const tagNames = labels.map((label) => getTagNameOfElementAssociatedWithLabelViaFor(container, label)).filter((tagName) => !!tagName);
      if (tagNames.length) {
        throw getConfig2().getElementError(tagNames.map((tagName) => "Found a label with the text of: " + text + ", however the element associated with this label (<" + tagName + " />) is non-labellable [https://html.spec.whatwg.org/multipage/forms.html#category-label]. If you really need to label a <" + tagName + " />, you can use aria-label or aria-labelledby instead.").join("\n\n"), container);
      } else {
        throw getConfig2().getElementError("Found a label with the text of: " + text + `, however no form control was found associated to that label. Make sure you're using the "for" attribute or "aria-labelledby" attribute correctly.`, container);
      }
    } else {
      throw getConfig2().getElementError("Unable to find a label with the text of: " + text, container);
    }
  }
  return els;
}, "getAllByLabelText");
function getTagNameOfElementAssociatedWithLabelViaFor(container, label) {
  const htmlFor = label.getAttribute("for");
  if (!htmlFor) {
    return null;
  }
  const element = container.querySelector('[id="' + htmlFor + '"]');
  return element ? element.tagName.toLowerCase() : null;
}
__name(getTagNameOfElementAssociatedWithLabelViaFor, "getTagNameOfElementAssociatedWithLabelViaFor");
var getMultipleError$7 = /* @__PURE__ */ __name((c2, text) => "Found multiple elements with the text of: " + text, "getMultipleError$7");
var queryByLabelText = wrapSingleQueryWithSuggestion(makeSingleQuery(queryAllByLabelText, getMultipleError$7), queryAllByLabelText.name, "query");
var getByLabelText = makeSingleQuery(getAllByLabelText, getMultipleError$7);
var findAllByLabelText = makeFindQuery(wrapAllByQueryWithSuggestion(getAllByLabelText, getAllByLabelText.name, "findAll"));
var findByLabelText = makeFindQuery(wrapSingleQueryWithSuggestion(getByLabelText, getAllByLabelText.name, "find"));
var getAllByLabelTextWithSuggestions = wrapAllByQueryWithSuggestion(getAllByLabelText, getAllByLabelText.name, "getAll");
var getByLabelTextWithSuggestions = wrapSingleQueryWithSuggestion(getByLabelText, getAllByLabelText.name, "get");
var queryAllByLabelTextWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByLabelText, queryAllByLabelText.name, "queryAll");
var queryAllByPlaceholderText = /* @__PURE__ */ __name(function() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  checkContainerType(args[0]);
  return queryAllByAttribute("placeholder", ...args);
}, "queryAllByPlaceholderText");
var getMultipleError$6 = /* @__PURE__ */ __name((c2, text) => "Found multiple elements with the placeholder text of: " + text, "getMultipleError$6");
var getMissingError$6 = /* @__PURE__ */ __name((c2, text) => "Unable to find an element with the placeholder text of: " + text, "getMissingError$6");
var queryAllByPlaceholderTextWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByPlaceholderText, queryAllByPlaceholderText.name, "queryAll");
var [queryByPlaceholderText, getAllByPlaceholderText, getByPlaceholderText, findAllByPlaceholderText, findByPlaceholderText] = buildQueries(queryAllByPlaceholderText, getMultipleError$6, getMissingError$6);
var queryAllByText = /* @__PURE__ */ __name(function(container, text, _temp) {
  let {
    selector = "*",
    exact = true,
    collapseWhitespace,
    trim,
    ignore = getConfig2().defaultIgnore,
    normalizer
  } = _temp === void 0 ? {} : _temp;
  checkContainerType(container);
  const matcher = exact ? matches2 : fuzzyMatches;
  const matchNormalizer = makeNormalizer({
    collapseWhitespace,
    trim,
    normalizer
  });
  let baseArray = [];
  if (typeof container.matches === "function" && container.matches(selector)) {
    baseArray = [container];
  }
  return [...baseArray, ...Array.from(container.querySelectorAll(selector))].filter((node) => !ignore || !node.matches(ignore)).filter((node) => matcher(getNodeText(node), node, text, matchNormalizer));
}, "queryAllByText");
var getMultipleError$5 = /* @__PURE__ */ __name((c2, text) => "Found multiple elements with the text: " + text, "getMultipleError$5");
var getMissingError$5 = /* @__PURE__ */ __name(function(c2, text, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    collapseWhitespace,
    trim,
    normalizer,
    selector
  } = options;
  const matchNormalizer = makeNormalizer({
    collapseWhitespace,
    trim,
    normalizer
  });
  const normalizedText = matchNormalizer(text.toString());
  const isNormalizedDifferent = normalizedText !== text.toString();
  const isCustomSelector = (selector != null ? selector : "*") !== "*";
  return "Unable to find an element with the text: " + (isNormalizedDifferent ? normalizedText + " (normalized from '" + text + "')" : text) + (isCustomSelector ? ", which matches selector '" + selector + "'" : "") + ". This could be because the text is broken up by multiple elements. In this case, you can provide a function for your text matcher to make your matcher more flexible.";
}, "getMissingError$5");
var queryAllByTextWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByText, queryAllByText.name, "queryAll");
var [queryByText, getAllByText, getByText, findAllByText, findByText] = buildQueries(queryAllByText, getMultipleError$5, getMissingError$5);
var queryAllByDisplayValue = /* @__PURE__ */ __name(function(container, value, _temp) {
  let {
    exact = true,
    collapseWhitespace,
    trim,
    normalizer
  } = _temp === void 0 ? {} : _temp;
  checkContainerType(container);
  const matcher = exact ? matches2 : fuzzyMatches;
  const matchNormalizer = makeNormalizer({
    collapseWhitespace,
    trim,
    normalizer
  });
  return Array.from(container.querySelectorAll("input,textarea,select")).filter((node) => {
    if (node.tagName === "SELECT") {
      const selectedOptions = Array.from(node.options).filter((option) => option.selected);
      return selectedOptions.some((optionNode) => matcher(getNodeText(optionNode), optionNode, value, matchNormalizer));
    } else {
      return matcher(node.value, node, value, matchNormalizer);
    }
  });
}, "queryAllByDisplayValue");
var getMultipleError$4 = /* @__PURE__ */ __name((c2, value) => "Found multiple elements with the display value: " + value + ".", "getMultipleError$4");
var getMissingError$4 = /* @__PURE__ */ __name((c2, value) => "Unable to find an element with the display value: " + value + ".", "getMissingError$4");
var queryAllByDisplayValueWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByDisplayValue, queryAllByDisplayValue.name, "queryAll");
var [queryByDisplayValue, getAllByDisplayValue, getByDisplayValue, findAllByDisplayValue, findByDisplayValue] = buildQueries(queryAllByDisplayValue, getMultipleError$4, getMissingError$4);
var VALID_TAG_REGEXP = /^(img|input|area|.+-.+)$/i;
var queryAllByAltText = /* @__PURE__ */ __name(function(container, alt, options) {
  if (options === void 0) {
    options = {};
  }
  checkContainerType(container);
  return queryAllByAttribute("alt", container, alt, options).filter((node) => VALID_TAG_REGEXP.test(node.tagName));
}, "queryAllByAltText");
var getMultipleError$3 = /* @__PURE__ */ __name((c2, alt) => "Found multiple elements with the alt text: " + alt, "getMultipleError$3");
var getMissingError$3 = /* @__PURE__ */ __name((c2, alt) => "Unable to find an element with the alt text: " + alt, "getMissingError$3");
var queryAllByAltTextWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByAltText, queryAllByAltText.name, "queryAll");
var [queryByAltText, getAllByAltText, getByAltText, findAllByAltText, findByAltText] = buildQueries(queryAllByAltText, getMultipleError$3, getMissingError$3);
var isSvgTitle = /* @__PURE__ */ __name((node) => {
  var _node$parentElement;
  return node.tagName.toLowerCase() === "title" && ((_node$parentElement = node.parentElement) == null ? void 0 : _node$parentElement.tagName.toLowerCase()) === "svg";
}, "isSvgTitle");
var queryAllByTitle = /* @__PURE__ */ __name(function(container, text, _temp) {
  let {
    exact = true,
    collapseWhitespace,
    trim,
    normalizer
  } = _temp === void 0 ? {} : _temp;
  checkContainerType(container);
  const matcher = exact ? matches2 : fuzzyMatches;
  const matchNormalizer = makeNormalizer({
    collapseWhitespace,
    trim,
    normalizer
  });
  return Array.from(container.querySelectorAll("[title], svg > title")).filter((node) => matcher(node.getAttribute("title"), node, text, matchNormalizer) || isSvgTitle(node) && matcher(getNodeText(node), node, text, matchNormalizer));
}, "queryAllByTitle");
var getMultipleError$2 = /* @__PURE__ */ __name((c2, title) => "Found multiple elements with the title: " + title + ".", "getMultipleError$2");
var getMissingError$2 = /* @__PURE__ */ __name((c2, title) => "Unable to find an element with the title: " + title + ".", "getMissingError$2");
var queryAllByTitleWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByTitle, queryAllByTitle.name, "queryAll");
var [queryByTitle, getAllByTitle, getByTitle, findAllByTitle, findByTitle] = buildQueries(queryAllByTitle, getMultipleError$2, getMissingError$2);
var queryAllByRole = /* @__PURE__ */ __name(function(container, role, _temp) {
  let {
    hidden = getConfig2().defaultHidden,
    name,
    description,
    queryFallbacks = false,
    selected,
    busy,
    checked,
    pressed,
    current,
    level,
    expanded,
    value: {
      now: valueNow,
      min: valueMin,
      max: valueMax,
      text: valueText
    } = {}
  } = _temp === void 0 ? {} : _temp;
  checkContainerType(container);
  if (selected !== void 0) {
    var _allRoles$get;
    if (((_allRoles$get = import_aria_query3.roles.get(role)) == null ? void 0 : _allRoles$get.props["aria-selected"]) === void 0) {
      throw new Error('"aria-selected" is not supported on role "' + role + '".');
    }
  }
  if (busy !== void 0) {
    var _allRoles$get2;
    if (((_allRoles$get2 = import_aria_query3.roles.get(role)) == null ? void 0 : _allRoles$get2.props["aria-busy"]) === void 0) {
      throw new Error('"aria-busy" is not supported on role "' + role + '".');
    }
  }
  if (checked !== void 0) {
    var _allRoles$get3;
    if (((_allRoles$get3 = import_aria_query3.roles.get(role)) == null ? void 0 : _allRoles$get3.props["aria-checked"]) === void 0) {
      throw new Error('"aria-checked" is not supported on role "' + role + '".');
    }
  }
  if (pressed !== void 0) {
    var _allRoles$get4;
    if (((_allRoles$get4 = import_aria_query3.roles.get(role)) == null ? void 0 : _allRoles$get4.props["aria-pressed"]) === void 0) {
      throw new Error('"aria-pressed" is not supported on role "' + role + '".');
    }
  }
  if (current !== void 0) {
    var _allRoles$get5;
    if (((_allRoles$get5 = import_aria_query3.roles.get(role)) == null ? void 0 : _allRoles$get5.props["aria-current"]) === void 0) {
      throw new Error('"aria-current" is not supported on role "' + role + '".');
    }
  }
  if (level !== void 0) {
    if (role !== "heading") {
      throw new Error('Role "' + role + '" cannot have "level" property.');
    }
  }
  if (valueNow !== void 0) {
    var _allRoles$get6;
    if (((_allRoles$get6 = import_aria_query3.roles.get(role)) == null ? void 0 : _allRoles$get6.props["aria-valuenow"]) === void 0) {
      throw new Error('"aria-valuenow" is not supported on role "' + role + '".');
    }
  }
  if (valueMax !== void 0) {
    var _allRoles$get7;
    if (((_allRoles$get7 = import_aria_query3.roles.get(role)) == null ? void 0 : _allRoles$get7.props["aria-valuemax"]) === void 0) {
      throw new Error('"aria-valuemax" is not supported on role "' + role + '".');
    }
  }
  if (valueMin !== void 0) {
    var _allRoles$get8;
    if (((_allRoles$get8 = import_aria_query3.roles.get(role)) == null ? void 0 : _allRoles$get8.props["aria-valuemin"]) === void 0) {
      throw new Error('"aria-valuemin" is not supported on role "' + role + '".');
    }
  }
  if (valueText !== void 0) {
    var _allRoles$get9;
    if (((_allRoles$get9 = import_aria_query3.roles.get(role)) == null ? void 0 : _allRoles$get9.props["aria-valuetext"]) === void 0) {
      throw new Error('"aria-valuetext" is not supported on role "' + role + '".');
    }
  }
  if (expanded !== void 0) {
    var _allRoles$get0;
    if (((_allRoles$get0 = import_aria_query3.roles.get(role)) == null ? void 0 : _allRoles$get0.props["aria-expanded"]) === void 0) {
      throw new Error('"aria-expanded" is not supported on role "' + role + '".');
    }
  }
  const subtreeIsInaccessibleCache = /* @__PURE__ */ new WeakMap();
  function cachedIsSubtreeInaccessible(element) {
    if (!subtreeIsInaccessibleCache.has(element)) {
      subtreeIsInaccessibleCache.set(element, isSubtreeInaccessible(element));
    }
    return subtreeIsInaccessibleCache.get(element);
  }
  __name(cachedIsSubtreeInaccessible, "cachedIsSubtreeInaccessible");
  return Array.from(container.querySelectorAll(
    // Only query elements that can be matched by the following filters
    makeRoleSelector(role)
  )).filter((node) => {
    const isRoleSpecifiedExplicitly = node.hasAttribute("role");
    if (isRoleSpecifiedExplicitly) {
      const roleValue = node.getAttribute("role");
      if (queryFallbacks) {
        return roleValue.split(" ").filter(Boolean).some((roleAttributeToken) => roleAttributeToken === role);
      }
      const [firstRoleAttributeToken] = roleValue.split(" ");
      return firstRoleAttributeToken === role;
    }
    const implicitRoles = getImplicitAriaRoles2(node);
    return implicitRoles.some((implicitRole) => {
      return implicitRole === role;
    });
  }).filter((element) => {
    if (selected !== void 0) {
      return selected === computeAriaSelected(element);
    }
    if (busy !== void 0) {
      return busy === computeAriaBusy(element);
    }
    if (checked !== void 0) {
      return checked === computeAriaChecked(element);
    }
    if (pressed !== void 0) {
      return pressed === computeAriaPressed(element);
    }
    if (current !== void 0) {
      return current === computeAriaCurrent(element);
    }
    if (expanded !== void 0) {
      return expanded === computeAriaExpanded(element);
    }
    if (level !== void 0) {
      return level === computeHeadingLevel(element);
    }
    if (valueNow !== void 0 || valueMax !== void 0 || valueMin !== void 0 || valueText !== void 0) {
      let valueMatches = true;
      if (valueNow !== void 0) {
        valueMatches && (valueMatches = valueNow === computeAriaValueNow(element));
      }
      if (valueMax !== void 0) {
        valueMatches && (valueMatches = valueMax === computeAriaValueMax(element));
      }
      if (valueMin !== void 0) {
        valueMatches && (valueMatches = valueMin === computeAriaValueMin(element));
      }
      if (valueText !== void 0) {
        var _computeAriaValueText;
        valueMatches && (valueMatches = matches2((_computeAriaValueText = computeAriaValueText(element)) != null ? _computeAriaValueText : null, element, valueText, (text) => text));
      }
      return valueMatches;
    }
    return true;
  }).filter((element) => {
    if (name === void 0) {
      return true;
    }
    return matches2(computeAccessibleName2(element, {
      computedStyleSupportsPseudoElements: getConfig2().computedStyleSupportsPseudoElements
    }), element, name, (text) => text);
  }).filter((element) => {
    if (description === void 0) {
      return true;
    }
    return matches2(computeAccessibleDescription2(element, {
      computedStyleSupportsPseudoElements: getConfig2().computedStyleSupportsPseudoElements
    }), element, description, (text) => text);
  }).filter((element) => {
    return hidden === false ? isInaccessible(element, {
      isSubtreeInaccessible: cachedIsSubtreeInaccessible
    }) === false : true;
  });
}, "queryAllByRole");
function makeRoleSelector(role) {
  var _roleElements$get;
  const explicitRoleSelector = '*[role~="' + role + '"]';
  const roleRelations = (_roleElements$get = import_aria_query3.roleElements.get(role)) != null ? _roleElements$get : /* @__PURE__ */ new Set();
  const implicitRoleSelectors = new Set(Array.from(roleRelations).map((_ref) => {
    let {
      name
    } = _ref;
    return name;
  }));
  return [explicitRoleSelector].concat(Array.from(implicitRoleSelectors)).join(",");
}
__name(makeRoleSelector, "makeRoleSelector");
var getNameHint = /* @__PURE__ */ __name((name) => {
  let nameHint = "";
  if (name === void 0) {
    nameHint = "";
  } else if (typeof name === "string") {
    nameHint = ' and name "' + name + '"';
  } else {
    nameHint = " and name `" + name + "`";
  }
  return nameHint;
}, "getNameHint");
var getMultipleError$1 = /* @__PURE__ */ __name(function(c2, role, _temp2) {
  let {
    name
  } = _temp2 === void 0 ? {} : _temp2;
  return 'Found multiple elements with the role "' + role + '"' + getNameHint(name);
}, "getMultipleError$1");
var getMissingError$1 = /* @__PURE__ */ __name(function(container, role, _temp3) {
  let {
    hidden = getConfig2().defaultHidden,
    name,
    description
  } = _temp3 === void 0 ? {} : _temp3;
  if (getConfig2()._disableExpensiveErrorDiagnostics) {
    return 'Unable to find role="' + role + '"' + getNameHint(name);
  }
  let roles3 = "";
  Array.from(container.children).forEach((childElement) => {
    roles3 += prettyRoles(childElement, {
      hidden,
      includeDescription: description !== void 0
    });
  });
  let roleMessage;
  if (roles3.length === 0) {
    if (hidden === false) {
      roleMessage = "There are no accessible roles. But there might be some inaccessible roles. If you wish to access them, then set the `hidden` option to `true`. Learn more about this here: https://testing-library.com/docs/dom-testing-library/api-queries#byrole";
    } else {
      roleMessage = "There are no available roles.";
    }
  } else {
    roleMessage = ("\nHere are the " + (hidden === false ? "accessible" : "available") + " roles:\n\n  " + roles3.replace(/\n/g, "\n  ").replace(/\n\s\s\n/g, "\n\n") + "\n").trim();
  }
  let nameHint = "";
  if (name === void 0) {
    nameHint = "";
  } else if (typeof name === "string") {
    nameHint = ' and name "' + name + '"';
  } else {
    nameHint = " and name `" + name + "`";
  }
  let descriptionHint = "";
  if (description === void 0) {
    descriptionHint = "";
  } else if (typeof description === "string") {
    descriptionHint = ' and description "' + description + '"';
  } else {
    descriptionHint = " and description `" + description + "`";
  }
  return ("\nUnable to find an " + (hidden === false ? "accessible " : "") + 'element with the role "' + role + '"' + nameHint + descriptionHint + "\n\n" + roleMessage).trim();
}, "getMissingError$1");
var queryAllByRoleWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByRole, queryAllByRole.name, "queryAll");
var [queryByRole, getAllByRole, getByRole, findAllByRole, findByRole] = buildQueries(queryAllByRole, getMultipleError$1, getMissingError$1);
var getTestIdAttribute = /* @__PURE__ */ __name(() => getConfig2().testIdAttribute, "getTestIdAttribute");
var queryAllByTestId = /* @__PURE__ */ __name(function() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  checkContainerType(args[0]);
  return queryAllByAttribute(getTestIdAttribute(), ...args);
}, "queryAllByTestId");
var getMultipleError = /* @__PURE__ */ __name((c2, id) => "Found multiple elements by: [" + getTestIdAttribute() + '="' + id + '"]', "getMultipleError");
var getMissingError = /* @__PURE__ */ __name((c2, id) => "Unable to find an element by: [" + getTestIdAttribute() + '="' + id + '"]', "getMissingError");
var queryAllByTestIdWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByTestId, queryAllByTestId.name, "queryAll");
var [queryByTestId, getAllByTestId, getByTestId, findAllByTestId, findByTestId] = buildQueries(queryAllByTestId, getMultipleError, getMissingError);
var queries = Object.freeze({
  __proto__: null,
  queryAllByLabelText: queryAllByLabelTextWithSuggestions,
  queryByLabelText,
  getAllByLabelText: getAllByLabelTextWithSuggestions,
  getByLabelText: getByLabelTextWithSuggestions,
  findAllByLabelText,
  findByLabelText,
  queryByPlaceholderText,
  queryAllByPlaceholderText: queryAllByPlaceholderTextWithSuggestions,
  getByPlaceholderText,
  getAllByPlaceholderText,
  findAllByPlaceholderText,
  findByPlaceholderText,
  queryByText,
  queryAllByText: queryAllByTextWithSuggestions,
  getByText,
  getAllByText,
  findAllByText,
  findByText,
  queryByDisplayValue,
  queryAllByDisplayValue: queryAllByDisplayValueWithSuggestions,
  getByDisplayValue,
  getAllByDisplayValue,
  findAllByDisplayValue,
  findByDisplayValue,
  queryByAltText,
  queryAllByAltText: queryAllByAltTextWithSuggestions,
  getByAltText,
  getAllByAltText,
  findAllByAltText,
  findByAltText,
  queryByTitle,
  queryAllByTitle: queryAllByTitleWithSuggestions,
  getByTitle,
  getAllByTitle,
  findAllByTitle,
  findByTitle,
  queryByRole,
  queryAllByRole: queryAllByRoleWithSuggestions,
  getAllByRole,
  getByRole,
  findAllByRole,
  findByRole,
  queryByTestId,
  queryAllByTestId: queryAllByTestIdWithSuggestions,
  getByTestId,
  getAllByTestId,
  findAllByTestId,
  findByTestId
});
function getQueriesForElement(element, queries$1, initialValue2) {
  if (queries$1 === void 0) {
    queries$1 = queries;
  }
  if (initialValue2 === void 0) {
    initialValue2 = {};
  }
  return Object.keys(queries$1).reduce((helpers, key) => {
    const fn3 = queries$1[key];
    helpers[key] = fn3.bind(null, element);
    return helpers;
  }, initialValue2);
}
__name(getQueriesForElement, "getQueriesForElement");
var isRemoved = /* @__PURE__ */ __name((result) => !result || Array.isArray(result) && !result.length, "isRemoved");
function initialCheck(elements) {
  if (isRemoved(elements)) {
    throw new Error("The element(s) given to waitForElementToBeRemoved are already removed. waitForElementToBeRemoved requires that the element(s) exist(s) before waiting for removal.");
  }
}
__name(initialCheck, "initialCheck");
async function waitForElementToBeRemoved(callback, options) {
  const timeoutError = new Error("Timed out in waitForElementToBeRemoved.");
  if (typeof callback !== "function") {
    initialCheck(callback);
    const elements = Array.isArray(callback) ? callback : [callback];
    const getRemainingElements = elements.map((element) => {
      let parent = element.parentElement;
      if (parent === null) return () => null;
      while (parent.parentElement) parent = parent.parentElement;
      return () => parent.contains(element) ? element : null;
    });
    callback = /* @__PURE__ */ __name(() => getRemainingElements.map((c2) => c2()).filter(Boolean), "callback");
  }
  initialCheck(callback());
  return waitForWrapper(() => {
    let result;
    try {
      result = callback();
    } catch (error) {
      if (error.name === "TestingLibraryElementError") {
        return void 0;
      }
      throw error;
    }
    if (!isRemoved(result)) {
      throw timeoutError;
    }
    return void 0;
  }, options);
}
__name(waitForElementToBeRemoved, "waitForElementToBeRemoved");
var eventMap = {
  // Clipboard Events
  copy: {
    EventType: "ClipboardEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  cut: {
    EventType: "ClipboardEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  paste: {
    EventType: "ClipboardEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  // Composition Events
  compositionEnd: {
    EventType: "CompositionEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  compositionStart: {
    EventType: "CompositionEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  compositionUpdate: {
    EventType: "CompositionEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  // Keyboard Events
  keyDown: {
    EventType: "KeyboardEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      charCode: 0,
      composed: true
    }
  },
  keyPress: {
    EventType: "KeyboardEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      charCode: 0,
      composed: true
    }
  },
  keyUp: {
    EventType: "KeyboardEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      charCode: 0,
      composed: true
    }
  },
  // Focus Events
  focus: {
    EventType: "FocusEvent",
    defaultInit: {
      bubbles: false,
      cancelable: false,
      composed: true
    }
  },
  blur: {
    EventType: "FocusEvent",
    defaultInit: {
      bubbles: false,
      cancelable: false,
      composed: true
    }
  },
  focusIn: {
    EventType: "FocusEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false,
      composed: true
    }
  },
  focusOut: {
    EventType: "FocusEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false,
      composed: true
    }
  },
  // Form Events
  change: {
    EventType: "Event",
    defaultInit: {
      bubbles: true,
      cancelable: false
    }
  },
  input: {
    EventType: "InputEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false,
      composed: true
    }
  },
  invalid: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: true
    }
  },
  submit: {
    EventType: "Event",
    defaultInit: {
      bubbles: true,
      cancelable: true
    }
  },
  reset: {
    EventType: "Event",
    defaultInit: {
      bubbles: true,
      cancelable: true
    }
  },
  // Mouse Events
  click: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      button: 0,
      composed: true
    }
  },
  contextMenu: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  dblClick: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  drag: {
    EventType: "DragEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  dragEnd: {
    EventType: "DragEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false,
      composed: true
    }
  },
  dragEnter: {
    EventType: "DragEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  dragExit: {
    EventType: "DragEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false,
      composed: true
    }
  },
  dragLeave: {
    EventType: "DragEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false,
      composed: true
    }
  },
  dragOver: {
    EventType: "DragEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  dragStart: {
    EventType: "DragEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  drop: {
    EventType: "DragEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  mouseDown: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  mouseEnter: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: false,
      cancelable: false,
      composed: true
    }
  },
  mouseLeave: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: false,
      cancelable: false,
      composed: true
    }
  },
  mouseMove: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  mouseOut: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  mouseOver: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  mouseUp: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  // Selection Events
  select: {
    EventType: "Event",
    defaultInit: {
      bubbles: true,
      cancelable: false
    }
  },
  // Touch Events
  touchCancel: {
    EventType: "TouchEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false,
      composed: true
    }
  },
  touchEnd: {
    EventType: "TouchEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  touchMove: {
    EventType: "TouchEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  touchStart: {
    EventType: "TouchEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  // UI Events
  resize: {
    EventType: "UIEvent",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  scroll: {
    EventType: "UIEvent",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  // Wheel Events
  wheel: {
    EventType: "WheelEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  // Media Events
  abort: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  canPlay: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  canPlayThrough: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  durationChange: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  emptied: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  encrypted: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  ended: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  loadedData: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  loadedMetadata: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  loadStart: {
    EventType: "ProgressEvent",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  pause: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  play: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  playing: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  progress: {
    EventType: "ProgressEvent",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  rateChange: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  seeked: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  seeking: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  stalled: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  suspend: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  timeUpdate: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  volumeChange: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  waiting: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  // Events
  load: {
    // TODO: load events can be UIEvent or Event depending on what generated them
    // This is where this abstraction breaks down.
    // But the common targets are <img />, <script /> and window.
    // Neither of these targets receive a UIEvent
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  error: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  // Animation Events
  animationStart: {
    EventType: "AnimationEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false
    }
  },
  animationEnd: {
    EventType: "AnimationEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false
    }
  },
  animationIteration: {
    EventType: "AnimationEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false
    }
  },
  // Transition Events
  transitionCancel: {
    EventType: "TransitionEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false
    }
  },
  transitionEnd: {
    EventType: "TransitionEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true
    }
  },
  transitionRun: {
    EventType: "TransitionEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false
    }
  },
  transitionStart: {
    EventType: "TransitionEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false
    }
  },
  // pointer events
  pointerOver: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  pointerEnter: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  pointerDown: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  pointerMove: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  pointerUp: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  pointerCancel: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false,
      composed: true
    }
  },
  pointerOut: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  pointerLeave: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  gotPointerCapture: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false,
      composed: true
    }
  },
  lostPointerCapture: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false,
      composed: true
    }
  },
  // history events
  popState: {
    EventType: "PopStateEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false
    }
  },
  // window events
  offline: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  online: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  pageHide: {
    EventType: "PageTransitionEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true
    }
  },
  pageShow: {
    EventType: "PageTransitionEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true
    }
  }
};
var eventAliasMap = {
  doubleClick: "dblClick"
};
function fireEvent(element, event) {
  return getConfig2().eventWrapper(() => {
    if (!event) {
      throw new Error("Unable to fire an event - please provide an event object.");
    }
    if (!element) {
      throw new Error('Unable to fire a "' + event.type + '" event - please provide a DOM element.');
    }
    return element.dispatchEvent(event);
  });
}
__name(fireEvent, "fireEvent");
function createEvent(eventName, node, init2, _temp) {
  let {
    EventType = "Event",
    defaultInit = {}
  } = _temp === void 0 ? {} : _temp;
  if (!node) {
    throw new Error('Unable to fire a "' + eventName + '" event - please provide a DOM element.');
  }
  const eventInit = {
    ...defaultInit,
    ...init2
  };
  const {
    target: {
      value,
      files,
      ...targetProperties
    } = {}
  } = eventInit;
  if (value !== void 0) {
    setNativeValue(node, value);
  }
  if (files !== void 0) {
    Object.defineProperty(node, "files", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: files
    });
  }
  Object.assign(node, targetProperties);
  const window2 = getWindowFromNode(node);
  const EventConstructor = window2[EventType] || window2.Event;
  let event;
  if (typeof EventConstructor === "function") {
    event = new EventConstructor(eventName, eventInit);
  } else {
    event = window2.document.createEvent(EventType);
    const {
      bubbles,
      cancelable,
      detail,
      ...otherInit
    } = eventInit;
    event.initEvent(eventName, bubbles, cancelable, detail);
    Object.keys(otherInit).forEach((eventKey) => {
      event[eventKey] = otherInit[eventKey];
    });
  }
  const dataTransferProperties = ["dataTransfer", "clipboardData"];
  dataTransferProperties.forEach((dataTransferKey) => {
    const dataTransferValue = eventInit[dataTransferKey];
    if (typeof dataTransferValue === "object") {
      if (typeof window2.DataTransfer === "function") {
        Object.defineProperty(event, dataTransferKey, {
          value: Object.getOwnPropertyNames(dataTransferValue).reduce((acc, propName) => {
            Object.defineProperty(acc, propName, {
              value: dataTransferValue[propName]
            });
            return acc;
          }, new window2.DataTransfer())
        });
      } else {
        Object.defineProperty(event, dataTransferKey, {
          value: dataTransferValue
        });
      }
    }
  });
  return event;
}
__name(createEvent, "createEvent");
Object.keys(eventMap).forEach((key) => {
  const {
    EventType,
    defaultInit
  } = eventMap[key];
  const eventName = key.toLowerCase();
  createEvent[key] = (node, init2) => createEvent(eventName, node, init2, {
    EventType,
    defaultInit
  });
  fireEvent[key] = (node, init2) => fireEvent(node, createEvent[key](node, init2));
});
function setNativeValue(element, value) {
  const {
    set: valueSetter
  } = Object.getOwnPropertyDescriptor(element, "value") || {};
  const prototype = Object.getPrototypeOf(element);
  const {
    set: prototypeValueSetter
  } = Object.getOwnPropertyDescriptor(prototype, "value") || {};
  if (prototypeValueSetter && valueSetter !== prototypeValueSetter) {
    prototypeValueSetter.call(element, value);
  } else {
    if (valueSetter) {
      valueSetter.call(element, value);
    } else {
      throw new Error("The given element does not have a value setter");
    }
  }
}
__name(setNativeValue, "setNativeValue");
Object.keys(eventAliasMap).forEach((aliasKey) => {
  const key = eventAliasMap[aliasKey];
  fireEvent[aliasKey] = function() {
    return fireEvent[key](...arguments);
  };
});
function unindent(string) {
  return string.replace(/[ \t]*[\n][ \t]*/g, "\n");
}
__name(unindent, "unindent");
function encode(value) {
  return import_lz_string.default.compressToEncodedURIComponent(unindent(value));
}
__name(encode, "encode");
function getPlaygroundUrl(markup) {
  return "https://testing-playground.com/#markup=" + encode(markup);
}
__name(getPlaygroundUrl, "getPlaygroundUrl");
var debug = /* @__PURE__ */ __name((element, maxLength, options) => Array.isArray(element) ? element.forEach((el) => logDOM(el, maxLength, options)) : logDOM(element, maxLength, options), "debug");
var logTestingPlaygroundURL = /* @__PURE__ */ __name(function(element) {
  if (element === void 0) {
    element = getDocument().body;
  }
  if (!element || !("innerHTML" in element)) {
    console.log("The element you're providing isn't a valid DOM element.");
    return;
  }
  if (!element.innerHTML) {
    console.log("The provided element doesn't have any children.");
    return;
  }
  const playgroundUrl = getPlaygroundUrl(element.innerHTML);
  console.log("Open this URL in your browser\n\n" + playgroundUrl);
  return playgroundUrl;
}, "logTestingPlaygroundURL");
var initialValue = {
  debug,
  logTestingPlaygroundURL
};
var screen = typeof document !== "undefined" && document.body ? getQueriesForElement(document.body, queries, initialValue) : Object.keys(queries).reduce((helpers, key) => {
  helpers[key] = () => {
    throw new TypeError("For queries bound to document.body a global document has to be available... Learn more: https://testing-library.com/s/screen-global-error");
  };
  return helpers;
}, initialValue);

// ../node_modules/@testing-library/user-event/dist/esm/utils/misc/isElementType.js
function isElementType(element, tag, props) {
  if (element.namespaceURI && element.namespaceURI !== "http://www.w3.org/1999/xhtml") {
    return false;
  }
  tag = Array.isArray(tag) ? tag : [
    tag
  ];
  if (!tag.includes(element.tagName.toLowerCase())) {
    return false;
  }
  if (props) {
    return Object.entries(props).every(([k2, v2]) => element[k2] === v2);
  }
  return true;
}
__name(isElementType, "isElementType");

// ../node_modules/@testing-library/user-event/dist/esm/utils/misc/getWindow.js
function getWindow(node) {
  var _node_ownerDocument;
  if (isDocument(node) && node.defaultView) {
    return node.defaultView;
  } else if ((_node_ownerDocument = node.ownerDocument) === null || _node_ownerDocument === void 0 ? void 0 : _node_ownerDocument.defaultView) {
    return node.ownerDocument.defaultView;
  }
  throw new Error(`Could not determine window of node. Node was ${describe(node)}`);
}
__name(getWindow, "getWindow");
function isDocument(node) {
  return node.nodeType === 9;
}
__name(isDocument, "isDocument");
function describe(val) {
  return typeof val === "function" ? `function ${val.name}` : val === null ? "null" : String(val);
}
__name(describe, "describe");

// ../node_modules/@testing-library/user-event/dist/esm/utils/dataTransfer/Blob.js
function readBlobText(blob, FileReader) {
  return new Promise((res, rej) => {
    const fr = new FileReader();
    fr.onerror = rej;
    fr.onabort = rej;
    fr.onload = () => {
      res(String(fr.result));
    };
    fr.readAsText(blob);
  });
}
__name(readBlobText, "readBlobText");

// ../node_modules/@testing-library/user-event/dist/esm/utils/dataTransfer/FileList.js
function createFileList(window2, files) {
  const list = {
    ...files,
    length: files.length,
    item: /* @__PURE__ */ __name((index2) => list[index2], "item"),
    [Symbol.iterator]: /* @__PURE__ */ __name(function* nextFile() {
      for (let i2 = 0; i2 < list.length; i2++) {
        yield list[i2];
      }
    }, "nextFile")
  };
  list.constructor = window2.FileList;
  if (window2.FileList) {
    Object.setPrototypeOf(list, window2.FileList.prototype);
  }
  Object.freeze(list);
  return list;
}
__name(createFileList, "createFileList");

// ../node_modules/@testing-library/user-event/dist/esm/utils/dataTransfer/DataTransfer.js
function _define_property(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
__name(_define_property, "_define_property");
var _DataTransferItemStub = class _DataTransferItemStub {
  getAsFile() {
    return this.file;
  }
  getAsString(callback) {
    if (typeof this.data === "string") {
      callback(this.data);
    }
  }
  /* istanbul ignore next */
  webkitGetAsEntry() {
    throw new Error("not implemented");
  }
  constructor(dataOrFile, type5) {
    _define_property(this, "kind", void 0);
    _define_property(this, "type", void 0);
    _define_property(this, "file", null);
    _define_property(this, "data", void 0);
    if (typeof dataOrFile === "string") {
      this.kind = "string";
      this.type = String(type5);
      this.data = dataOrFile;
    } else {
      this.kind = "file";
      this.type = dataOrFile.type;
      this.file = dataOrFile;
    }
  }
};
__name(_DataTransferItemStub, "DataTransferItemStub");
var DataTransferItemStub = _DataTransferItemStub;
var _DataTransferItemListStub = class _DataTransferItemListStub extends Array {
  add(...args) {
    const item = new DataTransferItemStub(args[0], args[1]);
    this.push(item);
    return item;
  }
  clear() {
    this.splice(0, this.length);
  }
  remove(index2) {
    this.splice(index2, 1);
  }
};
__name(_DataTransferItemListStub, "DataTransferItemListStub");
var DataTransferItemListStub = _DataTransferItemListStub;
function getTypeMatcher(type5, exact) {
  const [group, sub] = type5.split("/");
  const isGroup = !sub || sub === "*";
  return (item) => {
    return exact ? item.type === (isGroup ? group : type5) : isGroup ? item.type.startsWith(`${group}/`) : item.type === group;
  };
}
__name(getTypeMatcher, "getTypeMatcher");
function createDataTransferStub(window2) {
  var _a3;
  return new (_a3 = class {
    getData(format4) {
      var _this_items_find;
      const match = (_this_items_find = this.items.find(getTypeMatcher(format4, true))) !== null && _this_items_find !== void 0 ? _this_items_find : this.items.find(getTypeMatcher(format4, false));
      let text = "";
      match === null || match === void 0 ? void 0 : match.getAsString((t2) => {
        text = t2;
      });
      return text;
    }
    setData(format4, data) {
      const matchIndex = this.items.findIndex(getTypeMatcher(format4, true));
      const item = new DataTransferItemStub(data, format4);
      if (matchIndex >= 0) {
        this.items.splice(matchIndex, 1, item);
      } else {
        this.items.push(item);
      }
    }
    clearData(format4) {
      if (format4) {
        const matchIndex = this.items.findIndex(getTypeMatcher(format4, true));
        if (matchIndex >= 0) {
          this.items.remove(matchIndex);
        }
      } else {
        this.items.clear();
      }
    }
    get types() {
      const t2 = [];
      if (this.files.length) {
        t2.push("Files");
      }
      this.items.forEach((i2) => t2.push(i2.type));
      Object.freeze(t2);
      return t2;
    }
    /* istanbul ignore next */
    setDragImage() {
    }
    constructor() {
      _define_property(this, "dropEffect", "none");
      _define_property(this, "effectAllowed", "uninitialized");
      _define_property(this, "items", new DataTransferItemListStub());
      _define_property(this, "files", createFileList(window2, []));
    }
  }, __name(_a3, "DataTransferStub"), _a3)();
}
__name(createDataTransferStub, "createDataTransferStub");
function createDataTransfer(window2, files = []) {
  const dt = typeof window2.DataTransfer === "undefined" ? createDataTransferStub(window2) : (
    /* istanbul ignore next */
    new window2.DataTransfer()
  );
  Object.defineProperty(dt, "files", {
    get: /* @__PURE__ */ __name(() => createFileList(window2, files), "get")
  });
  return dt;
}
__name(createDataTransfer, "createDataTransfer");
async function getBlobFromDataTransferItem(window2, item) {
  if (item.kind === "file") {
    return item.getAsFile();
  }
  return new window2.Blob([
    await new Promise((r2) => item.getAsString(r2))
  ], {
    type: item.type
  });
}
__name(getBlobFromDataTransferItem, "getBlobFromDataTransferItem");

// ../node_modules/@testing-library/user-event/dist/esm/utils/dataTransfer/Clipboard.js
function _define_property2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
__name(_define_property2, "_define_property");
function createClipboardItem(window2, ...blobs) {
  var _a3;
  const dataMap = Object.fromEntries(blobs.map((b2) => [
    typeof b2 === "string" ? "text/plain" : b2.type,
    Promise.resolve(b2)
  ]));
  if (typeof window2.ClipboardItem !== "undefined") {
    return new window2.ClipboardItem(dataMap);
  }
  return new (_a3 = class {
    get types() {
      return Array.from(Object.keys(this.data));
    }
    async getType(type5) {
      const value = await this.data[type5];
      if (!value) {
        throw new Error(`${type5} is not one of the available MIME types on this item.`);
      }
      return value instanceof window2.Blob ? value : new window2.Blob([
        value
      ], {
        type: type5
      });
    }
    constructor(d) {
      _define_property2(this, "data", void 0);
      this.data = d;
    }
  }, __name(_a3, "ClipboardItem"), _a3)(dataMap);
}
__name(createClipboardItem, "createClipboardItem");
var ClipboardStubControl = Symbol("Manage ClipboardSub");
function createClipboardStub(window2, control) {
  var _a3;
  return Object.assign(new (_a3 = class extends window2.EventTarget {
    async read() {
      return Array.from(this.items);
    }
    async readText() {
      let text = "";
      for (const item of this.items) {
        const type5 = item.types.includes("text/plain") ? "text/plain" : item.types.find((t2) => t2.startsWith("text/"));
        if (type5) {
          text += await item.getType(type5).then((b2) => readBlobText(b2, window2.FileReader));
        }
      }
      return text;
    }
    async write(data) {
      this.items = data;
    }
    async writeText(text) {
      this.items = [
        createClipboardItem(window2, text)
      ];
    }
    constructor(...args) {
      super(...args), _define_property2(this, "items", []);
    }
  }, __name(_a3, "Clipboard"), _a3)(), {
    [ClipboardStubControl]: control
  });
}
__name(createClipboardStub, "createClipboardStub");
function isClipboardStub(clipboard) {
  return !!(clipboard === null || clipboard === void 0 ? void 0 : clipboard[ClipboardStubControl]);
}
__name(isClipboardStub, "isClipboardStub");
function attachClipboardStubToView(window2) {
  if (isClipboardStub(window2.navigator.clipboard)) {
    return window2.navigator.clipboard[ClipboardStubControl];
  }
  const realClipboard = Object.getOwnPropertyDescriptor(window2.navigator, "clipboard");
  let stub;
  const control = {
    resetClipboardStub: /* @__PURE__ */ __name(() => {
      stub = createClipboardStub(window2, control);
    }, "resetClipboardStub"),
    detachClipboardStub: /* @__PURE__ */ __name(() => {
      if (realClipboard) {
        Object.defineProperty(window2.navigator, "clipboard", realClipboard);
      } else {
        Object.defineProperty(window2.navigator, "clipboard", {
          value: void 0,
          configurable: true
        });
      }
    }, "detachClipboardStub")
  };
  stub = createClipboardStub(window2, control);
  Object.defineProperty(window2.navigator, "clipboard", {
    get: /* @__PURE__ */ __name(() => stub, "get"),
    configurable: true
  });
  return stub[ClipboardStubControl];
}
__name(attachClipboardStubToView, "attachClipboardStubToView");
function resetClipboardStubOnView(window2) {
  if (isClipboardStub(window2.navigator.clipboard)) {
    window2.navigator.clipboard[ClipboardStubControl].resetClipboardStub();
  }
}
__name(resetClipboardStubOnView, "resetClipboardStubOnView");
function detachClipboardStubFromView(window2) {
  if (isClipboardStub(window2.navigator.clipboard)) {
    window2.navigator.clipboard[ClipboardStubControl].detachClipboardStub();
  }
}
__name(detachClipboardStubFromView, "detachClipboardStubFromView");
async function readDataTransferFromClipboard(document7) {
  const window2 = document7.defaultView;
  const clipboard = window2 === null || window2 === void 0 ? void 0 : window2.navigator.clipboard;
  const items = clipboard && await clipboard.read();
  if (!items) {
    throw new Error("The Clipboard API is unavailable.");
  }
  const dt = createDataTransfer(window2);
  for (const item of items) {
    for (const type5 of item.types) {
      dt.setData(type5, await item.getType(type5).then((b2) => readBlobText(b2, window2.FileReader)));
    }
  }
  return dt;
}
__name(readDataTransferFromClipboard, "readDataTransferFromClipboard");
async function writeDataTransferToClipboard(document7, clipboardData) {
  const window2 = getWindow(document7);
  const clipboard = window2.navigator.clipboard;
  const items = [];
  for (let i2 = 0; i2 < clipboardData.items.length; i2++) {
    const dtItem = clipboardData.items[i2];
    const blob = await getBlobFromDataTransferItem(window2, dtItem);
    items.push(createClipboardItem(window2, blob));
  }
  const written = clipboard && await clipboard.write(items).then(
    () => true,
    // Can happen with other implementations that e.g. require permissions
    /* istanbul ignore next */
    () => false
  );
  if (!written) {
    throw new Error("The Clipboard API is unavailable.");
  }
}
__name(writeDataTransferToClipboard, "writeDataTransferToClipboard");
var g = globalThis;
if (typeof g.afterEach === "function") {
  g.afterEach(() => {
    if (typeof globalThis.window !== "undefined") {
      resetClipboardStubOnView(globalThis.window);
    }
  });
}
if (typeof g.afterAll === "function") {
  g.afterAll(() => {
    if (typeof globalThis.window !== "undefined") {
      detachClipboardStubFromView(globalThis.window);
    }
  });
}

// ../node_modules/@testing-library/user-event/dist/esm/utils/focus/selector.js
var FOCUSABLE_SELECTOR = [
  "input:not([type=hidden]):not([disabled])",
  "button:not([disabled])",
  "select:not([disabled])",
  "textarea:not([disabled])",
  '[contenteditable=""]',
  '[contenteditable="true"]',
  "a[href]",
  "[tabindex]:not([disabled])"
].join(", ");

// ../node_modules/@testing-library/user-event/dist/esm/utils/focus/isFocusable.js
function isFocusable(element) {
  return element.matches(FOCUSABLE_SELECTOR);
}
__name(isFocusable, "isFocusable");

// ../node_modules/@testing-library/user-event/dist/esm/utils/misc/cloneEvent.js
function cloneEvent(event) {
  return new event.constructor(event.type, event);
}
__name(cloneEvent, "cloneEvent");

// ../node_modules/@testing-library/user-event/dist/esm/utils/misc/isDisabled.js
function isDisabled2(element) {
  for (let el = element; el; el = el.parentElement) {
    if (isElementType(el, [
      "button",
      "input",
      "select",
      "textarea",
      "optgroup",
      "option"
    ])) {
      if (el.hasAttribute("disabled")) {
        return true;
      }
    } else if (isElementType(el, "fieldset")) {
      var _el_querySelector;
      if (el.hasAttribute("disabled") && !((_el_querySelector = el.querySelector(":scope > legend")) === null || _el_querySelector === void 0 ? void 0 : _el_querySelector.contains(element))) {
        return true;
      }
    } else if (el.tagName.includes("-")) {
      if (el.constructor.formAssociated && el.hasAttribute("disabled")) {
        return true;
      }
    }
  }
  return false;
}
__name(isDisabled2, "isDisabled");

// ../node_modules/@testing-library/user-event/dist/esm/utils/focus/getActiveElement.js
function getActiveElement(document7) {
  const activeElement = document7.activeElement;
  if (activeElement === null || activeElement === void 0 ? void 0 : activeElement.shadowRoot) {
    return getActiveElement(activeElement.shadowRoot);
  } else {
    if (isDisabled2(activeElement)) {
      return document7.ownerDocument ? (
        /* istanbul ignore next */
        document7.ownerDocument.body
      ) : document7.body;
    }
    return activeElement;
  }
}
__name(getActiveElement, "getActiveElement");
function getActiveElementOrBody(document7) {
  var _getActiveElement;
  return (_getActiveElement = getActiveElement(document7)) !== null && _getActiveElement !== void 0 ? _getActiveElement : (
    /* istanbul ignore next */
    document7.body
  );
}
__name(getActiveElementOrBody, "getActiveElementOrBody");

// ../node_modules/@testing-library/user-event/dist/esm/utils/misc/findClosest.js
function findClosest(element, callback) {
  let el = element;
  do {
    if (callback(el)) {
      return el;
    }
    el = el.parentElement;
  } while (el && el !== element.ownerDocument.body);
  return void 0;
}
__name(findClosest, "findClosest");

// ../node_modules/@testing-library/user-event/dist/esm/utils/edit/isContentEditable.js
function isContentEditable(element) {
  return element.hasAttribute("contenteditable") && (element.getAttribute("contenteditable") == "true" || element.getAttribute("contenteditable") == "");
}
__name(isContentEditable, "isContentEditable");
function getContentEditable(node) {
  const element = getElement(node);
  return element && (element.closest('[contenteditable=""]') || element.closest('[contenteditable="true"]'));
}
__name(getContentEditable, "getContentEditable");
function getElement(node) {
  return node.nodeType === 1 ? node : node.parentElement;
}
__name(getElement, "getElement");

// ../node_modules/@testing-library/user-event/dist/esm/utils/click/isClickableInput.js
var clickableInputTypes = function(clickableInputTypes2) {
  clickableInputTypes2["button"] = "button";
  clickableInputTypes2["color"] = "color";
  clickableInputTypes2["file"] = "file";
  clickableInputTypes2["image"] = "image";
  clickableInputTypes2["reset"] = "reset";
  clickableInputTypes2["submit"] = "submit";
  clickableInputTypes2["checkbox"] = "checkbox";
  clickableInputTypes2["radio"] = "radio";
  return clickableInputTypes2;
}(clickableInputTypes || {});
function isClickableInput(element) {
  return isElementType(element, "button") || isElementType(element, "input") && element.type in clickableInputTypes;
}
__name(isClickableInput, "isClickableInput");

// ../node_modules/@testing-library/user-event/dist/esm/utils/edit/isEditable.js
function isEditable(element) {
  return isEditableInputOrTextArea(element) && !element.readOnly || isContentEditable(element);
}
__name(isEditable, "isEditable");
var editableInputTypes = function(editableInputTypes2) {
  editableInputTypes2["text"] = "text";
  editableInputTypes2["date"] = "date";
  editableInputTypes2["datetime-local"] = "datetime-local";
  editableInputTypes2["email"] = "email";
  editableInputTypes2["month"] = "month";
  editableInputTypes2["number"] = "number";
  editableInputTypes2["password"] = "password";
  editableInputTypes2["search"] = "search";
  editableInputTypes2["tel"] = "tel";
  editableInputTypes2["time"] = "time";
  editableInputTypes2["url"] = "url";
  editableInputTypes2["week"] = "week";
  return editableInputTypes2;
}(editableInputTypes || {});
function isEditableInputOrTextArea(element) {
  return isElementType(element, "textarea") || isElementType(element, "input") && element.type in editableInputTypes;
}
__name(isEditableInputOrTextArea, "isEditableInputOrTextArea");

// ../node_modules/@testing-library/user-event/dist/esm/utils/focus/selection.js
function hasOwnSelection(node) {
  return isElement3(node) && isEditableInputOrTextArea(node);
}
__name(hasOwnSelection, "hasOwnSelection");
function hasNoSelection(node) {
  return isElement3(node) && isClickableInput(node);
}
__name(hasNoSelection, "hasNoSelection");
function isElement3(node) {
  return node.nodeType === 1;
}
__name(isElement3, "isElement");

// ../node_modules/@testing-library/user-event/dist/esm/event/selection/updateSelectionOnFocus.js
function updateSelectionOnFocus(element) {
  const selection = element.ownerDocument.getSelection();
  if (!(selection === null || selection === void 0 ? void 0 : selection.focusNode)) {
    return;
  }
  if (hasOwnSelection(element)) {
    const contenteditable = getContentEditable(selection.focusNode);
    if (contenteditable) {
      if (!selection.isCollapsed) {
        var _contenteditable_firstChild;
        const focusNode = ((_contenteditable_firstChild = contenteditable.firstChild) === null || _contenteditable_firstChild === void 0 ? void 0 : _contenteditable_firstChild.nodeType) === 3 ? contenteditable.firstChild : contenteditable;
        selection.setBaseAndExtent(focusNode, 0, focusNode, 0);
      }
    } else {
      selection.setBaseAndExtent(element, 0, element, 0);
    }
  }
}
__name(updateSelectionOnFocus, "updateSelectionOnFocus");

// ../node_modules/@testing-library/user-event/dist/esm/event/wrapEvent.js
function wrapEvent(cb, _element) {
  return getConfig2().eventWrapper(cb);
}
__name(wrapEvent, "wrapEvent");

// ../node_modules/@testing-library/user-event/dist/esm/event/focus.js
function focusElement(element) {
  const target = findClosest(element, isFocusable);
  const activeElement = getActiveElement(element.ownerDocument);
  if ((target !== null && target !== void 0 ? target : element.ownerDocument.body) === activeElement) {
    return;
  } else if (target) {
    wrapEvent(() => target.focus());
  } else {
    wrapEvent(() => activeElement === null || activeElement === void 0 ? void 0 : activeElement.blur());
  }
  updateSelectionOnFocus(target !== null && target !== void 0 ? target : element.ownerDocument.body);
}
__name(focusElement, "focusElement");
function blurElement(element) {
  if (!isFocusable(element)) return;
  const wasActive = getActiveElement(element.ownerDocument) === element;
  if (!wasActive) return;
  wrapEvent(() => element.blur());
}
__name(blurElement, "blurElement");

// ../node_modules/@testing-library/user-event/dist/esm/event/behavior/registry.js
var behavior = {};

// ../node_modules/@testing-library/user-event/dist/esm/event/behavior/click.js
behavior.click = (event, target, instance) => {
  const context = target.closest("button,input,label,select,textarea");
  const control = context && isElementType(context, "label") && context.control;
  if (control && control !== target) {
    return () => {
      if (isFocusable(control)) {
        focusElement(control);
        instance.dispatchEvent(control, cloneEvent(event));
      }
    };
  } else if (isElementType(target, "input", {
    type: "file"
  })) {
    return () => {
      blurElement(target);
      target.dispatchEvent(new (getWindow(target)).Event("fileDialog"));
      focusElement(target);
    };
  }
};

// ../node_modules/@testing-library/user-event/dist/esm/document/UI.js
var UIValue = Symbol("Displayed value in UI");
var UISelection = Symbol("Displayed selection in UI");
var InitialValue = Symbol("Initial value to compare on blur");
function isUIValue(value) {
  return typeof value === "object" && UIValue in value;
}
__name(isUIValue, "isUIValue");
function isUISelectionStart(start) {
  return !!start && typeof start === "object" && UISelection in start;
}
__name(isUISelectionStart, "isUISelectionStart");
function setUIValue(element, value) {
  if (element[InitialValue] === void 0) {
    element[InitialValue] = element.value;
  }
  element[UIValue] = value;
  element.value = Object.assign(new String(value), {
    [UIValue]: true
  });
}
__name(setUIValue, "setUIValue");
function getUIValue(element) {
  return element[UIValue] === void 0 ? element.value : String(element[UIValue]);
}
__name(getUIValue, "getUIValue");
function setUIValueClean(element) {
  element[UIValue] = void 0;
}
__name(setUIValueClean, "setUIValueClean");
function clearInitialValue(element) {
  element[InitialValue] = void 0;
}
__name(clearInitialValue, "clearInitialValue");
function getInitialValue(element) {
  return element[InitialValue];
}
__name(getInitialValue, "getInitialValue");
function setUISelectionRaw(element, selection) {
  element[UISelection] = selection;
}
__name(setUISelectionRaw, "setUISelectionRaw");
function setUISelection(element, { focusOffset: focusOffsetParam, anchorOffset: anchorOffsetParam = focusOffsetParam }, mode = "replace") {
  const valueLength = getUIValue(element).length;
  const sanitizeOffset = /* @__PURE__ */ __name((o2) => Math.max(0, Math.min(valueLength, o2)), "sanitizeOffset");
  const anchorOffset = mode === "replace" || element[UISelection] === void 0 ? sanitizeOffset(anchorOffsetParam) : element[UISelection].anchorOffset;
  const focusOffset = sanitizeOffset(focusOffsetParam);
  const startOffset = Math.min(anchorOffset, focusOffset);
  const endOffset = Math.max(anchorOffset, focusOffset);
  element[UISelection] = {
    anchorOffset,
    focusOffset
  };
  if (element.selectionStart === startOffset && element.selectionEnd === endOffset) {
    return;
  }
  const startObj = Object.assign(new Number(startOffset), {
    [UISelection]: true
  });
  try {
    element.setSelectionRange(startObj, endOffset);
  } catch {
  }
}
__name(setUISelection, "setUISelection");
function getUISelection(element) {
  var _element_selectionStart, _element_selectionEnd, _element_UISelection;
  const sel = (_element_UISelection = element[UISelection]) !== null && _element_UISelection !== void 0 ? _element_UISelection : {
    anchorOffset: (_element_selectionStart = element.selectionStart) !== null && _element_selectionStart !== void 0 ? _element_selectionStart : 0,
    focusOffset: (_element_selectionEnd = element.selectionEnd) !== null && _element_selectionEnd !== void 0 ? _element_selectionEnd : 0
  };
  return {
    ...sel,
    startOffset: Math.min(sel.anchorOffset, sel.focusOffset),
    endOffset: Math.max(sel.anchorOffset, sel.focusOffset)
  };
}
__name(getUISelection, "getUISelection");
function hasUISelection(element) {
  return !!element[UISelection];
}
__name(hasUISelection, "hasUISelection");
function setUISelectionClean(element) {
  element[UISelection] = void 0;
}
__name(setUISelectionClean, "setUISelectionClean");

// ../node_modules/@testing-library/user-event/dist/esm/utils/edit/timeValue.js
var parseInt2 = globalThis.parseInt;
function buildTimeValue(value) {
  const onlyDigitsValue = value.replace(/\D/g, "");
  if (onlyDigitsValue.length < 2) {
    return value;
  }
  const firstDigit = parseInt2(onlyDigitsValue[0], 10);
  const secondDigit = parseInt2(onlyDigitsValue[1], 10);
  if (firstDigit >= 3 || firstDigit === 2 && secondDigit >= 4) {
    let index2;
    if (firstDigit >= 3) {
      index2 = 1;
    } else {
      index2 = 2;
    }
    return build2(onlyDigitsValue, index2);
  }
  if (value.length === 2) {
    return value;
  }
  return build2(onlyDigitsValue, 2);
}
__name(buildTimeValue, "buildTimeValue");
function build2(onlyDigitsValue, index2) {
  const hours = onlyDigitsValue.slice(0, index2);
  const validHours = Math.min(parseInt2(hours, 10), 23);
  const minuteCharacters = onlyDigitsValue.slice(index2);
  const parsedMinutes = parseInt2(minuteCharacters, 10);
  const validMinutes = Math.min(parsedMinutes, 59);
  return `${validHours.toString().padStart(2, "0")}:${validMinutes.toString().padStart(2, "0")}`;
}
__name(build2, "build");
function isValidDateOrTimeValue(element, value) {
  const clone3 = element.cloneNode();
  clone3.value = value;
  return clone3.value === value;
}
__name(isValidDateOrTimeValue, "isValidDateOrTimeValue");

// ../node_modules/@testing-library/user-event/dist/esm/utils/edit/maxLength.js
var maxLengthSupportedTypes = function(maxLengthSupportedTypes2) {
  maxLengthSupportedTypes2["email"] = "email";
  maxLengthSupportedTypes2["password"] = "password";
  maxLengthSupportedTypes2["search"] = "search";
  maxLengthSupportedTypes2["telephone"] = "telephone";
  maxLengthSupportedTypes2["text"] = "text";
  maxLengthSupportedTypes2["url"] = "url";
  return maxLengthSupportedTypes2;
}(maxLengthSupportedTypes || {});
function getMaxLength(element) {
  var _element_getAttribute;
  const attr = (_element_getAttribute = element.getAttribute("maxlength")) !== null && _element_getAttribute !== void 0 ? _element_getAttribute : "";
  return /^\d+$/.test(attr) && Number(attr) >= 0 ? Number(attr) : void 0;
}
__name(getMaxLength, "getMaxLength");
function supportsMaxLength(element) {
  return isElementType(element, "textarea") || isElementType(element, "input") && element.type in maxLengthSupportedTypes;
}
__name(supportsMaxLength, "supportsMaxLength");

// ../node_modules/@testing-library/user-event/dist/esm/utils/focus/cursor.js
function getNextCursorPosition(node, offset2, direction, inputType) {
  if (isTextNode(node) && offset2 + direction >= 0 && offset2 + direction <= node.nodeValue.length) {
    return {
      node,
      offset: offset2 + direction
    };
  }
  const nextNode = getNextCharacterContentNode(node, offset2, direction);
  if (nextNode) {
    if (isTextNode(nextNode)) {
      return {
        node: nextNode,
        offset: direction > 0 ? Math.min(1, nextNode.nodeValue.length) : Math.max(nextNode.nodeValue.length - 1, 0)
      };
    } else if (isElementType(nextNode, "br")) {
      const nextPlusOne = getNextCharacterContentNode(nextNode, void 0, direction);
      if (!nextPlusOne) {
        if (direction < 0 && inputType === "deleteContentBackward") {
          return {
            node: nextNode.parentNode,
            offset: getOffset(nextNode)
          };
        }
        return void 0;
      } else if (isTextNode(nextPlusOne)) {
        return {
          node: nextPlusOne,
          offset: direction > 0 ? 0 : nextPlusOne.nodeValue.length
        };
      } else if (direction < 0 && isElementType(nextPlusOne, "br")) {
        return {
          node: nextNode.parentNode,
          offset: getOffset(nextNode)
        };
      } else {
        return {
          node: nextPlusOne.parentNode,
          offset: getOffset(nextPlusOne) + (direction > 0 ? 0 : 1)
        };
      }
    } else {
      return {
        node: nextNode.parentNode,
        offset: getOffset(nextNode) + (direction > 0 ? 1 : 0)
      };
    }
  }
}
__name(getNextCursorPosition, "getNextCursorPosition");
function getNextCharacterContentNode(node, offset2, direction) {
  const nextOffset = Number(offset2) + (direction < 0 ? -1 : 0);
  if (offset2 !== void 0 && isElement4(node) && nextOffset >= 0 && nextOffset < node.children.length) {
    node = node.children[nextOffset];
  }
  return walkNodes(node, direction === 1 ? "next" : "previous", isTreatedAsCharacterContent);
}
__name(getNextCharacterContentNode, "getNextCharacterContentNode");
function isTreatedAsCharacterContent(node) {
  if (isTextNode(node)) {
    return true;
  }
  if (isElement4(node)) {
    if (isElementType(node, [
      "input",
      "textarea"
    ])) {
      return node.type !== "hidden";
    } else if (isElementType(node, "br")) {
      return true;
    }
  }
  return false;
}
__name(isTreatedAsCharacterContent, "isTreatedAsCharacterContent");
function getOffset(node) {
  let i2 = 0;
  while (node.previousSibling) {
    i2++;
    node = node.previousSibling;
  }
  return i2;
}
__name(getOffset, "getOffset");
function isElement4(node) {
  return node.nodeType === 1;
}
__name(isElement4, "isElement");
function isTextNode(node) {
  return node.nodeType === 3;
}
__name(isTextNode, "isTextNode");
function walkNodes(node, direction, callback) {
  for (; ; ) {
    var _node_ownerDocument;
    const sibling = node[`${direction}Sibling`];
    if (sibling) {
      node = getDescendant(sibling, direction === "next" ? "first" : "last");
      if (callback(node)) {
        return node;
      }
    } else if (node.parentNode && (!isElement4(node.parentNode) || !isContentEditable(node.parentNode) && node.parentNode !== ((_node_ownerDocument = node.ownerDocument) === null || _node_ownerDocument === void 0 ? void 0 : _node_ownerDocument.body))) {
      node = node.parentNode;
    } else {
      break;
    }
  }
}
__name(walkNodes, "walkNodes");
function getDescendant(node, direction) {
  while (node.hasChildNodes()) {
    node = node[`${direction}Child`];
  }
  return node;
}
__name(getDescendant, "getDescendant");

// ../node_modules/@testing-library/user-event/dist/esm/document/trackValue.js
var TrackChanges = Symbol("Track programmatic changes for React workaround");
function isReact17Element(element) {
  return Object.getOwnPropertyNames(element).some((k2) => k2.startsWith("__react")) && getWindow(element).REACT_VERSION === 17;
}
__name(isReact17Element, "isReact17Element");
function startTrackValue(element) {
  if (!isReact17Element(element)) {
    return;
  }
  element[TrackChanges] = {
    previousValue: String(element.value),
    tracked: []
  };
}
__name(startTrackValue, "startTrackValue");
function trackOrSetValue(element, v2) {
  var _element_TrackChanges_tracked, _element_TrackChanges;
  (_element_TrackChanges = element[TrackChanges]) === null || _element_TrackChanges === void 0 ? void 0 : (_element_TrackChanges_tracked = _element_TrackChanges.tracked) === null || _element_TrackChanges_tracked === void 0 ? void 0 : _element_TrackChanges_tracked.push(v2);
  if (!element[TrackChanges]) {
    setUIValueClean(element);
    setUISelection(element, {
      focusOffset: v2.length
    });
  }
}
__name(trackOrSetValue, "trackOrSetValue");
function commitValueAfterInput(element, cursorOffset) {
  var _changes_tracked;
  const changes = element[TrackChanges];
  element[TrackChanges] = void 0;
  if (!(changes === null || changes === void 0 ? void 0 : (_changes_tracked = changes.tracked) === null || _changes_tracked === void 0 ? void 0 : _changes_tracked.length)) {
    return;
  }
  const isJustReactStateUpdate = changes.tracked.length === 2 && changes.tracked[0] === changes.previousValue && changes.tracked[1] === element.value;
  if (!isJustReactStateUpdate) {
    setUIValueClean(element);
  }
  if (hasUISelection(element)) {
    setUISelection(element, {
      focusOffset: isJustReactStateUpdate ? cursorOffset : element.value.length
    });
  }
}
__name(commitValueAfterInput, "commitValueAfterInput");

// ../node_modules/@testing-library/user-event/dist/esm/event/selection/getTargetTypeAndSelection.js
function getTargetTypeAndSelection(node) {
  const element = getElement2(node);
  if (element && hasOwnSelection(element)) {
    return {
      type: "input",
      selection: getUISelection(element)
    };
  }
  const selection = element === null || element === void 0 ? void 0 : element.ownerDocument.getSelection();
  const isCE = getContentEditable(node) && (selection === null || selection === void 0 ? void 0 : selection.anchorNode) && getContentEditable(selection.anchorNode);
  return {
    type: isCE ? "contenteditable" : "default",
    selection
  };
}
__name(getTargetTypeAndSelection, "getTargetTypeAndSelection");
function getElement2(node) {
  return node.nodeType === 1 ? node : node.parentElement;
}
__name(getElement2, "getElement");

// ../node_modules/@testing-library/user-event/dist/esm/event/selection/getInputRange.js
function getInputRange(focusNode) {
  const typeAndSelection = getTargetTypeAndSelection(focusNode);
  if (typeAndSelection.type === "input") {
    return typeAndSelection.selection;
  } else if (typeAndSelection.type === "contenteditable") {
    var _typeAndSelection_selection;
    return (_typeAndSelection_selection = typeAndSelection.selection) === null || _typeAndSelection_selection === void 0 ? void 0 : _typeAndSelection_selection.getRangeAt(0);
  }
}
__name(getInputRange, "getInputRange");

// ../node_modules/@testing-library/user-event/dist/esm/event/selection/setSelection.js
function setSelection({ focusNode, focusOffset, anchorNode = focusNode, anchorOffset = focusOffset }) {
  var _anchorNode_ownerDocument_getSelection, _anchorNode_ownerDocument;
  const typeAndSelection = getTargetTypeAndSelection(focusNode);
  if (typeAndSelection.type === "input") {
    return setUISelection(focusNode, {
      anchorOffset,
      focusOffset
    });
  }
  (_anchorNode_ownerDocument = anchorNode.ownerDocument) === null || _anchorNode_ownerDocument === void 0 ? void 0 : (_anchorNode_ownerDocument_getSelection = _anchorNode_ownerDocument.getSelection()) === null || _anchorNode_ownerDocument_getSelection === void 0 ? void 0 : _anchorNode_ownerDocument_getSelection.setBaseAndExtent(anchorNode, anchorOffset, focusNode, focusOffset);
}
__name(setSelection, "setSelection");

// ../node_modules/@testing-library/user-event/dist/esm/event/input.js
function isDateOrTime(element) {
  return isElementType(element, "input") && [
    "date",
    "time"
  ].includes(element.type);
}
__name(isDateOrTime, "isDateOrTime");
function input(instance, element, data, inputType = "insertText") {
  const inputRange = getInputRange(element);
  if (!inputRange) {
    return;
  }
  if (!isDateOrTime(element)) {
    const unprevented = instance.dispatchUIEvent(element, "beforeinput", {
      inputType,
      data
    });
    if (!unprevented) {
      return;
    }
  }
  if ("startContainer" in inputRange) {
    editContenteditable(instance, element, inputRange, data, inputType);
  } else {
    editInputElement(instance, element, inputRange, data, inputType);
  }
}
__name(input, "input");
function editContenteditable(instance, element, inputRange, data, inputType) {
  let del = false;
  if (!inputRange.collapsed) {
    del = true;
    inputRange.deleteContents();
  } else if ([
    "deleteContentBackward",
    "deleteContentForward"
  ].includes(inputType)) {
    const nextPosition = getNextCursorPosition(inputRange.startContainer, inputRange.startOffset, inputType === "deleteContentBackward" ? -1 : 1, inputType);
    if (nextPosition) {
      del = true;
      const delRange = inputRange.cloneRange();
      if (delRange.comparePoint(nextPosition.node, nextPosition.offset) < 0) {
        delRange.setStart(nextPosition.node, nextPosition.offset);
      } else {
        delRange.setEnd(nextPosition.node, nextPosition.offset);
      }
      delRange.deleteContents();
    }
  }
  if (data) {
    if (inputRange.endContainer.nodeType === 3) {
      const offset2 = inputRange.endOffset;
      inputRange.endContainer.insertData(offset2, data);
      inputRange.setStart(inputRange.endContainer, offset2 + data.length);
      inputRange.setEnd(inputRange.endContainer, offset2 + data.length);
    } else {
      const text = element.ownerDocument.createTextNode(data);
      inputRange.insertNode(text);
      inputRange.setStart(text, data.length);
      inputRange.setEnd(text, data.length);
    }
  }
  if (del || data) {
    instance.dispatchUIEvent(element, "input", {
      inputType
    });
  }
}
__name(editContenteditable, "editContenteditable");
function editInputElement(instance, element, inputRange, data, inputType) {
  let dataToInsert = data;
  if (supportsMaxLength(element)) {
    const maxLength = getMaxLength(element);
    if (maxLength !== void 0 && data.length > 0) {
      const spaceUntilMaxLength = maxLength - element.value.length;
      if (spaceUntilMaxLength > 0) {
        dataToInsert = data.substring(0, spaceUntilMaxLength);
      } else {
        return;
      }
    }
  }
  const { newValue, newOffset, oldValue } = calculateNewValue(dataToInsert, element, inputRange, inputType);
  if (newValue === oldValue && newOffset === inputRange.startOffset && newOffset === inputRange.endOffset) {
    return;
  }
  if (isElementType(element, "input", {
    type: "number"
  }) && !isValidNumberInput(newValue)) {
    return;
  }
  setUIValue(element, newValue);
  setSelection({
    focusNode: element,
    anchorOffset: newOffset,
    focusOffset: newOffset
  });
  if (isDateOrTime(element)) {
    if (isValidDateOrTimeValue(element, newValue)) {
      commitInput(instance, element, newOffset, {});
      instance.dispatchUIEvent(element, "change");
      clearInitialValue(element);
    }
  } else {
    commitInput(instance, element, newOffset, {
      data,
      inputType
    });
  }
}
__name(editInputElement, "editInputElement");
function calculateNewValue(inputData, node, { startOffset, endOffset }, inputType) {
  const value = getUIValue(node);
  const prologEnd = Math.max(0, startOffset === endOffset && inputType === "deleteContentBackward" ? startOffset - 1 : startOffset);
  const prolog = value.substring(0, prologEnd);
  const epilogStart = Math.min(value.length, startOffset === endOffset && inputType === "deleteContentForward" ? startOffset + 1 : endOffset);
  const epilog = value.substring(epilogStart, value.length);
  let newValue = `${prolog}${inputData}${epilog}`;
  let newOffset = prologEnd + inputData.length;
  if (isElementType(node, "input", {
    type: "time"
  })) {
    const builtValue = buildTimeValue(newValue);
    if (builtValue !== "" && isValidDateOrTimeValue(node, builtValue)) {
      newValue = builtValue;
      newOffset = builtValue.length;
    }
  }
  return {
    oldValue: value,
    newValue,
    newOffset
  };
}
__name(calculateNewValue, "calculateNewValue");
function commitInput(instance, element, newOffset, inputInit) {
  instance.dispatchUIEvent(element, "input", inputInit);
  commitValueAfterInput(element, newOffset);
}
__name(commitInput, "commitInput");
function isValidNumberInput(value) {
  var _value_match, _value_match1;
  const valueParts = value.split("e", 2);
  return !(/[^\d.\-e]/.test(value) || Number((_value_match = value.match(/-/g)) === null || _value_match === void 0 ? void 0 : _value_match.length) > 2 || Number((_value_match1 = value.match(/\./g)) === null || _value_match1 === void 0 ? void 0 : _value_match1.length) > 1 || valueParts[1] && !/^-?\d*$/.test(valueParts[1]));
}
__name(isValidNumberInput, "isValidNumberInput");

// ../node_modules/@testing-library/user-event/dist/esm/event/behavior/cut.js
behavior.cut = (event, target, instance) => {
  return () => {
    if (isEditable(target)) {
      input(instance, target, "", "deleteByCut");
    }
  };
};

// ../node_modules/@testing-library/user-event/dist/esm/document/getValueOrTextContent.js
function getValueOrTextContent(element) {
  if (!element) {
    return null;
  }
  if (isContentEditable(element)) {
    return element.textContent;
  }
  return getUIValue(element);
}
__name(getValueOrTextContent, "getValueOrTextContent");

// ../node_modules/@testing-library/user-event/dist/esm/utils/misc/isVisible.js
function isVisible(element) {
  const window2 = getWindow(element);
  for (let el = element; el === null || el === void 0 ? void 0 : el.ownerDocument; el = el.parentElement) {
    const { display: display2, visibility } = window2.getComputedStyle(el);
    if (display2 === "none") {
      return false;
    }
    if (visibility === "hidden") {
      return false;
    }
  }
  return true;
}
__name(isVisible, "isVisible");

// ../node_modules/@testing-library/user-event/dist/esm/utils/focus/getTabDestination.js
function getTabDestination(activeElement, shift) {
  const document7 = activeElement.ownerDocument;
  const focusableElements = document7.querySelectorAll(FOCUSABLE_SELECTOR);
  const enabledElements = Array.from(focusableElements).filter((el) => el === activeElement || !(Number(el.getAttribute("tabindex")) < 0 || isDisabled2(el)));
  if (Number(activeElement.getAttribute("tabindex")) >= 0) {
    enabledElements.sort((a2, b2) => {
      const i2 = Number(a2.getAttribute("tabindex"));
      const j2 = Number(b2.getAttribute("tabindex"));
      if (i2 === j2) {
        return 0;
      } else if (i2 === 0) {
        return 1;
      } else if (j2 === 0) {
        return -1;
      }
      return i2 - j2;
    });
  }
  const checkedRadio = {};
  let prunedElements = [
    document7.body
  ];
  const activeRadioGroup = isElementType(activeElement, "input", {
    type: "radio"
  }) ? activeElement.name : void 0;
  enabledElements.forEach((currentElement) => {
    const el = currentElement;
    if (isElementType(el, "input", {
      type: "radio"
    }) && el.name) {
      if (el === activeElement) {
        prunedElements.push(el);
        return;
      } else if (el.name === activeRadioGroup) {
        return;
      }
      if (el.checked) {
        prunedElements = prunedElements.filter((e2) => !isElementType(e2, "input", {
          type: "radio",
          name: el.name
        }));
        prunedElements.push(el);
        checkedRadio[el.name] = el;
        return;
      }
      if (typeof checkedRadio[el.name] !== "undefined") {
        return;
      }
    }
    prunedElements.push(el);
  });
  for (let index2 = prunedElements.findIndex((el) => el === activeElement); ; ) {
    index2 += shift ? -1 : 1;
    if (index2 === prunedElements.length) {
      index2 = 0;
    } else if (index2 === -1) {
      index2 = prunedElements.length - 1;
    }
    if (prunedElements[index2] === activeElement || prunedElements[index2] === document7.body || isVisible(prunedElements[index2])) {
      return prunedElements[index2];
    }
  }
}
__name(getTabDestination, "getTabDestination");

// ../node_modules/@testing-library/user-event/dist/esm/event/selection/moveSelection.js
function moveSelection(node, direction) {
  if (hasOwnSelection(node)) {
    const selection = getUISelection(node);
    setSelection({
      focusNode: node,
      focusOffset: selection.startOffset === selection.endOffset ? selection.focusOffset + direction : direction < 0 ? selection.startOffset : selection.endOffset
    });
  } else {
    const selection = node.ownerDocument.getSelection();
    if (!(selection === null || selection === void 0 ? void 0 : selection.focusNode)) {
      return;
    }
    if (selection.isCollapsed) {
      const nextPosition = getNextCursorPosition(selection.focusNode, selection.focusOffset, direction);
      if (nextPosition) {
        setSelection({
          focusNode: nextPosition.node,
          focusOffset: nextPosition.offset
        });
      }
    } else {
      selection[direction < 0 ? "collapseToStart" : "collapseToEnd"]();
    }
  }
}
__name(moveSelection, "moveSelection");

// ../node_modules/@testing-library/user-event/dist/esm/event/selection/selectAll.js
function selectAll(target) {
  if (hasOwnSelection(target)) {
    return setSelection({
      focusNode: target,
      anchorOffset: 0,
      focusOffset: getUIValue(target).length
    });
  }
  var _getContentEditable;
  const focusNode = (_getContentEditable = getContentEditable(target)) !== null && _getContentEditable !== void 0 ? _getContentEditable : target.ownerDocument.body;
  setSelection({
    focusNode,
    anchorOffset: 0,
    focusOffset: focusNode.childNodes.length
  });
}
__name(selectAll, "selectAll");
function isAllSelected(target) {
  if (hasOwnSelection(target)) {
    return getUISelection(target).startOffset === 0 && getUISelection(target).endOffset === getUIValue(target).length;
  }
  var _getContentEditable;
  const focusNode = (_getContentEditable = getContentEditable(target)) !== null && _getContentEditable !== void 0 ? _getContentEditable : target.ownerDocument.body;
  const selection = target.ownerDocument.getSelection();
  return (selection === null || selection === void 0 ? void 0 : selection.anchorNode) === focusNode && selection.focusNode === focusNode && selection.anchorOffset === 0 && selection.focusOffset === focusNode.childNodes.length;
}
__name(isAllSelected, "isAllSelected");

// ../node_modules/@testing-library/user-event/dist/esm/event/selection/setSelectionRange.js
function setSelectionRange(element, anchorOffset, focusOffset) {
  var _element_firstChild;
  if (hasOwnSelection(element)) {
    return setSelection({
      focusNode: element,
      anchorOffset,
      focusOffset
    });
  }
  if (isContentEditable(element) && ((_element_firstChild = element.firstChild) === null || _element_firstChild === void 0 ? void 0 : _element_firstChild.nodeType) === 3) {
    return setSelection({
      focusNode: element.firstChild,
      anchorOffset,
      focusOffset
    });
  }
  throw new Error("Not implemented. The result of this interaction is unreliable.");
}
__name(setSelectionRange, "setSelectionRange");

// ../node_modules/@testing-library/user-event/dist/esm/event/radio.js
function walkRadio(instance, el, direction) {
  const window2 = getWindow(el);
  const group = Array.from(el.ownerDocument.querySelectorAll(el.name ? `input[type="radio"][name="${window2.CSS.escape(el.name)}"]` : `input[type="radio"][name=""], input[type="radio"]:not([name])`));
  for (let i2 = group.findIndex((e2) => e2 === el) + direction; ; i2 += direction) {
    if (!group[i2]) {
      i2 = direction > 0 ? 0 : group.length - 1;
    }
    if (group[i2] === el) {
      return;
    }
    if (isDisabled2(group[i2])) {
      continue;
    }
    focusElement(group[i2]);
    instance.dispatchUIEvent(group[i2], "click");
    return;
  }
}
__name(walkRadio, "walkRadio");

// ../node_modules/@testing-library/user-event/dist/esm/event/behavior/keydown.js
behavior.keydown = (event, target, instance) => {
  var _keydownBehavior_event_key;
  var _keydownBehavior_event_key1;
  return (_keydownBehavior_event_key1 = (_keydownBehavior_event_key = keydownBehavior[event.key]) === null || _keydownBehavior_event_key === void 0 ? void 0 : _keydownBehavior_event_key.call(keydownBehavior, event, target, instance)) !== null && _keydownBehavior_event_key1 !== void 0 ? _keydownBehavior_event_key1 : combinationBehavior(event, target, instance);
};
var keydownBehavior = {
  ArrowDown: /* @__PURE__ */ __name((event, target, instance) => {
    if (isElementType(target, "input", {
      type: "radio"
    })) {
      return () => walkRadio(instance, target, 1);
    }
  }, "ArrowDown"),
  ArrowLeft: /* @__PURE__ */ __name((event, target, instance) => {
    if (isElementType(target, "input", {
      type: "radio"
    })) {
      return () => walkRadio(instance, target, -1);
    }
    return () => moveSelection(target, -1);
  }, "ArrowLeft"),
  ArrowRight: /* @__PURE__ */ __name((event, target, instance) => {
    if (isElementType(target, "input", {
      type: "radio"
    })) {
      return () => walkRadio(instance, target, 1);
    }
    return () => moveSelection(target, 1);
  }, "ArrowRight"),
  ArrowUp: /* @__PURE__ */ __name((event, target, instance) => {
    if (isElementType(target, "input", {
      type: "radio"
    })) {
      return () => walkRadio(instance, target, -1);
    }
  }, "ArrowUp"),
  Backspace: /* @__PURE__ */ __name((event, target, instance) => {
    if (isEditable(target)) {
      return () => {
        input(instance, target, "", "deleteContentBackward");
      };
    }
  }, "Backspace"),
  Delete: /* @__PURE__ */ __name((event, target, instance) => {
    if (isEditable(target)) {
      return () => {
        input(instance, target, "", "deleteContentForward");
      };
    }
  }, "Delete"),
  End: /* @__PURE__ */ __name((event, target) => {
    if (isElementType(target, [
      "input",
      "textarea"
    ]) || isContentEditable(target)) {
      return () => {
        var _getValueOrTextContent;
        var _getValueOrTextContent_length;
        const newPos = (_getValueOrTextContent_length = (_getValueOrTextContent = getValueOrTextContent(target)) === null || _getValueOrTextContent === void 0 ? void 0 : _getValueOrTextContent.length) !== null && _getValueOrTextContent_length !== void 0 ? _getValueOrTextContent_length : (
          /* istanbul ignore next */
          0
        );
        setSelectionRange(target, newPos, newPos);
      };
    }
  }, "End"),
  Home: /* @__PURE__ */ __name((event, target) => {
    if (isElementType(target, [
      "input",
      "textarea"
    ]) || isContentEditable(target)) {
      return () => {
        setSelectionRange(target, 0, 0);
      };
    }
  }, "Home"),
  PageDown: /* @__PURE__ */ __name((event, target) => {
    if (isElementType(target, [
      "input"
    ])) {
      return () => {
        const newPos = getUIValue(target).length;
        setSelectionRange(target, newPos, newPos);
      };
    }
  }, "PageDown"),
  PageUp: /* @__PURE__ */ __name((event, target) => {
    if (isElementType(target, [
      "input"
    ])) {
      return () => {
        setSelectionRange(target, 0, 0);
      };
    }
  }, "PageUp"),
  Tab: /* @__PURE__ */ __name((event, target, instance) => {
    return () => {
      const dest = getTabDestination(target, instance.system.keyboard.modifiers.Shift);
      focusElement(dest);
      if (hasOwnSelection(dest)) {
        setUISelection(dest, {
          anchorOffset: 0,
          focusOffset: dest.value.length
        });
      }
    };
  }, "Tab")
};
var combinationBehavior = /* @__PURE__ */ __name((event, target, instance) => {
  if (event.code === "KeyA" && instance.system.keyboard.modifiers.Control) {
    return () => selectAll(target);
  }
}, "combinationBehavior");

// ../node_modules/@testing-library/user-event/dist/esm/event/behavior/keypress.js
behavior.keypress = (event, target, instance) => {
  if (event.key === "Enter") {
    if (isElementType(target, "button") || isElementType(target, "input") && ClickInputOnEnter.includes(target.type) || isElementType(target, "a") && Boolean(target.href)) {
      return () => {
        instance.dispatchUIEvent(target, "click");
      };
    } else if (isElementType(target, "input")) {
      const form = target.form;
      const submit = form === null || form === void 0 ? void 0 : form.querySelector('input[type="submit"], button:not([type]), button[type="submit"]');
      if (submit) {
        return () => instance.dispatchUIEvent(submit, "click");
      } else if (form && SubmitSingleInputOnEnter.includes(target.type) && form.querySelectorAll("input").length === 1) {
        return () => instance.dispatchUIEvent(form, "submit");
      } else {
        return;
      }
    }
  }
  if (isEditable(target)) {
    const inputType = event.key === "Enter" ? isContentEditable(target) && !instance.system.keyboard.modifiers.Shift ? "insertParagraph" : "insertLineBreak" : "insertText";
    const inputData = event.key === "Enter" ? "\n" : event.key;
    return () => input(instance, target, inputData, inputType);
  }
};
var ClickInputOnEnter = [
  "button",
  "color",
  "file",
  "image",
  "reset",
  "submit"
];
var SubmitSingleInputOnEnter = [
  "email",
  "month",
  "password",
  "search",
  "tel",
  "text",
  "url",
  "week"
];

// ../node_modules/@testing-library/user-event/dist/esm/event/behavior/keyup.js
behavior.keyup = (event, target, instance) => {
  var _keyupBehavior_event_key;
  return (_keyupBehavior_event_key = keyupBehavior[event.key]) === null || _keyupBehavior_event_key === void 0 ? void 0 : _keyupBehavior_event_key.call(keyupBehavior, event, target, instance);
};
var keyupBehavior = {
  " ": /* @__PURE__ */ __name((event, target, instance) => {
    if (isClickableInput(target)) {
      return () => instance.dispatchUIEvent(target, "click");
    }
  }, " ")
};

// ../node_modules/@testing-library/user-event/dist/esm/event/behavior/paste.js
behavior.paste = (event, target, instance) => {
  if (isEditable(target)) {
    return () => {
      var _event_clipboardData;
      const insertData = (_event_clipboardData = event.clipboardData) === null || _event_clipboardData === void 0 ? void 0 : _event_clipboardData.getData("text");
      if (insertData) {
        input(instance, target, insertData, "insertFromPaste");
      }
    };
  }
};

// ../node_modules/@testing-library/user-event/dist/esm/event/eventMap.js
var eventMap2 = {
  auxclick: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  beforeinput: {
    EventType: "InputEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  blur: {
    EventType: "FocusEvent",
    defaultInit: {
      bubbles: false,
      cancelable: false,
      composed: true
    }
  },
  click: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  contextmenu: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  copy: {
    EventType: "ClipboardEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  change: {
    EventType: "Event",
    defaultInit: {
      bubbles: true,
      cancelable: false
    }
  },
  cut: {
    EventType: "ClipboardEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  dblclick: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  focus: {
    EventType: "FocusEvent",
    defaultInit: {
      bubbles: false,
      cancelable: false,
      composed: true
    }
  },
  focusin: {
    EventType: "FocusEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false,
      composed: true
    }
  },
  focusout: {
    EventType: "FocusEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false,
      composed: true
    }
  },
  keydown: {
    EventType: "KeyboardEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  keypress: {
    EventType: "KeyboardEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  keyup: {
    EventType: "KeyboardEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  paste: {
    EventType: "ClipboardEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  input: {
    EventType: "InputEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false,
      composed: true
    }
  },
  mousedown: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  mouseenter: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: false,
      cancelable: false,
      composed: true
    }
  },
  mouseleave: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: false,
      cancelable: false,
      composed: true
    }
  },
  mousemove: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  mouseout: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  mouseover: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  mouseup: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  pointerover: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  pointerenter: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  pointerdown: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  pointermove: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  pointerup: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  pointercancel: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false,
      composed: true
    }
  },
  pointerout: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  pointerleave: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  submit: {
    EventType: "Event",
    defaultInit: {
      bubbles: true,
      cancelable: true
    }
  }
};
function getEventClass(type5) {
  return eventMap2[type5].EventType;
}
__name(getEventClass, "getEventClass");
var mouseEvents = [
  "MouseEvent",
  "PointerEvent"
];
function isMouseEvent(type5) {
  return mouseEvents.includes(getEventClass(type5));
}
__name(isMouseEvent, "isMouseEvent");
function isKeyboardEvent(type5) {
  return getEventClass(type5) === "KeyboardEvent";
}
__name(isKeyboardEvent, "isKeyboardEvent");

// ../node_modules/@testing-library/user-event/dist/esm/event/createEvent.js
var eventInitializer = {
  ClipboardEvent: [
    initClipboardEvent
  ],
  Event: [],
  FocusEvent: [
    initUIEvent,
    initFocusEvent
  ],
  InputEvent: [
    initUIEvent,
    initInputEvent
  ],
  MouseEvent: [
    initUIEvent,
    initUIEventModifiers,
    initMouseEvent
  ],
  PointerEvent: [
    initUIEvent,
    initUIEventModifiers,
    initMouseEvent,
    initPointerEvent
  ],
  KeyboardEvent: [
    initUIEvent,
    initUIEventModifiers,
    initKeyboardEvent
  ]
};
function createEvent2(type5, target, init2) {
  const window2 = getWindow(target);
  const { EventType, defaultInit } = eventMap2[type5];
  const event = new (getEventConstructors(window2))[EventType](type5, defaultInit);
  eventInitializer[EventType].forEach((f4) => f4(event, init2 !== null && init2 !== void 0 ? init2 : {}));
  return event;
}
__name(createEvent2, "createEvent");
function getEventConstructors(window2) {
  var _a3, _b, _c, _d, _e2, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;
  var _window_Event;
  const Event2 = (_window_Event = window2.Event) !== null && _window_Event !== void 0 ? _window_Event : (_a3 = class {
  }, __name(_a3, "Event"), _a3);
  var _window_AnimationEvent;
  const AnimationEvent = (_window_AnimationEvent = window2.AnimationEvent) !== null && _window_AnimationEvent !== void 0 ? _window_AnimationEvent : (_b = class extends Event2 {
  }, __name(_b, "AnimationEvent"), _b);
  var _window_ClipboardEvent;
  const ClipboardEvent = (_window_ClipboardEvent = window2.ClipboardEvent) !== null && _window_ClipboardEvent !== void 0 ? _window_ClipboardEvent : (_c = class extends Event2 {
  }, __name(_c, "ClipboardEvent"), _c);
  var _window_PopStateEvent;
  const PopStateEvent = (_window_PopStateEvent = window2.PopStateEvent) !== null && _window_PopStateEvent !== void 0 ? _window_PopStateEvent : (_d = class extends Event2 {
  }, __name(_d, "PopStateEvent"), _d);
  var _window_ProgressEvent;
  const ProgressEvent = (_window_ProgressEvent = window2.ProgressEvent) !== null && _window_ProgressEvent !== void 0 ? _window_ProgressEvent : (_e2 = class extends Event2 {
  }, __name(_e2, "ProgressEvent"), _e2);
  var _window_TransitionEvent;
  const TransitionEvent = (_window_TransitionEvent = window2.TransitionEvent) !== null && _window_TransitionEvent !== void 0 ? _window_TransitionEvent : (_f = class extends Event2 {
  }, __name(_f, "TransitionEvent"), _f);
  var _window_UIEvent;
  const UIEvent = (_window_UIEvent = window2.UIEvent) !== null && _window_UIEvent !== void 0 ? _window_UIEvent : (_g = class extends Event2 {
  }, __name(_g, "UIEvent"), _g);
  var _window_CompositionEvent;
  const CompositionEvent = (_window_CompositionEvent = window2.CompositionEvent) !== null && _window_CompositionEvent !== void 0 ? _window_CompositionEvent : (_h = class extends UIEvent {
  }, __name(_h, "CompositionEvent"), _h);
  var _window_FocusEvent;
  const FocusEvent = (_window_FocusEvent = window2.FocusEvent) !== null && _window_FocusEvent !== void 0 ? _window_FocusEvent : (_i = class extends UIEvent {
  }, __name(_i, "FocusEvent"), _i);
  var _window_InputEvent;
  const InputEvent = (_window_InputEvent = window2.InputEvent) !== null && _window_InputEvent !== void 0 ? _window_InputEvent : (_j = class extends UIEvent {
  }, __name(_j, "InputEvent"), _j);
  var _window_KeyboardEvent;
  const KeyboardEvent = (_window_KeyboardEvent = window2.KeyboardEvent) !== null && _window_KeyboardEvent !== void 0 ? _window_KeyboardEvent : (_k = class extends UIEvent {
  }, __name(_k, "KeyboardEvent"), _k);
  var _window_MouseEvent;
  const MouseEvent = (_window_MouseEvent = window2.MouseEvent) !== null && _window_MouseEvent !== void 0 ? _window_MouseEvent : (_l = class extends UIEvent {
  }, __name(_l, "MouseEvent"), _l);
  var _window_DragEvent;
  const DragEvent = (_window_DragEvent = window2.DragEvent) !== null && _window_DragEvent !== void 0 ? _window_DragEvent : (_m = class extends MouseEvent {
  }, __name(_m, "DragEvent"), _m);
  var _window_PointerEvent;
  const PointerEvent = (_window_PointerEvent = window2.PointerEvent) !== null && _window_PointerEvent !== void 0 ? _window_PointerEvent : (_n = class extends MouseEvent {
  }, __name(_n, "PointerEvent"), _n);
  var _window_TouchEvent;
  const TouchEvent = (_window_TouchEvent = window2.TouchEvent) !== null && _window_TouchEvent !== void 0 ? _window_TouchEvent : (_o = class extends UIEvent {
  }, __name(_o, "TouchEvent"), _o);
  return {
    Event: Event2,
    AnimationEvent,
    ClipboardEvent,
    PopStateEvent,
    ProgressEvent,
    TransitionEvent,
    UIEvent,
    CompositionEvent,
    FocusEvent,
    InputEvent,
    KeyboardEvent,
    MouseEvent,
    DragEvent,
    PointerEvent,
    TouchEvent
  };
}
__name(getEventConstructors, "getEventConstructors");
function assignProps(obj, props) {
  for (const [key, value] of Object.entries(props)) {
    Object.defineProperty(obj, key, {
      get: /* @__PURE__ */ __name(() => value !== null && value !== void 0 ? value : null, "get")
    });
  }
}
__name(assignProps, "assignProps");
function sanitizeNumber(n2) {
  return Number(n2 !== null && n2 !== void 0 ? n2 : 0);
}
__name(sanitizeNumber, "sanitizeNumber");
function initClipboardEvent(event, { clipboardData }) {
  assignProps(event, {
    clipboardData
  });
}
__name(initClipboardEvent, "initClipboardEvent");
function initFocusEvent(event, { relatedTarget }) {
  assignProps(event, {
    relatedTarget
  });
}
__name(initFocusEvent, "initFocusEvent");
function initInputEvent(event, { data, inputType, isComposing }) {
  assignProps(event, {
    data,
    isComposing: Boolean(isComposing),
    inputType: String(inputType)
  });
}
__name(initInputEvent, "initInputEvent");
function initUIEvent(event, { view, detail }) {
  assignProps(event, {
    view,
    detail: sanitizeNumber(detail !== null && detail !== void 0 ? detail : 0)
  });
}
__name(initUIEvent, "initUIEvent");
function initUIEventModifiers(event, { altKey, ctrlKey, metaKey, shiftKey, modifierAltGraph, modifierCapsLock, modifierFn, modifierFnLock, modifierNumLock, modifierScrollLock, modifierSymbol, modifierSymbolLock }) {
  assignProps(event, {
    altKey: Boolean(altKey),
    ctrlKey: Boolean(ctrlKey),
    metaKey: Boolean(metaKey),
    shiftKey: Boolean(shiftKey),
    getModifierState(k2) {
      return Boolean({
        Alt: altKey,
        AltGraph: modifierAltGraph,
        CapsLock: modifierCapsLock,
        Control: ctrlKey,
        Fn: modifierFn,
        FnLock: modifierFnLock,
        Meta: metaKey,
        NumLock: modifierNumLock,
        ScrollLock: modifierScrollLock,
        Shift: shiftKey,
        Symbol: modifierSymbol,
        SymbolLock: modifierSymbolLock
      }[k2]);
    }
  });
}
__name(initUIEventModifiers, "initUIEventModifiers");
function initKeyboardEvent(event, { key, code, location: location2, repeat, isComposing, charCode }) {
  assignProps(event, {
    key: String(key),
    code: String(code),
    location: sanitizeNumber(location2),
    repeat: Boolean(repeat),
    isComposing: Boolean(isComposing),
    charCode
  });
}
__name(initKeyboardEvent, "initKeyboardEvent");
function initMouseEvent(event, { x: x2, y: y2, screenX, screenY, clientX = x2, clientY = y2, button, buttons, relatedTarget, offsetX, offsetY, pageX, pageY }) {
  assignProps(event, {
    screenX: sanitizeNumber(screenX),
    screenY: sanitizeNumber(screenY),
    clientX: sanitizeNumber(clientX),
    x: sanitizeNumber(clientX),
    clientY: sanitizeNumber(clientY),
    y: sanitizeNumber(clientY),
    button: sanitizeNumber(button),
    buttons: sanitizeNumber(buttons),
    relatedTarget,
    offsetX: sanitizeNumber(offsetX),
    offsetY: sanitizeNumber(offsetY),
    pageX: sanitizeNumber(pageX),
    pageY: sanitizeNumber(pageY)
  });
}
__name(initMouseEvent, "initMouseEvent");
function initPointerEvent(event, { pointerId, width, height, pressure, tangentialPressure, tiltX, tiltY, twist, pointerType, isPrimary }) {
  assignProps(event, {
    pointerId: sanitizeNumber(pointerId),
    width: sanitizeNumber(width !== null && width !== void 0 ? width : 1),
    height: sanitizeNumber(height !== null && height !== void 0 ? height : 1),
    pressure: sanitizeNumber(pressure),
    tangentialPressure: sanitizeNumber(tangentialPressure),
    tiltX: sanitizeNumber(tiltX),
    tiltY: sanitizeNumber(tiltY),
    twist: sanitizeNumber(twist),
    pointerType: String(pointerType),
    isPrimary: Boolean(isPrimary)
  });
}
__name(initPointerEvent, "initPointerEvent");

// ../node_modules/@testing-library/user-event/dist/esm/event/dispatchEvent.js
function dispatchUIEvent(target, type5, init2, preventDefault = false) {
  if (isMouseEvent(type5) || isKeyboardEvent(type5)) {
    init2 = {
      ...init2,
      ...this.system.getUIEventModifiers()
    };
  }
  const event = createEvent2(type5, target, init2);
  return dispatchEvent.call(this, target, event, preventDefault);
}
__name(dispatchUIEvent, "dispatchUIEvent");
function dispatchEvent(target, event, preventDefault = false) {
  var _behavior_type;
  const type5 = event.type;
  const behaviorImplementation = preventDefault ? () => {
  } : (_behavior_type = behavior[type5]) === null || _behavior_type === void 0 ? void 0 : _behavior_type.call(behavior, event, target, this);
  if (behaviorImplementation) {
    event.preventDefault();
    let defaultPrevented = false;
    Object.defineProperty(event, "defaultPrevented", {
      get: /* @__PURE__ */ __name(() => defaultPrevented, "get")
    });
    Object.defineProperty(event, "preventDefault", {
      value: /* @__PURE__ */ __name(() => {
        defaultPrevented = event.cancelable;
      }, "value")
    });
    wrapEvent(() => target.dispatchEvent(event));
    if (!defaultPrevented) {
      behaviorImplementation();
    }
    return !defaultPrevented;
  }
  return wrapEvent(() => target.dispatchEvent(event));
}
__name(dispatchEvent, "dispatchEvent");
function dispatchDOMEvent(target, type5, init2) {
  const event = createEvent2(type5, target, init2);
  wrapEvent(() => target.dispatchEvent(event));
}
__name(dispatchDOMEvent, "dispatchDOMEvent");

// ../node_modules/@testing-library/user-event/dist/esm/document/patchFocus.js
var patched = Symbol("patched focus/blur methods");
function patchFocus(HTMLElement2) {
  if (HTMLElement2.prototype[patched]) {
    return;
  }
  const { focus, blur } = HTMLElement2.prototype;
  Object.defineProperties(HTMLElement2.prototype, {
    focus: {
      configurable: true,
      get: /* @__PURE__ */ __name(() => patchedFocus2, "get")
    },
    blur: {
      configurable: true,
      get: /* @__PURE__ */ __name(() => patchedBlur, "get")
    },
    [patched]: {
      configurable: true,
      get: /* @__PURE__ */ __name(() => ({
        focus,
        blur
      }), "get")
    }
  });
  let activeCall;
  function patchedFocus2(options) {
    if (this.ownerDocument.visibilityState !== "hidden") {
      return focus.call(this, options);
    }
    const blurred = getActiveTarget(this.ownerDocument);
    if (blurred === this) {
      return;
    }
    const thisCall = Symbol("focus call");
    activeCall = thisCall;
    if (blurred) {
      blur.call(blurred);
      dispatchDOMEvent(blurred, "blur", {
        relatedTarget: this
      });
      dispatchDOMEvent(blurred, "focusout", {
        relatedTarget: activeCall === thisCall ? this : null
      });
    }
    if (activeCall === thisCall) {
      focus.call(this, options);
      dispatchDOMEvent(this, "focus", {
        relatedTarget: blurred
      });
    }
    if (activeCall === thisCall) {
      dispatchDOMEvent(this, "focusin", {
        relatedTarget: blurred
      });
    }
  }
  __name(patchedFocus2, "patchedFocus");
  function patchedBlur() {
    if (this.ownerDocument.visibilityState !== "hidden") {
      return blur.call(this);
    }
    const blurred = getActiveTarget(this.ownerDocument);
    if (blurred !== this) {
      return;
    }
    const thisCall = Symbol("blur call");
    activeCall = thisCall;
    blur.call(this);
    dispatchDOMEvent(blurred, "blur", {
      relatedTarget: null
    });
    dispatchDOMEvent(blurred, "focusout", {
      relatedTarget: null
    });
  }
  __name(patchedBlur, "patchedBlur");
}
__name(patchFocus, "patchFocus");
function getActiveTarget(document7) {
  const active = getActiveElement(document7);
  return (active === null || active === void 0 ? void 0 : active.tagName) === "BODY" ? null : active;
}
__name(getActiveTarget, "getActiveTarget");

// ../node_modules/@testing-library/user-event/dist/esm/document/interceptor.js
var Interceptor = Symbol("Interceptor for programmatical calls");
function prepareInterceptor(element, propName, interceptorImpl) {
  const prototypeDescriptor = Object.getOwnPropertyDescriptor(element.constructor.prototype, propName);
  const objectDescriptor = Object.getOwnPropertyDescriptor(element, propName);
  const target = (prototypeDescriptor === null || prototypeDescriptor === void 0 ? void 0 : prototypeDescriptor.set) ? "set" : "value";
  if (typeof (prototypeDescriptor === null || prototypeDescriptor === void 0 ? void 0 : prototypeDescriptor[target]) !== "function" || prototypeDescriptor[target][Interceptor]) {
    throw new Error(`Element ${element.tagName} does not implement "${String(propName)}".`);
  }
  function intercept(...args) {
    const { applyNative = false, realArgs, then } = interceptorImpl.call(this, ...args);
    const realFunc = (!applyNative && objectDescriptor || prototypeDescriptor)[target];
    if (target === "set") {
      realFunc.call(this, realArgs);
    } else {
      realFunc.call(this, ...realArgs);
    }
    then === null || then === void 0 ? void 0 : then();
  }
  __name(intercept, "intercept");
  intercept[Interceptor] = Interceptor;
  Object.defineProperty(element, propName, {
    ...objectDescriptor !== null && objectDescriptor !== void 0 ? objectDescriptor : prototypeDescriptor,
    [target]: intercept
  });
}
__name(prepareInterceptor, "prepareInterceptor");
function prepareValueInterceptor(element) {
  prepareInterceptor(element, "value", /* @__PURE__ */ __name(function interceptorImpl(v2) {
    const isUI = isUIValue(v2);
    if (isUI) {
      startTrackValue(this);
    }
    return {
      applyNative: !!isUI,
      realArgs: sanitizeValue(this, v2),
      then: isUI ? void 0 : () => trackOrSetValue(this, String(v2))
    };
  }, "interceptorImpl"));
}
__name(prepareValueInterceptor, "prepareValueInterceptor");
function sanitizeValue(element, v2) {
  if (isElementType(element, "input", {
    type: "number"
  }) && String(v2) !== "" && !Number.isNaN(Number(v2))) {
    return String(Number(v2));
  }
  return String(v2);
}
__name(sanitizeValue, "sanitizeValue");
function prepareSelectionInterceptor(element) {
  prepareInterceptor(element, "setSelectionRange", /* @__PURE__ */ __name(function interceptorImpl(start, ...others) {
    const isUI = isUISelectionStart(start);
    return {
      applyNative: !!isUI,
      realArgs: [
        Number(start),
        ...others
      ],
      then: /* @__PURE__ */ __name(() => isUI ? void 0 : setUISelectionClean(element), "then")
    };
  }, "interceptorImpl"));
  prepareInterceptor(element, "selectionStart", /* @__PURE__ */ __name(function interceptorImpl(v2) {
    return {
      realArgs: v2,
      then: /* @__PURE__ */ __name(() => setUISelectionClean(element), "then")
    };
  }, "interceptorImpl"));
  prepareInterceptor(element, "selectionEnd", /* @__PURE__ */ __name(function interceptorImpl(v2) {
    return {
      realArgs: v2,
      then: /* @__PURE__ */ __name(() => setUISelectionClean(element), "then")
    };
  }, "interceptorImpl"));
  prepareInterceptor(element, "select", /* @__PURE__ */ __name(function interceptorImpl() {
    return {
      realArgs: [],
      then: /* @__PURE__ */ __name(() => setUISelectionRaw(element, {
        anchorOffset: 0,
        focusOffset: getUIValue(element).length
      }), "then")
    };
  }, "interceptorImpl"));
}
__name(prepareSelectionInterceptor, "prepareSelectionInterceptor");
function prepareRangeTextInterceptor(element) {
  prepareInterceptor(element, "setRangeText", /* @__PURE__ */ __name(function interceptorImpl(...realArgs) {
    return {
      realArgs,
      then: /* @__PURE__ */ __name(() => {
        setUIValueClean(element);
        setUISelectionClean(element);
      }, "then")
    };
  }, "interceptorImpl"));
}
__name(prepareRangeTextInterceptor, "prepareRangeTextInterceptor");

// ../node_modules/@testing-library/user-event/dist/esm/document/prepareDocument.js
var isPrepared = Symbol("Node prepared with document state workarounds");
function prepareDocument(document7) {
  if (document7[isPrepared]) {
    return;
  }
  document7.addEventListener("focus", (e2) => {
    const el = e2.target;
    prepareElement(el);
  }, {
    capture: true,
    passive: true
  });
  if (document7.activeElement) {
    prepareElement(document7.activeElement);
  }
  document7.addEventListener("blur", (e2) => {
    const el = e2.target;
    const initialValue2 = getInitialValue(el);
    if (initialValue2 !== void 0) {
      if (el.value !== initialValue2) {
        dispatchDOMEvent(el, "change");
      }
      clearInitialValue(el);
    }
  }, {
    capture: true,
    passive: true
  });
  document7[isPrepared] = isPrepared;
}
__name(prepareDocument, "prepareDocument");
function prepareElement(el) {
  if (el[isPrepared]) {
    return;
  }
  if (isElementType(el, [
    "input",
    "textarea"
  ])) {
    prepareValueInterceptor(el);
    prepareSelectionInterceptor(el);
    prepareRangeTextInterceptor(el);
  }
  el[isPrepared] = isPrepared;
}
__name(prepareElement, "prepareElement");

// ../node_modules/@testing-library/user-event/dist/esm/utils/misc/getDocumentFromNode.js
function getDocumentFromNode(el) {
  return isDocument2(el) ? el : el.ownerDocument;
}
__name(getDocumentFromNode, "getDocumentFromNode");
function isDocument2(node) {
  return node.nodeType === 9;
}
__name(isDocument2, "isDocument");

// ../node_modules/@testing-library/user-event/dist/esm/utils/misc/level.js
var ApiLevel = function(ApiLevel2) {
  ApiLevel2[ApiLevel2["Trigger"] = 2] = "Trigger";
  ApiLevel2[ApiLevel2["Call"] = 1] = "Call";
  return ApiLevel2;
}({});
function setLevelRef(instance, level) {
  instance.levelRefs[level] = {};
}
__name(setLevelRef, "setLevelRef");
function getLevelRef(instance, level) {
  return instance.levelRefs[level];
}
__name(getLevelRef, "getLevelRef");

// ../node_modules/@testing-library/user-event/dist/esm/utils/misc/wait.js
function wait(config4) {
  const delay = config4.delay;
  if (typeof delay !== "number") {
    return;
  }
  return Promise.all([
    new Promise((resolve) => globalThis.setTimeout(() => resolve(), delay)),
    config4.advanceTimers(delay)
  ]);
}
__name(wait, "wait");

// ../node_modules/@testing-library/user-event/dist/esm/options.js
var PointerEventsCheckLevel = function(PointerEventsCheckLevel2) {
  PointerEventsCheckLevel2[PointerEventsCheckLevel2["EachTrigger"] = 4] = "EachTrigger";
  PointerEventsCheckLevel2[PointerEventsCheckLevel2["EachApiCall"] = 2] = "EachApiCall";
  PointerEventsCheckLevel2[PointerEventsCheckLevel2["EachTarget"] = 1] = "EachTarget";
  PointerEventsCheckLevel2[PointerEventsCheckLevel2["Never"] = 0] = "Never";
  return PointerEventsCheckLevel2;
}({});

// ../node_modules/@testing-library/user-event/dist/esm/system/keyboard.js
function _define_property3(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
__name(_define_property3, "_define_property");
var DOM_KEY_LOCATION = function(DOM_KEY_LOCATION2) {
  DOM_KEY_LOCATION2[DOM_KEY_LOCATION2["STANDARD"] = 0] = "STANDARD";
  DOM_KEY_LOCATION2[DOM_KEY_LOCATION2["LEFT"] = 1] = "LEFT";
  DOM_KEY_LOCATION2[DOM_KEY_LOCATION2["RIGHT"] = 2] = "RIGHT";
  DOM_KEY_LOCATION2[DOM_KEY_LOCATION2["NUMPAD"] = 3] = "NUMPAD";
  return DOM_KEY_LOCATION2;
}({});
var modifierKeys = [
  "Alt",
  "AltGraph",
  "Control",
  "Fn",
  "Meta",
  "Shift",
  "Symbol"
];
function isModifierKey(key) {
  return modifierKeys.includes(key);
}
__name(isModifierKey, "isModifierKey");
var modifierLocks = [
  "CapsLock",
  "FnLock",
  "NumLock",
  "ScrollLock",
  "SymbolLock"
];
function isModifierLock(key) {
  return modifierLocks.includes(key);
}
__name(isModifierLock, "isModifierLock");
var _KeyboardHost = class _KeyboardHost {
  isKeyPressed(keyDef) {
    return this.pressed.has(String(keyDef.code));
  }
  getPressedKeys() {
    return this.pressed.values().map((p2) => p2.keyDef);
  }
  /** Press a key */
  async keydown(instance, keyDef) {
    const key = String(keyDef.key);
    const code = String(keyDef.code);
    const target = getActiveElementOrBody(instance.config.document);
    this.setKeydownTarget(target);
    this.pressed.add(code, keyDef);
    if (isModifierKey(key)) {
      this.modifiers[key] = true;
    }
    const unprevented = instance.dispatchUIEvent(target, "keydown", {
      key,
      code
    });
    if (isModifierLock(key) && !this.modifiers[key]) {
      this.modifiers[key] = true;
      this.modifierLockStart[key] = true;
    }
    if (unprevented) {
      this.pressed.setUnprevented(code);
    }
    if (unprevented && this.hasKeyPress(key)) {
      instance.dispatchUIEvent(getActiveElementOrBody(instance.config.document), "keypress", {
        key,
        code,
        charCode: keyDef.key === "Enter" ? 13 : String(keyDef.key).charCodeAt(0)
      });
    }
  }
  /** Release a key */
  async keyup(instance, keyDef) {
    const key = String(keyDef.key);
    const code = String(keyDef.code);
    const unprevented = this.pressed.isUnprevented(code);
    this.pressed.delete(code);
    if (isModifierKey(key) && !this.pressed.values().find((p2) => p2.keyDef.key === key)) {
      this.modifiers[key] = false;
    }
    instance.dispatchUIEvent(getActiveElementOrBody(instance.config.document), "keyup", {
      key,
      code
    }, !unprevented);
    if (isModifierLock(key) && this.modifiers[key]) {
      if (this.modifierLockStart[key]) {
        this.modifierLockStart[key] = false;
      } else {
        this.modifiers[key] = false;
      }
    }
  }
  setKeydownTarget(target) {
    if (target !== this.lastKeydownTarget) {
      this.carryChar = "";
    }
    this.lastKeydownTarget = target;
  }
  hasKeyPress(key) {
    return (key.length === 1 || key === "Enter") && !this.modifiers.Control && !this.modifiers.Alt;
  }
  constructor(system) {
    _define_property3(this, "system", void 0);
    _define_property3(this, "modifiers", {
      Alt: false,
      AltGraph: false,
      CapsLock: false,
      Control: false,
      Fn: false,
      FnLock: false,
      Meta: false,
      NumLock: false,
      ScrollLock: false,
      Shift: false,
      Symbol: false,
      SymbolLock: false
    });
    _define_property3(this, "pressed", new class {
      add(code, keyDef) {
        var _this_registry, _code;
        var _;
        (_ = (_this_registry = this.registry)[_code = code]) !== null && _ !== void 0 ? _ : _this_registry[_code] = {
          keyDef,
          unpreventedDefault: false
        };
      }
      has(code) {
        return !!this.registry[code];
      }
      setUnprevented(code) {
        const o2 = this.registry[code];
        if (o2) {
          o2.unpreventedDefault = true;
        }
      }
      isUnprevented(code) {
        var _this_registry_code;
        return !!((_this_registry_code = this.registry[code]) === null || _this_registry_code === void 0 ? void 0 : _this_registry_code.unpreventedDefault);
      }
      delete(code) {
        delete this.registry[code];
      }
      values() {
        return Object.values(this.registry);
      }
      constructor() {
        _define_property3(this, "registry", {});
      }
    }());
    _define_property3(this, "carryChar", "");
    _define_property3(this, "lastKeydownTarget", void 0);
    _define_property3(this, "modifierLockStart", {});
    this.system = system;
  }
};
__name(_KeyboardHost, "KeyboardHost");
var KeyboardHost = _KeyboardHost;

// ../node_modules/@testing-library/user-event/dist/esm/keyboard/keyMap.js
var defaultKeyMap = [
  // alphanumeric block - writing system
  ..."0123456789".split("").map((c2) => ({
    code: `Digit${c2}`,
    key: c2
  })),
  ...")!@#$%^&*(".split("").map((c2, i2) => ({
    code: `Digit${i2}`,
    key: c2,
    shiftKey: true
  })),
  ..."abcdefghijklmnopqrstuvwxyz".split("").map((c2) => ({
    code: `Key${c2.toUpperCase()}`,
    key: c2
  })),
  ..."ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("").map((c2) => ({
    code: `Key${c2}`,
    key: c2,
    shiftKey: true
  })),
  {
    code: "BracketLeft",
    key: "["
  },
  {
    code: "BracketLeft",
    key: "{",
    shiftKey: true
  },
  {
    code: "BracketRight",
    key: "]"
  },
  {
    code: "BracketRight",
    key: "}",
    shiftKey: true
  },
  // alphanumeric block - functional
  {
    code: "Space",
    key: " "
  },
  {
    code: "AltLeft",
    key: "Alt",
    location: DOM_KEY_LOCATION.LEFT
  },
  {
    code: "AltRight",
    key: "Alt",
    location: DOM_KEY_LOCATION.RIGHT
  },
  {
    code: "ShiftLeft",
    key: "Shift",
    location: DOM_KEY_LOCATION.LEFT
  },
  {
    code: "ShiftRight",
    key: "Shift",
    location: DOM_KEY_LOCATION.RIGHT
  },
  {
    code: "ControlLeft",
    key: "Control",
    location: DOM_KEY_LOCATION.LEFT
  },
  {
    code: "ControlRight",
    key: "Control",
    location: DOM_KEY_LOCATION.RIGHT
  },
  {
    code: "MetaLeft",
    key: "Meta",
    location: DOM_KEY_LOCATION.LEFT
  },
  {
    code: "MetaRight",
    key: "Meta",
    location: DOM_KEY_LOCATION.RIGHT
  },
  {
    code: "OSLeft",
    key: "OS",
    location: DOM_KEY_LOCATION.LEFT
  },
  {
    code: "OSRight",
    key: "OS",
    location: DOM_KEY_LOCATION.RIGHT
  },
  {
    code: "ContextMenu",
    key: "ContextMenu"
  },
  {
    code: "Tab",
    key: "Tab"
  },
  {
    code: "CapsLock",
    key: "CapsLock"
  },
  {
    code: "Backspace",
    key: "Backspace"
  },
  {
    code: "Enter",
    key: "Enter"
  },
  // function
  {
    code: "Escape",
    key: "Escape"
  },
  // arrows
  {
    code: "ArrowUp",
    key: "ArrowUp"
  },
  {
    code: "ArrowDown",
    key: "ArrowDown"
  },
  {
    code: "ArrowLeft",
    key: "ArrowLeft"
  },
  {
    code: "ArrowRight",
    key: "ArrowRight"
  },
  // control pad
  {
    code: "Home",
    key: "Home"
  },
  {
    code: "End",
    key: "End"
  },
  {
    code: "Delete",
    key: "Delete"
  },
  {
    code: "PageUp",
    key: "PageUp"
  },
  {
    code: "PageDown",
    key: "PageDown"
  },
  // Special keys that are not part of a default US-layout but included for specific behavior
  {
    code: "Fn",
    key: "Fn"
  },
  {
    code: "Symbol",
    key: "Symbol"
  },
  {
    code: "AltRight",
    key: "AltGraph"
  }
];

// ../node_modules/@testing-library/user-event/dist/esm/pointer/keyMap.js
var defaultKeyMap2 = [
  {
    name: "MouseLeft",
    pointerType: "mouse",
    button: "primary"
  },
  {
    name: "MouseRight",
    pointerType: "mouse",
    button: "secondary"
  },
  {
    name: "MouseMiddle",
    pointerType: "mouse",
    button: "auxiliary"
  },
  {
    name: "TouchA",
    pointerType: "touch"
  },
  {
    name: "TouchB",
    pointerType: "touch"
  },
  {
    name: "TouchC",
    pointerType: "touch"
  }
];

// ../node_modules/@testing-library/user-event/dist/esm/system/pointer/buttons.js
function _define_property4(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
__name(_define_property4, "_define_property");
var _Buttons = class _Buttons {
  getButtons() {
    let v2 = 0;
    for (const button of Object.keys(this.pressed)) {
      v2 |= 2 ** Number(button);
    }
    return v2;
  }
  down(keyDef) {
    const button = getMouseButtonId(keyDef.button);
    if (button in this.pressed) {
      this.pressed[button].push(keyDef);
      return void 0;
    }
    this.pressed[button] = [
      keyDef
    ];
    return button;
  }
  up(keyDef) {
    const button = getMouseButtonId(keyDef.button);
    if (button in this.pressed) {
      this.pressed[button] = this.pressed[button].filter((k2) => k2.name !== keyDef.name);
      if (this.pressed[button].length === 0) {
        delete this.pressed[button];
        return button;
      }
    }
    return void 0;
  }
  constructor() {
    _define_property4(this, "pressed", {});
  }
};
__name(_Buttons, "Buttons");
var Buttons = _Buttons;
var MouseButton = {
  primary: 0,
  secondary: 1,
  auxiliary: 2,
  back: 3,
  X1: 3,
  forward: 4,
  X2: 4
};
function getMouseButtonId(button = 0) {
  if (button in MouseButton) {
    return MouseButton[button];
  }
  return Number(button);
}
__name(getMouseButtonId, "getMouseButtonId");
var MouseButtonFlip = {
  1: 2,
  2: 1
};
function getMouseEventButton(button) {
  button = getMouseButtonId(button);
  if (button in MouseButtonFlip) {
    return MouseButtonFlip[button];
  }
  return button;
}
__name(getMouseEventButton, "getMouseEventButton");

// ../node_modules/@testing-library/user-event/dist/esm/system/pointer/device.js
function _define_property5(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
__name(_define_property5, "_define_property");
var _Device = class _Device {
  get countPressed() {
    return this.pressedKeys.size;
  }
  isPressed(keyDef) {
    return this.pressedKeys.has(keyDef.name);
  }
  addPressed(keyDef) {
    return this.pressedKeys.add(keyDef.name);
  }
  removePressed(keyDef) {
    return this.pressedKeys.delete(keyDef.name);
  }
  constructor() {
    _define_property5(this, "pressedKeys", /* @__PURE__ */ new Set());
  }
};
__name(_Device, "Device");
var Device = _Device;

// ../node_modules/@testing-library/user-event/dist/esm/utils/misc/getTreeDiff.js
function getTreeDiff(a2, b2) {
  const treeA = [];
  for (let el = a2; el; el = el.parentElement) {
    treeA.push(el);
  }
  const treeB = [];
  for (let el = b2; el; el = el.parentElement) {
    treeB.push(el);
  }
  let i2 = 0;
  for (; ; i2++) {
    if (i2 >= treeA.length || i2 >= treeB.length || treeA[treeA.length - 1 - i2] !== treeB[treeB.length - 1 - i2]) {
      break;
    }
  }
  return [
    treeA.slice(0, treeA.length - i2),
    treeB.slice(0, treeB.length - i2),
    treeB.slice(treeB.length - i2)
  ];
}
__name(getTreeDiff, "getTreeDiff");

// ../node_modules/@testing-library/user-event/dist/esm/event/selection/resolveCaretPosition.js
function resolveCaretPosition({ target, node, offset: offset2 }) {
  if (hasOwnSelection(target)) {
    return {
      node: target,
      offset: offset2 !== null && offset2 !== void 0 ? offset2 : getUIValue(target).length
    };
  } else if (node) {
    return {
      node,
      offset: offset2 !== null && offset2 !== void 0 ? offset2 : node.nodeType === 3 ? node.nodeValue.length : node.childNodes.length
    };
  }
  return findNodeAtTextOffset(target, offset2);
}
__name(resolveCaretPosition, "resolveCaretPosition");
function findNodeAtTextOffset(node, offset2, isRoot = true) {
  let i2 = offset2 === void 0 ? node.childNodes.length - 1 : 0;
  const step2 = offset2 === void 0 ? -1 : 1;
  while (offset2 === void 0 ? i2 >= (isRoot ? Math.max(node.childNodes.length - 1, 0) : 0) : i2 <= node.childNodes.length) {
    if (offset2 && i2 === node.childNodes.length) {
      throw new Error("The given offset is out of bounds.");
    }
    const c2 = node.childNodes.item(i2);
    const text = String(c2.textContent);
    if (text.length) {
      if (offset2 !== void 0 && text.length < offset2) {
        offset2 -= text.length;
      } else if (c2.nodeType === 1) {
        return findNodeAtTextOffset(c2, offset2, false);
      } else {
        if (c2.nodeType === 3) {
          return {
            node: c2,
            offset: offset2 !== null && offset2 !== void 0 ? offset2 : c2.nodeValue.length
          };
        }
      }
    }
    i2 += step2;
  }
  return {
    node,
    offset: node.childNodes.length
  };
}
__name(findNodeAtTextOffset, "findNodeAtTextOffset");

// ../node_modules/@testing-library/user-event/dist/esm/event/selection/setSelectionPerMouse.js
function setSelectionPerMouseDown({ document: document7, target, clickCount, node, offset: offset2 }) {
  if (hasNoSelection(target)) {
    return;
  }
  const targetHasOwnSelection = hasOwnSelection(target);
  const text = String(targetHasOwnSelection ? getUIValue(target) : target.textContent);
  const [start, end] = node ? (
    // which elements might be considered in the same line of text.
    // TODO: support expanding initial range on multiple clicks if node is given
    [
      offset2,
      offset2
    ]
  ) : getTextRange(text, offset2, clickCount);
  if (targetHasOwnSelection) {
    setUISelection(target, {
      anchorOffset: start !== null && start !== void 0 ? start : text.length,
      focusOffset: end !== null && end !== void 0 ? end : text.length
    });
    return {
      node: target,
      start: start !== null && start !== void 0 ? start : 0,
      end: end !== null && end !== void 0 ? end : text.length
    };
  } else {
    const { node: startNode, offset: startOffset } = resolveCaretPosition({
      target,
      node,
      offset: start
    });
    const { node: endNode, offset: endOffset } = resolveCaretPosition({
      target,
      node,
      offset: end
    });
    const range = target.ownerDocument.createRange();
    try {
      range.setStart(startNode, startOffset);
      range.setEnd(endNode, endOffset);
    } catch (e2) {
      throw new Error("The given offset is out of bounds.");
    }
    const selection = document7.getSelection();
    selection === null || selection === void 0 ? void 0 : selection.removeAllRanges();
    selection === null || selection === void 0 ? void 0 : selection.addRange(range.cloneRange());
    return range;
  }
}
__name(setSelectionPerMouseDown, "setSelectionPerMouseDown");
function getTextRange(text, pos, clickCount) {
  if (clickCount % 3 === 1 || text.length === 0) {
    return [
      pos,
      pos
    ];
  }
  const textPos = pos !== null && pos !== void 0 ? pos : text.length;
  if (clickCount % 3 === 2) {
    return [
      textPos - text.substr(0, pos).match(/(\w+|\s+|\W)?$/)[0].length,
      pos === void 0 ? pos : pos + text.substr(pos).match(/^(\w+|\s+|\W)?/)[0].length
    ];
  }
  return [
    textPos - text.substr(0, pos).match(/[^\r\n]*$/)[0].length,
    pos === void 0 ? pos : pos + text.substr(pos).match(/^[^\r\n]*/)[0].length
  ];
}
__name(getTextRange, "getTextRange");

// ../node_modules/@testing-library/user-event/dist/esm/event/selection/modifySelectionPerMouse.js
function modifySelectionPerMouseMove(selectionRange, { document: document7, target, node, offset: offset2 }) {
  const selectionFocus = resolveCaretPosition({
    target,
    node,
    offset: offset2
  });
  if ("node" in selectionRange) {
    if (selectionFocus.node === selectionRange.node) {
      const anchorOffset = selectionFocus.offset < selectionRange.start ? selectionRange.end : selectionRange.start;
      const focusOffset = selectionFocus.offset > selectionRange.end || selectionFocus.offset < selectionRange.start ? selectionFocus.offset : selectionRange.end;
      setUISelection(selectionRange.node, {
        anchorOffset,
        focusOffset
      });
    }
  } else {
    const range = selectionRange.cloneRange();
    const cmp = range.comparePoint(selectionFocus.node, selectionFocus.offset);
    if (cmp < 0) {
      range.setStart(selectionFocus.node, selectionFocus.offset);
    } else if (cmp > 0) {
      range.setEnd(selectionFocus.node, selectionFocus.offset);
    }
    const selection = document7.getSelection();
    selection === null || selection === void 0 ? void 0 : selection.removeAllRanges();
    selection === null || selection === void 0 ? void 0 : selection.addRange(range.cloneRange());
  }
}
__name(modifySelectionPerMouseMove, "modifySelectionPerMouseMove");

// ../node_modules/@testing-library/user-event/dist/esm/system/pointer/shared.js
function isDifferentPointerPosition(positionA, positionB) {
  var _positionA_coords, _positionB_coords, _positionA_coords1, _positionB_coords1, _positionA_coords2, _positionB_coords2, _positionA_coords3, _positionB_coords3, _positionA_coords4, _positionB_coords4, _positionA_coords5, _positionB_coords5, _positionA_coords6, _positionB_coords6, _positionA_coords7, _positionB_coords7, _positionA_coords8, _positionB_coords8, _positionA_coords9, _positionB_coords9, _positionA_caret, _positionB_caret, _positionA_caret1, _positionB_caret1;
  return positionA.target !== positionB.target || ((_positionA_coords = positionA.coords) === null || _positionA_coords === void 0 ? void 0 : _positionA_coords.x) !== ((_positionB_coords = positionB.coords) === null || _positionB_coords === void 0 ? void 0 : _positionB_coords.x) || ((_positionA_coords1 = positionA.coords) === null || _positionA_coords1 === void 0 ? void 0 : _positionA_coords1.y) !== ((_positionB_coords1 = positionB.coords) === null || _positionB_coords1 === void 0 ? void 0 : _positionB_coords1.y) || ((_positionA_coords2 = positionA.coords) === null || _positionA_coords2 === void 0 ? void 0 : _positionA_coords2.clientX) !== ((_positionB_coords2 = positionB.coords) === null || _positionB_coords2 === void 0 ? void 0 : _positionB_coords2.clientX) || ((_positionA_coords3 = positionA.coords) === null || _positionA_coords3 === void 0 ? void 0 : _positionA_coords3.clientY) !== ((_positionB_coords3 = positionB.coords) === null || _positionB_coords3 === void 0 ? void 0 : _positionB_coords3.clientY) || ((_positionA_coords4 = positionA.coords) === null || _positionA_coords4 === void 0 ? void 0 : _positionA_coords4.offsetX) !== ((_positionB_coords4 = positionB.coords) === null || _positionB_coords4 === void 0 ? void 0 : _positionB_coords4.offsetX) || ((_positionA_coords5 = positionA.coords) === null || _positionA_coords5 === void 0 ? void 0 : _positionA_coords5.offsetY) !== ((_positionB_coords5 = positionB.coords) === null || _positionB_coords5 === void 0 ? void 0 : _positionB_coords5.offsetY) || ((_positionA_coords6 = positionA.coords) === null || _positionA_coords6 === void 0 ? void 0 : _positionA_coords6.pageX) !== ((_positionB_coords6 = positionB.coords) === null || _positionB_coords6 === void 0 ? void 0 : _positionB_coords6.pageX) || ((_positionA_coords7 = positionA.coords) === null || _positionA_coords7 === void 0 ? void 0 : _positionA_coords7.pageY) !== ((_positionB_coords7 = positionB.coords) === null || _positionB_coords7 === void 0 ? void 0 : _positionB_coords7.pageY) || ((_positionA_coords8 = positionA.coords) === null || _positionA_coords8 === void 0 ? void 0 : _positionA_coords8.screenX) !== ((_positionB_coords8 = positionB.coords) === null || _positionB_coords8 === void 0 ? void 0 : _positionB_coords8.screenX) || ((_positionA_coords9 = positionA.coords) === null || _positionA_coords9 === void 0 ? void 0 : _positionA_coords9.screenY) !== ((_positionB_coords9 = positionB.coords) === null || _positionB_coords9 === void 0 ? void 0 : _positionB_coords9.screenY) || ((_positionA_caret = positionA.caret) === null || _positionA_caret === void 0 ? void 0 : _positionA_caret.node) !== ((_positionB_caret = positionB.caret) === null || _positionB_caret === void 0 ? void 0 : _positionB_caret.node) || ((_positionA_caret1 = positionA.caret) === null || _positionA_caret1 === void 0 ? void 0 : _positionA_caret1.offset) !== ((_positionB_caret1 = positionB.caret) === null || _positionB_caret1 === void 0 ? void 0 : _positionB_caret1.offset);
}
__name(isDifferentPointerPosition, "isDifferentPointerPosition");

// ../node_modules/@testing-library/user-event/dist/esm/system/pointer/mouse.js
function _define_property6(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
__name(_define_property6, "_define_property");
var _Mouse = class _Mouse {
  move(instance, position, isPrevented) {
    const prevPosition = this.position;
    const prevTarget = this.getTarget(instance);
    this.position = position;
    if (!isDifferentPointerPosition(prevPosition, position)) {
      return;
    }
    const nextTarget = this.getTarget(instance);
    const init2 = this.getEventInit("mousemove");
    const [leave, enter] = getTreeDiff(prevTarget, nextTarget);
    return {
      leave: /* @__PURE__ */ __name(() => {
        if (prevTarget !== nextTarget) {
          instance.dispatchUIEvent(prevTarget, "mouseout", init2);
          leave.forEach((el) => instance.dispatchUIEvent(el, "mouseleave", init2));
        }
      }, "leave"),
      enter: /* @__PURE__ */ __name(() => {
        if (prevTarget !== nextTarget) {
          instance.dispatchUIEvent(nextTarget, "mouseover", init2);
          enter.forEach((el) => instance.dispatchUIEvent(el, "mouseenter", init2));
        }
      }, "enter"),
      move: /* @__PURE__ */ __name(() => {
        if (isPrevented) {
          return;
        }
        instance.dispatchUIEvent(nextTarget, "mousemove", init2);
        this.modifySelecting(instance);
      }, "move")
    };
  }
  down(instance, keyDef, isPrevented) {
    const button = this.buttons.down(keyDef);
    if (button === void 0) {
      return;
    }
    const target = this.getTarget(instance);
    this.buttonDownTarget[button] = target;
    const init2 = this.getEventInit("mousedown", keyDef.button);
    const disabled = isDisabled2(target);
    if (!isPrevented && (disabled || instance.dispatchUIEvent(target, "mousedown", init2))) {
      this.startSelecting(instance, init2.detail);
      focusElement(target);
    }
    if (!disabled && getMouseEventButton(keyDef.button) === 2) {
      instance.dispatchUIEvent(target, "contextmenu", this.getEventInit("contextmenu", keyDef.button));
    }
  }
  up(instance, keyDef, isPrevented) {
    const button = this.buttons.up(keyDef);
    if (button === void 0) {
      return;
    }
    const target = this.getTarget(instance);
    if (!isDisabled2(target)) {
      if (!isPrevented) {
        const mouseUpInit = this.getEventInit("mouseup", keyDef.button);
        instance.dispatchUIEvent(target, "mouseup", mouseUpInit);
        this.endSelecting();
      }
      const clickTarget = getTreeDiff(this.buttonDownTarget[button], target)[2][0];
      if (clickTarget) {
        const init2 = this.getEventInit("click", keyDef.button);
        if (init2.detail) {
          instance.dispatchUIEvent(clickTarget, init2.button === 0 ? "click" : "auxclick", init2);
          if (init2.button === 0 && init2.detail === 2) {
            instance.dispatchUIEvent(clickTarget, "dblclick", {
              ...this.getEventInit("dblclick", keyDef.button),
              detail: init2.detail
            });
          }
        }
      }
    }
  }
  resetClickCount() {
    this.clickCount.reset();
  }
  getEventInit(type5, button) {
    const init2 = {
      ...this.position.coords
    };
    init2.button = getMouseEventButton(button);
    init2.buttons = this.buttons.getButtons();
    if (type5 === "mousedown") {
      init2.detail = this.clickCount.getOnDown(init2.button);
    } else if (type5 === "mouseup") {
      init2.detail = this.clickCount.getOnUp(init2.button);
    } else if (type5 === "click" || type5 === "auxclick") {
      init2.detail = this.clickCount.incOnClick(init2.button);
    }
    return init2;
  }
  getTarget(instance) {
    var _this_position_target;
    return (_this_position_target = this.position.target) !== null && _this_position_target !== void 0 ? _this_position_target : instance.config.document.body;
  }
  startSelecting(instance, clickCount) {
    var _this_position_caret, _this_position_caret1;
    this.selecting = setSelectionPerMouseDown({
      document: instance.config.document,
      target: this.getTarget(instance),
      node: (_this_position_caret = this.position.caret) === null || _this_position_caret === void 0 ? void 0 : _this_position_caret.node,
      offset: (_this_position_caret1 = this.position.caret) === null || _this_position_caret1 === void 0 ? void 0 : _this_position_caret1.offset,
      clickCount
    });
  }
  modifySelecting(instance) {
    var _this_position_caret, _this_position_caret1;
    if (!this.selecting) {
      return;
    }
    modifySelectionPerMouseMove(this.selecting, {
      document: instance.config.document,
      target: this.getTarget(instance),
      node: (_this_position_caret = this.position.caret) === null || _this_position_caret === void 0 ? void 0 : _this_position_caret.node,
      offset: (_this_position_caret1 = this.position.caret) === null || _this_position_caret1 === void 0 ? void 0 : _this_position_caret1.offset
    });
  }
  endSelecting() {
    this.selecting = void 0;
  }
  constructor() {
    _define_property6(this, "position", {});
    _define_property6(this, "buttons", new Buttons());
    _define_property6(this, "selecting", void 0);
    _define_property6(this, "buttonDownTarget", {});
    _define_property6(this, "clickCount", new class {
      incOnClick(button) {
        const current = this.down[button] === void 0 ? void 0 : Number(this.down[button]) + 1;
        this.count = this.count[button] === void 0 ? {} : {
          [button]: Number(this.count[button]) + 1
        };
        return current;
      }
      getOnDown(button) {
        var _this_count_button;
        this.down = {
          [button]: (_this_count_button = this.count[button]) !== null && _this_count_button !== void 0 ? _this_count_button : 0
        };
        var _this_count_button1;
        this.count = {
          [button]: (_this_count_button1 = this.count[button]) !== null && _this_count_button1 !== void 0 ? _this_count_button1 : 0
        };
        return Number(this.count[button]) + 1;
      }
      getOnUp(button) {
        return this.down[button] === void 0 ? void 0 : Number(this.down[button]) + 1;
      }
      reset() {
        this.count = {};
      }
      constructor() {
        _define_property6(this, "down", {});
        _define_property6(this, "count", {});
      }
    }());
  }
};
__name(_Mouse, "Mouse");
var Mouse = _Mouse;

// ../node_modules/@testing-library/user-event/dist/esm/utils/pointer/cssPointerEvents.js
function hasPointerEvents(instance, element) {
  var _checkPointerEvents;
  return ((_checkPointerEvents = checkPointerEvents(instance, element)) === null || _checkPointerEvents === void 0 ? void 0 : _checkPointerEvents.pointerEvents) !== "none";
}
__name(hasPointerEvents, "hasPointerEvents");
function closestPointerEventsDeclaration(element) {
  const window2 = getWindow(element);
  for (let el = element, tree = []; el === null || el === void 0 ? void 0 : el.ownerDocument; el = el.parentElement) {
    tree.push(el);
    const pointerEvents = window2.getComputedStyle(el).pointerEvents;
    if (pointerEvents && ![
      "inherit",
      "unset"
    ].includes(pointerEvents)) {
      return {
        pointerEvents,
        tree
      };
    }
  }
  return void 0;
}
__name(closestPointerEventsDeclaration, "closestPointerEventsDeclaration");
var PointerEventsCheck = Symbol("Last check for pointer-events");
function checkPointerEvents(instance, element) {
  const lastCheck = element[PointerEventsCheck];
  const needsCheck = instance.config.pointerEventsCheck !== PointerEventsCheckLevel.Never && (!lastCheck || hasBitFlag(instance.config.pointerEventsCheck, PointerEventsCheckLevel.EachApiCall) && lastCheck[ApiLevel.Call] !== getLevelRef(instance, ApiLevel.Call) || hasBitFlag(instance.config.pointerEventsCheck, PointerEventsCheckLevel.EachTrigger) && lastCheck[ApiLevel.Trigger] !== getLevelRef(instance, ApiLevel.Trigger));
  if (!needsCheck) {
    return lastCheck === null || lastCheck === void 0 ? void 0 : lastCheck.result;
  }
  const declaration = closestPointerEventsDeclaration(element);
  element[PointerEventsCheck] = {
    [ApiLevel.Call]: getLevelRef(instance, ApiLevel.Call),
    [ApiLevel.Trigger]: getLevelRef(instance, ApiLevel.Trigger),
    result: declaration
  };
  return declaration;
}
__name(checkPointerEvents, "checkPointerEvents");
function assertPointerEvents(instance, element) {
  const declaration = checkPointerEvents(instance, element);
  if ((declaration === null || declaration === void 0 ? void 0 : declaration.pointerEvents) === "none") {
    throw new Error([
      `Unable to perform pointer interaction as the element ${declaration.tree.length > 1 ? "inherits" : "has"} \`pointer-events: none\`:`,
      "",
      printTree(declaration.tree)
    ].join("\n"));
  }
}
__name(assertPointerEvents, "assertPointerEvents");
function printTree(tree) {
  return tree.reverse().map((el, i2) => [
    "".padEnd(i2),
    el.tagName,
    el.id && `#${el.id}`,
    el.hasAttribute("data-testid") && `(testId=${el.getAttribute("data-testid")})`,
    getLabelDescr(el),
    tree.length > 1 && i2 === 0 && "  <-- This element declared `pointer-events: none`",
    tree.length > 1 && i2 === tree.length - 1 && "  <-- Asserted pointer events here"
  ].filter(Boolean).join("")).join("\n");
}
__name(printTree, "printTree");
function getLabelDescr(element) {
  var _element_labels;
  let label;
  if (element.hasAttribute("aria-label")) {
    label = element.getAttribute("aria-label");
  } else if (element.hasAttribute("aria-labelledby")) {
    var _element_ownerDocument_getElementById_textContent, _element_ownerDocument_getElementById;
    label = (_element_ownerDocument_getElementById = element.ownerDocument.getElementById(element.getAttribute("aria-labelledby"))) === null || _element_ownerDocument_getElementById === void 0 ? void 0 : (_element_ownerDocument_getElementById_textContent = _element_ownerDocument_getElementById.textContent) === null || _element_ownerDocument_getElementById_textContent === void 0 ? void 0 : _element_ownerDocument_getElementById_textContent.trim();
  } else if (isElementType(element, [
    "button",
    "input",
    "meter",
    "output",
    "progress",
    "select",
    "textarea"
  ]) && ((_element_labels = element.labels) === null || _element_labels === void 0 ? void 0 : _element_labels.length)) {
    label = Array.from(element.labels).map((el) => {
      var _el_textContent;
      return (_el_textContent = el.textContent) === null || _el_textContent === void 0 ? void 0 : _el_textContent.trim();
    }).join("|");
  } else if (isElementType(element, "button")) {
    var _element_textContent;
    label = (_element_textContent = element.textContent) === null || _element_textContent === void 0 ? void 0 : _element_textContent.trim();
  }
  label = label === null || label === void 0 ? void 0 : label.replace(/\n/g, "  ");
  if (Number(label === null || label === void 0 ? void 0 : label.length) > 30) {
    label = `${label === null || label === void 0 ? void 0 : label.substring(0, 29)}\u2026`;
  }
  return label ? `(label=${label})` : "";
}
__name(getLabelDescr, "getLabelDescr");
function hasBitFlag(conf, flag3) {
  return (conf & flag3) > 0;
}
__name(hasBitFlag, "hasBitFlag");

// ../node_modules/@testing-library/user-event/dist/esm/system/pointer/pointer.js
function _define_property7(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
__name(_define_property7, "_define_property");
var _Pointer = class _Pointer {
  init(instance) {
    const target = this.getTarget(instance);
    const [, enter] = getTreeDiff(null, target);
    const init2 = this.getEventInit();
    assertPointerEvents(instance, target);
    instance.dispatchUIEvent(target, "pointerover", init2);
    enter.forEach((el) => instance.dispatchUIEvent(el, "pointerenter", init2));
    return this;
  }
  move(instance, position) {
    const prevPosition = this.position;
    const prevTarget = this.getTarget(instance);
    this.position = position;
    if (!isDifferentPointerPosition(prevPosition, position)) {
      return;
    }
    const nextTarget = this.getTarget(instance);
    const init2 = this.getEventInit(-1);
    const [leave, enter] = getTreeDiff(prevTarget, nextTarget);
    return {
      leave: /* @__PURE__ */ __name(() => {
        if (hasPointerEvents(instance, prevTarget)) {
          if (prevTarget !== nextTarget) {
            instance.dispatchUIEvent(prevTarget, "pointerout", init2);
            leave.forEach((el) => instance.dispatchUIEvent(el, "pointerleave", init2));
          }
        }
      }, "leave"),
      enter: /* @__PURE__ */ __name(() => {
        assertPointerEvents(instance, nextTarget);
        if (prevTarget !== nextTarget) {
          instance.dispatchUIEvent(nextTarget, "pointerover", init2);
          enter.forEach((el) => instance.dispatchUIEvent(el, "pointerenter", init2));
        }
      }, "enter"),
      move: /* @__PURE__ */ __name(() => {
        instance.dispatchUIEvent(nextTarget, "pointermove", init2);
      }, "move")
    };
  }
  down(instance, button = 0) {
    if (this.isDown) {
      return;
    }
    const target = this.getTarget(instance);
    assertPointerEvents(instance, target);
    this.isDown = true;
    this.isPrevented = !instance.dispatchUIEvent(target, "pointerdown", this.getEventInit(button));
  }
  up(instance, button = 0) {
    if (!this.isDown) {
      return;
    }
    const target = this.getTarget(instance);
    assertPointerEvents(instance, target);
    this.isPrevented = false;
    this.isDown = false;
    instance.dispatchUIEvent(target, "pointerup", this.getEventInit(button));
  }
  release(instance) {
    const target = this.getTarget(instance);
    const [leave] = getTreeDiff(target, null);
    const init2 = this.getEventInit();
    if (hasPointerEvents(instance, target)) {
      instance.dispatchUIEvent(target, "pointerout", init2);
      leave.forEach((el) => instance.dispatchUIEvent(el, "pointerleave", init2));
    }
    this.isCancelled = true;
  }
  getTarget(instance) {
    var _this_position_target;
    return (_this_position_target = this.position.target) !== null && _this_position_target !== void 0 ? _this_position_target : instance.config.document.body;
  }
  getEventInit(button) {
    return {
      ...this.position.coords,
      pointerId: this.pointerId,
      pointerType: this.pointerType,
      isPrimary: this.isPrimary,
      button: getMouseEventButton(button),
      buttons: this.buttons.getButtons()
    };
  }
  constructor({ pointerId, pointerType, isPrimary }, buttons) {
    _define_property7(this, "pointerId", void 0);
    _define_property7(this, "pointerType", void 0);
    _define_property7(this, "isPrimary", void 0);
    _define_property7(this, "buttons", void 0);
    _define_property7(this, "isMultitouch", false);
    _define_property7(this, "isCancelled", false);
    _define_property7(this, "isDown", false);
    _define_property7(this, "isPrevented", false);
    _define_property7(this, "position", {});
    this.pointerId = pointerId;
    this.pointerType = pointerType;
    this.isPrimary = isPrimary;
    this.isMultitouch = !isPrimary;
    this.buttons = buttons;
  }
};
__name(_Pointer, "Pointer");
var Pointer = _Pointer;

// ../node_modules/@testing-library/user-event/dist/esm/system/pointer/index.js
function _define_property8(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
__name(_define_property8, "_define_property");
var _PointerHost = class _PointerHost {
  isKeyPressed(keyDef) {
    return this.devices.get(keyDef.pointerType).isPressed(keyDef);
  }
  async press(instance, keyDef, position) {
    this.devices.get(keyDef.pointerType).addPressed(keyDef);
    this.buttons.down(keyDef);
    const pointerName = this.getPointerName(keyDef);
    const pointer4 = keyDef.pointerType === "touch" ? this.pointers.new(pointerName, keyDef.pointerType, this.buttons) : this.pointers.get(pointerName);
    pointer4.position = position;
    if (pointer4.pointerType !== "touch") {
      this.mouse.position = position;
    }
    if (pointer4.pointerType === "touch") {
      pointer4.init(instance);
    }
    pointer4.down(instance, keyDef.button);
    if (pointer4.pointerType !== "touch") {
      this.mouse.down(instance, keyDef, pointer4.isPrevented);
    }
  }
  async move(instance, pointerName, position) {
    const pointer4 = this.pointers.get(pointerName);
    const pointermove = pointer4.move(instance, position);
    const mousemove = pointer4.pointerType === "touch" ? void 0 : this.mouse.move(instance, position, pointer4.isPrevented);
    pointermove === null || pointermove === void 0 ? void 0 : pointermove.leave();
    mousemove === null || mousemove === void 0 ? void 0 : mousemove.leave();
    pointermove === null || pointermove === void 0 ? void 0 : pointermove.enter();
    mousemove === null || mousemove === void 0 ? void 0 : mousemove.enter();
    pointermove === null || pointermove === void 0 ? void 0 : pointermove.move();
    mousemove === null || mousemove === void 0 ? void 0 : mousemove.move();
  }
  async release(instance, keyDef, position) {
    const device = this.devices.get(keyDef.pointerType);
    device.removePressed(keyDef);
    this.buttons.up(keyDef);
    const pointer4 = this.pointers.get(this.getPointerName(keyDef));
    const isPrevented = pointer4.isPrevented;
    pointer4.position = position;
    if (pointer4.pointerType !== "touch") {
      this.mouse.position = position;
    }
    if (device.countPressed === 0) {
      pointer4.up(instance, keyDef.button);
    }
    if (pointer4.pointerType === "touch") {
      pointer4.release(instance);
    }
    if (pointer4.pointerType === "touch" && !pointer4.isMultitouch) {
      const mousemove = this.mouse.move(instance, position, isPrevented);
      mousemove === null || mousemove === void 0 ? void 0 : mousemove.leave();
      mousemove === null || mousemove === void 0 ? void 0 : mousemove.enter();
      mousemove === null || mousemove === void 0 ? void 0 : mousemove.move();
      this.mouse.down(instance, keyDef, isPrevented);
    }
    if (!pointer4.isMultitouch) {
      const mousemove = this.mouse.move(instance, position, isPrevented);
      mousemove === null || mousemove === void 0 ? void 0 : mousemove.leave();
      mousemove === null || mousemove === void 0 ? void 0 : mousemove.enter();
      mousemove === null || mousemove === void 0 ? void 0 : mousemove.move();
      this.mouse.up(instance, keyDef, isPrevented);
    }
  }
  getPointerName(keyDef) {
    return keyDef.pointerType === "touch" ? keyDef.name : keyDef.pointerType;
  }
  getPreviousPosition(pointerName) {
    return this.pointers.has(pointerName) ? this.pointers.get(pointerName).position : void 0;
  }
  resetClickCount() {
    this.mouse.resetClickCount();
  }
  getMouseTarget(instance) {
    var _this_mouse_position_target;
    return (_this_mouse_position_target = this.mouse.position.target) !== null && _this_mouse_position_target !== void 0 ? _this_mouse_position_target : instance.config.document.body;
  }
  setMousePosition(position) {
    this.mouse.position = position;
    this.pointers.get("mouse").position = position;
  }
  constructor(system) {
    _define_property8(this, "system", void 0);
    _define_property8(this, "mouse", void 0);
    _define_property8(this, "buttons", void 0);
    _define_property8(this, "devices", new class {
      get(k2) {
        var _this_registry, _k;
        var _;
        return (_ = (_this_registry = this.registry)[_k = k2]) !== null && _ !== void 0 ? _ : _this_registry[_k] = new Device();
      }
      constructor() {
        _define_property8(this, "registry", {});
      }
    }());
    _define_property8(this, "pointers", new class {
      new(pointerName, pointerType, buttons) {
        const isPrimary = pointerType !== "touch" || !Object.values(this.registry).some((p2) => p2.pointerType === "touch" && !p2.isCancelled);
        if (!isPrimary) {
          Object.values(this.registry).forEach((p2) => {
            if (p2.pointerType === pointerType && !p2.isCancelled) {
              p2.isMultitouch = true;
            }
          });
        }
        this.registry[pointerName] = new Pointer({
          pointerId: this.nextId++,
          pointerType,
          isPrimary
        }, buttons);
        return this.registry[pointerName];
      }
      get(pointerName) {
        if (!this.has(pointerName)) {
          throw new Error(`Trying to access pointer "${pointerName}" which does not exist.`);
        }
        return this.registry[pointerName];
      }
      has(pointerName) {
        return pointerName in this.registry;
      }
      constructor() {
        _define_property8(this, "registry", {});
        _define_property8(this, "nextId", 1);
      }
    }());
    this.system = system;
    this.buttons = new Buttons();
    this.mouse = new Mouse();
    this.pointers.new("mouse", "mouse", this.buttons);
  }
};
__name(_PointerHost, "PointerHost");
var PointerHost = _PointerHost;

// ../node_modules/@testing-library/user-event/dist/esm/system/index.js
function _define_property9(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
__name(_define_property9, "_define_property");
var _System = class _System {
  getUIEventModifiers() {
    return {
      altKey: this.keyboard.modifiers.Alt,
      ctrlKey: this.keyboard.modifiers.Control,
      metaKey: this.keyboard.modifiers.Meta,
      shiftKey: this.keyboard.modifiers.Shift,
      modifierAltGraph: this.keyboard.modifiers.AltGraph,
      modifierCapsLock: this.keyboard.modifiers.CapsLock,
      modifierFn: this.keyboard.modifiers.Fn,
      modifierFnLock: this.keyboard.modifiers.FnLock,
      modifierNumLock: this.keyboard.modifiers.NumLock,
      modifierScrollLock: this.keyboard.modifiers.ScrollLock,
      modifierSymbol: this.keyboard.modifiers.Symbol,
      modifierSymbolLock: this.keyboard.modifiers.SymbolLock
    };
  }
  constructor() {
    _define_property9(this, "keyboard", new KeyboardHost(this));
    _define_property9(this, "pointer", new PointerHost(this));
  }
};
__name(_System, "System");
var System = _System;

// ../node_modules/@testing-library/user-event/dist/esm/convenience/click.js
async function click(element) {
  const pointerIn = [];
  if (!this.config.skipHover) {
    pointerIn.push({
      target: element
    });
  }
  pointerIn.push({
    keys: "[MouseLeft]",
    target: element
  });
  return this.pointer(pointerIn);
}
__name(click, "click");
async function dblClick(element) {
  return this.pointer([
    {
      target: element
    },
    "[MouseLeft][MouseLeft]"
  ]);
}
__name(dblClick, "dblClick");
async function tripleClick(element) {
  return this.pointer([
    {
      target: element
    },
    "[MouseLeft][MouseLeft][MouseLeft]"
  ]);
}
__name(tripleClick, "tripleClick");

// ../node_modules/@testing-library/user-event/dist/esm/convenience/hover.js
async function hover(element) {
  return this.pointer({
    target: element
  });
}
__name(hover, "hover");
async function unhover(element) {
  assertPointerEvents(this, this.system.pointer.getMouseTarget(this));
  return this.pointer({
    target: element.ownerDocument.body
  });
}
__name(unhover, "unhover");

// ../node_modules/@testing-library/user-event/dist/esm/convenience/tab.js
async function tab({ shift } = {}) {
  return this.keyboard(shift === true ? "{Shift>}{Tab}{/Shift}" : shift === false ? "[/ShiftLeft][/ShiftRight]{Tab}" : "{Tab}");
}
__name(tab, "tab");

// ../node_modules/@testing-library/user-event/dist/esm/utils/keyDef/readNextDescriptor.js
var bracketDict = function(bracketDict2) {
  bracketDict2["{"] = "}";
  bracketDict2["["] = "]";
  return bracketDict2;
}(bracketDict || {});
function readNextDescriptor(text, context) {
  let pos = 0;
  const startBracket = text[pos] in bracketDict ? text[pos] : "";
  pos += startBracket.length;
  const isEscapedChar = new RegExp(`^\\${startBracket}{2}`).test(text);
  const type5 = isEscapedChar ? "" : startBracket;
  return {
    type: type5,
    ...type5 === "" ? readPrintableChar(text, pos, context) : readTag(text, pos, type5, context)
  };
}
__name(readNextDescriptor, "readNextDescriptor");
function readPrintableChar(text, pos, context) {
  const descriptor = text[pos];
  assertDescriptor(descriptor, text, pos, context);
  pos += descriptor.length;
  return {
    consumedLength: pos,
    descriptor,
    releasePrevious: false,
    releaseSelf: true,
    repeat: 1
  };
}
__name(readPrintableChar, "readPrintableChar");
function readTag(text, pos, startBracket, context) {
  var _text_slice_match, _text_slice_match1;
  const releasePreviousModifier = text[pos] === "/" ? "/" : "";
  pos += releasePreviousModifier.length;
  const escapedDescriptor = startBracket === "{" && text[pos] === "\\";
  pos += Number(escapedDescriptor);
  const descriptor = escapedDescriptor ? text[pos] : (_text_slice_match = text.slice(pos).match(startBracket === "{" ? /^\w+|^[^}>/]/ : /^\w+/)) === null || _text_slice_match === void 0 ? void 0 : _text_slice_match[0];
  assertDescriptor(descriptor, text, pos, context);
  pos += descriptor.length;
  var _text_slice_match_;
  const repeatModifier = (_text_slice_match_ = (_text_slice_match1 = text.slice(pos).match(/^>\d+/)) === null || _text_slice_match1 === void 0 ? void 0 : _text_slice_match1[0]) !== null && _text_slice_match_ !== void 0 ? _text_slice_match_ : "";
  pos += repeatModifier.length;
  const releaseSelfModifier = text[pos] === "/" || !repeatModifier && text[pos] === ">" ? text[pos] : "";
  pos += releaseSelfModifier.length;
  const expectedEndBracket = bracketDict[startBracket];
  const endBracket = text[pos] === expectedEndBracket ? expectedEndBracket : "";
  if (!endBracket) {
    throw new Error(getErrorMessage([
      !repeatModifier && "repeat modifier",
      !releaseSelfModifier && "release modifier",
      `"${expectedEndBracket}"`
    ].filter(Boolean).join(" or "), text[pos], text, context));
  }
  pos += endBracket.length;
  return {
    consumedLength: pos,
    descriptor,
    releasePrevious: !!releasePreviousModifier,
    repeat: repeatModifier ? Math.max(Number(repeatModifier.substr(1)), 1) : 1,
    releaseSelf: hasReleaseSelf(releaseSelfModifier, repeatModifier)
  };
}
__name(readTag, "readTag");
function assertDescriptor(descriptor, text, pos, context) {
  if (!descriptor) {
    throw new Error(getErrorMessage("key descriptor", text[pos], text, context));
  }
}
__name(assertDescriptor, "assertDescriptor");
function hasReleaseSelf(releaseSelfModifier, repeatModifier) {
  if (releaseSelfModifier) {
    return releaseSelfModifier === "/";
  }
  if (repeatModifier) {
    return false;
  }
}
__name(hasReleaseSelf, "hasReleaseSelf");
function getErrorMessage(expected, found, text, context) {
  return `Expected ${expected} but found "${found !== null && found !== void 0 ? found : ""}" in "${text}"
    See ${context === "pointer" ? `https://testing-library.com/docs/user-event/pointer#pressing-a-button-or-touching-the-screen` : `https://testing-library.com/docs/user-event/keyboard`}
    for more information about how userEvent parses your input.`;
}
__name(getErrorMessage, "getErrorMessage");

// ../node_modules/@testing-library/user-event/dist/esm/keyboard/parseKeyDef.js
function parseKeyDef(keyboardMap, text) {
  const defs = [];
  do {
    const { type: type5, descriptor, consumedLength, releasePrevious, releaseSelf = true, repeat } = readNextDescriptor(text, "keyboard");
    var _keyboardMap_find;
    const keyDef = (_keyboardMap_find = keyboardMap.find((def) => {
      if (type5 === "[") {
        var _def_code;
        return ((_def_code = def.code) === null || _def_code === void 0 ? void 0 : _def_code.toLowerCase()) === descriptor.toLowerCase();
      } else if (type5 === "{") {
        var _def_key;
        return ((_def_key = def.key) === null || _def_key === void 0 ? void 0 : _def_key.toLowerCase()) === descriptor.toLowerCase();
      }
      return def.key === descriptor;
    })) !== null && _keyboardMap_find !== void 0 ? _keyboardMap_find : {
      key: "Unknown",
      code: "Unknown",
      [type5 === "[" ? "code" : "key"]: descriptor
    };
    defs.push({
      keyDef,
      releasePrevious,
      releaseSelf,
      repeat
    });
    text = text.slice(consumedLength);
  } while (text);
  return defs;
}
__name(parseKeyDef, "parseKeyDef");

// ../node_modules/@testing-library/user-event/dist/esm/keyboard/index.js
async function keyboard(text) {
  const actions2 = parseKeyDef(this.config.keyboardMap, text);
  for (let i2 = 0; i2 < actions2.length; i2++) {
    await wait(this.config);
    await keyboardAction(this, actions2[i2]);
  }
}
__name(keyboard, "keyboard");
async function keyboardAction(instance, { keyDef, releasePrevious, releaseSelf, repeat }) {
  const { system } = instance;
  if (system.keyboard.isKeyPressed(keyDef)) {
    await system.keyboard.keyup(instance, keyDef);
  }
  if (!releasePrevious) {
    for (let i2 = 1; i2 <= repeat; i2++) {
      await system.keyboard.keydown(instance, keyDef);
      if (i2 < repeat) {
        await wait(instance.config);
      }
    }
    if (releaseSelf) {
      await system.keyboard.keyup(instance, keyDef);
    }
  }
}
__name(keyboardAction, "keyboardAction");
async function releaseAllKeys(instance) {
  for (const k2 of instance.system.keyboard.getPressedKeys()) {
    await instance.system.keyboard.keyup(instance, k2);
  }
}
__name(releaseAllKeys, "releaseAllKeys");

// ../node_modules/@testing-library/user-event/dist/esm/document/copySelection.js
function copySelection(target) {
  const data = hasOwnSelection(target) ? {
    "text/plain": readSelectedValueFromInput(target)
  } : {
    "text/plain": String(target.ownerDocument.getSelection())
  };
  const dt = createDataTransfer(getWindow(target));
  for (const type5 in data) {
    if (data[type5]) {
      dt.setData(type5, data[type5]);
    }
  }
  return dt;
}
__name(copySelection, "copySelection");
function readSelectedValueFromInput(target) {
  const sel = getUISelection(target);
  const val = getUIValue(target);
  return val.substring(sel.startOffset, sel.endOffset);
}
__name(readSelectedValueFromInput, "readSelectedValueFromInput");

// ../node_modules/@testing-library/user-event/dist/esm/clipboard/copy.js
async function copy() {
  const doc = this.config.document;
  var _doc_activeElement;
  const target = (_doc_activeElement = doc.activeElement) !== null && _doc_activeElement !== void 0 ? _doc_activeElement : (
    /* istanbul ignore next */
    doc.body
  );
  const clipboardData = copySelection(target);
  if (clipboardData.items.length === 0) {
    return;
  }
  if (this.dispatchUIEvent(target, "copy", {
    clipboardData
  }) && this.config.writeToClipboard) {
    await writeDataTransferToClipboard(doc, clipboardData);
  }
  return clipboardData;
}
__name(copy, "copy");

// ../node_modules/@testing-library/user-event/dist/esm/clipboard/cut.js
async function cut() {
  const doc = this.config.document;
  var _doc_activeElement;
  const target = (_doc_activeElement = doc.activeElement) !== null && _doc_activeElement !== void 0 ? _doc_activeElement : (
    /* istanbul ignore next */
    doc.body
  );
  const clipboardData = copySelection(target);
  if (clipboardData.items.length === 0) {
    return;
  }
  if (this.dispatchUIEvent(target, "cut", {
    clipboardData
  }) && this.config.writeToClipboard) {
    await writeDataTransferToClipboard(target.ownerDocument, clipboardData);
  }
  return clipboardData;
}
__name(cut, "cut");

// ../node_modules/@testing-library/user-event/dist/esm/clipboard/paste.js
async function paste(clipboardData) {
  const doc = this.config.document;
  var _doc_activeElement;
  const target = (_doc_activeElement = doc.activeElement) !== null && _doc_activeElement !== void 0 ? _doc_activeElement : (
    /* istanbul ignore next */
    doc.body
  );
  var _ref;
  const dataTransfer = (_ref = typeof clipboardData === "string" ? getClipboardDataFromString(doc, clipboardData) : clipboardData) !== null && _ref !== void 0 ? _ref : await readDataTransferFromClipboard(doc).catch(() => {
    throw new Error("`userEvent.paste()` without `clipboardData` requires the `ClipboardAPI` to be available.");
  });
  this.dispatchUIEvent(target, "paste", {
    clipboardData: dataTransfer
  });
}
__name(paste, "paste");
function getClipboardDataFromString(doc, text) {
  const dt = createDataTransfer(getWindow(doc));
  dt.setData("text", text);
  return dt;
}
__name(getClipboardDataFromString, "getClipboardDataFromString");

// ../node_modules/@testing-library/user-event/dist/esm/pointer/parseKeyDef.js
function parseKeyDef2(pointerMap, keys2) {
  const defs = [];
  do {
    const { descriptor, consumedLength, releasePrevious, releaseSelf = true } = readNextDescriptor(keys2, "pointer");
    const keyDef = pointerMap.find((p2) => p2.name === descriptor);
    if (keyDef) {
      defs.push({
        keyDef,
        releasePrevious,
        releaseSelf
      });
    }
    keys2 = keys2.slice(consumedLength);
  } while (keys2);
  return defs;
}
__name(parseKeyDef2, "parseKeyDef");

// ../node_modules/@testing-library/user-event/dist/esm/pointer/index.js
async function pointer(input2) {
  const { pointerMap } = this.config;
  const actions2 = [];
  (Array.isArray(input2) ? input2 : [
    input2
  ]).forEach((actionInput) => {
    if (typeof actionInput === "string") {
      actions2.push(...parseKeyDef2(pointerMap, actionInput));
    } else if ("keys" in actionInput) {
      actions2.push(...parseKeyDef2(pointerMap, actionInput.keys).map((i2) => ({
        ...actionInput,
        ...i2
      })));
    } else {
      actions2.push(actionInput);
    }
  });
  for (let i2 = 0; i2 < actions2.length; i2++) {
    await wait(this.config);
    await pointerAction(this, actions2[i2]);
  }
  this.system.pointer.resetClickCount();
}
__name(pointer, "pointer");
async function pointerAction(instance, action2) {
  var _previousPosition_caret, _previousPosition_caret1;
  const pointerName = "pointerName" in action2 && action2.pointerName ? action2.pointerName : "keyDef" in action2 ? instance.system.pointer.getPointerName(action2.keyDef) : "mouse";
  const previousPosition = instance.system.pointer.getPreviousPosition(pointerName);
  var _action_target, _action_coords, _action_node, _action_offset;
  const position = {
    target: (_action_target = action2.target) !== null && _action_target !== void 0 ? _action_target : getPrevTarget(instance, previousPosition),
    coords: (_action_coords = action2.coords) !== null && _action_coords !== void 0 ? _action_coords : previousPosition === null || previousPosition === void 0 ? void 0 : previousPosition.coords,
    caret: {
      node: (_action_node = action2.node) !== null && _action_node !== void 0 ? _action_node : hasCaretPosition(action2) ? void 0 : previousPosition === null || previousPosition === void 0 ? void 0 : (_previousPosition_caret = previousPosition.caret) === null || _previousPosition_caret === void 0 ? void 0 : _previousPosition_caret.node,
      offset: (_action_offset = action2.offset) !== null && _action_offset !== void 0 ? _action_offset : hasCaretPosition(action2) ? void 0 : previousPosition === null || previousPosition === void 0 ? void 0 : (_previousPosition_caret1 = previousPosition.caret) === null || _previousPosition_caret1 === void 0 ? void 0 : _previousPosition_caret1.offset
    }
  };
  if ("keyDef" in action2) {
    if (instance.system.pointer.isKeyPressed(action2.keyDef)) {
      setLevelRef(instance, ApiLevel.Trigger);
      await instance.system.pointer.release(instance, action2.keyDef, position);
    }
    if (!action2.releasePrevious) {
      setLevelRef(instance, ApiLevel.Trigger);
      await instance.system.pointer.press(instance, action2.keyDef, position);
      if (action2.releaseSelf) {
        setLevelRef(instance, ApiLevel.Trigger);
        await instance.system.pointer.release(instance, action2.keyDef, position);
      }
    }
  } else {
    setLevelRef(instance, ApiLevel.Trigger);
    await instance.system.pointer.move(instance, pointerName, position);
  }
}
__name(pointerAction, "pointerAction");
function hasCaretPosition(action2) {
  var _action_target, _ref;
  return !!((_ref = (_action_target = action2.target) !== null && _action_target !== void 0 ? _action_target : action2.node) !== null && _ref !== void 0 ? _ref : action2.offset !== void 0);
}
__name(hasCaretPosition, "hasCaretPosition");
function getPrevTarget(instance, position) {
  if (!position) {
    throw new Error("This pointer has no previous position. Provide a target property!");
  }
  var _position_target;
  return (_position_target = position.target) !== null && _position_target !== void 0 ? _position_target : instance.config.document.body;
}
__name(getPrevTarget, "getPrevTarget");

// ../node_modules/@testing-library/user-event/dist/esm/utility/clear.js
async function clear(element) {
  if (!isEditable(element) || isDisabled2(element)) {
    throw new Error("clear()` is only supported on editable elements.");
  }
  focusElement(element);
  if (element.ownerDocument.activeElement !== element) {
    throw new Error("The element to be cleared could not be focused.");
  }
  selectAll(element);
  if (!isAllSelected(element)) {
    throw new Error("The element content to be cleared could not be selected.");
  }
  input(this, element, "", "deleteContentBackward");
}
__name(clear, "clear");

// ../node_modules/@testing-library/user-event/dist/esm/utility/selectOptions.js
async function selectOptions(select, values) {
  return selectOptionsBase.call(this, true, select, values);
}
__name(selectOptions, "selectOptions");
async function deselectOptions(select, values) {
  return selectOptionsBase.call(this, false, select, values);
}
__name(deselectOptions, "deselectOptions");
async function selectOptionsBase(newValue, select, values) {
  if (!newValue && !select.multiple) {
    throw getConfig2().getElementError(`Unable to deselect an option in a non-multiple select. Use selectOptions to change the selection instead.`, select);
  }
  const valArray = Array.isArray(values) ? values : [
    values
  ];
  const allOptions = Array.from(select.querySelectorAll('option, [role="option"]'));
  const selectedOptions = valArray.map((val) => {
    if (typeof val !== "string" && allOptions.includes(val)) {
      return val;
    } else {
      const matchingOption = allOptions.find((o2) => o2.value === val || o2.innerHTML === val);
      if (matchingOption) {
        return matchingOption;
      } else {
        throw getConfig2().getElementError(`Value "${String(val)}" not found in options`, select);
      }
    }
  }).filter((option) => !isDisabled2(option));
  if (isDisabled2(select) || !selectedOptions.length) return;
  const selectOption = /* @__PURE__ */ __name((option) => {
    option.selected = newValue;
    this.dispatchUIEvent(select, "input", {
      bubbles: true,
      cancelable: false,
      composed: true
    });
    this.dispatchUIEvent(select, "change");
  }, "selectOption");
  if (isElementType(select, "select")) {
    if (select.multiple) {
      for (const option of selectedOptions) {
        const withPointerEvents = this.config.pointerEventsCheck === 0 ? true : hasPointerEvents(this, option);
        if (withPointerEvents) {
          this.dispatchUIEvent(option, "pointerover");
          this.dispatchUIEvent(select, "pointerenter");
          this.dispatchUIEvent(option, "mouseover");
          this.dispatchUIEvent(select, "mouseenter");
          this.dispatchUIEvent(option, "pointermove");
          this.dispatchUIEvent(option, "mousemove");
          this.dispatchUIEvent(option, "pointerdown");
          this.dispatchUIEvent(option, "mousedown");
        }
        focusElement(select);
        if (withPointerEvents) {
          this.dispatchUIEvent(option, "pointerup");
          this.dispatchUIEvent(option, "mouseup");
        }
        selectOption(option);
        if (withPointerEvents) {
          this.dispatchUIEvent(option, "click");
        }
        await wait(this.config);
      }
    } else if (selectedOptions.length === 1) {
      const withPointerEvents = this.config.pointerEventsCheck === 0 ? true : hasPointerEvents(this, select);
      if (withPointerEvents) {
        await this.click(select);
      } else {
        focusElement(select);
      }
      selectOption(selectedOptions[0]);
      if (withPointerEvents) {
        this.dispatchUIEvent(select, "pointerover");
        this.dispatchUIEvent(select, "pointerenter");
        this.dispatchUIEvent(select, "mouseover");
        this.dispatchUIEvent(select, "mouseenter");
        this.dispatchUIEvent(select, "pointerup");
        this.dispatchUIEvent(select, "mouseup");
        this.dispatchUIEvent(select, "click");
      }
      await wait(this.config);
    } else {
      throw getConfig2().getElementError(`Cannot select multiple options on a non-multiple select`, select);
    }
  } else if (select.getAttribute("role") === "listbox") {
    for (const option of selectedOptions) {
      await this.click(option);
      await this.unhover(option);
    }
  } else {
    throw getConfig2().getElementError(`Cannot select options on elements that are neither select nor listbox elements`, select);
  }
}
__name(selectOptionsBase, "selectOptionsBase");

// ../node_modules/@testing-library/user-event/dist/esm/utility/type.js
async function type3(element, text, { skipClick = this.config.skipClick, skipAutoClose = this.config.skipAutoClose, initialSelectionStart, initialSelectionEnd } = {}) {
  if (element.disabled) return;
  if (!skipClick) {
    await this.click(element);
  }
  if (initialSelectionStart !== void 0) {
    setSelectionRange(element, initialSelectionStart, initialSelectionEnd !== null && initialSelectionEnd !== void 0 ? initialSelectionEnd : initialSelectionStart);
  }
  await this.keyboard(text);
  if (!skipAutoClose) {
    await releaseAllKeys(this);
  }
}
__name(type3, "type");

// ../node_modules/@testing-library/user-event/dist/esm/utils/edit/setFiles.js
var fakeFiles = Symbol("files and value properties are mocked");
function restoreProperty(obj, prop, descriptor) {
  if (descriptor) {
    Object.defineProperty(obj, prop, descriptor);
  } else {
    delete obj[prop];
  }
}
__name(restoreProperty, "restoreProperty");
function setFiles(el, files) {
  var _el_fakeFiles;
  (_el_fakeFiles = el[fakeFiles]) === null || _el_fakeFiles === void 0 ? void 0 : _el_fakeFiles.restore();
  const typeDescr = Object.getOwnPropertyDescriptor(el, "type");
  const valueDescr = Object.getOwnPropertyDescriptor(el, "value");
  const filesDescr = Object.getOwnPropertyDescriptor(el, "files");
  function restore() {
    restoreProperty(el, "type", typeDescr);
    restoreProperty(el, "value", valueDescr);
    restoreProperty(el, "files", filesDescr);
  }
  __name(restore, "restore");
  el[fakeFiles] = {
    restore
  };
  Object.defineProperties(el, {
    files: {
      configurable: true,
      get: /* @__PURE__ */ __name(() => files, "get")
    },
    value: {
      configurable: true,
      get: /* @__PURE__ */ __name(() => files.length ? `C:\\fakepath\\${files[0].name}` : "", "get"),
      set(v2) {
        if (v2 === "") {
          restore();
        } else {
          var _valueDescr_set;
          valueDescr === null || valueDescr === void 0 ? void 0 : (_valueDescr_set = valueDescr.set) === null || _valueDescr_set === void 0 ? void 0 : _valueDescr_set.call(el, v2);
        }
      }
    },
    type: {
      configurable: true,
      get: /* @__PURE__ */ __name(() => "file", "get"),
      set(v2) {
        if (v2 !== "file") {
          restore();
          el.type = v2;
        }
      }
    }
  });
}
__name(setFiles, "setFiles");

// ../node_modules/@testing-library/user-event/dist/esm/utility/upload.js
async function upload(element, fileOrFiles) {
  const input2 = isElementType(element, "label") ? element.control : element;
  if (!input2 || !isElementType(input2, "input", {
    type: "file"
  })) {
    throw new TypeError(`The ${input2 === element ? "given" : "associated"} ${input2 === null || input2 === void 0 ? void 0 : input2.tagName} element does not accept file uploads`);
  }
  if (isDisabled2(element)) return;
  const files = (Array.isArray(fileOrFiles) ? fileOrFiles : [
    fileOrFiles
  ]).filter((file) => !this.config.applyAccept || isAcceptableFile(file, input2.accept)).slice(0, input2.multiple ? void 0 : 1);
  const fileDialog = /* @__PURE__ */ __name(() => {
    var _input_files;
    if (files.length === ((_input_files = input2.files) === null || _input_files === void 0 ? void 0 : _input_files.length) && files.every((f4, i2) => {
      var _input_files2;
      return f4 === ((_input_files2 = input2.files) === null || _input_files2 === void 0 ? void 0 : _input_files2.item(i2));
    })) {
      return;
    }
    setFiles(input2, createFileList(getWindow(element), files));
    this.dispatchUIEvent(input2, "input");
    this.dispatchUIEvent(input2, "change");
  }, "fileDialog");
  input2.addEventListener("fileDialog", fileDialog);
  await this.click(element);
  input2.removeEventListener("fileDialog", fileDialog);
}
__name(upload, "upload");
function normalize3(nameOrType) {
  return nameOrType.toLowerCase().replace(/(\.|\/)jpg\b/g, "$1jpeg");
}
__name(normalize3, "normalize");
function isAcceptableFile(file, accept) {
  if (!accept) {
    return true;
  }
  const wildcards = [
    "audio/*",
    "image/*",
    "video/*"
  ];
  return normalize3(accept).trim().split(/\s*,\s*/).some((acceptToken) => {
    if (acceptToken.startsWith(".")) {
      return normalize3(file.name).endsWith(acceptToken);
    } else if (wildcards.includes(acceptToken)) {
      return normalize3(file.type).startsWith(acceptToken.replace("*", ""));
    }
    return normalize3(file.type) === acceptToken;
  });
}
__name(isAcceptableFile, "isAcceptableFile");

// ../node_modules/@testing-library/user-event/dist/esm/setup/api.js
var userEventApi = {
  click,
  dblClick,
  tripleClick,
  hover,
  unhover,
  tab,
  keyboard,
  copy,
  cut,
  paste,
  pointer,
  clear,
  deselectOptions,
  selectOptions,
  type: type3,
  upload
};

// ../node_modules/@testing-library/user-event/dist/esm/setup/wrapAsync.js
function wrapAsync(implementation) {
  return getConfig2().asyncWrapper(implementation);
}
__name(wrapAsync, "wrapAsync");

// ../node_modules/@testing-library/user-event/dist/esm/setup/setup.js
var defaultOptionsDirect = {
  applyAccept: true,
  autoModify: true,
  delay: 0,
  document: globalThis.document,
  keyboardMap: defaultKeyMap,
  pointerMap: defaultKeyMap2,
  pointerEventsCheck: PointerEventsCheckLevel.EachApiCall,
  skipAutoClose: false,
  skipClick: false,
  skipHover: false,
  writeToClipboard: false,
  advanceTimers: /* @__PURE__ */ __name(() => Promise.resolve(), "advanceTimers")
};
var defaultOptionsSetup = {
  ...defaultOptionsDirect,
  writeToClipboard: true
};
function createConfig(options = {}, defaults = defaultOptionsSetup, node) {
  const document7 = getDocument2(options, node, defaults);
  return {
    ...defaults,
    ...options,
    document: document7
  };
}
__name(createConfig, "createConfig");
function setupMain(options = {}) {
  const config4 = createConfig(options);
  prepareDocument(config4.document);
  patchFocus(getWindow(config4.document).HTMLElement);
  var _config_document_defaultView;
  const view = (_config_document_defaultView = config4.document.defaultView) !== null && _config_document_defaultView !== void 0 ? _config_document_defaultView : (
    /* istanbul ignore next */
    globalThis.window
  );
  attachClipboardStubToView(view);
  return createInstance(config4).api;
}
__name(setupMain, "setupMain");
function setupDirect({ keyboardState, pointerState, ...options } = {}, node) {
  const config4 = createConfig(options, defaultOptionsDirect, node);
  prepareDocument(config4.document);
  patchFocus(getWindow(config4.document).HTMLElement);
  var _ref;
  const system = (_ref = pointerState !== null && pointerState !== void 0 ? pointerState : keyboardState) !== null && _ref !== void 0 ? _ref : new System();
  return {
    api: createInstance(config4, system).api,
    system
  };
}
__name(setupDirect, "setupDirect");
function setupSub(options) {
  return createInstance({
    ...this.config,
    ...options
  }, this.system).api;
}
__name(setupSub, "setupSub");
function wrapAndBindImpl(instance, impl) {
  function method(...args) {
    setLevelRef(instance, ApiLevel.Call);
    return wrapAsync(() => impl.apply(instance, args).then(async (ret) => {
      await wait(instance.config);
      return ret;
    }));
  }
  __name(method, "method");
  Object.defineProperty(method, "name", {
    get: /* @__PURE__ */ __name(() => impl.name, "get")
  });
  return method;
}
__name(wrapAndBindImpl, "wrapAndBindImpl");
function createInstance(config4, system = new System()) {
  const instance = {};
  Object.assign(instance, {
    config: config4,
    dispatchEvent: dispatchEvent.bind(instance),
    dispatchUIEvent: dispatchUIEvent.bind(instance),
    system,
    levelRefs: {},
    ...userEventApi
  });
  return {
    instance,
    api: {
      ...Object.fromEntries(Object.entries(userEventApi).map(([name, api]) => [
        name,
        wrapAndBindImpl(instance, api)
      ])),
      setup: setupSub.bind(instance)
    }
  };
}
__name(createInstance, "createInstance");
function getDocument2(options, node, defaults) {
  var _options_document, _ref;
  return (_ref = (_options_document = options.document) !== null && _options_document !== void 0 ? _options_document : node && getDocumentFromNode(node)) !== null && _ref !== void 0 ? _ref : defaults.document;
}
__name(getDocument2, "getDocument");

// ../node_modules/@testing-library/user-event/dist/esm/setup/directApi.js
var directApi_exports = {};
__export(directApi_exports, {
  clear: () => clear2,
  click: () => click2,
  copy: () => copy2,
  cut: () => cut2,
  dblClick: () => dblClick2,
  deselectOptions: () => deselectOptions2,
  hover: () => hover2,
  keyboard: () => keyboard2,
  paste: () => paste2,
  pointer: () => pointer2,
  selectOptions: () => selectOptions2,
  tab: () => tab2,
  tripleClick: () => tripleClick2,
  type: () => type4,
  unhover: () => unhover2,
  upload: () => upload2
});
function clear2(element) {
  return setupDirect().api.clear(element);
}
__name(clear2, "clear");
function click2(element, options = {}) {
  return setupDirect(options, element).api.click(element);
}
__name(click2, "click");
function copy2(options = {}) {
  return setupDirect(options).api.copy();
}
__name(copy2, "copy");
function cut2(options = {}) {
  return setupDirect(options).api.cut();
}
__name(cut2, "cut");
function dblClick2(element, options = {}) {
  return setupDirect(options).api.dblClick(element);
}
__name(dblClick2, "dblClick");
function deselectOptions2(select, values, options = {}) {
  return setupDirect(options).api.deselectOptions(select, values);
}
__name(deselectOptions2, "deselectOptions");
function hover2(element, options = {}) {
  return setupDirect(options).api.hover(element);
}
__name(hover2, "hover");
async function keyboard2(text, options = {}) {
  const { api, system } = setupDirect(options);
  return api.keyboard(text).then(() => system);
}
__name(keyboard2, "keyboard");
async function pointer2(input2, options = {}) {
  const { api, system } = setupDirect(options);
  return api.pointer(input2).then(() => system);
}
__name(pointer2, "pointer");
function paste2(clipboardData, options) {
  return setupDirect(options).api.paste(clipboardData);
}
__name(paste2, "paste");
function selectOptions2(select, values, options = {}) {
  return setupDirect(options).api.selectOptions(select, values);
}
__name(selectOptions2, "selectOptions");
function tripleClick2(element, options = {}) {
  return setupDirect(options).api.tripleClick(element);
}
__name(tripleClick2, "tripleClick");
function type4(element, text, options = {}) {
  return setupDirect(options, element).api.type(element, text, options);
}
__name(type4, "type");
function unhover2(element, options = {}) {
  const { api, system } = setupDirect(options);
  system.pointer.setMousePosition({
    target: element
  });
  return api.unhover(element);
}
__name(unhover2, "unhover");
function upload2(element, fileOrFiles, options = {}) {
  return setupDirect(options).api.upload(element, fileOrFiles);
}
__name(upload2, "upload");
function tab2(options = {}) {
  return setupDirect().api.tab(options);
}
__name(tab2, "tab");

// ../node_modules/@testing-library/user-event/dist/esm/setup/index.js
var userEvent = {
  ...directApi_exports,
  setup: setupMain
};

// src/test/testing-library.ts
var testingLibrary = instrument(
  { ...dom_esm_exports },
  {
    getKeys: /* @__PURE__ */ __name((obj) => Object.keys(obj).filter((key) => key !== "eventWrapper"), "getKeys"),
    intercept: /* @__PURE__ */ __name((method, path) => path[0] === "fireEvent" || method.startsWith("find") || method.startsWith("waitFor"), "intercept")
  }
);
testingLibrary.screen = new Proxy(testingLibrary.screen, {
  get(target, prop, receiver) {
    if (typeof window !== "undefined" && globalThis.location?.href?.includes("viewMode=docs")) {
      once.warn(dedent`
        You are using Testing Library's \`screen\` object while the story is rendered in docs mode. This will likely lead to issues, as multiple stories are rendered in the same page and therefore screen will potentially find multiple elements. Use the \`canvas\` utility from the story context instead, which will scope the queries to each story's canvas.

        More info: https://storybook.js.org/docs/writing-tests/interaction-testing?ref=error#querying-the-canvas
      `);
    }
    return Reflect.get(target, prop, receiver);
  }
});
var {
  buildQueries: buildQueries2,
  configure: configure2,
  createEvent: createEvent3,
  fireEvent: fireEvent2,
  findAllByAltText: findAllByAltText2,
  findAllByDisplayValue: findAllByDisplayValue2,
  findAllByLabelText: findAllByLabelText2,
  findAllByPlaceholderText: findAllByPlaceholderText2,
  findAllByRole: findAllByRole2,
  findAllByTestId: findAllByTestId2,
  findAllByText: findAllByText2,
  findAllByTitle: findAllByTitle2,
  findByAltText: findByAltText2,
  findByDisplayValue: findByDisplayValue2,
  findByLabelText: findByLabelText2,
  findByPlaceholderText: findByPlaceholderText2,
  findByRole: findByRole2,
  findByTestId: findByTestId2,
  findByText: findByText2,
  findByTitle: findByTitle2,
  getAllByAltText: getAllByAltText2,
  getAllByDisplayValue: getAllByDisplayValue2,
  getAllByLabelText: getAllByLabelText2,
  getAllByPlaceholderText: getAllByPlaceholderText2,
  getAllByRole: getAllByRole2,
  getAllByTestId: getAllByTestId2,
  getAllByText: getAllByText2,
  getAllByTitle: getAllByTitle2,
  getByAltText: getByAltText2,
  getByDisplayValue: getByDisplayValue2,
  getByLabelText: getByLabelText2,
  getByPlaceholderText: getByPlaceholderText2,
  getByRole: getByRole2,
  getByTestId: getByTestId2,
  getByText: getByText2,
  getByTitle: getByTitle2,
  getConfig: getConfig3,
  getDefaultNormalizer: getDefaultNormalizer2,
  getElementError: getElementError2,
  getNodeText: getNodeText2,
  getQueriesForElement: getQueriesForElement2,
  getRoles: getRoles2,
  getSuggestedQuery: getSuggestedQuery2,
  isInaccessible: isInaccessible2,
  logDOM: logDOM2,
  logRoles: logRoles2,
  prettyDOM: prettyDOM2,
  queries: queries2,
  queryAllByAltText: queryAllByAltText2,
  queryAllByAttribute: queryAllByAttribute2,
  queryAllByDisplayValue: queryAllByDisplayValue2,
  queryAllByLabelText: queryAllByLabelText2,
  queryAllByPlaceholderText: queryAllByPlaceholderText2,
  queryAllByRole: queryAllByRole2,
  queryAllByTestId: queryAllByTestId2,
  queryAllByText: queryAllByText2,
  queryAllByTitle: queryAllByTitle2,
  queryByAltText: queryByAltText2,
  queryByAttribute: queryByAttribute2,
  queryByDisplayValue: queryByDisplayValue2,
  queryByLabelText: queryByLabelText2,
  queryByPlaceholderText: queryByPlaceholderText2,
  queryByRole: queryByRole2,
  queryByTestId: queryByTestId2,
  queryByText: queryByText2,
  queryByTitle: queryByTitle2,
  queryHelpers: queryHelpers2,
  screen: screen2,
  waitFor: waitFor2,
  waitForElementToBeRemoved: waitForElementToBeRemoved2,
  within,
  prettyFormat: prettyFormat2
} = testingLibrary;
var uninstrumentedUserEvent = userEvent;
var { userEvent: userEvent2 } = instrument(
  { userEvent },
  { intercept: true, getKeys: /* @__PURE__ */ __name((obj) => Object.keys(obj).filter((key) => key !== "eventWrapper"), "getKeys") }
);

// src/test/index.ts
var { expect: expect3 } = instrument(
  { expect: expect2 },
  {
    getKeys: /* @__PURE__ */ __name((obj, depth) => {
      if ("constructor" in obj && obj.constructor === Assertion) {
        const privateApi = ["assert", "__methods", "__flags", "_obj"];
        const keys2 = Object.keys(Object.getPrototypeOf(obj)).filter(
          (it) => !privateApi.includes(it)
        );
        return depth > 2 ? keys2 : [...keys2, "not"];
      }
      if ("any" in obj) {
        return Object.keys(obj).filter((it) => it !== "any");
      }
      return Object.keys(obj);
    }, "getKeys"),
    mutate: true,
    intercept: /* @__PURE__ */ __name((method) => method !== "expect", "intercept")
  }
);
var sb = {
  mock: /* @__PURE__ */ __name(() => {
  }, "mock")
};

// src/actions/loaders.ts
var subscribed = false;
var logActionsWhenMockCalled = /* @__PURE__ */ __name((context) => {
  const { parameters: parameters2 } = context;
  if (parameters2?.actions?.disable) {
    return;
  }
  if (!subscribed) {
    onMockCall((mock, args) => {
      const name = mock.getMockName();
      if (name === "spy") {
        return;
      }
      if (name === "vi.fn()") {
        return;
      }
      if (!/^next\/.*::/.test(name) || [
        "next/router::useRouter()",
        "next/navigation::useRouter()",
        "next/navigation::redirect",
        "next/cache::",
        "next/headers::cookies().set",
        "next/headers::cookies().delete",
        "next/headers::headers().set",
        "next/headers::headers().delete"
      ].some((prefix2) => name.startsWith(prefix2))) {
        action(name)(args);
      }
    });
    subscribed = true;
  }
}, "logActionsWhenMockCalled");
var loaders = [logActionsWhenMockCalled];

// src/actions/preview.ts
var preview_default = /* @__PURE__ */ __name(() => definePreviewAddon({
  ...addArgs_exports,
  ...loaders_exports
}), "default");

// src/backgrounds/constants.ts
var ADDON_ID2 = "storybook/background";
var PARAM_KEY2 = "backgrounds";
var EVENTS2 = {
  UPDATE: `${ADDON_ID2}/update`
};

// src/backgrounds/defaults.ts
var DEFAULT_BACKGROUNDS = {
  light: { name: "light", value: "#F8F8F8" },
  dark: { name: "dark", value: "#333" }
};

// src/backgrounds/utils.ts
var { document: document3 } = globalThis;
var isReduceMotionEnabled = /* @__PURE__ */ __name(() => {
  if (!globalThis?.matchMedia) {
    return false;
  }
  const prefersReduceMotion = globalThis.matchMedia("(prefers-reduced-motion: reduce)");
  return !!prefersReduceMotion?.matches;
}, "isReduceMotionEnabled");
var clearStyles = /* @__PURE__ */ __name((selector) => {
  const selectors = Array.isArray(selector) ? selector : [selector];
  selectors.forEach(clearStyle);
}, "clearStyles");
var clearStyle = /* @__PURE__ */ __name((selector) => {
  if (!document3) {
    return;
  }
  const element = document3.getElementById(selector);
  if (element && element.parentElement) {
    element.parentElement.removeChild(element);
  }
}, "clearStyle");
var addGridStyle = /* @__PURE__ */ __name((selector, css) => {
  if (!document3) {
    return;
  }
  const existingStyle = document3.getElementById(selector);
  if (existingStyle) {
    if (existingStyle.innerHTML !== css) {
      existingStyle.innerHTML = css;
    }
  } else {
    const style = document3.createElement("style");
    style.setAttribute("id", selector);
    style.innerHTML = css;
    document3.head.appendChild(style);
  }
}, "addGridStyle");
var addBackgroundStyle = /* @__PURE__ */ __name((selector, css, storyId) => {
  if (!document3) {
    return;
  }
  const existingStyle = document3.getElementById(selector);
  if (existingStyle) {
    if (existingStyle.innerHTML !== css) {
      existingStyle.innerHTML = css;
    }
  } else {
    const style = document3.createElement("style");
    style.setAttribute("id", selector);
    style.innerHTML = css;
    const gridStyleSelector = `addon-backgrounds-grid${storyId ? `-docs-${storyId}` : ""}`;
    const existingGridStyle = document3.getElementById(gridStyleSelector);
    if (existingGridStyle) {
      existingGridStyle.parentElement?.insertBefore(style, existingGridStyle);
    } else {
      document3.head.appendChild(style);
    }
  }
}, "addBackgroundStyle");

// src/backgrounds/decorator.ts
var defaultGrid = {
  cellSize: 100,
  cellAmount: 10,
  opacity: 0.8
};
var BG_SELECTOR_BASE = `addon-backgrounds`;
var GRID_SELECTOR_BASE = "addon-backgrounds-grid";
var transitionStyle = isReduceMotionEnabled() ? "" : "transition: background-color 0.3s;";
var withBackgroundAndGrid = /* @__PURE__ */ __name((StoryFn, context) => {
  const { globals = {}, parameters: parameters2 = {}, viewMode, id } = context;
  const {
    options = DEFAULT_BACKGROUNDS,
    disable,
    grid = defaultGrid
  } = parameters2[PARAM_KEY2] || {};
  const data = globals[PARAM_KEY2] || {};
  const backgroundName = typeof data === "string" ? data : data?.value;
  const item = backgroundName ? options[backgroundName] : void 0;
  const value = typeof item === "string" ? item : item?.value || "transparent";
  const showGrid = typeof data === "string" ? false : data.grid || false;
  const shownBackground = !!item && !disable;
  const backgroundSelector = viewMode === "docs" ? `#anchor--${id} .docs-story` : ".sb-show-main";
  const gridSelector = viewMode === "docs" ? `#anchor--${id} .docs-story` : ".sb-show-main";
  const isLayoutPadded = parameters2.layout === void 0 || parameters2.layout === "padded";
  const defaultOffset = viewMode === "docs" ? 20 : isLayoutPadded ? 16 : 0;
  const { cellAmount, cellSize, opacity, offsetX = defaultOffset, offsetY = defaultOffset } = grid;
  const backgroundSelectorId = viewMode === "docs" ? `${BG_SELECTOR_BASE}-docs-${id}` : `${BG_SELECTOR_BASE}-color`;
  const backgroundTarget = viewMode === "docs" ? id : null;
  useEffect(() => {
    const backgroundStyles = `
    ${backgroundSelector} {
      background: ${value} !important;
      ${transitionStyle}
      }`;
    if (!shownBackground) {
      clearStyles(backgroundSelectorId);
      return;
    }
    addBackgroundStyle(backgroundSelectorId, backgroundStyles, backgroundTarget);
  }, [backgroundSelector, backgroundSelectorId, backgroundTarget, shownBackground, value]);
  const gridSelectorId = viewMode === "docs" ? `${GRID_SELECTOR_BASE}-docs-${id}` : `${GRID_SELECTOR_BASE}`;
  useEffect(() => {
    if (!showGrid) {
      clearStyles(gridSelectorId);
      return;
    }
    const gridSize = [
      `${cellSize * cellAmount}px ${cellSize * cellAmount}px`,
      `${cellSize * cellAmount}px ${cellSize * cellAmount}px`,
      `${cellSize}px ${cellSize}px`,
      `${cellSize}px ${cellSize}px`
    ].join(", ");
    const gridStyles = `
        ${gridSelector} {
          background-size: ${gridSize} !important;
          background-position: ${offsetX}px ${offsetY}px, ${offsetX}px ${offsetY}px, ${offsetX}px ${offsetY}px, ${offsetX}px ${offsetY}px !important;
          background-blend-mode: difference !important;
          background-image: linear-gradient(rgba(130, 130, 130, ${opacity}) 1px, transparent 1px),
           linear-gradient(90deg, rgba(130, 130, 130, ${opacity}) 1px, transparent 1px),
           linear-gradient(rgba(130, 130, 130, ${opacity / 2}) 1px, transparent 1px),
           linear-gradient(90deg, rgba(130, 130, 130, ${opacity / 2}) 1px, transparent 1px) !important;
        }
      `;
    addGridStyle(gridSelectorId, gridStyles);
  }, [cellAmount, cellSize, gridSelector, gridSelectorId, showGrid, offsetX, offsetY, opacity]);
  return StoryFn();
}, "withBackgroundAndGrid");

// src/backgrounds/preview.ts
var decorators = globalThis.FEATURES?.backgrounds ? [withBackgroundAndGrid] : [];
var parameters = {
  [PARAM_KEY2]: {
    grid: {
      cellSize: 20,
      opacity: 0.5,
      cellAmount: 5
    },
    disable: false
  }
};
var initialGlobals = {
  [PARAM_KEY2]: { value: void 0, grid: false }
};
var preview_default2 = /* @__PURE__ */ __name(() => definePreviewAddon({
  decorators,
  parameters,
  initialGlobals
}), "default");

// src/component-testing/preview.ts
var { step } = instrument(
  {
    // It seems like the label is unused, but the instrumenter has access to it
    // The context will be bounded later in StoryRender, so that the user can write just:
    // await step("label", (context) => {
    //   // labeled step
    // });
    step: /* @__PURE__ */ __name(async (label, play, context) => play(context), "step")
  },
  { intercept: true }
);
var preview_default3 = /* @__PURE__ */ __name(() => definePreviewAddon({
  parameters: {
    throwPlayFunctionExceptions: false
  },
  runStep: step
}), "default");

// src/highlight/constants.ts
var ADDON_ID3 = "storybook/highlight";
var HIGHLIGHT = `${ADDON_ID3}/add`;
var REMOVE_HIGHLIGHT = `${ADDON_ID3}/remove`;
var RESET_HIGHLIGHT = `${ADDON_ID3}/reset`;
var SCROLL_INTO_VIEW = `${ADDON_ID3}/scroll-into-view`;
var MAX_Z_INDEX = 2147483647;
var MIN_TOUCH_AREA_SIZE = 28;

// src/highlight/icons.ts
var iconPaths = {
  chevronLeft: [
    "M9.10355 10.1464C9.29882 10.3417 9.29882 10.6583 9.10355 10.8536C8.90829 11.0488 8.59171 11.0488 8.39645 10.8536L4.89645 7.35355C4.70118 7.15829 4.70118 6.84171 4.89645 6.64645L8.39645 3.14645C8.59171 2.95118 8.90829 2.95118 9.10355 3.14645C9.29882 3.34171 9.29882 3.65829 9.10355 3.85355L5.95711 7L9.10355 10.1464Z"
  ],
  chevronRight: [
    "M4.89645 10.1464C4.70118 10.3417 4.70118 10.6583 4.89645 10.8536C5.09171 11.0488 5.40829 11.0488 5.60355 10.8536L9.10355 7.35355C9.29882 7.15829 9.29882 6.84171 9.10355 6.64645L5.60355 3.14645C5.40829 2.95118 5.09171 2.95118 4.89645 3.14645C4.70118 3.34171 4.70118 3.65829 4.89645 3.85355L8.04289 7L4.89645 10.1464Z"
  ],
  info: [
    "M7 5.5a.5.5 0 01.5.5v4a.5.5 0 01-1 0V6a.5.5 0 01.5-.5zM7 4.5A.75.75 0 107 3a.75.75 0 000 1.5z",
    "M7 14A7 7 0 107 0a7 7 0 000 14zm0-1A6 6 0 107 1a6 6 0 000 12z"
  ],
  shareAlt: [
    "M2 1.004a1 1 0 00-1 1v10a1 1 0 001 1h10a1 1 0 001-1v-4.5a.5.5 0 00-1 0v4.5H2v-10h4.5a.5.5 0 000-1H2z",
    "M7.354 7.357L12 2.711v1.793a.5.5 0 001 0v-3a.5.5 0 00-.5-.5h-3a.5.5 0 100 1h1.793L6.646 6.65a.5.5 0 10.708.707z"
  ]
};

// src/highlight/utils.ts
var svgElements = "svg,path,rect,circle,line,polyline,polygon,ellipse,text".split(",");
var createElement = /* @__PURE__ */ __name((type5, props = {}, children) => {
  const element = svgElements.includes(type5) ? document.createElementNS("http://www.w3.org/2000/svg", type5) : document.createElement(type5);
  Object.entries(props).forEach(([key, val]) => {
    if (/[A-Z]/.test(key)) {
      if (key === "onClick") {
        element.addEventListener("click", val);
        element.addEventListener("keydown", (e2) => {
          if (e2.key === "Enter" || e2.key === " ") {
            e2.preventDefault();
            val();
          }
        });
      }
      if (key === "onMouseEnter") {
        element.addEventListener("mouseenter", val);
      }
      if (key === "onMouseLeave") {
        element.addEventListener("mouseleave", val);
      }
    } else {
      element.setAttribute(key, val);
    }
  });
  children?.forEach((child) => {
    if (child === null || child === void 0 || child === false) {
      return;
    }
    try {
      element.appendChild(child);
    } catch (e2) {
      element.appendChild(document.createTextNode(String(child)));
    }
  });
  return element;
}, "createElement");
var createIcon = /* @__PURE__ */ __name((name) => iconPaths[name] && createElement(
  "svg",
  { width: "14", height: "14", viewBox: "0 0 14 14", xmlns: "http://www.w3.org/2000/svg" },
  iconPaths[name].map(
    (d) => createElement("path", {
      fill: "currentColor",
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d
    })
  )
), "createIcon");
var normalizeOptions = /* @__PURE__ */ __name((options) => {
  if ("elements" in options) {
    const { elements, color, style } = options;
    return {
      id: void 0,
      priority: 0,
      selectors: elements,
      styles: {
        outline: `2px ${style} ${color}`,
        outlineOffset: "2px",
        boxShadow: "0 0 0 6px rgba(255,255,255,0.6)"
      },
      menu: void 0
    };
  }
  const { menu, ...rest } = options;
  return {
    id: void 0,
    priority: 0,
    styles: {
      outline: "2px dashed #029cfd"
    },
    ...rest,
    menu: Array.isArray(menu) ? menu.every(Array.isArray) ? menu : [menu] : void 0
  };
}, "normalizeOptions");
var isFunction2 = /* @__PURE__ */ __name((obj) => obj instanceof Function, "isFunction");
var state = /* @__PURE__ */ new Map();
var listeners2 = /* @__PURE__ */ new Map();
var teardowns = /* @__PURE__ */ new Map();
var useStore = /* @__PURE__ */ __name((initialValue2) => {
  const key = Symbol();
  listeners2.set(key, []);
  state.set(key, initialValue2);
  const get3 = /* @__PURE__ */ __name(() => state.get(key), "get");
  const set2 = /* @__PURE__ */ __name((update) => {
    const current = state.get(key);
    const next = isFunction2(update) ? update(current) : update;
    if (next !== current) {
      state.set(key, next);
      listeners2.get(key)?.forEach((listener) => {
        teardowns.get(listener)?.();
        teardowns.set(listener, listener(next));
      });
    }
  }, "set");
  const subscribe = /* @__PURE__ */ __name((listener) => {
    listeners2.get(key)?.push(listener);
    return () => {
      const list = listeners2.get(key);
      if (list) {
        listeners2.set(
          key,
          list.filter((l2) => l2 !== listener)
        );
      }
    };
  }, "subscribe");
  const teardown = /* @__PURE__ */ __name(() => {
    listeners2.get(key)?.forEach((listener) => {
      teardowns.get(listener)?.();
      teardowns.delete(listener);
    });
    listeners2.delete(key);
    state.delete(key);
  }, "teardown");
  return { get: get3, set: set2, subscribe, teardown };
}, "useStore");
var mapElements = /* @__PURE__ */ __name((highlights) => {
  const root2 = document.getElementById("storybook-root");
  const map2 = /* @__PURE__ */ new Map();
  for (const highlight of highlights) {
    const { priority = 0 } = highlight;
    for (const selector of highlight.selectors) {
      const elements = [
        ...document.querySelectorAll(
          // Elements matching the selector, excluding storybook elements and their descendants.
          // Necessary to find portaled elements (e.g. children of `body`).
          `:is(${selector}):not([id^="storybook-"], [id^="storybook-"] *, [class^="sb-"], [class^="sb-"] *)`
        ),
        // Elements matching the selector inside the storybook root, as these were excluded above.
        ...root2?.querySelectorAll(selector) || []
      ];
      for (const element of elements) {
        const existing = map2.get(element);
        if (!existing || existing.priority <= priority) {
          map2.set(element, {
            ...highlight,
            priority,
            selectors: Array.from(new Set((existing?.selectors || []).concat(selector)))
          });
        }
      }
    }
  }
  return map2;
}, "mapElements");
var mapBoxes = /* @__PURE__ */ __name((elements) => Array.from(elements.entries()).map(([element, { selectors, styles: styles3, hoverStyles, focusStyles, menu }]) => {
  const { top, left, width, height } = element.getBoundingClientRect();
  const { position } = getComputedStyle(element);
  return {
    element,
    selectors,
    styles: styles3,
    hoverStyles,
    focusStyles,
    menu,
    top: position === "fixed" ? top : top + window.scrollY,
    left: position === "fixed" ? left : left + window.scrollX,
    width,
    height
  };
}).sort((a2, b2) => b2.width * b2.height - a2.width * a2.height), "mapBoxes");
var isOverMenu = /* @__PURE__ */ __name((menuElement, coordinates) => {
  const menu = menuElement.getBoundingClientRect();
  const { x: x2, y: y2 } = coordinates;
  return menu?.top && menu?.left && x2 >= menu.left && x2 <= menu.left + menu.width && y2 >= menu.top && y2 <= menu.top + menu.height;
}, "isOverMenu");
var isTargeted = /* @__PURE__ */ __name((box, boxElement, coordinates) => {
  if (!boxElement || !coordinates) {
    return false;
  }
  let { left, top, width, height } = box;
  if (height < MIN_TOUCH_AREA_SIZE) {
    top = top - Math.round((MIN_TOUCH_AREA_SIZE - height) / 2);
    height = MIN_TOUCH_AREA_SIZE;
  }
  if (width < MIN_TOUCH_AREA_SIZE) {
    left = left - Math.round((MIN_TOUCH_AREA_SIZE - width) / 2);
    width = MIN_TOUCH_AREA_SIZE;
  }
  if (boxElement.style.position === "fixed") {
    left += window.scrollX;
    top += window.scrollY;
  }
  const { x: x2, y: y2 } = coordinates;
  return x2 >= left && x2 <= left + width && y2 >= top && y2 <= top + height;
}, "isTargeted");
var keepInViewport = /* @__PURE__ */ __name((element, targetCoordinates, options = {}) => {
  const { x: x2, y: y2 } = targetCoordinates;
  const { margin = 5, topOffset = 0, centered = false } = options;
  const { scrollX, scrollY, innerHeight: windowHeight, innerWidth: windowWidth } = window;
  const top = Math.min(
    element.style.position === "fixed" ? y2 - scrollY : y2,
    windowHeight - element.clientHeight - margin - topOffset + scrollY
  );
  const leftOffset = centered ? element.clientWidth / 2 : 0;
  const left = element.style.position === "fixed" ? Math.max(Math.min(x2 - scrollX, windowWidth - leftOffset - margin), leftOffset + margin) : Math.max(
    Math.min(x2, windowWidth - leftOffset - margin + scrollX),
    leftOffset + margin + scrollX
  );
  Object.assign(element.style, {
    ...left !== x2 && { left: `${left}px` },
    ...top !== y2 && { top: `${top}px` }
  });
}, "keepInViewport");
var showPopover = /* @__PURE__ */ __name((element) => {
  if (window.HTMLElement.prototype.hasOwnProperty("showPopover")) {
    element.showPopover();
  }
}, "showPopover");
var hidePopover = /* @__PURE__ */ __name((element) => {
  if (window.HTMLElement.prototype.hasOwnProperty("showPopover")) {
    element.hidePopover();
  }
}, "hidePopover");
var getEventDetails = /* @__PURE__ */ __name((target) => ({
  top: target.top,
  left: target.left,
  width: target.width,
  height: target.height,
  selectors: target.selectors,
  element: {
    attributes: Object.fromEntries(
      Array.from(target.element.attributes).map((attr) => [attr.name, attr.value])
    ),
    localName: target.element.localName,
    tagName: target.element.tagName,
    outerHTML: target.element.outerHTML
  }
}), "getEventDetails");

// src/highlight/useHighlights.ts
var menuId = "storybook-highlights-menu";
var rootId = "storybook-highlights-root";
var storybookRootId = "storybook-root";
var useHighlights = /* @__PURE__ */ __name((channel) => {
  if (globalThis.__STORYBOOK_HIGHLIGHT_INITIALIZED) {
    return;
  }
  globalThis.__STORYBOOK_HIGHLIGHT_INITIALIZED = true;
  const { document: document7 } = globalThis;
  const highlights = useStore([]);
  const elements = useStore(/* @__PURE__ */ new Map());
  const boxes = useStore([]);
  const clickCoords = useStore();
  const hoverCoords = useStore();
  const targets = useStore([]);
  const hovered = useStore([]);
  const focused = useStore();
  const selected = useStore();
  let root2 = document7.getElementById(rootId);
  highlights.subscribe(() => {
    if (!root2) {
      root2 = createElement("div", { id: rootId });
      document7.body.appendChild(root2);
    }
  });
  highlights.subscribe((value) => {
    const storybookRoot = document7.getElementById(storybookRootId);
    if (!storybookRoot) {
      return;
    }
    elements.set(mapElements(value));
    const observer = new MutationObserver(() => elements.set(mapElements(value)));
    observer.observe(storybookRoot, { subtree: true, childList: true });
    return () => {
      observer.disconnect();
    };
  });
  elements.subscribe((value) => {
    const updateBoxes = /* @__PURE__ */ __name(() => requestAnimationFrame(() => boxes.set(mapBoxes(value))), "updateBoxes");
    const observer = new ResizeObserver(updateBoxes);
    observer.observe(document7.body);
    Array.from(value.keys()).forEach((element) => observer.observe(element));
    const scrollers = Array.from(document7.body.querySelectorAll("*")).filter((el) => {
      const { overflow, overflowX, overflowY } = window.getComputedStyle(el);
      return ["auto", "scroll"].some((o2) => [overflow, overflowX, overflowY].includes(o2));
    });
    scrollers.forEach((element) => element.addEventListener("scroll", updateBoxes));
    return () => {
      observer.disconnect();
      scrollers.forEach((element) => element.removeEventListener("scroll", updateBoxes));
    };
  });
  elements.subscribe((value) => {
    const sticky = Array.from(value.keys()).filter(({ style }) => style.position === "sticky");
    const updateBoxes = /* @__PURE__ */ __name(() => requestAnimationFrame(() => {
      boxes.set(
        (current) => current.map((box) => {
          if (sticky.includes(box.element)) {
            const { top, left } = box.element.getBoundingClientRect();
            return { ...box, top: top + window.scrollY, left: left + window.scrollX };
          }
          return box;
        })
      );
    }), "updateBoxes");
    document7.addEventListener("scroll", updateBoxes);
    return () => document7.removeEventListener("scroll", updateBoxes);
  });
  elements.subscribe((value) => {
    targets.set((t2) => t2.filter(({ element }) => value.has(element)));
  });
  targets.subscribe((value) => {
    if (value.length) {
      selected.set((s3) => value.some((t2) => t2.element === s3?.element) ? s3 : void 0);
      focused.set((s3) => value.some((t2) => t2.element === s3?.element) ? s3 : void 0);
    } else {
      selected.set(void 0);
      focused.set(void 0);
      clickCoords.set(void 0);
    }
  });
  const styleElementByHighlight = new Map(/* @__PURE__ */ new Map());
  highlights.subscribe((value) => {
    value.forEach(({ keyframes }) => {
      if (keyframes) {
        let style = styleElementByHighlight.get(keyframes);
        if (!style) {
          style = document7.createElement("style");
          style.setAttribute("data-highlight", "keyframes");
          styleElementByHighlight.set(keyframes, style);
          document7.head.appendChild(style);
        }
        style.innerHTML = keyframes;
      }
    });
    styleElementByHighlight.forEach((style, keyframes) => {
      if (!value.some((v2) => v2.keyframes === keyframes)) {
        style.remove();
        styleElementByHighlight.delete(keyframes);
      }
    });
  });
  const boxElementByTargetElement = new Map(/* @__PURE__ */ new Map());
  boxes.subscribe((value) => {
    value.forEach((box) => {
      let boxElement = boxElementByTargetElement.get(box.element);
      if (root2 && !boxElement) {
        const props = {
          popover: "manual",
          "data-highlight-dimensions": `w${box.width.toFixed(0)}h${box.height.toFixed(0)}`,
          "data-highlight-coordinates": `x${box.left.toFixed(0)}y${box.top.toFixed(0)}`
        };
        boxElement = root2.appendChild(
          createElement("div", props, [createElement("div")])
        );
        boxElementByTargetElement.set(box.element, boxElement);
      }
    });
    boxElementByTargetElement.forEach((box, element) => {
      if (!value.some(({ element: e2 }) => e2 === element)) {
        box.remove();
        boxElementByTargetElement.delete(element);
      }
    });
  });
  boxes.subscribe((value) => {
    const targetable = value.filter((box) => box.menu);
    if (!targetable.length) {
      return;
    }
    const onClick = /* @__PURE__ */ __name((event) => {
      requestAnimationFrame(() => {
        const menu = document7.getElementById(menuId);
        const coords = { x: event.pageX, y: event.pageY };
        if (menu && !isOverMenu(menu, coords)) {
          const results = targetable.filter((box) => {
            const boxElement = boxElementByTargetElement.get(box.element);
            return isTargeted(box, boxElement, coords);
          });
          clickCoords.set(results.length ? coords : void 0);
          targets.set(results);
        }
      });
    }, "onClick");
    document7.addEventListener("click", onClick);
    return () => document7.removeEventListener("click", onClick);
  });
  const updateHovered = /* @__PURE__ */ __name(() => {
    const menu = document7.getElementById(menuId);
    const coords = hoverCoords.get();
    if (!coords || menu && isOverMenu(menu, coords)) {
      return;
    }
    hovered.set((current) => {
      const update = boxes.get().filter((box) => {
        const boxElement = boxElementByTargetElement.get(box.element);
        return isTargeted(box, boxElement, coords);
      });
      const existing = current.filter((box) => update.includes(box));
      const additions = update.filter((box) => !current.includes(box));
      const hasRemovals = current.length - existing.length;
      return additions.length || hasRemovals ? [...existing, ...additions] : current;
    });
  }, "updateHovered");
  hoverCoords.subscribe(updateHovered);
  boxes.subscribe(updateHovered);
  const updateBoxStyles = /* @__PURE__ */ __name(() => {
    const selectedElement = selected.get();
    const targetElements = selectedElement ? [selectedElement] : targets.get();
    const focusedElement = targetElements.length === 1 ? targetElements[0] : focused.get();
    const isMenuOpen = clickCoords.get() !== void 0;
    boxes.get().forEach((box) => {
      const boxElement = boxElementByTargetElement.get(box.element);
      if (boxElement) {
        const isFocused = focusedElement === box;
        const isHovered = isMenuOpen ? focusedElement ? isFocused : targetElements.includes(box) : hovered.get()?.includes(box);
        Object.assign(boxElement.style, {
          animation: "none",
          background: "transparent",
          border: "none",
          boxSizing: "border-box",
          outline: "none",
          outlineOffset: "0px",
          ...box.styles,
          ...isHovered ? box.hoverStyles : {},
          ...isFocused ? box.focusStyles : {},
          position: getComputedStyle(box.element).position === "fixed" ? "fixed" : "absolute",
          zIndex: MAX_Z_INDEX - 10,
          top: `${box.top}px`,
          left: `${box.left}px`,
          width: `${box.width}px`,
          height: `${box.height}px`,
          margin: 0,
          padding: 0,
          cursor: box.menu && isHovered ? "pointer" : "default",
          pointerEvents: box.menu ? "auto" : "none",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          overflow: "visible"
        });
        Object.assign(boxElement.children[0].style, {
          width: "100%",
          height: "100%",
          minHeight: `${MIN_TOUCH_AREA_SIZE}px`,
          minWidth: `${MIN_TOUCH_AREA_SIZE}px`,
          boxSizing: "content-box",
          padding: boxElement.style.outlineWidth || "0px"
        });
        showPopover(boxElement);
      }
    });
  }, "updateBoxStyles");
  boxes.subscribe(updateBoxStyles);
  targets.subscribe(updateBoxStyles);
  hovered.subscribe(updateBoxStyles);
  focused.subscribe(updateBoxStyles);
  selected.subscribe(updateBoxStyles);
  const renderMenu = /* @__PURE__ */ __name(() => {
    if (!root2) {
      return;
    }
    let menu = document7.getElementById(menuId);
    if (menu) {
      menu.innerHTML = "";
    } else {
      const props = { id: menuId, popover: "manual" };
      menu = root2.appendChild(createElement("div", props));
      root2.appendChild(
        createElement("style", {}, [
          `
            #${menuId} {
              position: absolute;
              z-index: ${MAX_Z_INDEX};
              width: 300px;
              padding: 0px;
              margin: 15px 0 0 0;
              transform: translateX(-50%);
              font-family: "Nunito Sans", -apple-system, ".SFNSText-Regular", "San Francisco", BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", Helvetica, Arial, sans-serif;
              font-size: 12px;
              background: white;
              border: none;
              border-radius: 6px;
              box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.05), 0 5px 15px 0 rgba(0, 0, 0, 0.1);
              color: #2E3438;
            }
            #${menuId} ul {
              list-style: none;
              margin: 0;
              padding: 0;
            }
            #${menuId} > ul {
              max-height: 300px;
              overflow-y: auto;
              padding: 4px 0;
            }
            #${menuId} li {
              padding: 0 4px;
              margin: 0;
            }
            #${menuId} li > :not(ul) {
              display: flex;
              padding: 8px;
              margin: 0;
              align-items: center;
              gap: 8px;
              border-radius: 4px;
            }
            #${menuId} button {
              width: 100%;
              border: 0;
              background: transparent;
              color: inherit;
              text-align: left;
              font-family: inherit;
              font-size: inherit;
            }
            #${menuId} button:focus-visible {
              outline-color: #029CFD;
            }
            #${menuId} button:hover {
              background: rgba(2, 156, 253, 0.07);
              color: #029CFD;
              cursor: pointer;
            }
            #${menuId} li code {
              white-space: nowrap;
              overflow: hidden;
              text-overflow: ellipsis;
              line-height: 16px;
              font-size: 11px;
            }
            #${menuId} li svg {
              flex-shrink: 0;
              margin: 1px;
              color: #73828C;
            }
            #${menuId} li > button:hover svg, #${menuId} li > button:focus-visible svg {
              color: #029CFD;
            }
            #${menuId} .element-list li svg {
              display: none;
            }
            #${menuId} li.selectable svg, #${menuId} li.selected svg {
              display: block;
            }
            #${menuId} .menu-list {
              border-top: 1px solid rgba(38, 85, 115, 0.15);
            }
            #${menuId} .menu-list > li:not(:last-child) {
              padding-bottom: 4px;
              margin-bottom: 4px;
              border-bottom: 1px solid rgba(38, 85, 115, 0.15);
            }
            #${menuId} .menu-items, #${menuId} .menu-items li {
              padding: 0;
            }
            #${menuId} .menu-item {
              display: flex;
            }
            #${menuId} .menu-item-content {
              display: flex;
              flex-direction: column;
              flex-grow: 1;
            }
          `
        ])
      );
    }
    const selectedElement = selected.get();
    const elementList = selectedElement ? [selectedElement] : targets.get();
    if (elementList.length) {
      menu.style.position = getComputedStyle(elementList[0].element).position === "fixed" ? "fixed" : "absolute";
      menu.appendChild(
        createElement(
          "ul",
          { class: "element-list" },
          elementList.map((target) => {
            const selectable = elementList.length > 1 && !!target.menu?.some(
              (group) => group.some(
                (item) => !item.selectors || item.selectors.some((s3) => target.selectors.includes(s3))
              )
            );
            const props = selectable ? {
              class: "selectable",
              onClick: /* @__PURE__ */ __name(() => selected.set(target), "onClick"),
              onMouseEnter: /* @__PURE__ */ __name(() => focused.set(target), "onMouseEnter"),
              onMouseLeave: /* @__PURE__ */ __name(() => focused.set(void 0), "onMouseLeave")
            } : selectedElement ? { class: "selected", onClick: /* @__PURE__ */ __name(() => selected.set(void 0), "onClick") } : {};
            const asButton = selectable || selectedElement;
            return createElement("li", props, [
              createElement(asButton ? "button" : "div", asButton ? { type: "button" } : {}, [
                selectedElement ? createIcon("chevronLeft") : null,
                createElement("code", {}, [target.element.outerHTML]),
                selectable ? createIcon("chevronRight") : null
              ])
            ]);
          })
        )
      );
    }
    if (selected.get() || targets.get().length === 1) {
      const target = selected.get() || targets.get()[0];
      const menuGroups = target.menu?.filter(
        (group) => group.some(
          (item) => !item.selectors || item.selectors.some((s3) => target.selectors.includes(s3))
        )
      );
      if (menuGroups?.length) {
        menu.appendChild(
          createElement(
            "ul",
            { class: "menu-list" },
            menuGroups.map(
              (menuItems) => createElement("li", {}, [
                createElement(
                  "ul",
                  { class: "menu-items" },
                  menuItems.map(
                    ({ id, title, description, iconLeft, iconRight, clickEvent: event }) => {
                      const onClick = event && (() => channel.emit(event, id, getEventDetails(target)));
                      return createElement("li", {}, [
                        createElement(
                          onClick ? "button" : "div",
                          onClick ? { class: "menu-item", type: "button", onClick } : { class: "menu-item" },
                          [
                            iconLeft ? createIcon(iconLeft) : null,
                            createElement("div", { class: "menu-item-content" }, [
                              createElement(description ? "strong" : "span", {}, [title]),
                              description && createElement("span", {}, [description])
                            ]),
                            iconRight ? createIcon(iconRight) : null
                          ]
                        )
                      ]);
                    }
                  )
                )
              ])
            )
          )
        );
      }
    }
    const coords = clickCoords.get();
    if (coords) {
      Object.assign(menu.style, {
        display: "block",
        left: `${menu.style.position === "fixed" ? coords.x - window.scrollX : coords.x}px`,
        top: `${menu.style.position === "fixed" ? coords.y - window.scrollY : coords.y}px`
      });
      showPopover(menu);
      requestAnimationFrame(() => keepInViewport(menu, coords, { topOffset: 15, centered: true }));
    } else {
      hidePopover(menu);
      Object.assign(menu.style, { display: "none" });
    }
  }, "renderMenu");
  targets.subscribe(renderMenu);
  selected.subscribe(renderMenu);
  const addHighlight = /* @__PURE__ */ __name((highlight) => {
    const info = normalizeOptions(highlight);
    highlights.set((value) => {
      const others = info.id ? value.filter((h3) => h3.id !== info.id) : value;
      return info.selectors?.length ? [...others, info] : others;
    });
  }, "addHighlight");
  const removeHighlight = /* @__PURE__ */ __name((id) => {
    if (id) {
      highlights.set((value) => value.filter((h3) => h3.id !== id));
    }
  }, "removeHighlight");
  const resetState = /* @__PURE__ */ __name(() => {
    highlights.set([]);
    elements.set(/* @__PURE__ */ new Map());
    boxes.set([]);
    clickCoords.set(void 0);
    hoverCoords.set(void 0);
    targets.set([]);
    hovered.set([]);
    focused.set(void 0);
    selected.set(void 0);
  }, "resetState");
  let removeTimeout;
  const scrollIntoView = /* @__PURE__ */ __name((target, options) => {
    const id = "scrollIntoView-highlight";
    clearTimeout(removeTimeout);
    removeHighlight(id);
    const element = document7.querySelector(target);
    if (!element) {
      console.warn(`Cannot scroll into view: ${target} not found`);
      return;
    }
    element.scrollIntoView({ behavior: "smooth", block: "center", ...options });
    const keyframeName = `kf-${Math.random().toString(36).substring(2, 15)}`;
    highlights.set((value) => [
      ...value,
      {
        id,
        priority: 1e3,
        selectors: [target],
        styles: {
          outline: "2px solid #1EA7FD",
          outlineOffset: "-1px",
          animation: `${keyframeName} 3s linear forwards`
        },
        keyframes: `@keyframes ${keyframeName} {
          0% { outline: 2px solid #1EA7FD; }
          20% { outline: 2px solid #1EA7FD00; }
          40% { outline: 2px solid #1EA7FD; }
          60% { outline: 2px solid #1EA7FD00; }
          80% { outline: 2px solid #1EA7FD; }
          100% { outline: 2px solid #1EA7FD00; }
        }`
      }
    ]);
    removeTimeout = setTimeout(() => removeHighlight(id), 3500);
  }, "scrollIntoView");
  const onMouseMove = /* @__PURE__ */ __name((event) => {
    requestAnimationFrame(() => hoverCoords.set({ x: event.pageX, y: event.pageY }));
  }, "onMouseMove");
  document7.body.addEventListener("mousemove", onMouseMove);
  channel.on(HIGHLIGHT, addHighlight);
  channel.on(REMOVE_HIGHLIGHT, removeHighlight);
  channel.on(RESET_HIGHLIGHT, resetState);
  channel.on(SCROLL_INTO_VIEW, scrollIntoView);
  channel.on(STORY_RENDER_PHASE_CHANGED, ({ newPhase }) => {
    if (newPhase === "loading") {
      resetState();
    }
  });
}, "useHighlights");

// src/highlight/preview.ts
if (globalThis?.FEATURES?.highlight && addons?.ready) {
  addons.ready().then(useHighlights);
}
var preview_default4 = /* @__PURE__ */ __name(() => definePreviewAddon({}), "default");

// src/measure/constants.ts
var ADDON_ID4 = "storybook/measure-addon";
var TOOL_ID = `${ADDON_ID4}/tool`;
var PARAM_KEY3 = "measureEnabled";
var EVENTS3 = {
  RESULT: `${ADDON_ID4}/result`,
  REQUEST: `${ADDON_ID4}/request`,
  CLEAR: `${ADDON_ID4}/clear`
};

// src/measure/box-model/canvas.ts
function getDocumentWidthAndHeight() {
  const container = scope.document.documentElement;
  const height = Math.max(container.scrollHeight, container.offsetHeight);
  const width = Math.max(container.scrollWidth, container.offsetWidth);
  return { width, height };
}
__name(getDocumentWidthAndHeight, "getDocumentWidthAndHeight");
function createCanvas() {
  const canvas = scope.document.createElement("canvas");
  canvas.id = "storybook-addon-measure";
  const context = canvas.getContext("2d");
  invariant(context != null);
  const { width, height } = getDocumentWidthAndHeight();
  setCanvasWidthAndHeight(canvas, context, { width, height });
  canvas.style.position = "absolute";
  canvas.style.left = "0";
  canvas.style.top = "0";
  canvas.style.zIndex = "2147483647";
  canvas.style.pointerEvents = "none";
  scope.document.body.appendChild(canvas);
  return { canvas, context, width, height };
}
__name(createCanvas, "createCanvas");
function setCanvasWidthAndHeight(canvas, context, { width, height }) {
  canvas.style.width = `${width}px`;
  canvas.style.height = `${height}px`;
  const scale = scope.window.devicePixelRatio;
  canvas.width = Math.floor(width * scale);
  canvas.height = Math.floor(height * scale);
  context.scale(scale, scale);
}
__name(setCanvasWidthAndHeight, "setCanvasWidthAndHeight");
var state2 = {};
function init() {
  if (!state2.canvas) {
    state2 = createCanvas();
  }
}
__name(init, "init");
function clear3() {
  if (state2.context) {
    state2.context.clearRect(0, 0, state2.width ?? 0, state2.height ?? 0);
  }
}
__name(clear3, "clear");
function draw(callback) {
  clear3();
  callback(state2.context);
}
__name(draw, "draw");
function rescale() {
  invariant(state2.canvas, "Canvas should exist in the state.");
  invariant(state2.context, "Context should exist in the state.");
  setCanvasWidthAndHeight(state2.canvas, state2.context, { width: 0, height: 0 });
  const { width, height } = getDocumentWidthAndHeight();
  setCanvasWidthAndHeight(state2.canvas, state2.context, { width, height });
  state2.width = width;
  state2.height = height;
}
__name(rescale, "rescale");
function destroy() {
  if (state2.canvas) {
    clear3();
    state2.canvas.parentNode?.removeChild(state2.canvas);
    state2 = {};
  }
}
__name(destroy, "destroy");

// src/measure/box-model/labels.ts
var colors = {
  margin: "#f6b26b",
  border: "#ffe599",
  padding: "#93c47d",
  content: "#6fa8dc",
  text: "#232020"
};
var labelPadding = 6;
function roundedRect(context, { x: x2, y: y2, w: w2, h: h3, r: r2 }) {
  x2 = x2 - w2 / 2;
  y2 = y2 - h3 / 2;
  if (w2 < 2 * r2) {
    r2 = w2 / 2;
  }
  if (h3 < 2 * r2) {
    r2 = h3 / 2;
  }
  context.beginPath();
  context.moveTo(x2 + r2, y2);
  context.arcTo(x2 + w2, y2, x2 + w2, y2 + h3, r2);
  context.arcTo(x2 + w2, y2 + h3, x2, y2 + h3, r2);
  context.arcTo(x2, y2 + h3, x2, y2, r2);
  context.arcTo(x2, y2, x2 + w2, y2, r2);
  context.closePath();
}
__name(roundedRect, "roundedRect");
function positionCoordinate(position, { padding, border, width, height, top, left }) {
  const contentWidth = width - border.left - border.right - padding.left - padding.right;
  const contentHeight = height - padding.top - padding.bottom - border.top - border.bottom;
  let x2 = left + border.left + padding.left;
  let y2 = top + border.top + padding.top;
  if (position === "top") {
    x2 += contentWidth / 2;
  } else if (position === "right") {
    x2 += contentWidth;
    y2 += contentHeight / 2;
  } else if (position === "bottom") {
    x2 += contentWidth / 2;
    y2 += contentHeight;
  } else if (position === "left") {
    y2 += contentHeight / 2;
  } else if (position === "center") {
    x2 += contentWidth / 2;
    y2 += contentHeight / 2;
  }
  return { x: x2, y: y2 };
}
__name(positionCoordinate, "positionCoordinate");
function offset(type5, position, { margin, border, padding }, labelPaddingSize, external) {
  let shift = /* @__PURE__ */ __name((dir) => 0, "shift");
  let offsetX = 0;
  let offsetY = 0;
  const locationMultiplier = external ? 1 : 0.5;
  const labelPaddingShift = external ? labelPaddingSize * 2 : 0;
  if (type5 === "padding") {
    shift = /* @__PURE__ */ __name((dir) => padding[dir] * locationMultiplier + labelPaddingShift, "shift");
  } else if (type5 === "border") {
    shift = /* @__PURE__ */ __name((dir) => padding[dir] + border[dir] * locationMultiplier + labelPaddingShift, "shift");
  } else if (type5 === "margin") {
    shift = /* @__PURE__ */ __name((dir) => padding[dir] + border[dir] + margin[dir] * locationMultiplier + labelPaddingShift, "shift");
  }
  if (position === "top") {
    offsetY = -shift("top");
  } else if (position === "right") {
    offsetX = shift("right");
  } else if (position === "bottom") {
    offsetY = shift("bottom");
  } else if (position === "left") {
    offsetX = -shift("left");
  }
  return { offsetX, offsetY };
}
__name(offset, "offset");
function collide(a2, b2) {
  return Math.abs(a2.x - b2.x) < Math.abs(a2.w + b2.w) / 2 && Math.abs(a2.y - b2.y) < Math.abs(a2.h + b2.h) / 2;
}
__name(collide, "collide");
function overlapAdjustment(position, currentRect, prevRect) {
  if (position === "top") {
    currentRect.y = prevRect.y - prevRect.h - labelPadding;
  } else if (position === "right") {
    currentRect.x = prevRect.x + prevRect.w / 2 + labelPadding + currentRect.w / 2;
  } else if (position === "bottom") {
    currentRect.y = prevRect.y + prevRect.h + labelPadding;
  } else if (position === "left") {
    currentRect.x = prevRect.x - prevRect.w / 2 - labelPadding - currentRect.w / 2;
  }
  return { x: currentRect.x, y: currentRect.y };
}
__name(overlapAdjustment, "overlapAdjustment");
function textWithRect(context, type5, { x: x2, y: y2, w: w2, h: h3 }, text) {
  roundedRect(context, { x: x2, y: y2, w: w2, h: h3, r: 3 });
  context.fillStyle = `${colors[type5]}dd`;
  context.fill();
  context.strokeStyle = colors[type5];
  context.stroke();
  context.fillStyle = colors.text;
  context.fillText(text, x2, y2);
  roundedRect(context, { x: x2, y: y2, w: w2, h: h3, r: 3 });
  context.fillStyle = `${colors[type5]}dd`;
  context.fill();
  context.strokeStyle = colors[type5];
  context.stroke();
  context.fillStyle = colors.text;
  context.fillText(text, x2, y2);
  return { x: x2, y: y2, w: w2, h: h3 };
}
__name(textWithRect, "textWithRect");
function configureText(context, text) {
  context.font = "600 12px monospace";
  context.textBaseline = "middle";
  context.textAlign = "center";
  const metrics = context.measureText(text);
  const actualHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
  const w2 = metrics.width + labelPadding * 2;
  const h3 = actualHeight + labelPadding * 2;
  return { w: w2, h: h3 };
}
__name(configureText, "configureText");
function drawLabel(context, measurements, { type: type5, position = "center", text }, prevRect, external = false) {
  let { x: x2, y: y2 } = positionCoordinate(position, measurements);
  const { offsetX, offsetY } = offset(type5, position, measurements, labelPadding + 1, external);
  x2 += offsetX;
  y2 += offsetY;
  const { w: w2, h: h3 } = configureText(context, text);
  if (prevRect && collide({ x: x2, y: y2, w: w2, h: h3 }, prevRect)) {
    const adjusted = overlapAdjustment(position, { x: x2, y: y2, w: w2, h: h3 }, prevRect);
    x2 = adjusted.x;
    y2 = adjusted.y;
  }
  return textWithRect(context, type5, { x: x2, y: y2, w: w2, h: h3 }, text);
}
__name(drawLabel, "drawLabel");
function floatingOffset(alignment, { w: w2, h: h3 }) {
  const deltaW = w2 * 0.5 + labelPadding;
  const deltaH = h3 * 0.5 + labelPadding;
  return {
    offsetX: (alignment.x === "left" ? -1 : 1) * deltaW,
    offsetY: (alignment.y === "top" ? -1 : 1) * deltaH
  };
}
__name(floatingOffset, "floatingOffset");
function drawFloatingLabel(context, measurements, { type: type5, text }) {
  const { floatingAlignment: floatingAlignment2, extremities } = measurements;
  let x2 = extremities[floatingAlignment2.x];
  let y2 = extremities[floatingAlignment2.y];
  const { w: w2, h: h3 } = configureText(context, text);
  const { offsetX, offsetY } = floatingOffset(floatingAlignment2, {
    w: w2,
    h: h3
  });
  x2 += offsetX;
  y2 += offsetY;
  return textWithRect(context, type5, { x: x2, y: y2, w: w2, h: h3 }, text);
}
__name(drawFloatingLabel, "drawFloatingLabel");
function drawStack(context, measurements, stack, external) {
  const rects = [];
  stack.forEach((l2, idx) => {
    const rect = external && l2.position === "center" ? drawFloatingLabel(context, measurements, l2) : drawLabel(context, measurements, l2, rects[idx - 1], external);
    rects[idx] = rect;
  });
}
__name(drawStack, "drawStack");
function labelStacks(context, measurements, labels, externalLabels) {
  const stacks = labels.reduce((acc, l2) => {
    if (!Object.prototype.hasOwnProperty.call(acc, l2.position)) {
      acc[l2.position] = [];
    }
    acc[l2.position]?.push(l2);
    return acc;
  }, {});
  if (stacks.top) {
    drawStack(context, measurements, stacks.top, externalLabels);
  }
  if (stacks.right) {
    drawStack(context, measurements, stacks.right, externalLabels);
  }
  if (stacks.bottom) {
    drawStack(context, measurements, stacks.bottom, externalLabels);
  }
  if (stacks.left) {
    drawStack(context, measurements, stacks.left, externalLabels);
  }
  if (stacks.center) {
    drawStack(context, measurements, stacks.center, externalLabels);
  }
}
__name(labelStacks, "labelStacks");

// src/measure/box-model/visualizer.ts
var colors2 = {
  margin: "#f6b26ba8",
  border: "#ffe599a8",
  padding: "#93c47d8c",
  content: "#6fa8dca8"
};
var SMALL_NODE_SIZE = 30;
function pxToNumber(px) {
  return parseInt(px.replace("px", ""), 10);
}
__name(pxToNumber, "pxToNumber");
function round(value) {
  return Number.isInteger(value) ? value : value.toFixed(2);
}
__name(round, "round");
function filterZeroValues(labels) {
  return labels.filter((l2) => l2.text !== 0 && l2.text !== "0");
}
__name(filterZeroValues, "filterZeroValues");
function floatingAlignment(extremities) {
  const windowExtremities = {
    top: scope.window.scrollY,
    bottom: scope.window.scrollY + scope.window.innerHeight,
    left: scope.window.scrollX,
    right: scope.window.scrollX + scope.window.innerWidth
  };
  const distances = {
    top: Math.abs(windowExtremities.top - extremities.top),
    bottom: Math.abs(windowExtremities.bottom - extremities.bottom),
    left: Math.abs(windowExtremities.left - extremities.left),
    right: Math.abs(windowExtremities.right - extremities.right)
  };
  return {
    x: distances.left > distances.right ? "left" : "right",
    y: distances.top > distances.bottom ? "top" : "bottom"
  };
}
__name(floatingAlignment, "floatingAlignment");
function measureElement(element) {
  const style = scope.getComputedStyle(element);
  let { top, left, right, bottom, width, height } = element.getBoundingClientRect();
  const {
    marginTop,
    marginBottom,
    marginLeft,
    marginRight,
    paddingTop,
    paddingBottom,
    paddingLeft,
    paddingRight,
    borderBottomWidth,
    borderTopWidth,
    borderLeftWidth,
    borderRightWidth
  } = style;
  top = top + scope.window.scrollY;
  left = left + scope.window.scrollX;
  bottom = bottom + scope.window.scrollY;
  right = right + scope.window.scrollX;
  const margin = {
    top: pxToNumber(marginTop),
    bottom: pxToNumber(marginBottom),
    left: pxToNumber(marginLeft),
    right: pxToNumber(marginRight)
  };
  const padding = {
    top: pxToNumber(paddingTop),
    bottom: pxToNumber(paddingBottom),
    left: pxToNumber(paddingLeft),
    right: pxToNumber(paddingRight)
  };
  const border = {
    top: pxToNumber(borderTopWidth),
    bottom: pxToNumber(borderBottomWidth),
    left: pxToNumber(borderLeftWidth),
    right: pxToNumber(borderRightWidth)
  };
  const extremities = {
    top: top - margin.top,
    bottom: bottom + margin.bottom,
    left: left - margin.left,
    right: right + margin.right
  };
  return {
    margin,
    padding,
    border,
    top,
    left,
    bottom,
    right,
    width,
    height,
    extremities,
    floatingAlignment: floatingAlignment(extremities)
  };
}
__name(measureElement, "measureElement");
function drawMargin(context, { margin, width, height, top, left, bottom, right }) {
  const marginHeight = height + margin.bottom + margin.top;
  context.fillStyle = colors2.margin;
  context.fillRect(left, top - margin.top, width, margin.top);
  context.fillRect(right, top - margin.top, margin.right, marginHeight);
  context.fillRect(left, bottom, width, margin.bottom);
  context.fillRect(left - margin.left, top - margin.top, margin.left, marginHeight);
  const marginLabels = [
    {
      type: "margin",
      text: round(margin.top),
      position: "top"
    },
    {
      type: "margin",
      text: round(margin.right),
      position: "right"
    },
    {
      type: "margin",
      text: round(margin.bottom),
      position: "bottom"
    },
    {
      type: "margin",
      text: round(margin.left),
      position: "left"
    }
  ];
  return filterZeroValues(marginLabels);
}
__name(drawMargin, "drawMargin");
function drawPadding(context, { padding, border, width, height, top, left, bottom, right }) {
  const paddingWidth = width - border.left - border.right;
  const paddingHeight = height - padding.top - padding.bottom - border.top - border.bottom;
  context.fillStyle = colors2.padding;
  context.fillRect(left + border.left, top + border.top, paddingWidth, padding.top);
  context.fillRect(
    right - padding.right - border.right,
    top + padding.top + border.top,
    padding.right,
    paddingHeight
  );
  context.fillRect(
    left + border.left,
    bottom - padding.bottom - border.bottom,
    paddingWidth,
    padding.bottom
  );
  context.fillRect(left + border.left, top + padding.top + border.top, padding.left, paddingHeight);
  const paddingLabels = [
    {
      type: "padding",
      text: padding.top,
      position: "top"
    },
    {
      type: "padding",
      text: padding.right,
      position: "right"
    },
    {
      type: "padding",
      text: padding.bottom,
      position: "bottom"
    },
    {
      type: "padding",
      text: padding.left,
      position: "left"
    }
  ];
  return filterZeroValues(paddingLabels);
}
__name(drawPadding, "drawPadding");
function drawBorder(context, { border, width, height, top, left, bottom, right }) {
  const borderHeight = height - border.top - border.bottom;
  context.fillStyle = colors2.border;
  context.fillRect(left, top, width, border.top);
  context.fillRect(left, bottom - border.bottom, width, border.bottom);
  context.fillRect(left, top + border.top, border.left, borderHeight);
  context.fillRect(right - border.right, top + border.top, border.right, borderHeight);
  const borderLabels = [
    {
      type: "border",
      text: border.top,
      position: "top"
    },
    {
      type: "border",
      text: border.right,
      position: "right"
    },
    {
      type: "border",
      text: border.bottom,
      position: "bottom"
    },
    {
      type: "border",
      text: border.left,
      position: "left"
    }
  ];
  return filterZeroValues(borderLabels);
}
__name(drawBorder, "drawBorder");
function drawContent(context, { padding, border, width, height, top, left }) {
  const contentWidth = width - border.left - border.right - padding.left - padding.right;
  const contentHeight = height - padding.top - padding.bottom - border.top - border.bottom;
  context.fillStyle = colors2.content;
  context.fillRect(
    left + border.left + padding.left,
    top + border.top + padding.top,
    contentWidth,
    contentHeight
  );
  return [
    {
      type: "content",
      position: "center",
      text: `${round(contentWidth)} x ${round(contentHeight)}`
    }
  ];
}
__name(drawContent, "drawContent");
function drawBoxModel(element) {
  return (context) => {
    if (element && context) {
      const measurements = measureElement(element);
      const marginLabels = drawMargin(context, measurements);
      const paddingLabels = drawPadding(context, measurements);
      const borderLabels = drawBorder(context, measurements);
      const contentLabels = drawContent(context, measurements);
      const externalLabels = measurements.width <= SMALL_NODE_SIZE * 3 || measurements.height <= SMALL_NODE_SIZE;
      labelStacks(
        context,
        measurements,
        [...contentLabels, ...paddingLabels, ...borderLabels, ...marginLabels],
        externalLabels
      );
    }
  };
}
__name(drawBoxModel, "drawBoxModel");
function drawSelectedElement(element) {
  draw(drawBoxModel(element));
}
__name(drawSelectedElement, "drawSelectedElement");

// src/measure/util.ts
var deepElementFromPoint = /* @__PURE__ */ __name((x2, y2) => {
  const element = scope.document.elementFromPoint(x2, y2);
  const crawlShadows = /* @__PURE__ */ __name((node) => {
    if (node && node.shadowRoot) {
      const nestedElement = node.shadowRoot.elementFromPoint(x2, y2);
      if (node.isEqualNode(nestedElement)) {
        return node;
      }
      if (nestedElement.shadowRoot) {
        return crawlShadows(nestedElement);
      }
      return nestedElement;
    }
    return node;
  }, "crawlShadows");
  const shadowElement = crawlShadows(element);
  return shadowElement || element;
}, "deepElementFromPoint");

// src/measure/withMeasure.ts
var nodeAtPointerRef;
var pointer3 = { x: 0, y: 0 };
function findAndDrawElement(x2, y2) {
  nodeAtPointerRef = deepElementFromPoint(x2, y2);
  drawSelectedElement(nodeAtPointerRef);
}
__name(findAndDrawElement, "findAndDrawElement");
var withMeasure = /* @__PURE__ */ __name((StoryFn, context) => {
  const { measureEnabled } = context.globals || {};
  useEffect(() => {
    if (typeof globalThis.document === "undefined") {
      return;
    }
    const onPointerMove = /* @__PURE__ */ __name((event) => {
      window.requestAnimationFrame(() => {
        event.stopPropagation();
        pointer3.x = event.clientX;
        pointer3.y = event.clientY;
      });
    }, "onPointerMove");
    globalThis.document.addEventListener("pointermove", onPointerMove);
    return () => {
      globalThis.document.removeEventListener("pointermove", onPointerMove);
    };
  }, []);
  useEffect(() => {
    const onPointerOver = /* @__PURE__ */ __name((event) => {
      window.requestAnimationFrame(() => {
        event.stopPropagation();
        findAndDrawElement(event.clientX, event.clientY);
      });
    }, "onPointerOver");
    const onResize = /* @__PURE__ */ __name(() => {
      window.requestAnimationFrame(() => {
        rescale();
      });
    }, "onResize");
    if (context.viewMode === "story" && measureEnabled) {
      globalThis.document.addEventListener("pointerover", onPointerOver);
      init();
      globalThis.window.addEventListener("resize", onResize);
      findAndDrawElement(pointer3.x, pointer3.y);
    }
    return () => {
      globalThis.window.removeEventListener("resize", onResize);
      destroy();
    };
  }, [measureEnabled, context.viewMode]);
  return StoryFn();
}, "withMeasure");

// src/measure/preview.ts
var decorators2 = globalThis.FEATURES?.measure ? [withMeasure] : [];
var initialGlobals2 = {
  [PARAM_KEY3]: false
};
var preview_default5 = /* @__PURE__ */ __name(() => definePreviewAddon({
  decorators: decorators2,
  initialGlobals: initialGlobals2
}), "default");

// src/outline/constants.ts
var PARAM_KEY4 = "outline";

// src/outline/helpers.ts
var clearStyles2 = /* @__PURE__ */ __name((selector) => {
  const selectors = Array.isArray(selector) ? selector : [selector];
  selectors.forEach(clearStyle2);
}, "clearStyles");
var clearStyle2 = /* @__PURE__ */ __name((input2) => {
  const selector = typeof input2 === "string" ? input2 : input2.join("");
  const element = scope.document.getElementById(selector);
  if (element && element.parentElement) {
    element.parentElement.removeChild(element);
  }
}, "clearStyle");
var addOutlineStyles = /* @__PURE__ */ __name((selector, css) => {
  const existingStyle = scope.document.getElementById(selector);
  if (existingStyle) {
    if (existingStyle.innerHTML !== css) {
      existingStyle.innerHTML = css;
    }
  } else {
    const style = scope.document.createElement("style");
    style.setAttribute("id", selector);
    style.innerHTML = css;
    scope.document.head.appendChild(style);
  }
}, "addOutlineStyles");

// src/outline/outlineCSS.ts
function outlineCSS(selector) {
  return dedent`
    ${selector} body {
      outline: 1px solid #2980b9 !important;
    }

    ${selector} article {
      outline: 1px solid #3498db !important;
    }

    ${selector} nav {
      outline: 1px solid #0088c3 !important;
    }

    ${selector} aside {
      outline: 1px solid #33a0ce !important;
    }

    ${selector} section {
      outline: 1px solid #66b8da !important;
    }

    ${selector} header {
      outline: 1px solid #99cfe7 !important;
    }

    ${selector} footer {
      outline: 1px solid #cce7f3 !important;
    }

    ${selector} h1 {
      outline: 1px solid #162544 !important;
    }

    ${selector} h2 {
      outline: 1px solid #314e6e !important;
    }

    ${selector} h3 {
      outline: 1px solid #3e5e85 !important;
    }

    ${selector} h4 {
      outline: 1px solid #449baf !important;
    }

    ${selector} h5 {
      outline: 1px solid #c7d1cb !important;
    }

    ${selector} h6 {
      outline: 1px solid #4371d0 !important;
    }

    ${selector} main {
      outline: 1px solid #2f4f90 !important;
    }

    ${selector} address {
      outline: 1px solid #1a2c51 !important;
    }

    ${selector} div {
      outline: 1px solid #036cdb !important;
    }

    ${selector} p {
      outline: 1px solid #ac050b !important;
    }

    ${selector} hr {
      outline: 1px solid #ff063f !important;
    }

    ${selector} pre {
      outline: 1px solid #850440 !important;
    }

    ${selector} blockquote {
      outline: 1px solid #f1b8e7 !important;
    }

    ${selector} ol {
      outline: 1px solid #ff050c !important;
    }

    ${selector} ul {
      outline: 1px solid #d90416 !important;
    }

    ${selector} li {
      outline: 1px solid #d90416 !important;
    }

    ${selector} dl {
      outline: 1px solid #fd3427 !important;
    }

    ${selector} dt {
      outline: 1px solid #ff0043 !important;
    }

    ${selector} dd {
      outline: 1px solid #e80174 !important;
    }

    ${selector} figure {
      outline: 1px solid #ff00bb !important;
    }

    ${selector} figcaption {
      outline: 1px solid #bf0032 !important;
    }

    ${selector} table {
      outline: 1px solid #00cc99 !important;
    }

    ${selector} caption {
      outline: 1px solid #37ffc4 !important;
    }

    ${selector} thead {
      outline: 1px solid #98daca !important;
    }

    ${selector} tbody {
      outline: 1px solid #64a7a0 !important;
    }

    ${selector} tfoot {
      outline: 1px solid #22746b !important;
    }

    ${selector} tr {
      outline: 1px solid #86c0b2 !important;
    }

    ${selector} th {
      outline: 1px solid #a1e7d6 !important;
    }

    ${selector} td {
      outline: 1px solid #3f5a54 !important;
    }

    ${selector} col {
      outline: 1px solid #6c9a8f !important;
    }

    ${selector} colgroup {
      outline: 1px solid #6c9a9d !important;
    }

    ${selector} button {
      outline: 1px solid #da8301 !important;
    }

    ${selector} datalist {
      outline: 1px solid #c06000 !important;
    }

    ${selector} fieldset {
      outline: 1px solid #d95100 !important;
    }

    ${selector} form {
      outline: 1px solid #d23600 !important;
    }

    ${selector} input {
      outline: 1px solid #fca600 !important;
    }

    ${selector} keygen {
      outline: 1px solid #b31e00 !important;
    }

    ${selector} label {
      outline: 1px solid #ee8900 !important;
    }

    ${selector} legend {
      outline: 1px solid #de6d00 !important;
    }

    ${selector} meter {
      outline: 1px solid #e8630c !important;
    }

    ${selector} optgroup {
      outline: 1px solid #b33600 !important;
    }

    ${selector} option {
      outline: 1px solid #ff8a00 !important;
    }

    ${selector} output {
      outline: 1px solid #ff9619 !important;
    }

    ${selector} progress {
      outline: 1px solid #e57c00 !important;
    }

    ${selector} select {
      outline: 1px solid #e26e0f !important;
    }

    ${selector} textarea {
      outline: 1px solid #cc5400 !important;
    }

    ${selector} details {
      outline: 1px solid #33848f !important;
    }

    ${selector} summary {
      outline: 1px solid #60a1a6 !important;
    }

    ${selector} command {
      outline: 1px solid #438da1 !important;
    }

    ${selector} menu {
      outline: 1px solid #449da6 !important;
    }

    ${selector} del {
      outline: 1px solid #bf0000 !important;
    }

    ${selector} ins {
      outline: 1px solid #400000 !important;
    }

    ${selector} img {
      outline: 1px solid #22746b !important;
    }

    ${selector} iframe {
      outline: 1px solid #64a7a0 !important;
    }

    ${selector} embed {
      outline: 1px solid #98daca !important;
    }

    ${selector} object {
      outline: 1px solid #00cc99 !important;
    }

    ${selector} param {
      outline: 1px solid #37ffc4 !important;
    }

    ${selector} video {
      outline: 1px solid #6ee866 !important;
    }

    ${selector} audio {
      outline: 1px solid #027353 !important;
    }

    ${selector} source {
      outline: 1px solid #012426 !important;
    }

    ${selector} canvas {
      outline: 1px solid #a2f570 !important;
    }

    ${selector} track {
      outline: 1px solid #59a600 !important;
    }

    ${selector} map {
      outline: 1px solid #7be500 !important;
    }

    ${selector} area {
      outline: 1px solid #305900 !important;
    }

    ${selector} a {
      outline: 1px solid #ff62ab !important;
    }

    ${selector} em {
      outline: 1px solid #800b41 !important;
    }

    ${selector} strong {
      outline: 1px solid #ff1583 !important;
    }

    ${selector} i {
      outline: 1px solid #803156 !important;
    }

    ${selector} b {
      outline: 1px solid #cc1169 !important;
    }

    ${selector} u {
      outline: 1px solid #ff0430 !important;
    }

    ${selector} s {
      outline: 1px solid #f805e3 !important;
    }

    ${selector} small {
      outline: 1px solid #d107b2 !important;
    }

    ${selector} abbr {
      outline: 1px solid #4a0263 !important;
    }

    ${selector} q {
      outline: 1px solid #240018 !important;
    }

    ${selector} cite {
      outline: 1px solid #64003c !important;
    }

    ${selector} dfn {
      outline: 1px solid #b4005a !important;
    }

    ${selector} sub {
      outline: 1px solid #dba0c8 !important;
    }

    ${selector} sup {
      outline: 1px solid #cc0256 !important;
    }

    ${selector} time {
      outline: 1px solid #d6606d !important;
    }

    ${selector} code {
      outline: 1px solid #e04251 !important;
    }

    ${selector} kbd {
      outline: 1px solid #5e001f !important;
    }

    ${selector} samp {
      outline: 1px solid #9c0033 !important;
    }

    ${selector} var {
      outline: 1px solid #d90047 !important;
    }

    ${selector} mark {
      outline: 1px solid #ff0053 !important;
    }

    ${selector} bdi {
      outline: 1px solid #bf3668 !important;
    }

    ${selector} bdo {
      outline: 1px solid #6f1400 !important;
    }

    ${selector} ruby {
      outline: 1px solid #ff7b93 !important;
    }

    ${selector} rt {
      outline: 1px solid #ff2f54 !important;
    }

    ${selector} rp {
      outline: 1px solid #803e49 !important;
    }

    ${selector} span {
      outline: 1px solid #cc2643 !important;
    }

    ${selector} br {
      outline: 1px solid #db687d !important;
    }

    ${selector} wbr {
      outline: 1px solid #db175b !important;
    }`;
}
__name(outlineCSS, "outlineCSS");

// src/outline/withOutline.ts
var withOutline = /* @__PURE__ */ __name((StoryFn, context) => {
  const globals = context.globals || {};
  const isActive = [true, "true"].includes(globals[PARAM_KEY4]);
  const isInDocs = context.viewMode === "docs";
  const outlineStyles = useMemo(() => {
    const selector = isInDocs ? `[data-story-block="true"]` : ".sb-show-main";
    return outlineCSS(selector);
  }, [context]);
  useEffect(() => {
    const selectorId = isInDocs ? `addon-outline-docs-${context.id}` : `addon-outline`;
    if (!isActive) {
      clearStyles2(selectorId);
    } else {
      addOutlineStyles(selectorId, outlineStyles);
    }
    return () => {
      clearStyles2(selectorId);
    };
  }, [isActive, outlineStyles, context]);
  return StoryFn();
}, "withOutline");

// src/outline/preview.ts
var decorators3 = globalThis.FEATURES?.outline ? [withOutline] : [];
var initialGlobals3 = {
  [PARAM_KEY4]: false
};
var preview_default6 = /* @__PURE__ */ __name(() => definePreviewAddon({ decorators: decorators3, initialGlobals: initialGlobals3 }), "default");

// src/test/preview.ts
var resetAllMocksLoader = /* @__PURE__ */ __name(({ parameters: parameters2 }) => {
  if (parameters2?.test?.mockReset === true) {
    resetAllMocks();
  } else if (parameters2?.test?.clearMocks === true) {
    clearAllMocks();
  } else if (parameters2?.test?.restoreMocks !== false) {
    restoreAllMocks();
  }
}, "resetAllMocksLoader");
var traverseArgs = /* @__PURE__ */ __name((value, depth = 0, key) => {
  if (depth > 5) {
    return value;
  }
  if (value == null) {
    return value;
  }
  if (isMockFunction(value)) {
    if (key) {
      value.mockName(key);
    }
    return value;
  }
  if (typeof value === "function" && "isAction" in value && value.isAction && !("implicit" in value && value.implicit)) {
    const mock = fn2(value);
    if (key) {
      mock.mockName(key);
    }
    return mock;
  }
  if (Array.isArray(value)) {
    depth++;
    for (let i2 = 0; i2 < value.length; i2++) {
      if (Object.getOwnPropertyDescriptor(value, i2)?.writable) {
        value[i2] = traverseArgs(value[i2], depth);
      }
    }
    return value;
  }
  if (typeof value === "object" && value.constructor === Object) {
    depth++;
    for (const [k2, v2] of Object.entries(value)) {
      if (Object.getOwnPropertyDescriptor(value, k2)?.writable) {
        value[k2] = traverseArgs(v2, depth, k2);
      }
    }
    return value;
  }
  return value;
}, "traverseArgs");
var nameSpiesAndWrapActionsInSpies = /* @__PURE__ */ __name(({ initialArgs }) => {
  traverseArgs(initialArgs);
}, "nameSpiesAndWrapActionsInSpies");
var patchedFocus = false;
var enhanceContext = /* @__PURE__ */ __name(async (context) => {
  if (globalThis.HTMLElement && context.canvasElement instanceof globalThis.HTMLElement) {
    context.canvas = within(context.canvasElement);
  }
  const clipboard = globalThis.window?.navigator?.clipboard;
  if (clipboard) {
    context.userEvent = instrument(
      { userEvent: uninstrumentedUserEvent.setup() },
      {
        intercept: true,
        getKeys: /* @__PURE__ */ __name((obj) => Object.keys(obj).filter((key) => key !== "eventWrapper"), "getKeys")
      }
    ).userEvent;
    Object.defineProperty(globalThis.window.navigator, "clipboard", {
      get: /* @__PURE__ */ __name(() => clipboard, "get"),
      configurable: true
    });
    if (!patchedFocus) {
      const originalFocus = HTMLElement.prototype.focus;
      let currentFocus = HTMLElement.prototype.focus;
      const focusingElements = /* @__PURE__ */ new Set();
      Object.defineProperties(HTMLElement.prototype, {
        focus: {
          configurable: true,
          set: /* @__PURE__ */ __name((newFocus) => {
            currentFocus = newFocus;
          }, "set"),
          get() {
            if (focusingElements.has(this)) {
              return originalFocus;
            }
            focusingElements.add(this);
            setTimeout(() => focusingElements.delete(this), 0);
            return currentFocus;
          }
        }
      });
      patchedFocus = true;
    }
  }
}, "enhanceContext");
var preview_default7 = /* @__PURE__ */ __name(() => definePreviewAddon({
  loaders: [resetAllMocksLoader, nameSpiesAndWrapActionsInSpies, enhanceContext]
}), "default");

// src/viewport/constants.ts
var ADDON_ID5 = "storybook/viewport";
var PARAM_KEY5 = "viewport";
var PANEL_ID2 = `${ADDON_ID5}/panel`;
var TOOL_ID2 = `${ADDON_ID5}/tool`;

// src/viewport/preview.ts
var initialGlobals4 = {
  [PARAM_KEY5]: { value: void 0, isRotated: false }
};
var preview_default8 = /* @__PURE__ */ __name(() => definePreviewAddon({
  initialGlobals: initialGlobals4
}), "default");

// src/csf/core-annotations.ts
function getCoreAnnotations() {
  return [
    // @ts-expect-error CJS fallback
    (preview_default5.default ?? preview_default5)(),
    // @ts-expect-error CJS fallback
    (preview_default2.default ?? preview_default2)(),
    // @ts-expect-error CJS fallback
    (preview_default4.default ?? preview_default4)(),
    // @ts-expect-error CJS fallback
    (preview_default6.default ?? preview_default6)(),
    // @ts-expect-error CJS fallback
    (preview_default8.default ?? preview_default8)(),
    // @ts-expect-error CJS fallback
    (preview_default.default ?? preview_default)(),
    // @ts-expect-error CJS fallback
    (preview_default3.default ?? preview_default3)(),
    // @ts-expect-error CJS fallback
    (preview_default7.default ?? preview_default7)()
  ];
}
__name(getCoreAnnotations, "getCoreAnnotations");

// src/csf/csf-factories.ts
function definePreviewAddon(preview) {
  return preview;
}
__name(definePreviewAddon, "definePreviewAddon");
function isMeta(input2) {
  return input2 != null && typeof input2 === "object" && "_tag" in input2 && input2?._tag === "Meta";
}
__name(isMeta, "isMeta");
function isStory(input2) {
  return input2 != null && typeof input2 === "object" && "_tag" in input2 && input2?._tag === "Story";
}
__name(isStory, "isStory");
function getStoryChildren(story) {
  if ("__children" in story) {
    return story.__children;
  }
  return [];
}
__name(getStoryChildren, "getStoryChildren");

// src/csf/index.ts
var sanitize = /* @__PURE__ */ __name((string) => {
  return string.toLowerCase().replace(/[ '`~!@#$%^&*()_|+\-=?;:'",.<>\{\}\[\]\\\/]/gi, "-").replace(/-+/g, "-").replace(/^-+/, "").replace(/-+$/, "");
}, "sanitize");
var sanitizeSafe = /* @__PURE__ */ __name((string, part) => {
  const sanitized = sanitize(string);
  if (sanitized === "") {
    throw new Error(`Invalid ${part} '${string}', must include alphanumeric characters`);
  }
  return sanitized;
}, "sanitizeSafe");
var toId = /* @__PURE__ */ __name((kind, name) => `${sanitizeSafe(kind, "kind")}${name ? `--${sanitizeSafe(name, "name")}` : ""}`, "toId");
var toTestId = /* @__PURE__ */ __name((parentId, testName2) => `${parentId}:${sanitizeSafe(testName2, "test")}`, "toTestId");
var storyNameFromExport = /* @__PURE__ */ __name((key) => toStartCaseStr(key), "storyNameFromExport");
function matches3(storyKey, arrayOrRegex) {
  if (Array.isArray(arrayOrRegex)) {
    return arrayOrRegex.includes(storyKey);
  }
  return storyKey.match(arrayOrRegex);
}
__name(matches3, "matches");
function isExportStory(key, { includeStories, excludeStories }) {
  return (
    // https://babeljs.io/docs/en/babel-plugin-transform-modules-commonjs
    key !== "__esModule" && (!includeStories || matches3(key, includeStories)) && (!excludeStories || !matches3(key, excludeStories))
  );
}
__name(isExportStory, "isExportStory");
var combineTags = /* @__PURE__ */ __name((...tags) => {
  const result = tags.reduce((acc, tag) => {
    if (tag.startsWith("!")) {
      acc.delete(tag.slice(1));
    } else {
      acc.add(tag);
    }
    return acc;
  }, /* @__PURE__ */ new Set());
  return Array.from(result);
}, "combineTags");

// ../node_modules/es-toolkit/dist/compat/_internal/getSymbols.mjs
function getSymbols(object) {
  return Object.getOwnPropertySymbols(object).filter((symbol) => Object.prototype.propertyIsEnumerable.call(object, symbol));
}
__name(getSymbols, "getSymbols");

// ../node_modules/es-toolkit/dist/compat/_internal/getTag.mjs
function getTag2(value) {
  if (value == null) {
    return value === void 0 ? "[object Undefined]" : "[object Null]";
  }
  return Object.prototype.toString.call(value);
}
__name(getTag2, "getTag");

// ../node_modules/es-toolkit/dist/compat/_internal/tags.mjs
var regexpTag = "[object RegExp]";
var stringTag = "[object String]";
var numberTag = "[object Number]";
var booleanTag = "[object Boolean]";
var argumentsTag = "[object Arguments]";
var symbolTag2 = "[object Symbol]";
var dateTag = "[object Date]";
var mapTag = "[object Map]";
var setTag = "[object Set]";
var arrayTag = "[object Array]";
var functionTag = "[object Function]";
var arrayBufferTag = "[object ArrayBuffer]";
var objectTag = "[object Object]";
var errorTag = "[object Error]";
var dataViewTag = "[object DataView]";
var uint8ArrayTag = "[object Uint8Array]";
var uint8ClampedArrayTag = "[object Uint8ClampedArray]";
var uint16ArrayTag = "[object Uint16Array]";
var uint32ArrayTag = "[object Uint32Array]";
var bigUint64ArrayTag = "[object BigUint64Array]";
var int8ArrayTag = "[object Int8Array]";
var int16ArrayTag = "[object Int16Array]";
var int32ArrayTag = "[object Int32Array]";
var bigInt64ArrayTag = "[object BigInt64Array]";
var float32ArrayTag = "[object Float32Array]";
var float64ArrayTag = "[object Float64Array]";

// ../node_modules/es-toolkit/dist/predicate/isPlainObject.mjs
function isPlainObject(value) {
  if (!value || typeof value !== "object") {
    return false;
  }
  const proto = Object.getPrototypeOf(value);
  const hasObjectPrototype = proto === null || proto === Object.prototype || Object.getPrototypeOf(proto) === null;
  if (!hasObjectPrototype) {
    return false;
  }
  return Object.prototype.toString.call(value) === "[object Object]";
}
__name(isPlainObject, "isPlainObject");

// ../node_modules/es-toolkit/dist/object/mapValues.mjs
function mapValues(object, getNewValue) {
  const result = {};
  const keys2 = Object.keys(object);
  for (let i2 = 0; i2 < keys2.length; i2++) {
    const key = keys2[i2];
    const value = object[key];
    result[key] = getNewValue(value, key, object);
  }
  return result;
}
__name(mapValues, "mapValues");

// ../node_modules/es-toolkit/dist/object/pickBy.mjs
function pickBy(obj, shouldPick) {
  const result = {};
  const keys2 = Object.keys(obj);
  for (let i2 = 0; i2 < keys2.length; i2++) {
    const key = keys2[i2];
    const value = obj[key];
    if (shouldPick(value, key)) {
      result[key] = value;
    }
  }
  return result;
}
__name(pickBy, "pickBy");

// ../node_modules/es-toolkit/dist/string/words.mjs
var CASE_SPLIT_PATTERN = new RegExp("\\p{Lu}?\\p{Ll}+|[0-9]+|\\p{Lu}+(?!\\p{Ll})|\\p{Emoji_Presentation}|\\p{Extended_Pictographic}|\\p{L}+", "gu");

// src/preview-api/modules/store/StoryStore.ts
var import_memoizerific2 = __toESM(require_memoizerific(), 1);

// ../node_modules/es-toolkit/dist/compat/util/eq.mjs
function eq3(value, other) {
  return value === other || Number.isNaN(value) && Number.isNaN(other);
}
__name(eq3, "eq");

// ../node_modules/es-toolkit/dist/predicate/isEqualWith.mjs
function isEqualWith(a2, b2, areValuesEqual) {
  return isEqualWithImpl(a2, b2, void 0, void 0, void 0, void 0, areValuesEqual);
}
__name(isEqualWith, "isEqualWith");
function isEqualWithImpl(a2, b2, property, aParent, bParent, stack, areValuesEqual) {
  const result = areValuesEqual(a2, b2, property, aParent, bParent, stack);
  if (result !== void 0) {
    return result;
  }
  if (typeof a2 === typeof b2) {
    switch (typeof a2) {
      case "bigint":
      case "string":
      case "boolean":
      case "symbol":
      case "undefined": {
        return a2 === b2;
      }
      case "number": {
        return a2 === b2 || Object.is(a2, b2);
      }
      case "function": {
        return a2 === b2;
      }
      case "object": {
        return areObjectsEqual(a2, b2, stack, areValuesEqual);
      }
    }
  }
  return areObjectsEqual(a2, b2, stack, areValuesEqual);
}
__name(isEqualWithImpl, "isEqualWithImpl");
function areObjectsEqual(a2, b2, stack, areValuesEqual) {
  if (Object.is(a2, b2)) {
    return true;
  }
  let aTag = getTag2(a2);
  let bTag = getTag2(b2);
  if (aTag === argumentsTag) {
    aTag = objectTag;
  }
  if (bTag === argumentsTag) {
    bTag = objectTag;
  }
  if (aTag !== bTag) {
    return false;
  }
  switch (aTag) {
    case stringTag:
      return a2.toString() === b2.toString();
    case numberTag: {
      const x2 = a2.valueOf();
      const y2 = b2.valueOf();
      return eq3(x2, y2);
    }
    case booleanTag:
    case dateTag:
    case symbolTag2:
      return Object.is(a2.valueOf(), b2.valueOf());
    case regexpTag: {
      return a2.source === b2.source && a2.flags === b2.flags;
    }
    case functionTag: {
      return a2 === b2;
    }
  }
  stack = stack ?? /* @__PURE__ */ new Map();
  const aStack = stack.get(a2);
  const bStack = stack.get(b2);
  if (aStack != null && bStack != null) {
    return aStack === b2;
  }
  stack.set(a2, b2);
  stack.set(b2, a2);
  try {
    switch (aTag) {
      case mapTag: {
        if (a2.size !== b2.size) {
          return false;
        }
        for (const [key, value] of a2.entries()) {
          if (!b2.has(key) || !isEqualWithImpl(value, b2.get(key), key, a2, b2, stack, areValuesEqual)) {
            return false;
          }
        }
        return true;
      }
      case setTag: {
        if (a2.size !== b2.size) {
          return false;
        }
        const aValues = Array.from(a2.values());
        const bValues = Array.from(b2.values());
        for (let i2 = 0; i2 < aValues.length; i2++) {
          const aValue = aValues[i2];
          const index2 = bValues.findIndex((bValue) => {
            return isEqualWithImpl(aValue, bValue, void 0, a2, b2, stack, areValuesEqual);
          });
          if (index2 === -1) {
            return false;
          }
          bValues.splice(index2, 1);
        }
        return true;
      }
      case arrayTag:
      case uint8ArrayTag:
      case uint8ClampedArrayTag:
      case uint16ArrayTag:
      case uint32ArrayTag:
      case bigUint64ArrayTag:
      case int8ArrayTag:
      case int16ArrayTag:
      case int32ArrayTag:
      case bigInt64ArrayTag:
      case float32ArrayTag:
      case float64ArrayTag: {
        if (typeof Buffer !== "undefined" && Buffer.isBuffer(a2) !== Buffer.isBuffer(b2)) {
          return false;
        }
        if (a2.length !== b2.length) {
          return false;
        }
        for (let i2 = 0; i2 < a2.length; i2++) {
          if (!isEqualWithImpl(a2[i2], b2[i2], i2, a2, b2, stack, areValuesEqual)) {
            return false;
          }
        }
        return true;
      }
      case arrayBufferTag: {
        if (a2.byteLength !== b2.byteLength) {
          return false;
        }
        return areObjectsEqual(new Uint8Array(a2), new Uint8Array(b2), stack, areValuesEqual);
      }
      case dataViewTag: {
        if (a2.byteLength !== b2.byteLength || a2.byteOffset !== b2.byteOffset) {
          return false;
        }
        return areObjectsEqual(new Uint8Array(a2), new Uint8Array(b2), stack, areValuesEqual);
      }
      case errorTag: {
        return a2.name === b2.name && a2.message === b2.message;
      }
      case objectTag: {
        const areEqualInstances = areObjectsEqual(a2.constructor, b2.constructor, stack, areValuesEqual) || isPlainObject(a2) && isPlainObject(b2);
        if (!areEqualInstances) {
          return false;
        }
        const aKeys = [...Object.keys(a2), ...getSymbols(a2)];
        const bKeys = [...Object.keys(b2), ...getSymbols(b2)];
        if (aKeys.length !== bKeys.length) {
          return false;
        }
        for (let i2 = 0; i2 < aKeys.length; i2++) {
          const propKey = aKeys[i2];
          const aProp = a2[propKey];
          if (!Object.hasOwn(b2, propKey)) {
            return false;
          }
          const bProp = b2[propKey];
          if (!isEqualWithImpl(aProp, bProp, propKey, a2, b2, stack, areValuesEqual)) {
            return false;
          }
        }
        return true;
      }
      default: {
        return false;
      }
    }
  } finally {
    stack.delete(a2);
    stack.delete(b2);
  }
}
__name(areObjectsEqual, "areObjectsEqual");

// ../node_modules/es-toolkit/dist/function/noop.mjs
function noop2() {
}
__name(noop2, "noop");

// ../node_modules/es-toolkit/dist/predicate/isEqual.mjs
function isEqual2(a2, b2) {
  return isEqualWith(a2, b2, noop2);
}
__name(isEqual2, "isEqual");

// src/preview-api/modules/store/args.ts
var INCOMPATIBLE = Symbol("incompatible");
var map = /* @__PURE__ */ __name((arg, argType) => {
  const type5 = argType.type;
  if (arg === void 0 || arg === null || !type5) {
    return arg;
  }
  if (argType.mapping) {
    return arg;
  }
  switch (type5.name) {
    case "string":
      return String(arg);
    case "enum":
      return arg;
    case "number":
      return Number(arg);
    case "boolean":
      return String(arg) === "true";
    case "array":
      if (!type5.value || !Array.isArray(arg)) {
        return INCOMPATIBLE;
      }
      return arg.reduce((acc, item, index2) => {
        const mapped = map(item, { type: type5.value });
        if (mapped !== INCOMPATIBLE) {
          acc[index2] = mapped;
        }
        return acc;
      }, new Array(arg.length));
    case "object":
      if (typeof arg === "string" || typeof arg === "number") {
        return arg;
      }
      if (!type5.value || typeof arg !== "object") {
        return INCOMPATIBLE;
      }
      return Object.entries(arg).reduce((acc, [key, val]) => {
        const mapped = map(val, { type: type5.value[key] });
        return mapped === INCOMPATIBLE ? acc : Object.assign(acc, { [key]: mapped });
      }, {});
    case "other": {
      const isPrimitiveArg = typeof arg === "string" || typeof arg === "number" || typeof arg === "boolean";
      if (type5.value === "ReactNode" && isPrimitiveArg) {
        return arg;
      }
      return INCOMPATIBLE;
    }
    default:
      return INCOMPATIBLE;
  }
}, "map");
var mapArgsToTypes = /* @__PURE__ */ __name((args, argTypes) => {
  return Object.entries(args).reduce((acc, [key, value]) => {
    if (!argTypes[key]) {
      return acc;
    }
    const mapped = map(value, argTypes[key]);
    return mapped === INCOMPATIBLE ? acc : Object.assign(acc, { [key]: mapped });
  }, {});
}, "mapArgsToTypes");
var combineArgs = /* @__PURE__ */ __name((value, update) => {
  if (Array.isArray(value) && Array.isArray(update)) {
    return update.reduce(
      (acc, upd, index2) => {
        acc[index2] = combineArgs(value[index2], update[index2]);
        return acc;
      },
      [...value]
    ).filter((v2) => v2 !== void 0);
  }
  if (!isPlainObject(value) || !isPlainObject(update)) {
    return update;
  }
  return Object.keys({ ...value, ...update }).reduce((acc, key) => {
    if (key in update) {
      const combined = combineArgs(value[key], update[key]);
      if (combined !== void 0) {
        acc[key] = combined;
      }
    } else {
      acc[key] = value[key];
    }
    return acc;
  }, {});
}, "combineArgs");
var validateOptions2 = /* @__PURE__ */ __name((args, argTypes) => {
  return Object.entries(argTypes).reduce((acc, [key, { options }]) => {
    function allowArg() {
      if (key in args) {
        acc[key] = args[key];
      }
      return acc;
    }
    __name(allowArg, "allowArg");
    if (!options) {
      return allowArg();
    }
    if (!Array.isArray(options)) {
      once.error(dedent`
        Invalid argType: '${key}.options' should be an array.

        More info: https://storybook.js.org/docs/api/arg-types?ref=error
      `);
      return allowArg();
    }
    if (options.some((opt) => opt && ["object", "function"].includes(typeof opt))) {
      once.error(dedent`
        Invalid argType: '${key}.options' should only contain primitives. Use a 'mapping' for complex values.

        More info: https://storybook.js.org/docs/writing-stories/args?ref=error#mapping-to-complex-arg-values
      `);
      return allowArg();
    }
    const isArray3 = Array.isArray(args[key]);
    const invalidIndex = isArray3 && args[key].findIndex((val) => !options.includes(val));
    const isValidArray = isArray3 && invalidIndex === -1;
    if (args[key] === void 0 || options.includes(args[key]) || isValidArray) {
      return allowArg();
    }
    const field = isArray3 ? `${key}[${invalidIndex}]` : key;
    const supportedOptions = options.map((opt) => typeof opt === "string" ? `'${opt}'` : String(opt)).join(", ");
    once.warn(`Received illegal value for '${field}'. Supported options: ${supportedOptions}`);
    return acc;
  }, {});
}, "validateOptions");
var DEEPLY_EQUAL = Symbol("Deeply equal");
var deepDiff = /* @__PURE__ */ __name((value, update) => {
  if (typeof value !== typeof update) {
    return update;
  }
  if (isEqual2(value, update)) {
    return DEEPLY_EQUAL;
  }
  if (Array.isArray(value) && Array.isArray(update)) {
    const res = update.reduce((acc, upd, index2) => {
      const diff2 = deepDiff(value[index2], upd);
      if (diff2 !== DEEPLY_EQUAL) {
        acc[index2] = diff2;
      }
      return acc;
    }, new Array(update.length));
    if (update.length >= value.length) {
      return res;
    }
    return res.concat(new Array(value.length - update.length).fill(void 0));
  }
  if (isPlainObject(value) && isPlainObject(update)) {
    return Object.keys({ ...value, ...update }).reduce((acc, key) => {
      const diff2 = deepDiff(value?.[key], update?.[key]);
      return diff2 === DEEPLY_EQUAL ? acc : Object.assign(acc, { [key]: diff2 });
    }, {});
  }
  return update;
}, "deepDiff");
var UNTARGETED = "UNTARGETED";
function groupArgsByTarget({
  args,
  argTypes
}) {
  const groupedArgs = {};
  Object.entries(args).forEach(([name, value]) => {
    const { target = UNTARGETED } = argTypes[name] || {};
    groupedArgs[target] = groupedArgs[target] || {};
    groupedArgs[target][name] = value;
  });
  return groupedArgs;
}
__name(groupArgsByTarget, "groupArgsByTarget");

// src/preview-api/modules/store/ArgsStore.ts
function deleteUndefined(obj) {
  Object.keys(obj).forEach((key) => obj[key] === void 0 && delete obj[key]);
  return obj;
}
__name(deleteUndefined, "deleteUndefined");
var _ArgsStore = class _ArgsStore {
  constructor() {
    this.initialArgsByStoryId = {};
    this.argsByStoryId = {};
  }
  get(storyId) {
    if (!(storyId in this.argsByStoryId)) {
      throw new Error(`No args known for ${storyId} -- has it been rendered yet?`);
    }
    return this.argsByStoryId[storyId];
  }
  setInitial(story) {
    if (!this.initialArgsByStoryId[story.id]) {
      this.initialArgsByStoryId[story.id] = story.initialArgs;
      this.argsByStoryId[story.id] = story.initialArgs;
    } else if (this.initialArgsByStoryId[story.id] !== story.initialArgs) {
      const delta = deepDiff(this.initialArgsByStoryId[story.id], this.argsByStoryId[story.id]);
      this.initialArgsByStoryId[story.id] = story.initialArgs;
      this.argsByStoryId[story.id] = story.initialArgs;
      if (delta !== DEEPLY_EQUAL) {
        this.updateFromDelta(story, delta);
      }
    }
  }
  updateFromDelta(story, delta) {
    const validatedDelta = validateOptions2(delta, story.argTypes);
    this.argsByStoryId[story.id] = combineArgs(this.argsByStoryId[story.id], validatedDelta);
  }
  updateFromPersisted(story, persisted) {
    const mappedPersisted = mapArgsToTypes(persisted, story.argTypes);
    return this.updateFromDelta(story, mappedPersisted);
  }
  update(storyId, argsUpdate) {
    if (!(storyId in this.argsByStoryId)) {
      throw new Error(`No args known for ${storyId} -- has it been rendered yet?`);
    }
    this.argsByStoryId[storyId] = deleteUndefined({
      ...this.argsByStoryId[storyId],
      ...argsUpdate
    });
  }
};
__name(_ArgsStore, "ArgsStore");
var ArgsStore = _ArgsStore;

// src/preview-api/modules/store/csf/getValuesFromArgTypes.ts
var getValuesFromArgTypes = /* @__PURE__ */ __name((argTypes = {}) => Object.entries(argTypes).reduce((acc, [arg, { defaultValue }]) => {
  if (typeof defaultValue !== "undefined") {
    acc[arg] = defaultValue;
  }
  return acc;
}, {}), "getValuesFromArgTypes");

// src/preview-api/modules/store/GlobalsStore.ts
var _GlobalsStore = class _GlobalsStore {
  constructor({
    globals = {},
    globalTypes = {}
  }) {
    this.set({ globals, globalTypes });
  }
  set({ globals = {}, globalTypes = {} }) {
    const delta = this.initialGlobals && deepDiff(this.initialGlobals, this.globals);
    this.allowedGlobalNames = /* @__PURE__ */ new Set([...Object.keys(globals), ...Object.keys(globalTypes)]);
    const defaultGlobals = getValuesFromArgTypes(globalTypes);
    this.initialGlobals = { ...defaultGlobals, ...globals };
    this.globals = this.initialGlobals;
    if (delta && delta !== DEEPLY_EQUAL) {
      this.updateFromPersisted(delta);
    }
  }
  filterAllowedGlobals(globals) {
    return Object.entries(globals).reduce((acc, [key, value]) => {
      if (this.allowedGlobalNames.has(key)) {
        acc[key] = value;
      } else {
        logger.warn(
          `Attempted to set a global (${key}) that is not defined in initial globals or globalTypes`
        );
      }
      return acc;
    }, {});
  }
  updateFromPersisted(persisted) {
    const allowedUrlGlobals = this.filterAllowedGlobals(persisted);
    this.globals = { ...this.globals, ...allowedUrlGlobals };
  }
  get() {
    return this.globals;
  }
  update(newGlobals) {
    this.globals = { ...this.globals, ...this.filterAllowedGlobals(newGlobals) };
    for (const key in newGlobals) {
      if (newGlobals[key] === void 0) {
        this.globals[key] = this.initialGlobals[key];
      }
    }
  }
};
__name(_GlobalsStore, "GlobalsStore");
var GlobalsStore = _GlobalsStore;

// src/preview-api/modules/store/StoryIndexStore.ts
var import_memoizerific = __toESM(require_memoizerific(), 1);
var getImportPathMap = (0, import_memoizerific.default)(1)(
  (entries) => Object.values(entries).reduce(
    (acc, entry) => {
      acc[entry.importPath] = acc[entry.importPath] || entry;
      return acc;
    },
    {}
  )
);
var _StoryIndexStore = class _StoryIndexStore {
  constructor({ entries } = { v: 5, entries: {} }) {
    this.entries = entries;
  }
  entryFromSpecifier(specifier) {
    const entries = Object.values(this.entries);
    if (specifier === "*") {
      return entries[0];
    }
    if (typeof specifier === "string") {
      if (this.entries[specifier]) {
        return this.entries[specifier];
      }
      return entries.find((entry) => entry.id.startsWith(specifier));
    }
    const { name, title } = specifier;
    return entries.find((entry) => entry.name === name && entry.title === title);
  }
  storyIdToEntry(storyId) {
    const storyEntry = this.entries[storyId];
    if (!storyEntry) {
      throw new MissingStoryAfterHmrError({ storyId });
    }
    return storyEntry;
  }
  importPathToEntry(importPath) {
    return getImportPathMap(this.entries)[importPath];
  }
};
__name(_StoryIndexStore, "StoryIndexStore");
var StoryIndexStore = _StoryIndexStore;

// src/preview-api/modules/store/csf/normalizeInputTypes.ts
var normalizeType = /* @__PURE__ */ __name((type5) => {
  return typeof type5 === "string" ? { name: type5 } : type5;
}, "normalizeType");
var normalizeControl = /* @__PURE__ */ __name((control) => typeof control === "string" ? { type: control } : control, "normalizeControl");
var normalizeInputType = /* @__PURE__ */ __name((inputType, key) => {
  const { type: type5, control, ...rest } = inputType;
  const normalized = {
    name: key,
    ...rest
  };
  if (type5) {
    normalized.type = normalizeType(type5);
  }
  if (control) {
    normalized.control = normalizeControl(control);
  } else if (control === false) {
    normalized.control = { disable: true };
  }
  return normalized;
}, "normalizeInputType");
var normalizeInputTypes = /* @__PURE__ */ __name((inputTypes) => mapValues(inputTypes, normalizeInputType), "normalizeInputTypes");

// src/preview-api/modules/store/csf/normalizeArrays.ts
var normalizeArrays = /* @__PURE__ */ __name((array) => {
  if (Array.isArray(array)) {
    return array;
  }
  return array ? [array] : [];
}, "normalizeArrays");

// src/preview-api/modules/store/csf/normalizeStory.ts
var deprecatedStoryAnnotation = dedent`
CSF .story annotations deprecated; annotate story functions directly:
- StoryFn.story.name => StoryFn.storyName
- StoryFn.story.(parameters|decorators) => StoryFn.(parameters|decorators)
See https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#hoisted-csf-annotations for details and codemod.
`;
function normalizeStory(key, storyAnnotations, meta) {
  const storyObject = storyAnnotations;
  const userStoryFn = typeof storyAnnotations === "function" ? storyAnnotations : null;
  const { story } = storyObject;
  if (story) {
    logger.debug("deprecated story", story);
    deprecate(deprecatedStoryAnnotation);
  }
  const exportName = storyNameFromExport(key);
  const name = typeof storyObject !== "function" && storyObject.name || storyObject.storyName || story?.name || exportName;
  const decorators4 = [
    ...normalizeArrays(storyObject.decorators),
    ...normalizeArrays(story?.decorators)
  ];
  const parameters2 = { ...story?.parameters, ...storyObject.parameters };
  const args = { ...story?.args, ...storyObject.args };
  const argTypes = { ...story?.argTypes, ...storyObject.argTypes };
  const loaders2 = [...normalizeArrays(storyObject.loaders), ...normalizeArrays(story?.loaders)];
  const beforeEach = [
    ...normalizeArrays(storyObject.beforeEach),
    ...normalizeArrays(story?.beforeEach)
  ];
  const afterEach = [
    ...normalizeArrays(storyObject.afterEach),
    ...normalizeArrays(story?.afterEach)
  ];
  const { render, play, tags = [], globals = {} } = storyObject;
  const id = parameters2.__id || toId(meta.id, exportName);
  return {
    moduleExport: storyAnnotations,
    id,
    name,
    tags,
    decorators: decorators4,
    parameters: parameters2,
    args,
    argTypes: normalizeInputTypes(argTypes),
    loaders: loaders2,
    beforeEach,
    afterEach,
    globals,
    ...render && { render },
    ...userStoryFn && { userStoryFn },
    ...play && { play }
  };
}
__name(normalizeStory, "normalizeStory");

// src/preview-api/modules/store/csf/normalizeComponentAnnotations.ts
function normalizeComponentAnnotations(defaultExport, title = defaultExport.title, importPath) {
  const { id, argTypes } = defaultExport;
  return {
    id: sanitize(id || title),
    ...defaultExport,
    title,
    ...argTypes && { argTypes: normalizeInputTypes(argTypes) },
    parameters: {
      fileName: importPath,
      ...defaultExport.parameters
    }
  };
}
__name(normalizeComponentAnnotations, "normalizeComponentAnnotations");

// src/preview-api/modules/store/csf/processCSFFile.ts
var checkGlobals = /* @__PURE__ */ __name((parameters2) => {
  const { globals, globalTypes } = parameters2;
  if (globals || globalTypes) {
    logger.error(
      "Global args/argTypes can only be set globally",
      JSON.stringify({
        globals,
        globalTypes
      })
    );
  }
}, "checkGlobals");
var checkStorySort = /* @__PURE__ */ __name((parameters2) => {
  const { options } = parameters2;
  if (options?.storySort) {
    logger.error("The storySort option parameter can only be set globally");
  }
}, "checkStorySort");
var checkDisallowedParameters = /* @__PURE__ */ __name((parameters2) => {
  if (!parameters2) {
    return;
  }
  checkGlobals(parameters2);
  checkStorySort(parameters2);
}, "checkDisallowedParameters");
function processCSFFile(moduleExports, importPath, title) {
  const { default: defaultExport, __namedExportsOrder, ...namedExports } = moduleExports;
  const firstStory = Object.values(namedExports)[0];
  if (isStory(firstStory)) {
    const meta2 = normalizeComponentAnnotations(firstStory.meta.input, title, importPath);
    checkDisallowedParameters(meta2.parameters);
    const csfFile2 = { meta: meta2, stories: {}, moduleExports };
    Object.keys(namedExports).forEach((key) => {
      if (isExportStory(key, meta2)) {
        const story = namedExports[key];
        const storyMeta = normalizeStory(key, story.input, meta2);
        checkDisallowedParameters(storyMeta.parameters);
        csfFile2.stories[storyMeta.id] = storyMeta;
        getStoryChildren(story).forEach((child) => {
          const name = child.input.name;
          const childId = toTestId(storyMeta.id, name);
          child.input.parameters ??= {};
          child.input.parameters.__id = childId;
          csfFile2.stories[childId] = normalizeStory(name, child.input, meta2);
        });
      }
    });
    csfFile2.projectAnnotations = firstStory.meta.preview.composed;
    return csfFile2;
  }
  const meta = normalizeComponentAnnotations(
    defaultExport,
    title,
    importPath
  );
  checkDisallowedParameters(meta.parameters);
  const csfFile = { meta, stories: {}, moduleExports };
  Object.keys(namedExports).forEach((key) => {
    if (isExportStory(key, meta)) {
      const storyMeta = normalizeStory(key, namedExports[key], meta);
      checkDisallowedParameters(storyMeta.parameters);
      csfFile.stories[storyMeta.id] = storyMeta;
    }
  });
  return csfFile;
}
__name(processCSFFile, "processCSFFile");

// src/preview-api/modules/store/decorators.ts
function decorateStory(storyFn, decorator, bindWithContext) {
  const boundStoryFunction = bindWithContext(storyFn);
  return (context) => decorator(boundStoryFunction, context);
}
__name(decorateStory, "decorateStory");
function sanitizeStoryContextUpdate({
  componentId,
  title,
  kind,
  id,
  name,
  story,
  parameters: parameters2,
  initialArgs,
  argTypes,
  ...update
} = {}) {
  return update;
}
__name(sanitizeStoryContextUpdate, "sanitizeStoryContextUpdate");
function defaultDecorateStory(storyFn, decorators4) {
  const contextStore = {};
  const bindWithContext = /* @__PURE__ */ __name((decoratedStoryFn) => (update) => {
    if (!contextStore.value) {
      throw new Error("Decorated function called without init");
    }
    contextStore.value = {
      ...contextStore.value,
      ...sanitizeStoryContextUpdate(update)
    };
    return decoratedStoryFn(contextStore.value);
  }, "bindWithContext");
  const decoratedWithContextStore = decorators4.reduce(
    (story, decorator) => decorateStory(story, decorator, bindWithContext),
    storyFn
  );
  return (context) => {
    contextStore.value = context;
    return decoratedWithContextStore(context);
  };
}
__name(defaultDecorateStory, "defaultDecorateStory");

// src/preview-api/modules/store/parameters.ts
var combineParameters = /* @__PURE__ */ __name((...parameterSets) => {
  const mergeKeys = {};
  const definedParametersSets = parameterSets.filter(Boolean);
  const combined = definedParametersSets.reduce((acc, parameters2) => {
    Object.entries(parameters2).forEach(([key, value]) => {
      const existing = acc[key];
      if (Array.isArray(value) || typeof existing === "undefined") {
        acc[key] = value;
      } else if (isPlainObject(value) && isPlainObject(existing)) {
        mergeKeys[key] = true;
      } else if (typeof value !== "undefined") {
        acc[key] = value;
      }
    });
    return acc;
  }, {});
  Object.keys(mergeKeys).forEach((key) => {
    const mergeValues = definedParametersSets.filter(Boolean).map((p2) => p2[key]).filter((value) => typeof value !== "undefined");
    if (mergeValues.every((value) => isPlainObject(value))) {
      combined[key] = combineParameters(...mergeValues);
    } else {
      combined[key] = mergeValues[mergeValues.length - 1];
    }
  });
  return combined;
}, "combineParameters");

// src/preview-api/modules/store/csf/prepareStory.ts
function prepareStory(storyAnnotations, componentAnnotations, projectAnnotations) {
  const { moduleExport, id, name } = storyAnnotations || {};
  const partialAnnotations = preparePartialAnnotations(
    storyAnnotations,
    componentAnnotations,
    projectAnnotations
  );
  const applyLoaders = /* @__PURE__ */ __name(async (context) => {
    const loaded = {};
    for (const loaders2 of [
      normalizeArrays(projectAnnotations.loaders),
      normalizeArrays(componentAnnotations.loaders),
      normalizeArrays(storyAnnotations.loaders)
    ]) {
      if (context.abortSignal.aborted) {
        return loaded;
      }
      const loadResults = await Promise.all(loaders2.map((loader) => loader(context)));
      Object.assign(loaded, ...loadResults);
    }
    return loaded;
  }, "applyLoaders");
  const applyBeforeEach = /* @__PURE__ */ __name(async (context) => {
    const cleanupCallbacks = new Array();
    for (const beforeEach of [
      ...normalizeArrays(projectAnnotations.beforeEach),
      ...normalizeArrays(componentAnnotations.beforeEach),
      ...normalizeArrays(storyAnnotations.beforeEach)
    ]) {
      if (context.abortSignal.aborted) {
        return cleanupCallbacks;
      }
      const cleanup = await beforeEach(context);
      if (cleanup) {
        cleanupCallbacks.push(cleanup);
      }
    }
    return cleanupCallbacks;
  }, "applyBeforeEach");
  const applyAfterEach = /* @__PURE__ */ __name(async (context) => {
    const reversedFinalizers = [
      ...normalizeArrays(projectAnnotations.afterEach),
      ...normalizeArrays(componentAnnotations.afterEach),
      ...normalizeArrays(storyAnnotations.afterEach)
    ].reverse();
    for (const finalizer of reversedFinalizers) {
      if (context.abortSignal.aborted) {
        return;
      }
      await finalizer(context);
    }
  }, "applyAfterEach");
  const undecoratedStoryFn = /* @__PURE__ */ __name((context) => context.originalStoryFn(context.args, context), "undecoratedStoryFn");
  const { applyDecorators = defaultDecorateStory, runStep } = projectAnnotations;
  const decorators4 = [
    ...normalizeArrays(storyAnnotations?.decorators),
    ...normalizeArrays(componentAnnotations?.decorators),
    ...normalizeArrays(projectAnnotations?.decorators)
  ];
  const render = storyAnnotations?.userStoryFn || storyAnnotations?.render || componentAnnotations.render || projectAnnotations.render;
  const decoratedStoryFn = applyHooks(applyDecorators)(undecoratedStoryFn, decorators4);
  const unboundStoryFn = /* @__PURE__ */ __name((context) => decoratedStoryFn(context), "unboundStoryFn");
  const playFunction = storyAnnotations?.play ?? componentAnnotations?.play;
  const usesMount = mountDestructured(playFunction);
  if (!render && !usesMount) {
    throw new NoRenderFunctionError({ id });
  }
  const defaultMount = /* @__PURE__ */ __name((context) => {
    return async () => {
      await context.renderToCanvas();
      return context.canvas;
    };
  }, "defaultMount");
  const mount = storyAnnotations.mount ?? componentAnnotations.mount ?? projectAnnotations.mount ?? defaultMount;
  const testingLibraryRender = projectAnnotations.testingLibraryRender;
  return {
    storyGlobals: {},
    ...partialAnnotations,
    moduleExport,
    id,
    name,
    story: name,
    originalStoryFn: render,
    undecoratedStoryFn,
    unboundStoryFn,
    applyLoaders,
    applyBeforeEach,
    applyAfterEach,
    playFunction,
    runStep,
    mount,
    testingLibraryRender,
    renderToCanvas: projectAnnotations.renderToCanvas,
    usesMount
  };
}
__name(prepareStory, "prepareStory");
function prepareMeta(componentAnnotations, projectAnnotations, moduleExport) {
  return {
    ...preparePartialAnnotations(void 0, componentAnnotations, projectAnnotations),
    moduleExport
  };
}
__name(prepareMeta, "prepareMeta");
function preparePartialAnnotations(storyAnnotations, componentAnnotations, projectAnnotations) {
  const defaultTags = ["dev", "test"];
  const extraTags = scope.DOCS_OPTIONS?.autodocs === true ? ["autodocs"] : [];
  const overrideTags = storyAnnotations?.tags?.includes("test-fn") ? ["!autodocs"] : [];
  const tags = combineTags(
    ...defaultTags,
    ...extraTags,
    ...projectAnnotations.tags ?? [],
    ...componentAnnotations.tags ?? [],
    ...overrideTags,
    ...storyAnnotations?.tags ?? []
  );
  const parameters2 = combineParameters(
    projectAnnotations.parameters,
    componentAnnotations.parameters,
    storyAnnotations?.parameters
  );
  const { argTypesEnhancers = [], argsEnhancers: argsEnhancers2 = [] } = projectAnnotations;
  const passedArgTypes = combineParameters(
    projectAnnotations.argTypes,
    componentAnnotations.argTypes,
    storyAnnotations?.argTypes
  );
  if (storyAnnotations) {
    const render = storyAnnotations?.userStoryFn || storyAnnotations?.render || componentAnnotations.render || projectAnnotations.render;
    parameters2.__isArgsStory = render && render.length > 0;
  }
  const passedArgs = {
    ...projectAnnotations.args,
    ...componentAnnotations.args,
    ...storyAnnotations?.args
  };
  const storyGlobals = {
    ...componentAnnotations.globals,
    ...storyAnnotations?.globals
  };
  const contextForEnhancers = {
    componentId: componentAnnotations.id,
    title: componentAnnotations.title,
    kind: componentAnnotations.title,
    // Back compat
    id: storyAnnotations?.id || componentAnnotations.id,
    // if there's no story name, we create a fake one since enhancers expect a name
    name: storyAnnotations?.name || "__meta",
    story: storyAnnotations?.name || "__meta",
    // Back compat
    component: componentAnnotations.component,
    subcomponents: componentAnnotations.subcomponents,
    tags,
    parameters: parameters2,
    initialArgs: passedArgs,
    argTypes: passedArgTypes,
    storyGlobals
  };
  contextForEnhancers.argTypes = argTypesEnhancers.reduce(
    (accumulatedArgTypes, enhancer) => enhancer({ ...contextForEnhancers, argTypes: accumulatedArgTypes }),
    contextForEnhancers.argTypes
  );
  const initialArgsBeforeEnhancers = { ...passedArgs };
  contextForEnhancers.initialArgs = [...argsEnhancers2].reduce(
    (accumulatedArgs, enhancer) => ({
      ...accumulatedArgs,
      ...enhancer({
        ...contextForEnhancers,
        initialArgs: accumulatedArgs
      })
    }),
    initialArgsBeforeEnhancers
  );
  const { name, story, ...withoutStoryIdentifiers } = contextForEnhancers;
  return withoutStoryIdentifiers;
}
__name(preparePartialAnnotations, "preparePartialAnnotations");
function prepareContext(context) {
  const { args: unmappedArgs } = context;
  let targetedContext = {
    ...context,
    allArgs: void 0,
    argsByTarget: void 0
  };
  if (scope.FEATURES?.argTypeTargetsV7) {
    const argsByTarget = groupArgsByTarget(context);
    targetedContext = {
      ...context,
      allArgs: context.args,
      argsByTarget,
      args: argsByTarget[UNTARGETED] || {}
    };
  }
  const mappedArgs = Object.entries(targetedContext.args).reduce((acc, [key, val]) => {
    if (!targetedContext.argTypes[key]?.mapping) {
      acc[key] = val;
      return acc;
    }
    const mappingFn = /* @__PURE__ */ __name((originalValue) => {
      const mapping = targetedContext.argTypes[key].mapping;
      return mapping && originalValue in mapping ? mapping[originalValue] : originalValue;
    }, "mappingFn");
    acc[key] = Array.isArray(val) ? val.map(mappingFn) : mappingFn(val);
    return acc;
  }, {});
  const includedArgs = Object.entries(mappedArgs).reduce((acc, [key, val]) => {
    const argType = targetedContext.argTypes[key] || {};
    if (includeConditionalArg(argType, mappedArgs, targetedContext.globals)) {
      acc[key] = val;
    }
    return acc;
  }, {});
  return { ...targetedContext, unmappedArgs, args: includedArgs };
}
__name(prepareContext, "prepareContext");

// src/preview-api/modules/store/inferArgTypes.ts
var inferType = /* @__PURE__ */ __name((value, name, visited) => {
  const type5 = typeof value;
  switch (type5) {
    case "boolean":
    case "string":
    case "number":
    case "function":
    case "symbol":
      return { name: type5 };
    default:
      break;
  }
  if (value) {
    if (visited.has(value)) {
      logger.warn(dedent`
        We've detected a cycle in arg '${name}'. Args should be JSON-serializable.

        Consider using the mapping feature or fully custom args:
        - Mapping: https://storybook.js.org/docs/writing-stories/args#mapping-to-complex-arg-values
        - Custom args: https://storybook.js.org/docs/essentials/controls#fully-custom-args
      `);
      return { name: "other", value: "cyclic object" };
    }
    visited.add(value);
    if (Array.isArray(value)) {
      const childType = value.length > 0 ? inferType(value[0], name, new Set(visited)) : { name: "other", value: "unknown" };
      return { name: "array", value: childType };
    }
    const fieldTypes = mapValues(value, (field) => inferType(field, name, new Set(visited)));
    return { name: "object", value: fieldTypes };
  }
  return { name: "object", value: {} };
}, "inferType");
var inferArgTypes = /* @__PURE__ */ __name((context) => {
  const { id, argTypes: userArgTypes = {}, initialArgs = {} } = context;
  const argTypes = mapValues(initialArgs, (arg, key) => ({
    name: key,
    type: inferType(arg, `${id}.${key}`, /* @__PURE__ */ new Set())
  }));
  const userArgTypesNames = mapValues(userArgTypes, (argType, key) => ({
    name: key
  }));
  return combineParameters(argTypes, userArgTypesNames, userArgTypes);
}, "inferArgTypes");
inferArgTypes.secondPass = true;

// src/preview-api/modules/store/filterArgTypes.ts
var matches4 = /* @__PURE__ */ __name((name, descriptor) => Array.isArray(descriptor) ? descriptor.includes(name) : name.match(descriptor), "matches");
var filterArgTypes = /* @__PURE__ */ __name((argTypes, include2, exclude) => {
  if (!include2 && !exclude) {
    return argTypes;
  }
  return argTypes && pickBy(argTypes, (argType, key) => {
    const name = argType.name || key.toString();
    return !!(!include2 || matches4(name, include2)) && (!exclude || !matches4(name, exclude));
  });
}, "filterArgTypes");

// src/preview-api/modules/store/inferControls.ts
var inferControl = /* @__PURE__ */ __name((argType, name, matchers) => {
  const { type: type5, options } = argType;
  if (!type5) {
    return void 0;
  }
  if (matchers.color && matchers.color.test(name)) {
    const controlType = type5.name;
    if (controlType === "string") {
      return { control: { type: "color" } };
    }
    if (controlType !== "enum") {
      logger.warn(
        `Addon controls: Control of type color only supports string, received "${controlType}" instead`
      );
    }
  }
  if (matchers.date && matchers.date.test(name)) {
    return { control: { type: "date" } };
  }
  switch (type5.name) {
    case "array":
      return { control: { type: "object" } };
    case "boolean":
      return { control: { type: "boolean" } };
    case "string":
      return { control: { type: "text" } };
    case "number":
      return { control: { type: "number" } };
    case "enum": {
      const { value } = type5;
      return { control: { type: value?.length <= 5 ? "radio" : "select" }, options: value };
    }
    case "function":
    case "symbol":
      return null;
    default:
      return { control: { type: options ? "select" : "object" } };
  }
}, "inferControl");
var inferControls = /* @__PURE__ */ __name((context) => {
  const {
    argTypes,
    parameters: { __isArgsStory, controls: { include: include2 = null, exclude = null, matchers = {} } = {} }
  } = context;
  if (!__isArgsStory) {
    return argTypes;
  }
  const filteredArgTypes = filterArgTypes(argTypes, include2, exclude);
  const withControls = mapValues(filteredArgTypes, (argType, name) => {
    return argType?.type && inferControl(argType, name.toString(), matchers);
  });
  return combineParameters(withControls, filteredArgTypes);
}, "inferControls");
inferControls.secondPass = true;

// src/preview-api/modules/store/csf/normalizeProjectAnnotations.ts
function normalizeProjectAnnotations({
  argTypes,
  globalTypes,
  argTypesEnhancers,
  decorators: decorators4,
  loaders: loaders2,
  beforeEach,
  afterEach,
  initialGlobals: initialGlobals5,
  ...annotations
}) {
  return {
    ...argTypes && { argTypes: normalizeInputTypes(argTypes) },
    ...globalTypes && { globalTypes: normalizeInputTypes(globalTypes) },
    decorators: normalizeArrays(decorators4),
    loaders: normalizeArrays(loaders2),
    beforeEach: normalizeArrays(beforeEach),
    afterEach: normalizeArrays(afterEach),
    argTypesEnhancers: [
      ...argTypesEnhancers || [],
      inferArgTypes,
      // There's an architectural decision to be made regarding embedded addons in core:
      //
      // Option 1: Keep embedded addons but ensure consistency by moving addon-specific code
      // (like inferControls) to live alongside the addon code itself. This maintains the
      // concept of core addons while improving code organization.
      //
      // Option 2: Fully integrate these addons into core, potentially moving UI components
      // into the manager and treating them as core features rather than addons. This is a
      // bigger architectural change requiring careful consideration.
      //
      // For now, we're keeping inferControls here as we need time to properly evaluate
      // these options and their implications. Some features (like Angular's cleanArgsDecorator)
      // currently rely on this behavior.
      //
      // TODO: Make an architectural decision on the handling of core addons
      inferControls
    ],
    initialGlobals: initialGlobals5,
    ...annotations
  };
}
__name(normalizeProjectAnnotations, "normalizeProjectAnnotations");

// src/preview-api/modules/store/csf/beforeAll.ts
var composeBeforeAllHooks = /* @__PURE__ */ __name((hooks) => {
  return async () => {
    const cleanups2 = [];
    for (const hook of hooks) {
      const cleanup = await hook();
      if (cleanup) {
        cleanups2.unshift(cleanup);
      }
    }
    return async () => {
      for (const cleanup of cleanups2) {
        await cleanup();
      }
    };
  };
}, "composeBeforeAllHooks");

// src/preview-api/modules/store/csf/stepRunners.ts
function composeStepRunners(stepRunners) {
  return async (label, play, playContext) => {
    const composedPlay = stepRunners.reduceRight(
      (innerPlay, stepRunner) => async () => stepRunner(label, innerPlay, playContext),
      async () => play(playContext)
    );
    await composedPlay();
  };
}
__name(composeStepRunners, "composeStepRunners");

// src/preview-api/modules/store/csf/composeConfigs.ts
function getField(moduleExportList, field) {
  return moduleExportList.map((xs) => xs.default?.[field] ?? xs[field]).filter(Boolean);
}
__name(getField, "getField");
function getArrayField(moduleExportList, field, options = {}) {
  return getField(moduleExportList, field).reduce((prev, cur) => {
    const normalized = normalizeArrays(cur);
    return options.reverseFileOrder ? [...normalized, ...prev] : [...prev, ...normalized];
  }, []);
}
__name(getArrayField, "getArrayField");
function getObjectField(moduleExportList, field) {
  return Object.assign({}, ...getField(moduleExportList, field));
}
__name(getObjectField, "getObjectField");
function getSingletonField(moduleExportList, field) {
  return getField(moduleExportList, field).pop();
}
__name(getSingletonField, "getSingletonField");
function composeConfigs(moduleExportList) {
  const allArgTypeEnhancers = getArrayField(moduleExportList, "argTypesEnhancers");
  const stepRunners = getField(moduleExportList, "runStep");
  const beforeAllHooks = getArrayField(moduleExportList, "beforeAll");
  return {
    parameters: combineParameters(...getField(moduleExportList, "parameters")),
    decorators: getArrayField(moduleExportList, "decorators", {
      reverseFileOrder: !(scope.FEATURES?.legacyDecoratorFileOrder ?? false)
    }),
    args: getObjectField(moduleExportList, "args"),
    argsEnhancers: getArrayField(moduleExportList, "argsEnhancers"),
    argTypes: getObjectField(moduleExportList, "argTypes"),
    argTypesEnhancers: [
      ...allArgTypeEnhancers.filter((e2) => !e2.secondPass),
      ...allArgTypeEnhancers.filter((e2) => e2.secondPass)
    ],
    initialGlobals: getObjectField(moduleExportList, "initialGlobals"),
    globalTypes: getObjectField(moduleExportList, "globalTypes"),
    loaders: getArrayField(moduleExportList, "loaders"),
    beforeAll: composeBeforeAllHooks(beforeAllHooks),
    beforeEach: getArrayField(moduleExportList, "beforeEach"),
    afterEach: getArrayField(moduleExportList, "afterEach"),
    render: getSingletonField(moduleExportList, "render"),
    renderToCanvas: getSingletonField(moduleExportList, "renderToCanvas"),
    applyDecorators: getSingletonField(moduleExportList, "applyDecorators"),
    runStep: composeStepRunners(stepRunners),
    tags: getArrayField(moduleExportList, "tags"),
    mount: getSingletonField(moduleExportList, "mount"),
    testingLibraryRender: getSingletonField(moduleExportList, "testingLibraryRender")
  };
}
__name(composeConfigs, "composeConfigs");

// src/preview-api/modules/preview-web/render/animation-utils.ts
var ANIMATION_TIMEOUT = 5e3;
function isTestEnvironment() {
  try {
    return (
      // @ts-expect-error This property exists in Vitest browser mode
      !!globalThis.__vitest_browser__ || !!globalThis.window?.navigator?.userAgent?.match(/StorybookTestRunner/)
    );
  } catch {
    return false;
  }
}
__name(isTestEnvironment, "isTestEnvironment");
function pauseAnimations(atEnd = true) {
  if (!("document" in globalThis && "createElement" in globalThis.document)) {
    return () => {
    };
  }
  const disableStyle = document.createElement("style");
  disableStyle.textContent = `*, *:before, *:after {
    animation: none !important;
  }`;
  document.head.appendChild(disableStyle);
  const pauseStyle = document.createElement("style");
  pauseStyle.textContent = `*, *:before, *:after {
    animation-delay: 0s !important;
    animation-direction: ${atEnd ? "reverse" : "normal"} !important;
    animation-play-state: paused !important;
    transition: none !important;
  }`;
  document.head.appendChild(pauseStyle);
  document.body.clientHeight;
  document.head.removeChild(disableStyle);
  return () => {
    pauseStyle.parentNode?.removeChild(pauseStyle);
  };
}
__name(pauseAnimations, "pauseAnimations");
async function waitForAnimations(signal) {
  if (!("document" in globalThis && "getAnimations" in globalThis.document && "querySelectorAll" in globalThis.document)) {
    return;
  }
  let timedOut = false;
  await Promise.race([
    // After 50ms, retrieve any running animations and wait for them to finish
    // If new animations are created while waiting, we'll wait for them too
    new Promise((resolve) => {
      setTimeout(() => {
        const animationRoots = [globalThis.document, ...getShadowRoots(globalThis.document)];
        const checkAnimationsFinished = /* @__PURE__ */ __name(async () => {
          if (timedOut || signal?.aborted) {
            return;
          }
          const runningAnimations = animationRoots.flatMap((el) => el?.getAnimations?.() || []).filter((a2) => a2.playState === "running" && !isInfiniteAnimation(a2));
          if (runningAnimations.length > 0) {
            await Promise.all(runningAnimations.map((a2) => a2.finished));
            await checkAnimationsFinished();
          }
        }, "checkAnimationsFinished");
        checkAnimationsFinished().then(resolve);
      }, 100);
    }),
    // If animations don't finish within the timeout, continue without waiting
    new Promise(
      (resolve) => setTimeout(() => {
        timedOut = true;
        resolve(void 0);
      }, ANIMATION_TIMEOUT)
    )
  ]);
}
__name(waitForAnimations, "waitForAnimations");
function getShadowRoots(doc) {
  return [doc, ...doc.querySelectorAll("*")].reduce((acc, el) => {
    if ("shadowRoot" in el && el.shadowRoot) {
      acc.push(el.shadowRoot, ...getShadowRoots(el.shadowRoot));
    }
    return acc;
  }, []);
}
__name(getShadowRoots, "getShadowRoots");
function isInfiniteAnimation(anim) {
  if (anim instanceof CSSAnimation && anim.effect instanceof KeyframeEffect && anim.effect.target) {
    const style = getComputedStyle(anim.effect.target, anim.effect.pseudoElement);
    const index2 = style.animationName?.split(", ").indexOf(anim.animationName);
    const iterations = style.animationIterationCount.split(", ")[index2];
    return iterations === "infinite";
  }
  return false;
}
__name(isInfiniteAnimation, "isInfiniteAnimation");

// src/preview-api/modules/store/reporter-api.ts
var _ReporterAPI = class _ReporterAPI {
  constructor() {
    this.reports = [];
  }
  async addReport(report) {
    this.reports.push(report);
  }
};
__name(_ReporterAPI, "ReporterAPI");
var ReporterAPI = _ReporterAPI;

// src/preview-api/modules/store/csf/csf-factory-utils.ts
function getCsfFactoryAnnotations(story, meta, projectAnnotations) {
  return isStory(story) ? {
    story: story.input,
    meta: story.meta.input,
    preview: story.meta.preview.composed
  } : { story, meta: isMeta(meta) ? meta.input : meta, preview: projectAnnotations };
}
__name(getCsfFactoryAnnotations, "getCsfFactoryAnnotations");

// src/preview-api/modules/store/csf/portable-stories.ts
function setDefaultProjectAnnotations(_defaultProjectAnnotations) {
  globalThis.defaultProjectAnnotations = _defaultProjectAnnotations;
}
__name(setDefaultProjectAnnotations, "setDefaultProjectAnnotations");
var DEFAULT_STORY_TITLE = "ComposedStory";
var DEFAULT_STORY_NAME = "Unnamed Story";
function extractAnnotation(annotation) {
  if (!annotation) {
    return {};
  }
  return composeConfigs([annotation]);
}
__name(extractAnnotation, "extractAnnotation");
function setProjectAnnotations(projectAnnotations) {
  const annotations = Array.isArray(projectAnnotations) ? projectAnnotations : [projectAnnotations];
  globalThis.globalProjectAnnotations = composeConfigs([
    ...getCoreAnnotations(),
    globalThis.defaultProjectAnnotations ?? {},
    composeConfigs(annotations.map(extractAnnotation))
  ]);
  return globalThis.globalProjectAnnotations ?? {};
}
__name(setProjectAnnotations, "setProjectAnnotations");
var cleanups = [];
function composeStory(storyAnnotations, componentAnnotations, projectAnnotations, defaultConfig, exportsName) {
  if (storyAnnotations === void 0) {
    throw new Error("Expected a story but received undefined.");
  }
  componentAnnotations.title = componentAnnotations.title ?? DEFAULT_STORY_TITLE;
  const normalizedComponentAnnotations = normalizeComponentAnnotations(componentAnnotations);
  const storyName = exportsName || storyAnnotations.storyName || storyAnnotations.story?.name || storyAnnotations.name || DEFAULT_STORY_NAME;
  const normalizedStory = normalizeStory(
    storyName,
    storyAnnotations,
    normalizedComponentAnnotations
  );
  const normalizedProjectAnnotations = normalizeProjectAnnotations(
    composeConfigs([
      defaultConfig ?? globalThis.globalProjectAnnotations ?? {},
      projectAnnotations ?? {}
    ])
  );
  const story = prepareStory(
    normalizedStory,
    normalizedComponentAnnotations,
    normalizedProjectAnnotations
  );
  const globalsFromGlobalTypes = getValuesFromArgTypes(normalizedProjectAnnotations.globalTypes);
  const globals = {
    ...globalsFromGlobalTypes,
    ...normalizedProjectAnnotations.initialGlobals,
    ...story.storyGlobals
  };
  const reporting = new ReporterAPI();
  const initializeContext = /* @__PURE__ */ __name(() => {
    const context = prepareContext({
      hooks: new HooksContext(),
      globals,
      args: { ...story.initialArgs },
      viewMode: "story",
      reporting,
      loaded: {},
      abortSignal: new AbortController().signal,
      step: /* @__PURE__ */ __name((label, play2) => story.runStep(label, play2, context), "step"),
      canvasElement: null,
      canvas: {},
      userEvent: {},
      globalTypes: normalizedProjectAnnotations.globalTypes,
      ...story,
      context: null,
      mount: null
    });
    context.parameters.__isPortableStory = true;
    context.context = context;
    if (story.renderToCanvas) {
      context.renderToCanvas = async () => {
        const unmount = await story.renderToCanvas?.(
          {
            componentId: story.componentId,
            title: story.title,
            id: story.id,
            name: story.name,
            tags: story.tags,
            showMain: /* @__PURE__ */ __name(() => {
            }, "showMain"),
            showError: /* @__PURE__ */ __name((error) => {
              throw new Error(`${error.title}
${error.description}`);
            }, "showError"),
            showException: /* @__PURE__ */ __name((error) => {
              throw error;
            }, "showException"),
            forceRemount: true,
            storyContext: context,
            storyFn: /* @__PURE__ */ __name(() => story.unboundStoryFn(context), "storyFn"),
            unboundStoryFn: story.unboundStoryFn
          },
          context.canvasElement
        );
        if (unmount) {
          cleanups.push(unmount);
        }
      };
    }
    context.mount = story.mount(context);
    return context;
  }, "initializeContext");
  let loadedContext;
  const play = /* @__PURE__ */ __name(async (extraContext) => {
    const context = initializeContext();
    context.canvasElement ??= globalThis?.document?.body;
    if (loadedContext) {
      context.loaded = loadedContext.loaded;
    }
    Object.assign(context, extraContext);
    return story.playFunction(context);
  }, "play");
  const run = /* @__PURE__ */ __name((extraContext) => {
    const context = initializeContext();
    Object.assign(context, extraContext);
    return runStory(story, context);
  }, "run");
  const playFunction = story.playFunction ? play : void 0;
  const composedStory = Object.assign(
    /* @__PURE__ */ __name(function storyFn(extraArgs) {
      const context = initializeContext();
      if (loadedContext) {
        context.loaded = loadedContext.loaded;
      }
      context.args = {
        ...context.initialArgs,
        ...extraArgs
      };
      return story.unboundStoryFn(context);
    }, "storyFn"),
    {
      id: story.id,
      storyName,
      load: /* @__PURE__ */ __name(async () => {
        for (const callback of [...cleanups].reverse()) {
          await callback();
        }
        cleanups.length = 0;
        const context = initializeContext();
        context.loaded = await story.applyLoaders(context);
        cleanups.push(...(await story.applyBeforeEach(context)).filter(Boolean));
        loadedContext = context;
      }, "load"),
      globals,
      args: story.initialArgs,
      parameters: story.parameters,
      argTypes: story.argTypes,
      play: playFunction,
      run,
      reporting,
      tags: story.tags
    }
  );
  return composedStory;
}
__name(composeStory, "composeStory");
var defaultComposeStory = /* @__PURE__ */ __name((story, component, project, exportsName) => composeStory(story, component, project, {}, exportsName), "defaultComposeStory");
function composeStories(storiesImport, globalConfig, composeStoryFn = defaultComposeStory) {
  const { default: metaExport, __esModule, __namedExportsOrder, ...stories } = storiesImport;
  let meta = metaExport;
  const composedStories = Object.entries(stories).reduce(
    (storiesMap, [exportsName, story]) => {
      const { story: storyAnnotations, meta: componentAnnotations } = getCsfFactoryAnnotations(story);
      if (!meta && componentAnnotations) {
        meta = componentAnnotations;
      }
      if (!isExportStory(exportsName, meta)) {
        return storiesMap;
      }
      const result = Object.assign(storiesMap, {
        [exportsName]: composeStoryFn(storyAnnotations, meta, globalConfig, exportsName)
      });
      return result;
    },
    {}
  );
  return composedStories;
}
__name(composeStories, "composeStories");
function createPlaywrightTest(baseTest) {
  return baseTest.extend({
    mount: /* @__PURE__ */ __name(async ({ mount, page }, use2) => {
      await use2(async (storyRef, ...restArgs) => {
        if (!("__pw_type" in storyRef) || "__pw_type" in storyRef && storyRef.__pw_type !== "jsx") {
          throw new Error(dedent`
              Portable stories in Playwright CT only work when referencing JSX elements.
              Please use JSX format for your components such as:

              instead of:
              await mount(MyComponent, { props: { foo: 'bar' } })

              do:
              await mount(<MyComponent foo="bar"/>)

              More info: https://storybook.js.org/docs/api/portable-stories/portable-stories-playwright?ref=error
            `);
        }
        const { props, ...storyRefWithoutProps } = storyRef;
        await page.evaluate(async (wrappedStoryRef) => {
          const unwrappedStoryRef = await globalThis.__pwUnwrapObject?.(wrappedStoryRef);
          const story = "__pw_type" in unwrappedStoryRef ? unwrappedStoryRef.type : unwrappedStoryRef;
          return story?.load?.();
        }, storyRefWithoutProps);
        const mountResult = await mount(storyRef, ...restArgs);
        await page.evaluate(async (wrappedStoryRef) => {
          const unwrappedStoryRef = await globalThis.__pwUnwrapObject?.(wrappedStoryRef);
          const story = "__pw_type" in unwrappedStoryRef ? unwrappedStoryRef.type : unwrappedStoryRef;
          const canvasElement = document.querySelector("#root");
          return story?.play?.({ canvasElement });
        }, storyRefWithoutProps);
        return mountResult;
      });
    }, "mount")
  });
}
__name(createPlaywrightTest, "createPlaywrightTest");
async function runStory(story, context) {
  for (const callback of [...cleanups].reverse()) {
    await callback();
  }
  cleanups.length = 0;
  if (!context.canvasElement) {
    const container = document.createElement("div");
    globalThis?.document?.body?.appendChild(container);
    context.canvasElement = container;
    cleanups.push(() => {
      if (globalThis?.document?.body?.contains(container)) {
        globalThis?.document?.body?.removeChild(container);
      }
    });
  }
  context.loaded = await story.applyLoaders(context);
  if (context.abortSignal.aborted) {
    return;
  }
  cleanups.push(...(await story.applyBeforeEach(context)).filter(Boolean));
  const playFunction = story.playFunction;
  const isMountDestructured = story.usesMount;
  if (!isMountDestructured) {
    await context.mount();
  }
  if (context.abortSignal.aborted) {
    return;
  }
  if (playFunction) {
    if (!isMountDestructured) {
      context.mount = async () => {
        throw new MountMustBeDestructuredError({ playFunction: playFunction.toString() });
      };
    }
    await playFunction(context);
  }
  let cleanUp;
  if (isTestEnvironment()) {
    cleanUp = pauseAnimations();
  } else {
    await waitForAnimations(context.abortSignal);
  }
  await story.applyAfterEach(context);
  await cleanUp?.();
}
__name(runStory, "runStory");

// src/preview-api/modules/store/StoryStore.ts
var CSF_CACHE_SIZE = 1e3;
var STORY_CACHE_SIZE = 1e4;
var _StoryStore = class _StoryStore {
  constructor(storyIndex, importFn, projectAnnotations) {
    this.importFn = importFn;
    this.storyIndex = new StoryIndexStore(storyIndex);
    this.projectAnnotations = normalizeProjectAnnotations(
      composeConfigs([...getCoreAnnotations(), projectAnnotations])
    );
    const { initialGlobals: initialGlobals5, globalTypes } = this.projectAnnotations;
    this.args = new ArgsStore();
    this.userGlobals = new GlobalsStore({ globals: initialGlobals5, globalTypes });
    this.hooks = {};
    this.cleanupCallbacks = {};
    this.processCSFFileWithCache = (0, import_memoizerific2.default)(CSF_CACHE_SIZE)(processCSFFile);
    this.prepareMetaWithCache = (0, import_memoizerific2.default)(CSF_CACHE_SIZE)(prepareMeta);
    this.prepareStoryWithCache = (0, import_memoizerific2.default)(STORY_CACHE_SIZE)(prepareStory);
  }
  setProjectAnnotations(projectAnnotations) {
    this.projectAnnotations = normalizeProjectAnnotations(projectAnnotations);
    const { initialGlobals: initialGlobals5, globalTypes } = projectAnnotations;
    this.userGlobals.set({ globals: initialGlobals5, globalTypes });
  }
  // This means that one of the CSF files has changed.
  // If the `importFn` has changed, we will invalidate both caches.
  // If the `storyIndex` data has changed, we may or may not invalidate the caches, depending
  // on whether we've loaded the relevant files yet.
  async onStoriesChanged({
    importFn,
    storyIndex
  }) {
    if (importFn) {
      this.importFn = importFn;
    }
    if (storyIndex) {
      this.storyIndex.entries = storyIndex.entries;
    }
    if (this.cachedCSFFiles) {
      await this.cacheAllCSFFiles();
    }
  }
  // Get an entry from the index, waiting on initialization if necessary
  async storyIdToEntry(storyId) {
    return this.storyIndex.storyIdToEntry(storyId);
  }
  // To load a single CSF file to service a story we need to look up the importPath in the index
  async loadCSFFileByStoryId(storyId) {
    const { importPath, title } = this.storyIndex.storyIdToEntry(storyId);
    const moduleExports = await this.importFn(importPath);
    return this.processCSFFileWithCache(moduleExports, importPath, title);
  }
  async loadAllCSFFiles() {
    const importPaths = {};
    Object.entries(this.storyIndex.entries).forEach(([storyId, { importPath }]) => {
      importPaths[importPath] = storyId;
    });
    const list = await Promise.all(
      Object.entries(importPaths).map(async ([importPath, storyId]) => ({
        importPath,
        csfFile: await this.loadCSFFileByStoryId(storyId)
      }))
    );
    return list.reduce(
      (acc, { importPath, csfFile }) => {
        acc[importPath] = csfFile;
        return acc;
      },
      {}
    );
  }
  async cacheAllCSFFiles() {
    this.cachedCSFFiles = await this.loadAllCSFFiles();
  }
  preparedMetaFromCSFFile({ csfFile }) {
    const componentAnnotations = csfFile.meta;
    return this.prepareMetaWithCache(
      componentAnnotations,
      this.projectAnnotations,
      csfFile.moduleExports.default
    );
  }
  // Load the CSF file for a story and prepare the story from it and the project annotations.
  async loadStory({ storyId }) {
    const csfFile = await this.loadCSFFileByStoryId(storyId);
    return this.storyFromCSFFile({ storyId, csfFile });
  }
  // This function is synchronous for convenience -- often times if you have a CSF file already
  // it is easier not to have to await `loadStory`.
  storyFromCSFFile({
    storyId,
    csfFile
  }) {
    const storyAnnotations = csfFile.stories[storyId];
    if (!storyAnnotations) {
      throw new MissingStoryFromCsfFileError({ storyId });
    }
    const componentAnnotations = csfFile.meta;
    const story = this.prepareStoryWithCache(
      storyAnnotations,
      componentAnnotations,
      csfFile.projectAnnotations ?? this.projectAnnotations
    );
    this.args.setInitial(story);
    this.hooks[story.id] = this.hooks[story.id] || new HooksContext();
    return story;
  }
  // If we have a CSF file we can get all the stories from it synchronously
  componentStoriesFromCSFFile({
    csfFile
  }) {
    return Object.keys(this.storyIndex.entries).filter((storyId) => !!csfFile.stories[storyId]).map((storyId) => this.storyFromCSFFile({ storyId, csfFile }));
  }
  async loadEntry(id) {
    const entry = await this.storyIdToEntry(id);
    const storyImports = entry.type === "docs" ? entry.storiesImports : [];
    const [entryExports, ...csfFiles] = await Promise.all([
      this.importFn(entry.importPath),
      ...storyImports.map((storyImportPath) => {
        const firstStoryEntry = this.storyIndex.importPathToEntry(storyImportPath);
        return this.loadCSFFileByStoryId(firstStoryEntry.id);
      })
    ]);
    return { entryExports, csfFiles };
  }
  // A prepared story does not include args, globals or hooks. These are stored in the story store
  // and updated separately to the (immutable) story.
  getStoryContext(story, { forceInitialArgs = false } = {}) {
    const userGlobals = this.userGlobals.get();
    const { initialGlobals: initialGlobals5 } = this.userGlobals;
    const reporting = new ReporterAPI();
    return prepareContext({
      ...story,
      args: forceInitialArgs ? story.initialArgs : this.args.get(story.id),
      initialGlobals: initialGlobals5,
      globalTypes: this.projectAnnotations.globalTypes,
      userGlobals,
      reporting,
      globals: {
        ...userGlobals,
        ...story.storyGlobals
      },
      hooks: this.hooks[story.id]
    });
  }
  addCleanupCallbacks(story, ...callbacks) {
    this.cleanupCallbacks[story.id] = (this.cleanupCallbacks[story.id] || []).concat(callbacks);
  }
  async cleanupStory(story) {
    this.hooks[story.id].clean();
    const callbacks = this.cleanupCallbacks[story.id];
    if (callbacks) {
      for (const callback of [...callbacks].reverse()) {
        await callback();
      }
    }
    delete this.cleanupCallbacks[story.id];
  }
  extract(options = { includeDocsOnly: false }) {
    const { cachedCSFFiles } = this;
    console.log("extract: extracting stories", cachedCSFFiles);
    if (!cachedCSFFiles) {
      throw new CalledExtractOnStoreError();
    }
    const stories = Object.entries(this.storyIndex.entries).reduce(
      (acc, [storyId, entry]) => {
        if (entry.type === "docs") {
          return acc;
        }
        const csfFile = cachedCSFFiles[entry.importPath];
        const story = this.storyFromCSFFile({ storyId, csfFile });
        if (!options.includeDocsOnly && story.parameters.docsOnly) {
          return acc;
        }
        acc[storyId] = Object.entries(story).reduce(
          (storyAcc, [key, value]) => {
            if (key === "story" && entry.subtype === "test") {
              return { ...storyAcc, story: entry.parentName };
            }
            if (key === "moduleExport") {
              return storyAcc;
            }
            if (typeof value === "function") {
              return storyAcc;
            }
            if (Array.isArray(value)) {
              return Object.assign(storyAcc, { [key]: value.slice().sort() });
            }
            return Object.assign(storyAcc, { [key]: value });
          },
          {
            args: story.initialArgs,
            globals: {
              ...this.userGlobals.initialGlobals,
              ...this.userGlobals.globals,
              ...story.storyGlobals
            },
            storyId: entry.parent ? entry.parent : storyId
          }
        );
        return acc;
      },
      {}
    );
    console.log("extract: stories", stories);
    return stories;
  }
};
__name(_StoryStore, "StoryStore");
var StoryStore = _StoryStore;

// ../node_modules/slash/index.js
function slash2(path) {
  const isExtendedLengthPath = path.startsWith("\\\\?\\");
  if (isExtendedLengthPath) {
    return path;
  }
  return path.replace(/\\/g, "/");
}
__name(slash2, "slash");

// src/preview-api/modules/store/autoTitle.ts
var sanitize2 = /* @__PURE__ */ __name((parts) => {
  if (parts.length === 0) {
    return parts;
  }
  const last = parts[parts.length - 1];
  const lastStripped = last?.replace(/(?:[.](?:story|stories))?([.][^.]+)$/i, "");
  if (parts.length === 1) {
    return [lastStripped];
  }
  const nextToLast = parts[parts.length - 2];
  if (lastStripped && nextToLast && lastStripped.toLowerCase() === nextToLast.toLowerCase()) {
    return [...parts.slice(0, -2), lastStripped];
  }
  return lastStripped && (/^(story|stories)([.][^.]+)$/i.test(last) || /^index$/i.test(lastStripped)) ? parts.slice(0, -1) : [...parts.slice(0, -1), lastStripped];
}, "sanitize");
function pathJoin(paths) {
  return paths.flatMap((p2) => p2.split("/")).filter(Boolean).join("/");
}
__name(pathJoin, "pathJoin");
var userOrAutoTitleFromSpecifier = /* @__PURE__ */ __name((fileName, entry, userTitle) => {
  const { directory, importPathMatcher, titlePrefix = "" } = entry || {};
  if (typeof fileName === "number") {
    once.warn(dedent`
      CSF Auto-title received a numeric fileName. This typically happens when
      webpack is mis-configured in production mode. To force webpack to produce
      filenames, set optimization.moduleIds = "named" in your webpack config.
    `);
  }
  const normalizedFileName = slash2(String(fileName));
  if (importPathMatcher.exec(normalizedFileName)) {
    if (!userTitle) {
      const suffix = normalizedFileName.replace(directory, "");
      let parts = pathJoin([titlePrefix, suffix]).split("/");
      parts = sanitize2(parts);
      return parts.join("/");
    }
    if (!titlePrefix) {
      return userTitle;
    }
    return pathJoin([titlePrefix, userTitle]);
  }
  return void 0;
}, "userOrAutoTitleFromSpecifier");
var userOrAutoTitle = /* @__PURE__ */ __name((fileName, storiesEntries, userTitle) => {
  for (let i2 = 0; i2 < storiesEntries.length; i2 += 1) {
    const title = userOrAutoTitleFromSpecifier(fileName, storiesEntries[i2], userTitle);
    if (title) {
      return title;
    }
  }
  return userTitle || void 0;
}, "userOrAutoTitle");

// src/preview-api/modules/store/storySort.ts
var STORY_KIND_PATH_SEPARATOR = /\s*\/\s*/;
var storySort = /* @__PURE__ */ __name((options = {}) => (a2, b2) => {
  if (a2.title === b2.title && !options.includeNames) {
    return 0;
  }
  const method = options.method || "configure";
  let order = options.order || [];
  const storyTitleA = a2.title.trim().split(STORY_KIND_PATH_SEPARATOR);
  const storyTitleB = b2.title.trim().split(STORY_KIND_PATH_SEPARATOR);
  if (options.includeNames) {
    storyTitleA.push(a2.name);
    storyTitleB.push(b2.name);
  }
  let depth = 0;
  while (storyTitleA[depth] || storyTitleB[depth]) {
    if (!storyTitleA[depth]) {
      return -1;
    }
    if (!storyTitleB[depth]) {
      return 1;
    }
    const nameA = storyTitleA[depth];
    const nameB = storyTitleB[depth];
    if (nameA !== nameB) {
      let indexA = order.indexOf(nameA);
      let indexB = order.indexOf(nameB);
      const indexWildcard = order.indexOf("*");
      if (indexA !== -1 || indexB !== -1) {
        if (indexA === -1) {
          if (indexWildcard !== -1) {
            indexA = indexWildcard;
          } else {
            indexA = order.length;
          }
        }
        if (indexB === -1) {
          if (indexWildcard !== -1) {
            indexB = indexWildcard;
          } else {
            indexB = order.length;
          }
        }
        return indexA - indexB;
      }
      if (method === "configure") {
        return 0;
      }
      return nameA.localeCompare(nameB, options.locales ? options.locales : void 0, {
        numeric: true,
        sensitivity: "accent"
      });
    }
    let index2 = order.indexOf(nameA);
    if (index2 === -1) {
      index2 = order.indexOf("*");
    }
    order = index2 !== -1 && Array.isArray(order[index2 + 1]) ? order[index2 + 1] : [];
    depth += 1;
  }
  return 0;
}, "storySort");

// src/preview-api/modules/store/sortStories.ts
var sortStoriesCommon = /* @__PURE__ */ __name((stories, storySortParameter, fileNameOrder) => {
  if (storySortParameter) {
    let sortFn;
    if (typeof storySortParameter === "function") {
      sortFn = storySortParameter;
    } else {
      sortFn = storySort(storySortParameter);
    }
    stories.sort(sortFn);
  } else {
    stories.sort(
      (s1, s22) => fileNameOrder.indexOf(s1.importPath) - fileNameOrder.indexOf(s22.importPath)
    );
  }
  return stories;
}, "sortStoriesCommon");
var sortStoriesV7 = /* @__PURE__ */ __name((stories, storySortParameter, fileNameOrder) => {
  try {
    return sortStoriesCommon(stories, storySortParameter, fileNameOrder);
  } catch (err) {
    throw new Error(dedent`
    Error sorting stories with sort parameter ${storySortParameter}:

    > ${err.message}

    Are you using a V6-style sort function in V7 mode?

    More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#v7-style-story-sort
  `);
  }
}, "sortStoriesV7");

// src/preview-api/modules/preview-web/render/Render.ts
var PREPARE_ABORTED = new Error("prepareAborted");

// src/preview-api/modules/preview-web/render/StoryRender.ts
var { AbortController: AbortController2 } = globalThis;
function serializeError(error) {
  try {
    const { name = "Error", message = String(error), stack } = error;
    return { name, message, stack };
  } catch (e2) {
    return { name: "Error", message: String(error) };
  }
}
__name(serializeError, "serializeError");
var _StoryRender = class _StoryRender {
  constructor(channel, store, renderToScreen, callbacks, id, viewMode, renderOptions = { autoplay: true, forceInitialArgs: false }, story) {
    this.channel = channel;
    this.store = store;
    this.renderToScreen = renderToScreen;
    this.callbacks = callbacks;
    this.id = id;
    this.viewMode = viewMode;
    this.renderOptions = renderOptions;
    this.type = "story";
    this.notYetRendered = true;
    this.rerenderEnqueued = false;
    this.disableKeyListeners = false;
    this.teardownRender = /* @__PURE__ */ __name(() => {
    }, "teardownRender");
    this.torndown = false;
    this.abortController = new AbortController2();
    this.renderId = Date.now();
    if (story) {
      this.story = story;
      this.phase = "preparing";
    }
  }
  async runPhase(signal, phase, phaseFn) {
    this.phase = phase;
    this.channel.emit(STORY_RENDER_PHASE_CHANGED, {
      newPhase: this.phase,
      renderId: this.renderId,
      storyId: this.id
    });
    if (phaseFn) {
      await phaseFn();
      this.checkIfAborted(signal);
    }
  }
  checkIfAborted(signal) {
    if (signal.aborted && !["finished", "aborted", "errored"].includes(this.phase)) {
      this.phase = "aborted";
      this.channel.emit(STORY_RENDER_PHASE_CHANGED, {
        newPhase: this.phase,
        renderId: this.renderId,
        storyId: this.id
      });
    }
    return signal.aborted;
  }
  async prepare() {
    await this.runPhase(this.abortController.signal, "preparing", async () => {
      this.story = await this.store.loadStory({ storyId: this.id });
    });
    if (this.abortController.signal.aborted) {
      await this.store.cleanupStory(this.story);
      throw PREPARE_ABORTED;
    }
  }
  // The two story "renders" are equal and have both loaded the same story
  isEqual(other) {
    return !!(this.id === other.id && this.story && this.story === other.story);
  }
  isPreparing() {
    return ["preparing"].includes(this.phase);
  }
  isPending() {
    return ["loading", "beforeEach", "rendering", "playing", "afterEach"].includes(
      this.phase
    );
  }
  async renderToElement(canvasElement) {
    this.canvasElement = canvasElement;
    return this.render({ initial: true, forceRemount: true });
  }
  storyContext() {
    if (!this.story) {
      throw new Error(`Cannot call storyContext before preparing`);
    }
    const { forceInitialArgs } = this.renderOptions;
    return this.store.getStoryContext(this.story, { forceInitialArgs });
  }
  async render({
    initial = false,
    forceRemount = false
  } = {}) {
    const { canvasElement } = this;
    if (!this.story) {
      throw new Error("cannot render when not prepared");
    }
    const story = this.story;
    if (!canvasElement) {
      throw new Error("cannot render when canvasElement is unset");
    }
    const {
      id,
      componentId,
      title,
      name,
      tags,
      applyLoaders,
      applyBeforeEach,
      applyAfterEach,
      unboundStoryFn,
      playFunction,
      runStep
    } = story;
    if (forceRemount && !initial) {
      this.cancelRender();
      this.abortController = new AbortController2();
    }
    const abortSignal = this.abortController.signal;
    let mounted = false;
    const isMountDestructured = story.usesMount;
    try {
      const context = {
        ...this.storyContext(),
        viewMode: this.viewMode,
        abortSignal,
        canvasElement,
        loaded: {},
        step: /* @__PURE__ */ __name((label, play) => runStep(label, play, context), "step"),
        context: null,
        canvas: {},
        userEvent: {},
        renderToCanvas: /* @__PURE__ */ __name(async () => {
          const teardown = await this.renderToScreen(renderContext, canvasElement);
          this.teardownRender = teardown || (() => {
          });
          mounted = true;
        }, "renderToCanvas"),
        // The story provides (set in a renderer) a mount function that is a higher order function
        // (context) => (...args) => Canvas
        //
        // Before assigning it to the context, we resolve the context dependency,
        // so that a user can just call it as await mount(...args) in their play function.
        mount: /* @__PURE__ */ __name(async (...args) => {
          this.callbacks.showStoryDuringRender?.();
          let mountReturn = null;
          await this.runPhase(abortSignal, "rendering", async () => {
            mountReturn = await story.mount(context)(...args);
          });
          if (isMountDestructured) {
            await this.runPhase(abortSignal, "playing");
          }
          return mountReturn;
        }, "mount")
      };
      context.context = context;
      const renderContext = {
        componentId,
        title,
        kind: title,
        id,
        name,
        story: name,
        tags,
        ...this.callbacks,
        showError: /* @__PURE__ */ __name((error) => {
          this.phase = "errored";
          return this.callbacks.showError(error);
        }, "showError"),
        showException: /* @__PURE__ */ __name((error) => {
          this.phase = "errored";
          return this.callbacks.showException(error);
        }, "showException"),
        forceRemount: forceRemount || this.notYetRendered,
        storyContext: context,
        storyFn: /* @__PURE__ */ __name(() => unboundStoryFn(context), "storyFn"),
        unboundStoryFn
      };
      await this.runPhase(abortSignal, "loading", async () => {
        context.loaded = await applyLoaders(context);
      });
      if (abortSignal.aborted) {
        return;
      }
      const cleanupCallbacks = await applyBeforeEach(context);
      this.store.addCleanupCallbacks(story, ...cleanupCallbacks);
      if (this.checkIfAborted(abortSignal)) {
        return;
      }
      if (!mounted && !isMountDestructured) {
        await context.mount();
      }
      this.notYetRendered = false;
      if (abortSignal.aborted) {
        return;
      }
      const ignoreUnhandledErrors = this.story.parameters?.test?.dangerouslyIgnoreUnhandledErrors === true;
      const unhandledErrors = /* @__PURE__ */ new Set();
      const onError = /* @__PURE__ */ __name((event) => {
        if (event.error) {
          unhandledErrors.add(event.error);
        }
      }, "onError");
      const onUnhandledRejection = /* @__PURE__ */ __name((event) => {
        if (event.reason) {
          unhandledErrors.add(event.reason);
        }
      }, "onUnhandledRejection");
      if (this.renderOptions.autoplay && forceRemount && playFunction && this.phase !== "errored") {
        window?.addEventListener?.("error", onError);
        window?.addEventListener?.("unhandledrejection", onUnhandledRejection);
        this.disableKeyListeners = true;
        try {
          if (!isMountDestructured) {
            context.mount = async () => {
              throw new MountMustBeDestructuredError({ playFunction: playFunction.toString() });
            };
            await this.runPhase(abortSignal, "playing", async () => playFunction(context));
          } else {
            await playFunction(context);
          }
          if (!mounted) {
            throw new NoStoryMountedError();
          }
          this.checkIfAborted(abortSignal);
          if (!ignoreUnhandledErrors && unhandledErrors.size > 0) {
            await this.runPhase(abortSignal, "errored");
          } else {
            await this.runPhase(abortSignal, "played");
          }
        } catch (error) {
          this.callbacks.showStoryDuringRender?.();
          await this.runPhase(abortSignal, "errored", async () => {
            this.channel.emit(PLAY_FUNCTION_THREW_EXCEPTION, serializeError(error));
          });
          if (this.story.parameters.throwPlayFunctionExceptions !== false) {
            throw error;
          }
          console.error(error);
        }
        if (!ignoreUnhandledErrors && unhandledErrors.size > 0) {
          this.channel.emit(
            UNHANDLED_ERRORS_WHILE_PLAYING,
            Array.from(unhandledErrors).map(serializeError)
          );
        }
        this.disableKeyListeners = false;
        window?.removeEventListener?.("unhandledrejection", onUnhandledRejection);
        window?.removeEventListener?.("error", onError);
        if (abortSignal.aborted) {
          return;
        }
      }
      await this.runPhase(abortSignal, "completing", async () => {
        if (isTestEnvironment()) {
          this.store.addCleanupCallbacks(story, pauseAnimations());
        } else {
          await waitForAnimations(abortSignal);
        }
      });
      await this.runPhase(abortSignal, "completed", async () => {
        this.channel.emit(STORY_RENDERED, id);
      });
      if (this.phase !== "errored") {
        await this.runPhase(abortSignal, "afterEach", async () => {
          await applyAfterEach(context);
        });
      }
      const hasUnhandledErrors = !ignoreUnhandledErrors && unhandledErrors.size > 0;
      const hasSomeReportsFailed = context.reporting.reports.some(
        (report) => report.status === "failed"
      );
      const hasStoryErrored = hasUnhandledErrors || hasSomeReportsFailed;
      await this.runPhase(
        abortSignal,
        "finished",
        async () => this.channel.emit(STORY_FINISHED, {
          storyId: id,
          status: hasStoryErrored ? "error" : "success",
          reporters: context.reporting.reports
        })
      );
    } catch (err) {
      this.phase = "errored";
      this.callbacks.showException(err);
      await this.runPhase(
        abortSignal,
        "finished",
        async () => this.channel.emit(STORY_FINISHED, {
          storyId: id,
          status: "error",
          reporters: []
        })
      );
    }
    if (this.rerenderEnqueued) {
      this.rerenderEnqueued = false;
      this.render();
    }
  }
  /**
   * Rerender the story. If the story is currently pending (loading/rendering), the rerender will be
   * enqueued, and will be executed after the current render is completed. Rerendering while playing
   * will not be enqueued, and will be executed immediately, to support rendering args changes while
   * playing.
   */
  async rerender() {
    if (this.isPending() && this.phase !== "playing") {
      this.rerenderEnqueued = true;
    } else {
      return this.render();
    }
  }
  async remount() {
    await this.teardown();
    return this.render({ forceRemount: true });
  }
  // If the story is torn down (either a new story is rendered or the docs page removes it)
  // we need to consider the fact that the initial render may not be finished
  // (possibly the loaders or the play function are still running). We use the controller
  // as a method to abort them, ASAP, but this is not foolproof as we cannot control what
  // happens inside the user's code.
  cancelRender() {
    this.abortController.abort();
  }
  cancelPlayFunction() {
    if (this.phase === "playing") {
      this.abortController.abort();
      this.runPhase(this.abortController.signal, "aborted");
    }
  }
  async teardown() {
    this.torndown = true;
    this.cancelRender();
    if (this.story) {
      await this.store.cleanupStory(this.story);
    }
    for (let i2 = 0; i2 < 3; i2 += 1) {
      if (!this.isPending()) {
        await this.teardownRender();
        return;
      }
      await new Promise((resolve) => setTimeout(resolve, 0));
    }
    window?.location?.reload?.();
    await new Promise(() => {
    });
  }
};
__name(_StoryRender, "StoryRender");
var StoryRender = _StoryRender;

// src/preview-api/modules/preview-web/Preview.tsx
var { fetch: fetch2 } = scope;
var STORY_INDEX_PATH = "./index.json";
var _Preview = class _Preview {
  constructor(importFn, getProjectAnnotations, channel = addons.getChannel(), shouldInitialize = true) {
    this.importFn = importFn;
    this.getProjectAnnotations = getProjectAnnotations;
    this.channel = channel;
    this.storyRenders = [];
    this.storeInitializationPromise = new Promise((resolve, reject) => {
      this.resolveStoreInitializationPromise = resolve;
      this.rejectStoreInitializationPromise = reject;
    });
    if (shouldInitialize) {
      this.initialize();
    }
  }
  // Create a proxy object for `__STORYBOOK_STORY_STORE__` and `__STORYBOOK_PREVIEW__.storyStore`
  // That proxies through to the store once ready, and errors beforehand. This means we can set
  // `__STORYBOOK_STORY_STORE__ = __STORYBOOK_PREVIEW__.storyStore` without having to wait, and
  // similarly integrators can access the `storyStore` on the preview at any time, although
  // it is considered deprecated and we will no longer allow access in 9.0
  get storyStore() {
    return new Proxy(
      {},
      {
        get: /* @__PURE__ */ __name((_, method) => {
          if (this.storyStoreValue) {
            deprecate("Accessing the Story Store is deprecated and will be removed in 9.0");
            return this.storyStoreValue[method];
          }
          throw new StoryStoreAccessedBeforeInitializationError();
        }, "get")
      }
    );
  }
  // INITIALIZATION
  async initialize() {
    this.setupListeners();
    try {
      const projectAnnotations = await this.getProjectAnnotationsOrRenderError();
      await this.runBeforeAllHook(projectAnnotations);
      await this.initializeWithProjectAnnotations(projectAnnotations);
      const userAgent = globalThis?.navigator?.userAgent;
      await this.channel.emit(PREVIEW_INITIALIZED, { userAgent });
    } catch (err) {
      this.rejectStoreInitializationPromise(err);
    }
  }
  ready() {
    return this.storeInitializationPromise;
  }
  setupListeners() {
    this.channel.on(STORY_INDEX_INVALIDATED, this.onStoryIndexChanged.bind(this));
    this.channel.on(UPDATE_GLOBALS, this.onUpdateGlobals.bind(this));
    this.channel.on(UPDATE_STORY_ARGS, this.onUpdateArgs.bind(this));
    this.channel.on(ARGTYPES_INFO_REQUEST, this.onRequestArgTypesInfo.bind(this));
    this.channel.on(RESET_STORY_ARGS, this.onResetArgs.bind(this));
    this.channel.on(FORCE_RE_RENDER, this.onForceReRender.bind(this));
    this.channel.on(FORCE_REMOUNT, this.onForceRemount.bind(this));
    this.channel.on(STORY_HOT_UPDATED, this.onStoryHotUpdated.bind(this));
  }
  async getProjectAnnotationsOrRenderError() {
    try {
      const projectAnnotations = await this.getProjectAnnotations();
      this.renderToCanvas = projectAnnotations.renderToCanvas;
      if (!this.renderToCanvas) {
        throw new MissingRenderToCanvasError();
      }
      return projectAnnotations;
    } catch (err) {
      this.renderPreviewEntryError("Error reading preview.js:", err);
      throw err;
    }
  }
  // If initialization gets as far as project annotations, this function runs.
  async initializeWithProjectAnnotations(projectAnnotations) {
    this.projectAnnotationsBeforeInitialization = projectAnnotations;
    try {
      const storyIndex = await this.getStoryIndexFromServer();
      return this.initializeWithStoryIndex(storyIndex);
    } catch (err) {
      this.renderPreviewEntryError("Error loading story index:", err);
      throw err;
    }
  }
  async runBeforeAllHook(projectAnnotations) {
    try {
      await this.beforeAllCleanup?.();
      this.beforeAllCleanup = await projectAnnotations.beforeAll?.();
    } catch (err) {
      this.renderPreviewEntryError("Error in beforeAll hook:", err);
      throw err;
    }
  }
  async getStoryIndexFromServer() {
    const result = await fetch2(STORY_INDEX_PATH);
    if (result.status === 200) {
      return result.json();
    }
    throw new StoryIndexFetchError({ text: await result.text() });
  }
  // If initialization gets as far as the story index, this function runs.
  initializeWithStoryIndex(storyIndex) {
    if (!this.projectAnnotationsBeforeInitialization) {
      throw new Error("Cannot call initializeWithStoryIndex until project annotations resolve");
    }
    this.storyStoreValue = new StoryStore(
      storyIndex,
      this.importFn,
      this.projectAnnotationsBeforeInitialization
    );
    delete this.projectAnnotationsBeforeInitialization;
    this.setInitialGlobals();
    this.resolveStoreInitializationPromise();
  }
  async setInitialGlobals() {
    this.emitGlobals();
  }
  emitGlobals() {
    if (!this.storyStoreValue) {
      throw new CalledPreviewMethodBeforeInitializationError({ methodName: "emitGlobals" });
    }
    const payload = {
      globals: this.storyStoreValue.userGlobals.get() || {},
      globalTypes: this.storyStoreValue.projectAnnotations.globalTypes || {}
    };
    this.channel.emit(SET_GLOBALS, payload);
  }
  // EVENT HANDLERS
  // This happens when a config file gets reloaded
  async onGetProjectAnnotationsChanged({
    getProjectAnnotations
  }) {
    delete this.previewEntryError;
    this.getProjectAnnotations = getProjectAnnotations;
    const projectAnnotations = await this.getProjectAnnotationsOrRenderError();
    await this.runBeforeAllHook(projectAnnotations);
    if (!this.storyStoreValue) {
      await this.initializeWithProjectAnnotations(projectAnnotations);
      return;
    }
    this.storyStoreValue.setProjectAnnotations(projectAnnotations);
    this.emitGlobals();
  }
  async onStoryIndexChanged() {
    delete this.previewEntryError;
    if (!this.storyStoreValue && !this.projectAnnotationsBeforeInitialization) {
      return;
    }
    try {
      const storyIndex = await this.getStoryIndexFromServer();
      if (this.projectAnnotationsBeforeInitialization) {
        this.initializeWithStoryIndex(storyIndex);
        return;
      }
      await this.onStoriesChanged({ storyIndex });
    } catch (err) {
      this.renderPreviewEntryError("Error loading story index:", err);
      throw err;
    }
  }
  // This happens when a glob gets HMR-ed
  async onStoriesChanged({
    importFn,
    storyIndex
  }) {
    if (!this.storyStoreValue) {
      throw new CalledPreviewMethodBeforeInitializationError({ methodName: "onStoriesChanged" });
    }
    await this.storyStoreValue.onStoriesChanged({ importFn, storyIndex });
  }
  async onUpdateGlobals({
    globals: updatedGlobals,
    currentStory
  }) {
    if (!this.storyStoreValue) {
      await this.storeInitializationPromise;
    }
    if (!this.storyStoreValue) {
      throw new CalledPreviewMethodBeforeInitializationError({ methodName: "onUpdateGlobals" });
    }
    this.storyStoreValue.userGlobals.update(updatedGlobals);
    if (currentStory) {
      const { initialGlobals: initialGlobals5, storyGlobals, userGlobals, globals } = this.storyStoreValue.getStoryContext(currentStory);
      this.channel.emit(GLOBALS_UPDATED, {
        initialGlobals: initialGlobals5,
        userGlobals,
        storyGlobals,
        globals
      });
    } else {
      const { initialGlobals: initialGlobals5, globals } = this.storyStoreValue.userGlobals;
      this.channel.emit(GLOBALS_UPDATED, {
        initialGlobals: initialGlobals5,
        userGlobals: globals,
        storyGlobals: {},
        globals
      });
    }
    await Promise.all(this.storyRenders.map((r2) => r2.rerender()));
  }
  async onUpdateArgs({ storyId, updatedArgs }) {
    if (!this.storyStoreValue) {
      throw new CalledPreviewMethodBeforeInitializationError({ methodName: "onUpdateArgs" });
    }
    this.storyStoreValue.args.update(storyId, updatedArgs);
    await Promise.all(
      this.storyRenders.filter((r2) => r2.id === storyId && !r2.renderOptions.forceInitialArgs).map(
        (r2) => (
          // We only run the play function, with in a force remount.
          // But when mount is destructured, the rendering happens inside of the play function.
          r2.story && r2.story.usesMount ? r2.remount() : r2.rerender()
        )
      )
    );
    this.channel.emit(STORY_ARGS_UPDATED, {
      storyId,
      args: this.storyStoreValue.args.get(storyId)
    });
  }
  async onRequestArgTypesInfo({ id, payload }) {
    try {
      await this.storeInitializationPromise;
      const story = await this.storyStoreValue?.loadStory(payload);
      this.channel.emit(ARGTYPES_INFO_RESPONSE, {
        id,
        success: true,
        payload: { argTypes: story?.argTypes || {} },
        error: null
      });
    } catch (e2) {
      this.channel.emit(ARGTYPES_INFO_RESPONSE, {
        id,
        success: false,
        error: e2?.message
      });
    }
  }
  async onResetArgs({ storyId, argNames }) {
    if (!this.storyStoreValue) {
      throw new CalledPreviewMethodBeforeInitializationError({ methodName: "onResetArgs" });
    }
    const render = this.storyRenders.find((r2) => r2.id === storyId);
    const story = render?.story || await this.storyStoreValue.loadStory({ storyId });
    const argNamesToReset = argNames || [
      .../* @__PURE__ */ new Set([
        ...Object.keys(story.initialArgs),
        ...Object.keys(this.storyStoreValue.args.get(storyId))
      ])
    ];
    const updatedArgs = argNamesToReset.reduce((acc, argName) => {
      acc[argName] = story.initialArgs[argName];
      return acc;
    }, {});
    await this.onUpdateArgs({ storyId, updatedArgs });
  }
  // ForceReRender does not include a story id, so we simply must
  // re-render all stories in case they are relevant
  async onForceReRender() {
    await Promise.all(this.storyRenders.map((r2) => r2.rerender()));
  }
  async onForceRemount({ storyId }) {
    await Promise.all(this.storyRenders.filter((r2) => r2.id === storyId).map((r2) => r2.remount()));
  }
  async onStoryHotUpdated() {
    await Promise.all(this.storyRenders.map((r2) => r2.cancelPlayFunction()));
  }
  // Used by docs to render a story to a given element
  // Note this short-circuits the `prepare()` phase of the StoryRender,
  // main to be consistent with the previous behaviour. In the future,
  // we will change it to go ahead and load the story, which will end up being
  // "instant", although async.
  renderStoryToElement(story, element, callbacks, options) {
    if (!this.renderToCanvas || !this.storyStoreValue) {
      throw new CalledPreviewMethodBeforeInitializationError({
        methodName: "renderStoryToElement"
      });
    }
    const render = new StoryRender(
      this.channel,
      this.storyStoreValue,
      this.renderToCanvas,
      callbacks,
      story.id,
      "docs",
      options,
      story
    );
    render.renderToElement(element);
    this.storyRenders.push(render);
    return async () => {
      await this.teardownRender(render);
    };
  }
  async teardownRender(render, { viewModeChanged } = {}) {
    this.storyRenders = this.storyRenders.filter((r2) => r2 !== render);
    await render?.teardown?.({ viewModeChanged });
  }
  // API
  async loadStory({ storyId }) {
    if (!this.storyStoreValue) {
      throw new CalledPreviewMethodBeforeInitializationError({ methodName: "loadStory" });
    }
    return this.storyStoreValue.loadStory({ storyId });
  }
  getStoryContext(story, { forceInitialArgs = false } = {}) {
    if (!this.storyStoreValue) {
      throw new CalledPreviewMethodBeforeInitializationError({ methodName: "getStoryContext" });
    }
    return this.storyStoreValue.getStoryContext(story, { forceInitialArgs });
  }
  async extract(options) {
    if (!this.storyStoreValue) {
      throw new CalledPreviewMethodBeforeInitializationError({ methodName: "extract" });
    }
    if (this.previewEntryError) {
      throw this.previewEntryError;
    }
    await this.storyStoreValue.cacheAllCSFFiles();
    return this.storyStoreValue.extract(options);
  }
  // UTILITIES
  renderPreviewEntryError(reason, err) {
    this.previewEntryError = err;
    logger.error(reason);
    logger.error(err);
    this.channel.emit(CONFIG_ERROR, err);
  }
};
__name(_Preview, "Preview");
var Preview = _Preview;

// src/preview-api/modules/preview-web/docs-context/DocsContext.ts
var _DocsContext = class _DocsContext {
  constructor(channel, store, renderStoryToElement, csfFiles) {
    this.channel = channel;
    this.store = store;
    this.renderStoryToElement = renderStoryToElement;
    this.storyIdByName = /* @__PURE__ */ __name((storyName) => {
      const storyId = this.nameToStoryId.get(storyName);
      if (storyId) {
        return storyId;
      }
      throw new Error(`No story found with that name: ${storyName}`);
    }, "storyIdByName");
    this.componentStories = /* @__PURE__ */ __name(() => {
      return this.componentStoriesValue;
    }, "componentStories");
    this.componentStoriesFromCSFFile = /* @__PURE__ */ __name((csfFile) => {
      return this.store.componentStoriesFromCSFFile({ csfFile });
    }, "componentStoriesFromCSFFile");
    this.storyById = /* @__PURE__ */ __name((storyId) => {
      if (!storyId) {
        if (!this.primaryStory) {
          throw new Error(
            `No primary story defined for docs entry. Did you forget to use \`<Meta>\`?`
          );
        }
        return this.primaryStory;
      }
      const csfFile = this.storyIdToCSFFile.get(storyId);
      if (!csfFile) {
        throw new Error(`Called \`storyById\` for story that was never loaded: ${storyId}`);
      }
      return this.store.storyFromCSFFile({ storyId, csfFile });
    }, "storyById");
    this.getStoryContext = /* @__PURE__ */ __name((story) => {
      return {
        ...this.store.getStoryContext(story),
        loaded: {},
        viewMode: "docs"
      };
    }, "getStoryContext");
    this.loadStory = /* @__PURE__ */ __name((id) => {
      return this.store.loadStory({ storyId: id });
    }, "loadStory");
    this.componentStoriesValue = [];
    this.storyIdToCSFFile = /* @__PURE__ */ new Map();
    this.exportToStory = /* @__PURE__ */ new Map();
    this.exportsToCSFFile = /* @__PURE__ */ new Map();
    this.nameToStoryId = /* @__PURE__ */ new Map();
    this.attachedCSFFiles = /* @__PURE__ */ new Set();
    csfFiles.forEach((csfFile, index2) => {
      this.referenceCSFFile(csfFile);
    });
  }
  // This docs entry references this CSF file and can synchronously load the stories, as well
  // as reference them by module export. If the CSF is part of the "component" stories, they
  // can also be referenced by name and are in the componentStories list.
  referenceCSFFile(csfFile) {
    this.exportsToCSFFile.set(csfFile.moduleExports, csfFile);
    this.exportsToCSFFile.set(csfFile.moduleExports.default, csfFile);
    const stories = this.store.componentStoriesFromCSFFile({ csfFile });
    stories.forEach((story) => {
      const annotation = csfFile.stories[story.id];
      this.storyIdToCSFFile.set(annotation.id, csfFile);
      this.exportToStory.set(annotation.moduleExport, story);
    });
  }
  attachCSFFile(csfFile) {
    if (!this.exportsToCSFFile.has(csfFile.moduleExports)) {
      throw new Error("Cannot attach a CSF file that has not been referenced");
    }
    if (this.attachedCSFFiles.has(csfFile)) {
      return;
    }
    this.attachedCSFFiles.add(csfFile);
    const stories = this.store.componentStoriesFromCSFFile({ csfFile });
    stories.forEach((story) => {
      this.nameToStoryId.set(story.name, story.id);
      this.componentStoriesValue.push(story);
      if (!this.primaryStory) {
        this.primaryStory = story;
      }
    });
  }
  referenceMeta(metaExports, attach) {
    const resolved = this.resolveModuleExport(metaExports);
    if (resolved.type !== "meta") {
      throw new Error(
        "<Meta of={} /> must reference a CSF file module export or meta export. Did you mistakenly reference your component instead of your CSF file?"
      );
    }
    if (attach) {
      this.attachCSFFile(resolved.csfFile);
    }
  }
  get projectAnnotations() {
    const { projectAnnotations } = this.store;
    if (!projectAnnotations) {
      throw new Error("Can't get projectAnnotations from DocsContext before they are initialized");
    }
    return projectAnnotations;
  }
  resolveAttachedModuleExportType(moduleExportType) {
    if (moduleExportType === "story") {
      if (!this.primaryStory) {
        throw new Error(
          `No primary story attached to this docs file, did you forget to use <Meta of={} />?`
        );
      }
      return { type: "story", story: this.primaryStory };
    }
    if (this.attachedCSFFiles.size === 0) {
      throw new Error(
        `No CSF file attached to this docs file, did you forget to use <Meta of={} />?`
      );
    }
    const firstAttachedCSFFile = Array.from(this.attachedCSFFiles)[0];
    if (moduleExportType === "meta") {
      return { type: "meta", csfFile: firstAttachedCSFFile };
    }
    const { component } = firstAttachedCSFFile.meta;
    if (!component) {
      throw new Error(
        `Attached CSF file does not defined a component, did you forget to export one?`
      );
    }
    return { type: "component", component };
  }
  resolveModuleExport(moduleExportOrType) {
    const csfFile = this.exportsToCSFFile.get(moduleExportOrType);
    if (csfFile) {
      return { type: "meta", csfFile };
    }
    const story = this.exportToStory.get(
      isStory(moduleExportOrType) ? moduleExportOrType.input : moduleExportOrType
    );
    if (story) {
      return { type: "story", story };
    }
    return { type: "component", component: moduleExportOrType };
  }
  resolveOf(moduleExportOrType, validTypes = []) {
    let resolved;
    if (["component", "meta", "story"].includes(moduleExportOrType)) {
      const type5 = moduleExportOrType;
      resolved = this.resolveAttachedModuleExportType(type5);
    } else {
      resolved = this.resolveModuleExport(moduleExportOrType);
    }
    if (validTypes.length && !validTypes.includes(resolved.type)) {
      const prettyType = resolved.type === "component" ? "component or unknown" : resolved.type;
      throw new Error(dedent`Invalid value passed to the 'of' prop. The value was resolved to a '${prettyType}' type but the only types for this block are: ${validTypes.join(
        ", "
      )}.
        - Did you pass a component to the 'of' prop when the block only supports a story or a meta?
        - ... or vice versa?
        - Did you pass a story, CSF file or meta to the 'of' prop that is not indexed, ie. is not targeted by the 'stories' globs in the main configuration?`);
    }
    switch (resolved.type) {
      case "component": {
        return {
          ...resolved,
          projectAnnotations: this.projectAnnotations
        };
      }
      case "meta": {
        return {
          ...resolved,
          preparedMeta: this.store.preparedMetaFromCSFFile({ csfFile: resolved.csfFile })
        };
      }
      case "story":
      default: {
        return resolved;
      }
    }
  }
};
__name(_DocsContext, "DocsContext");
var DocsContext = _DocsContext;

// src/preview-api/modules/preview-web/render/CsfDocsRender.ts
var _CsfDocsRender = class _CsfDocsRender {
  constructor(channel, store, entry, callbacks) {
    this.channel = channel;
    this.store = store;
    this.entry = entry;
    this.callbacks = callbacks;
    this.type = "docs";
    this.subtype = "csf";
    this.torndown = false;
    this.disableKeyListeners = false;
    this.preparing = false;
    this.id = entry.id;
    this.renderId = Date.now();
  }
  isPreparing() {
    return this.preparing;
  }
  async prepare() {
    this.preparing = true;
    const { entryExports, csfFiles = [] } = await this.store.loadEntry(this.id);
    if (this.torndown) {
      throw PREPARE_ABORTED;
    }
    const { importPath, title } = this.entry;
    const primaryCsfFile = this.store.processCSFFileWithCache(
      entryExports,
      importPath,
      title
    );
    const primaryStoryId = Object.keys(primaryCsfFile.stories)[0];
    this.story = this.store.storyFromCSFFile({ storyId: primaryStoryId, csfFile: primaryCsfFile });
    this.csfFiles = [primaryCsfFile, ...csfFiles];
    this.preparing = false;
  }
  isEqual(other) {
    return !!(this.id === other.id && this.story && this.story === other.story);
  }
  docsContext(renderStoryToElement) {
    if (!this.csfFiles) {
      throw new Error("Cannot render docs before preparing");
    }
    const docsContext = new DocsContext(
      this.channel,
      this.store,
      renderStoryToElement,
      this.csfFiles
    );
    this.csfFiles.forEach((csfFile) => docsContext.attachCSFFile(csfFile));
    return docsContext;
  }
  async renderToElement(canvasElement, renderStoryToElement) {
    if (!this.story || !this.csfFiles) {
      throw new Error("Cannot render docs before preparing");
    }
    const docsContext = this.docsContext(renderStoryToElement);
    const { docs: docsParameter } = this.story.parameters || {};
    if (!docsParameter) {
      throw new Error(
        `Cannot render a story in viewMode=docs if \`@storybook/addon-docs\` is not installed`
      );
    }
    const renderer = await docsParameter.renderer();
    const { render } = renderer;
    const renderDocs = /* @__PURE__ */ __name(async () => {
      try {
        await render(docsContext, docsParameter, canvasElement);
        this.channel.emit(DOCS_RENDERED, this.id);
      } catch (err) {
        this.callbacks.showException(err);
      }
    }, "renderDocs");
    this.rerender = async () => renderDocs();
    this.teardownRender = async ({ viewModeChanged }) => {
      if (!viewModeChanged || !canvasElement) {
        return;
      }
      renderer.unmount(canvasElement);
    };
    return renderDocs();
  }
  async teardown({ viewModeChanged } = {}) {
    this.teardownRender?.({ viewModeChanged });
    this.torndown = true;
  }
};
__name(_CsfDocsRender, "CsfDocsRender");
var CsfDocsRender = _CsfDocsRender;

// src/preview-api/modules/preview-web/render/MdxDocsRender.ts
var _MdxDocsRender = class _MdxDocsRender {
  constructor(channel, store, entry, callbacks) {
    this.channel = channel;
    this.store = store;
    this.entry = entry;
    this.callbacks = callbacks;
    this.type = "docs";
    this.subtype = "mdx";
    this.torndown = false;
    this.disableKeyListeners = false;
    this.preparing = false;
    this.id = entry.id;
    this.renderId = Date.now();
  }
  isPreparing() {
    return this.preparing;
  }
  async prepare() {
    this.preparing = true;
    const { entryExports, csfFiles = [] } = await this.store.loadEntry(this.id);
    if (this.torndown) {
      throw PREPARE_ABORTED;
    }
    this.csfFiles = csfFiles;
    this.exports = entryExports;
    this.preparing = false;
  }
  isEqual(other) {
    return !!(this.id === other.id && this.exports && this.exports === other.exports);
  }
  docsContext(renderStoryToElement) {
    if (!this.csfFiles) {
      throw new Error("Cannot render docs before preparing");
    }
    return new DocsContext(
      this.channel,
      this.store,
      renderStoryToElement,
      this.csfFiles
    );
  }
  async renderToElement(canvasElement, renderStoryToElement) {
    if (!this.exports || !this.csfFiles || !this.store.projectAnnotations) {
      throw new Error("Cannot render docs before preparing");
    }
    const docsContext = this.docsContext(renderStoryToElement);
    const { docs } = this.store.projectAnnotations.parameters ?? {};
    if (!docs) {
      throw new Error(
        `Cannot render a story in viewMode=docs if \`@storybook/addon-docs\` is not installed`
      );
    }
    const docsParameter = { ...docs, page: this.exports.default };
    const renderer = await docs.renderer();
    const { render } = renderer;
    const renderDocs = /* @__PURE__ */ __name(async () => {
      try {
        await render(docsContext, docsParameter, canvasElement);
        this.channel.emit(DOCS_RENDERED, this.id);
      } catch (err) {
        this.callbacks.showException(err);
      }
    }, "renderDocs");
    this.rerender = async () => renderDocs();
    this.teardownRender = async ({ viewModeChanged } = {}) => {
      if (!viewModeChanged || !canvasElement) {
        return;
      }
      renderer.unmount(canvasElement);
      this.torndown = true;
    };
    return renderDocs();
  }
  async teardown({ viewModeChanged } = {}) {
    this.teardownRender?.({ viewModeChanged });
    this.torndown = true;
  }
};
__name(_MdxDocsRender, "MdxDocsRender");
var MdxDocsRender = _MdxDocsRender;

// src/preview-api/modules/preview-web/PreviewWithSelection.tsx
var globalWindow = globalThis;
function focusInInput(event) {
  const target = event.composedPath && event.composedPath()[0] || event.target;
  return /input|textarea/i.test(target.tagName) || target.getAttribute("contenteditable") !== null;
}
__name(focusInInput, "focusInInput");
var ATTACHED_MDX_TAG = "attached-mdx";
var UNATTACHED_MDX_TAG = "unattached-mdx";
function isMdxEntry({ tags }) {
  return tags?.includes(UNATTACHED_MDX_TAG) || tags?.includes(ATTACHED_MDX_TAG);
}
__name(isMdxEntry, "isMdxEntry");
function isStoryRender(r2) {
  return r2.type === "story";
}
__name(isStoryRender, "isStoryRender");
function isDocsRender(r2) {
  return r2.type === "docs";
}
__name(isDocsRender, "isDocsRender");
function isCsfDocsRender(r2) {
  return isDocsRender(r2) && r2.subtype === "csf";
}
__name(isCsfDocsRender, "isCsfDocsRender");
var _PreviewWithSelection = class _PreviewWithSelection extends Preview {
  constructor(importFn, getProjectAnnotations, selectionStore, view) {
    super(importFn, getProjectAnnotations, void 0, false);
    this.importFn = importFn;
    this.getProjectAnnotations = getProjectAnnotations;
    this.selectionStore = selectionStore;
    this.view = view;
    this.initialize();
  }
  setupListeners() {
    super.setupListeners();
    globalWindow.onkeydown = this.onKeydown.bind(this);
    this.channel.on(SET_CURRENT_STORY, this.onSetCurrentStory.bind(this));
    this.channel.on(UPDATE_QUERY_PARAMS, this.onUpdateQueryParams.bind(this));
    this.channel.on(PRELOAD_ENTRIES, this.onPreloadStories.bind(this));
  }
  async setInitialGlobals() {
    if (!this.storyStoreValue) {
      throw new CalledPreviewMethodBeforeInitializationError({ methodName: "setInitialGlobals" });
    }
    const { globals } = this.selectionStore.selectionSpecifier || {};
    if (globals) {
      this.storyStoreValue.userGlobals.updateFromPersisted(globals);
    }
    this.emitGlobals();
  }
  // If initialization gets as far as the story index, this function runs.
  async initializeWithStoryIndex(storyIndex) {
    await super.initializeWithStoryIndex(storyIndex);
    return this.selectSpecifiedStory();
  }
  // Use the selection specifier to choose a story, then render it
  async selectSpecifiedStory() {
    if (!this.storyStoreValue) {
      throw new CalledPreviewMethodBeforeInitializationError({
        methodName: "selectSpecifiedStory"
      });
    }
    if (this.selectionStore.selection) {
      await this.renderSelection();
      return;
    }
    if (!this.selectionStore.selectionSpecifier) {
      this.renderMissingStory();
      return;
    }
    const { storySpecifier, args } = this.selectionStore.selectionSpecifier;
    const entry = this.storyStoreValue.storyIndex.entryFromSpecifier(storySpecifier);
    if (!entry) {
      if (storySpecifier === "*") {
        this.renderStoryLoadingException(storySpecifier, new EmptyIndexError());
      } else {
        this.renderStoryLoadingException(
          storySpecifier,
          new NoStoryMatchError({ storySpecifier: storySpecifier.toString() })
        );
      }
      return;
    }
    const { id: storyId, type: viewMode } = entry;
    this.selectionStore.setSelection({ storyId, viewMode });
    this.channel.emit(STORY_SPECIFIED, this.selectionStore.selection);
    this.channel.emit(CURRENT_STORY_WAS_SET, this.selectionStore.selection);
    await this.renderSelection({ persistedArgs: args });
  }
  // EVENT HANDLERS
  // This happens when a config file gets reloaded
  async onGetProjectAnnotationsChanged({
    getProjectAnnotations
  }) {
    await super.onGetProjectAnnotationsChanged({ getProjectAnnotations });
    if (this.selectionStore.selection) {
      this.renderSelection();
    }
  }
  // This happens when a glob gets HMR-ed
  async onStoriesChanged({
    importFn,
    storyIndex
  }) {
    await super.onStoriesChanged({ importFn, storyIndex });
    if (this.selectionStore.selection) {
      await this.renderSelection();
    } else {
      await this.selectSpecifiedStory();
    }
  }
  onKeydown(event) {
    if (!this.storyRenders.find((r2) => r2.disableKeyListeners) && !focusInInput(event)) {
      const { altKey, ctrlKey, metaKey, shiftKey, key, code, keyCode } = event;
      this.channel.emit(PREVIEW_KEYDOWN, {
        event: { altKey, ctrlKey, metaKey, shiftKey, key, code, keyCode }
      });
    }
  }
  async onSetCurrentStory(selection) {
    this.selectionStore.setSelection({ viewMode: "story", ...selection });
    await this.storeInitializationPromise;
    this.channel.emit(CURRENT_STORY_WAS_SET, this.selectionStore.selection);
    this.renderSelection();
  }
  onUpdateQueryParams(queryParams) {
    this.selectionStore.setQueryParams(queryParams);
  }
  async onUpdateGlobals({ globals }) {
    const currentStory = this.currentRender instanceof StoryRender && this.currentRender.story || void 0;
    super.onUpdateGlobals({ globals, currentStory });
    if (this.currentRender instanceof MdxDocsRender || this.currentRender instanceof CsfDocsRender) {
      await this.currentRender.rerender?.();
    }
  }
  async onUpdateArgs({ storyId, updatedArgs }) {
    super.onUpdateArgs({ storyId, updatedArgs });
  }
  async onPreloadStories({ ids }) {
    await this.storeInitializationPromise;
    if (this.storyStoreValue) {
      await Promise.allSettled(ids.map((id) => this.storyStoreValue?.loadEntry(id)));
    }
  }
  // RENDERING
  // We can either have:
  // - a story selected in "story" viewMode,
  //     in which case we render it to the root element, OR
  // - a story selected in "docs" viewMode,
  //     in which case we render the docsPage for that story
  async renderSelection({ persistedArgs } = {}) {
    const { renderToCanvas } = this;
    if (!this.storyStoreValue || !renderToCanvas) {
      throw new CalledPreviewMethodBeforeInitializationError({ methodName: "renderSelection" });
    }
    const { selection } = this.selectionStore;
    if (!selection) {
      throw new Error("Cannot call renderSelection as no selection was made");
    }
    const { storyId } = selection;
    let entry;
    try {
      entry = await this.storyStoreValue.storyIdToEntry(storyId);
    } catch (err) {
      if (this.currentRender) {
        await this.teardownRender(this.currentRender);
      }
      this.renderStoryLoadingException(storyId, err);
      return;
    }
    const storyIdChanged = this.currentSelection?.storyId !== storyId;
    const viewModeChanged = this.currentRender?.type !== entry.type;
    if (entry.type === "story") {
      this.view.showPreparingStory({ immediate: viewModeChanged });
    } else {
      this.view.showPreparingDocs({ immediate: viewModeChanged });
    }
    if (this.currentRender?.isPreparing()) {
      await this.teardownRender(this.currentRender);
    }
    let render;
    if (entry.type === "story") {
      render = new StoryRender(
        this.channel,
        this.storyStoreValue,
        renderToCanvas,
        this.mainStoryCallbacks(storyId),
        storyId,
        "story"
      );
    } else if (isMdxEntry(entry)) {
      render = new MdxDocsRender(
        this.channel,
        this.storyStoreValue,
        entry,
        this.mainStoryCallbacks(storyId)
      );
    } else {
      render = new CsfDocsRender(
        this.channel,
        this.storyStoreValue,
        entry,
        this.mainStoryCallbacks(storyId)
      );
    }
    const lastSelection = this.currentSelection;
    this.currentSelection = selection;
    const lastRender = this.currentRender;
    this.currentRender = render;
    try {
      await render.prepare();
    } catch (err) {
      if (lastRender) {
        await this.teardownRender(lastRender);
      }
      if (err !== PREPARE_ABORTED) {
        this.renderStoryLoadingException(storyId, err);
      }
      return;
    }
    const implementationChanged = !storyIdChanged && lastRender && !render.isEqual(lastRender);
    if (persistedArgs && isStoryRender(render)) {
      invariant(!!render.story);
      this.storyStoreValue.args.updateFromPersisted(render.story, persistedArgs);
    }
    if (lastRender && !lastRender.torndown && !storyIdChanged && !implementationChanged && !viewModeChanged) {
      this.currentRender = lastRender;
      this.channel.emit(STORY_UNCHANGED, storyId);
      this.view.showMain();
      return;
    }
    if (lastRender) {
      await this.teardownRender(lastRender, { viewModeChanged });
    }
    if (lastSelection && (storyIdChanged || viewModeChanged)) {
      this.channel.emit(STORY_CHANGED, storyId);
    }
    if (isStoryRender(render)) {
      invariant(!!render.story);
      const {
        parameters: parameters2,
        initialArgs,
        argTypes,
        unmappedArgs,
        initialGlobals: initialGlobals5,
        userGlobals,
        storyGlobals,
        globals
      } = this.storyStoreValue.getStoryContext(render.story);
      this.channel.emit(STORY_PREPARED, {
        id: storyId,
        parameters: parameters2,
        initialArgs,
        argTypes,
        args: unmappedArgs
      });
      this.channel.emit(GLOBALS_UPDATED, { userGlobals, storyGlobals, globals, initialGlobals: initialGlobals5 });
    } else {
      let { parameters: parameters2 } = this.storyStoreValue.projectAnnotations;
      const { initialGlobals: initialGlobals5, globals } = this.storyStoreValue.userGlobals;
      this.channel.emit(GLOBALS_UPDATED, {
        globals,
        initialGlobals: initialGlobals5,
        storyGlobals: {},
        userGlobals: globals
      });
      if (isCsfDocsRender(render) || render.entry.tags?.includes(ATTACHED_MDX_TAG)) {
        if (!render.csfFiles) {
          throw new MdxFileWithNoCsfReferencesError({ storyId });
        }
        ({ parameters: parameters2 } = this.storyStoreValue.preparedMetaFromCSFFile({
          csfFile: render.csfFiles[0]
        }));
      }
      this.channel.emit(DOCS_PREPARED, {
        id: storyId,
        parameters: parameters2
      });
    }
    if (isStoryRender(render)) {
      invariant(!!render.story);
      this.storyRenders.push(render);
      this.currentRender.renderToElement(
        this.view.prepareForStory(render.story)
      );
    } else {
      this.currentRender.renderToElement(
        this.view.prepareForDocs(),
        // This argument is used for docs, which is currently only compatible with HTMLElements
        this.renderStoryToElement.bind(this)
      );
    }
  }
  async teardownRender(render, { viewModeChanged = false } = {}) {
    this.storyRenders = this.storyRenders.filter((r2) => r2 !== render);
    await render?.teardown?.({ viewModeChanged });
  }
  // UTILITIES
  mainStoryCallbacks(storyId) {
    return {
      showStoryDuringRender: /* @__PURE__ */ __name(() => this.view.showStoryDuringRender(), "showStoryDuringRender"),
      showMain: /* @__PURE__ */ __name(() => this.view.showMain(), "showMain"),
      showError: /* @__PURE__ */ __name((err) => this.renderError(storyId, err), "showError"),
      showException: /* @__PURE__ */ __name((err) => this.renderException(storyId, err), "showException")
    };
  }
  renderPreviewEntryError(reason, err) {
    super.renderPreviewEntryError(reason, err);
    this.view.showErrorDisplay(err);
  }
  renderMissingStory() {
    this.view.showNoPreview();
    this.channel.emit(STORY_MISSING);
  }
  renderStoryLoadingException(storySpecifier, err) {
    logger.error(err);
    this.view.showErrorDisplay(err);
    this.channel.emit(STORY_MISSING, storySpecifier);
  }
  // renderException is used if we fail to render the story and it is uncaught by the app layer
  renderException(storyId, error) {
    const { name = "Error", message = String(error), stack } = error;
    const renderId = this.currentRender?.renderId;
    this.channel.emit(STORY_THREW_EXCEPTION, { name, message, stack });
    this.channel.emit(STORY_RENDER_PHASE_CHANGED, { newPhase: "errored", renderId, storyId });
    this.view.showErrorDisplay(error);
    logger.error(`Error rendering story '${storyId}':`);
    logger.error(error);
  }
  // renderError is used by the various app layers to inform the user they have done something
  // wrong -- for instance returned the wrong thing from a story
  renderError(storyId, { title, description }) {
    const renderId = this.currentRender?.renderId;
    this.channel.emit(STORY_ERRORED, { title, description });
    this.channel.emit(STORY_RENDER_PHASE_CHANGED, { newPhase: "errored", renderId, storyId });
    this.view.showErrorDisplay({ message: title, stack: description });
    logger.error(`Error rendering story ${title}: ${description}`);
  }
};
__name(_PreviewWithSelection, "PreviewWithSelection");
var PreviewWithSelection = _PreviewWithSelection;

// src/preview-api/modules/preview-web/UrlStore.ts
var import_picoquery2 = __toESM(require_main(), 1);

// src/preview-api/modules/preview-web/parseArgsParam.ts
var import_picoquery = __toESM(require_main(), 1);
var VALIDATION_REGEXP = /^[a-zA-Z0-9 _-]*$/;
var NUMBER_REGEXP = /^-?[0-9]+(\.[0-9]+)?$/;
var HEX_REGEXP = /^#([a-f0-9]{3,4}|[a-f0-9]{6}|[a-f0-9]{8})$/i;
var COLOR_REGEXP = /^(rgba?|hsla?)\(([0-9]{1,3}),\s?([0-9]{1,3})%?,\s?([0-9]{1,3})%?,?\s?([0-9](\.[0-9]{1,2})?)?\)$/i;
var validateArgs = /* @__PURE__ */ __name((key = "", value) => {
  if (key === null) {
    return false;
  }
  if (key === "" || !VALIDATION_REGEXP.test(key)) {
    return false;
  }
  if (value === null || value === void 0) {
    return true;
  }
  if (value instanceof Date) {
    return true;
  }
  if (typeof value === "number" || typeof value === "boolean") {
    return true;
  }
  if (typeof value === "string") {
    return VALIDATION_REGEXP.test(value) || NUMBER_REGEXP.test(value) || HEX_REGEXP.test(value) || COLOR_REGEXP.test(value);
  }
  if (Array.isArray(value)) {
    return value.every((v2) => validateArgs(key, v2));
  }
  if (isPlainObject(value)) {
    return Object.entries(value).every(([k2, v2]) => validateArgs(k2, v2));
  }
  return false;
}, "validateArgs");
var QUERY_OPTIONS = {
  delimiter: ";",
  // we're parsing a single query param
  nesting: true,
  arrayRepeat: true,
  arrayRepeatSyntax: "bracket",
  nestingSyntax: "js",
  // objects are encoded using dot notation
  valueDeserializer(str2) {
    if (str2.startsWith("!")) {
      if (str2 === "!undefined") {
        return void 0;
      }
      if (str2 === "!null") {
        return null;
      }
      if (str2 === "!true") {
        return true;
      }
      if (str2 === "!false") {
        return false;
      }
      if (str2.startsWith("!date(") && str2.endsWith(")")) {
        return new Date(str2.replaceAll(" ", "+").slice(6, -1));
      }
      if (str2.startsWith("!hex(") && str2.endsWith(")")) {
        return `#${str2.slice(5, -1)}`;
      }
      const color = str2.slice(1).match(COLOR_REGEXP);
      if (color) {
        if (str2.startsWith("!rgba") || str2.startsWith("!RGBA")) {
          return `${color[1]}(${color[2]}, ${color[3]}, ${color[4]}, ${color[5]})`;
        }
        if (str2.startsWith("!hsla") || str2.startsWith("!HSLA")) {
          return `${color[1]}(${color[2]}, ${color[3]}%, ${color[4]}%, ${color[5]})`;
        }
        return str2.startsWith("!rgb") || str2.startsWith("!RGB") ? `${color[1]}(${color[2]}, ${color[3]}, ${color[4]})` : `${color[1]}(${color[2]}, ${color[3]}%, ${color[4]}%)`;
      }
    }
    if (NUMBER_REGEXP.test(str2)) {
      return Number(str2);
    }
    return str2;
  }
};
var parseArgsParam = /* @__PURE__ */ __name((argsString) => {
  const parts = argsString.split(";").map((part) => part.replace("=", "~").replace(":", "="));
  return Object.entries((0, import_picoquery.parse)(parts.join(";"), QUERY_OPTIONS)).reduce((acc, [key, value]) => {
    if (validateArgs(key, value)) {
      return Object.assign(acc, { [key]: value });
    }
    once.warn(dedent`
      Omitted potentially unsafe URL args.

      More info: https://storybook.js.org/docs/writing-stories/args#setting-args-through-the-url?ref=error
    `);
    return acc;
  }, {});
}, "parseArgsParam");

// src/preview-api/modules/preview-web/UrlStore.ts
var { history, document: document4 } = scope;
function pathToId(path) {
  const match = (path || "").match(/^\/story\/(.+)/);
  if (!match) {
    throw new Error(`Invalid path '${path}',  must start with '/story/'`);
  }
  return match[1];
}
__name(pathToId, "pathToId");
var getQueryString = /* @__PURE__ */ __name(({
  selection,
  extraParams
}) => {
  const search = document4?.location.search.slice(1);
  const { path, selectedKind, selectedStory, ...rest } = (0, import_picoquery2.parse)(search);
  const queryStr = (0, import_picoquery2.stringify)({
    ...rest,
    ...extraParams,
    ...selection && { id: selection.storyId, viewMode: selection.viewMode }
  });
  return `?${queryStr}`;
}, "getQueryString");
var setPath = /* @__PURE__ */ __name((selection) => {
  if (!selection) {
    return;
  }
  const query = getQueryString({ selection });
  const { hash = "" } = document4.location;
  document4.title = selection.storyId;
  history.replaceState({}, "", `${document4.location.pathname}${query}${hash}`);
}, "setPath");
var isObject6 = /* @__PURE__ */ __name((val) => val != null && typeof val === "object" && Array.isArray(val) === false, "isObject");
var getFirstString = /* @__PURE__ */ __name((v2) => {
  if (v2 === void 0) {
    return void 0;
  }
  if (typeof v2 === "string") {
    return v2;
  }
  if (Array.isArray(v2)) {
    return getFirstString(v2[0]);
  }
  if (isObject6(v2)) {
    return getFirstString(
      Object.values(v2).filter(Boolean)
    );
  }
  return void 0;
}, "getFirstString");
var getSelectionSpecifierFromPath = /* @__PURE__ */ __name(() => {
  if (typeof document4 !== "undefined") {
    const queryStr = document4.location.search.slice(1);
    const query = (0, import_picoquery2.parse)(queryStr);
    const args = typeof query.args === "string" ? parseArgsParam(query.args) : void 0;
    const globals = typeof query.globals === "string" ? parseArgsParam(query.globals) : void 0;
    let viewMode = getFirstString(query.viewMode);
    if (typeof viewMode !== "string" || !viewMode.match(/docs|story/)) {
      viewMode = "story";
    }
    const path = getFirstString(query.path);
    const storyId = path ? pathToId(path) : getFirstString(query.id);
    if (storyId) {
      return { storySpecifier: storyId, args, globals, viewMode };
    }
  }
  return null;
}, "getSelectionSpecifierFromPath");
var _UrlStore = class _UrlStore {
  constructor() {
    this.selectionSpecifier = getSelectionSpecifierFromPath();
  }
  setSelection(selection) {
    this.selection = selection;
    setPath(this.selection);
  }
  setQueryParams(queryParams) {
    const query = getQueryString({ extraParams: queryParams });
    const { hash = "" } = document4.location;
    history.replaceState({}, "", `${document4.location.pathname}${query}${hash}`);
  }
};
__name(_UrlStore, "UrlStore");
var UrlStore = _UrlStore;

// src/preview-api/modules/preview-web/WebView.ts
var import_ansi_to_html = __toESM(require_ansi_to_html(), 1);
var import_picoquery3 = __toESM(require_main(), 1);
var { document: document5 } = scope;
var PREPARING_DELAY = 100;
var Mode = /* @__PURE__ */ ((Mode2) => {
  Mode2["MAIN"] = "MAIN";
  Mode2["NOPREVIEW"] = "NOPREVIEW";
  Mode2["PREPARING_STORY"] = "PREPARING_STORY";
  Mode2["PREPARING_DOCS"] = "PREPARING_DOCS";
  Mode2["ERROR"] = "ERROR";
  return Mode2;
})(Mode || {});
var classes = {
  PREPARING_STORY: "sb-show-preparing-story",
  PREPARING_DOCS: "sb-show-preparing-docs",
  MAIN: "sb-show-main",
  NOPREVIEW: "sb-show-nopreview",
  ERROR: "sb-show-errordisplay"
};
var layoutClassMap = {
  centered: "sb-main-centered",
  fullscreen: "sb-main-fullscreen",
  padded: "sb-main-padded"
};
var ansiConverter = new import_ansi_to_html.default({
  escapeXML: true
});
var _WebView = class _WebView {
  constructor() {
    this.testing = false;
    if (typeof document5 !== "undefined") {
      const { __SPECIAL_TEST_PARAMETER__ } = (0, import_picoquery3.parse)(document5.location.search.slice(1));
      switch (__SPECIAL_TEST_PARAMETER__) {
        case "preparing-story": {
          this.showPreparingStory();
          this.testing = true;
          break;
        }
        case "preparing-docs": {
          this.showPreparingDocs();
          this.testing = true;
          break;
        }
        default:
      }
    }
  }
  // Get ready to render a story, returning the element to render to
  prepareForStory(story) {
    this.showStory();
    this.applyLayout(story.parameters.layout);
    document5.documentElement.scrollTop = 0;
    document5.documentElement.scrollLeft = 0;
    return this.storyRoot();
  }
  storyRoot() {
    return document5.getElementById("storybook-root");
  }
  prepareForDocs() {
    this.showMain();
    this.showDocs();
    this.applyLayout("fullscreen");
    document5.documentElement.scrollTop = 0;
    document5.documentElement.scrollLeft = 0;
    return this.docsRoot();
  }
  docsRoot() {
    return document5.getElementById("storybook-docs");
  }
  applyLayout(layout = "padded") {
    if (layout === "none") {
      document5.body.classList.remove(this.currentLayoutClass);
      this.currentLayoutClass = null;
      return;
    }
    this.checkIfLayoutExists(layout);
    const layoutClass = layoutClassMap[layout];
    document5.body.classList.remove(this.currentLayoutClass);
    document5.body.classList.add(layoutClass);
    this.currentLayoutClass = layoutClass;
  }
  checkIfLayoutExists(layout) {
    if (!layoutClassMap[layout]) {
      logger.warn(
        dedent`
          The desired layout: ${layout} is not a valid option.
          The possible options are: ${Object.keys(layoutClassMap).join(", ")}, none.
        `
      );
    }
  }
  showMode(mode) {
    clearTimeout(this.preparingTimeout);
    Object.keys(Mode).forEach((otherMode) => {
      if (otherMode === mode) {
        document5.body.classList.add(classes[otherMode]);
      } else {
        document5.body.classList.remove(classes[otherMode]);
      }
    });
  }
  showErrorDisplay({ message = "", stack = "" }) {
    let header = message;
    let detail = stack;
    const parts = message.split("\n");
    if (parts.length > 1) {
      [header] = parts;
      detail = parts.slice(1).join("\n").replace(/^\n/, "");
    }
    document5.getElementById("error-message").innerHTML = ansiConverter.toHtml(header);
    document5.getElementById("error-stack").innerHTML = ansiConverter.toHtml(detail);
    this.showMode("ERROR" /* ERROR */);
  }
  showNoPreview() {
    if (this.testing) {
      return;
    }
    this.showMode("NOPREVIEW" /* NOPREVIEW */);
    this.storyRoot()?.setAttribute("hidden", "true");
    this.docsRoot()?.setAttribute("hidden", "true");
  }
  showPreparingStory({ immediate = false } = {}) {
    clearTimeout(this.preparingTimeout);
    if (immediate) {
      this.showMode("PREPARING_STORY" /* PREPARING_STORY */);
    } else {
      this.preparingTimeout = setTimeout(
        () => this.showMode("PREPARING_STORY" /* PREPARING_STORY */),
        PREPARING_DELAY
      );
    }
  }
  showPreparingDocs({ immediate = false } = {}) {
    clearTimeout(this.preparingTimeout);
    if (immediate) {
      this.showMode("PREPARING_DOCS" /* PREPARING_DOCS */);
    } else {
      this.preparingTimeout = setTimeout(() => this.showMode("PREPARING_DOCS" /* PREPARING_DOCS */), PREPARING_DELAY);
    }
  }
  showMain() {
    this.showMode("MAIN" /* MAIN */);
  }
  showDocs() {
    this.storyRoot().setAttribute("hidden", "true");
    this.docsRoot().removeAttribute("hidden");
  }
  showStory() {
    this.docsRoot().setAttribute("hidden", "true");
    this.storyRoot().removeAttribute("hidden");
  }
  showStoryDuringRender() {
    document5.body.classList.add(classes.MAIN);
  }
};
__name(_WebView, "WebView");
var WebView = _WebView;

// src/preview-api/modules/preview-web/PreviewWeb.tsx
var _PreviewWeb = class _PreviewWeb extends PreviewWithSelection {
  constructor(importFn, getProjectAnnotations) {
    super(importFn, getProjectAnnotations, new UrlStore(), new WebView());
    this.importFn = importFn;
    this.getProjectAnnotations = getProjectAnnotations;
    scope.__STORYBOOK_PREVIEW__ = this;
  }
};
__name(_PreviewWeb, "PreviewWeb");
var PreviewWeb = _PreviewWeb;

// src/preview-api/modules/preview-web/simulate-pageload.ts
var { document: document6 } = scope;
var runScriptTypes = [
  "application/javascript",
  "application/ecmascript",
  "application/x-ecmascript",
  "application/x-javascript",
  "text/ecmascript",
  "text/javascript",
  "text/javascript1.0",
  "text/javascript1.1",
  "text/javascript1.2",
  "text/javascript1.3",
  "text/javascript1.4",
  "text/javascript1.5",
  "text/jscript",
  "text/livescript",
  "text/x-ecmascript",
  "text/x-javascript",
  // Support modern javascript
  "module"
];
var SCRIPT = "script";
var SCRIPTS_ROOT_ID = "scripts-root";
function simulateDOMContentLoaded() {
  const DOMContentLoadedEvent = document6.createEvent("Event");
  DOMContentLoadedEvent.initEvent("DOMContentLoaded", true, true);
  document6.dispatchEvent(DOMContentLoadedEvent);
}
__name(simulateDOMContentLoaded, "simulateDOMContentLoaded");
function insertScript($script, callback, $scriptRoot) {
  const scriptEl = document6.createElement("script");
  scriptEl.type = $script.type === "module" ? "module" : "text/javascript";
  if ($script.src) {
    scriptEl.onload = callback;
    scriptEl.onerror = callback;
    scriptEl.src = $script.src;
  } else {
    scriptEl.textContent = $script.innerText;
  }
  if ($scriptRoot) {
    $scriptRoot.appendChild(scriptEl);
  } else {
    document6.head.appendChild(scriptEl);
  }
  $script.parentNode.removeChild($script);
  if (!$script.src) {
    callback();
  }
}
__name(insertScript, "insertScript");
function insertScriptsSequentially(scriptsToExecute, callback, index2 = 0) {
  scriptsToExecute[index2](() => {
    index2++;
    if (index2 === scriptsToExecute.length) {
      callback();
    } else {
      insertScriptsSequentially(scriptsToExecute, callback, index2);
    }
  });
}
__name(insertScriptsSequentially, "insertScriptsSequentially");
function simulatePageLoad($container) {
  let $scriptsRoot = document6.getElementById(SCRIPTS_ROOT_ID);
  if (!$scriptsRoot) {
    $scriptsRoot = document6.createElement("div");
    $scriptsRoot.id = SCRIPTS_ROOT_ID;
    document6.body.appendChild($scriptsRoot);
  } else {
    $scriptsRoot.innerHTML = "";
  }
  const $scripts = Array.from($container.querySelectorAll(SCRIPT));
  if ($scripts.length) {
    const scriptsToExecute = [];
    $scripts.forEach(($script) => {
      const typeAttr = $script.getAttribute("type");
      if (!typeAttr || runScriptTypes.includes(typeAttr)) {
        scriptsToExecute.push((callback) => insertScript($script, callback, $scriptsRoot));
      }
    });
    if (scriptsToExecute.length) {
      insertScriptsSequentially(scriptsToExecute, simulateDOMContentLoaded, void 0);
    }
  } else {
    simulateDOMContentLoaded();
  }
}
__name(simulatePageLoad, "simulatePageLoad");

// ../node_modules/comment-parser/es6/primitives.js
var Markers;
(function(Markers2) {
  Markers2["start"] = "/**";
  Markers2["nostart"] = "/***";
  Markers2["delim"] = "*";
  Markers2["end"] = "*/";
})(Markers = Markers || (Markers = {}));

// ../node_modules/comment-parser/es6/stringifier/index.js
function join(tokens) {
  return tokens.start + tokens.delimiter + tokens.postDelimiter + tokens.tag + tokens.postTag + tokens.type + tokens.postType + tokens.name + tokens.postName + tokens.description + tokens.end + tokens.lineEnd;
}
__name(join, "join");
function getStringifier() {
  return (block) => block.source.map(({ tokens }) => join(tokens)).join("\n");
}
__name(getStringifier, "getStringifier");

// ../node_modules/comment-parser/es6/stringifier/inspect.js
var zeroWidth = {
  line: 0,
  start: 0,
  delimiter: 0,
  postDelimiter: 0,
  tag: 0,
  postTag: 0,
  name: 0,
  postName: 0,
  type: 0,
  postType: 0,
  description: 0,
  end: 0,
  lineEnd: 0
};
var fields = Object.keys(zeroWidth);

// ../node_modules/comment-parser/es6/index.js
var stringify4 = getStringifier();

// src/docs-tools/argTypes/jsdocParser.ts
var import_jsdoc_type_pratt_parser = __toESM(require_dist(), 1);
var jsdocStringifyRules = (0, import_jsdoc_type_pratt_parser.stringifyRules)();
var originalJsdocStringifyObject = jsdocStringifyRules.JsdocTypeObject;
jsdocStringifyRules.JsdocTypeAny = () => "any";
jsdocStringifyRules.JsdocTypeObject = (result, transform) => `(${originalJsdocStringifyObject(result, transform)})`;
jsdocStringifyRules.JsdocTypeOptional = (result, transform) => transform(result.element);
jsdocStringifyRules.JsdocTypeNullable = (result, transform) => transform(result.element);
jsdocStringifyRules.JsdocTypeNotNullable = (result, transform) => transform(result.element);
jsdocStringifyRules.JsdocTypeUnion = (result, transform) => result.elements.map(transform).join("|");

// src/docs-tools/shared.ts
var ADDON_ID6 = "storybook/docs";
var PANEL_ID3 = `${ADDON_ID6}/panel`;
var SNIPPET_RENDERED = `${ADDON_ID6}/snippet-rendered`;

// src/preview-api/modules/preview-web/emitTransformCode.ts
async function emitTransformCode(source, context) {
  const transform = context.parameters?.docs?.source?.transform;
  const { id, unmappedArgs } = context;
  const transformed = transform && source ? transform?.(source, context) : source;
  const result = transformed ? await transformed : void 0;
  addons.getChannel().emit(SNIPPET_RENDERED, {
    id,
    source: result,
    args: unmappedArgs
  });
}
__name(emitTransformCode, "emitTransformCode");

// src/actions/runtime/configureActions.ts
var config3 = {
  depth: 10,
  clearOnStoryChange: true,
  limit: 50
};
var configureActions = /* @__PURE__ */ __name((options = {}) => {
  Object.assign(config3, options);
}, "configureActions");

// src/actions/runtime/action.ts
var findProto = /* @__PURE__ */ __name((obj, callback) => {
  const proto = Object.getPrototypeOf(obj);
  if (!proto || callback(proto)) {
    return proto;
  }
  return findProto(proto, callback);
}, "findProto");
var isReactSyntheticEvent = /* @__PURE__ */ __name((e2) => Boolean(
  typeof e2 === "object" && e2 && findProto(e2, (proto) => /^Synthetic(?:Base)?Event$/.test(proto.constructor.name)) && typeof e2.persist === "function"
), "isReactSyntheticEvent");
var serializeArg = /* @__PURE__ */ __name((a2) => {
  if (isReactSyntheticEvent(a2)) {
    const e2 = Object.create(
      a2.constructor.prototype,
      Object.getOwnPropertyDescriptors(a2)
    );
    e2.persist();
    const viewDescriptor = Object.getOwnPropertyDescriptor(e2, "view");
    const view = viewDescriptor?.value;
    if (typeof view === "object" && view?.constructor.name === "Window") {
      Object.defineProperty(e2, "view", {
        ...viewDescriptor,
        value: Object.create(view.constructor.prototype)
      });
    }
    return e2;
  }
  return a2;
}, "serializeArg");
function action(name, options = {}) {
  const actionOptions = {
    ...config3,
    ...options
  };
  const handler = /* @__PURE__ */ __name(function actionHandler(...args) {
    if (options.implicit) {
      const preview = "__STORYBOOK_PREVIEW__" in scope ? scope.__STORYBOOK_PREVIEW__ : void 0;
      const storyRenderer = preview?.storyRenders.find(
        (render) => render.phase === "playing" || render.phase === "rendering"
      );
      if (storyRenderer) {
        const deprecated = !globalThis?.FEATURES?.disallowImplicitActionsInRenderV8;
        const error = new ImplicitActionsDuringRendering({
          phase: storyRenderer.phase,
          name,
          deprecated
        });
        if (deprecated) {
          console.warn(error);
        } else {
          throw error;
        }
      }
    }
    const channel = addons.getChannel();
    const id = Date.now().toString(36) + Math.random().toString(36).substring(2);
    const minDepth = 5;
    const serializedArgs = args.map(serializeArg);
    const normalizedArgs = args.length > 1 ? serializedArgs : serializedArgs[0];
    const actionDisplayToEmit = {
      id,
      count: 0,
      data: { name, args: normalizedArgs },
      options: {
        ...actionOptions,
        maxDepth: minDepth + (actionOptions.depth || 3)
      }
    };
    channel.emit(EVENT_ID, actionDisplayToEmit);
  }, "actionHandler");
  handler.isAction = true;
  handler.implicit = options.implicit;
  return handler;
}
__name(action, "action");

// src/actions/runtime/actions.ts
var actions = /* @__PURE__ */ __name((...args) => {
  let options = config3;
  let names = args;
  if (names.length === 1 && Array.isArray(names[0])) {
    [names] = names;
  }
  if (names.length !== 1 && typeof names[names.length - 1] !== "string") {
    options = {
      ...config3,
      ...names.pop()
    };
  }
  let namesObject = names[0];
  if (names.length !== 1 || typeof namesObject === "string") {
    namesObject = {};
    names.forEach((name) => {
      namesObject[name] = name;
    });
  }
  const actionsObject = {};
  Object.keys(namesObject).forEach((name) => {
    actionsObject[name] = action(namesObject[name], options);
  });
  return actionsObject;
}, "actions");

// src/preview/globals/runtime.ts
var globalsNameValueMap = {
  "@storybook/global": dist_exports,
  "storybook/test": test_exports,
  "storybook/actions": actions_exports,
  "storybook/preview-api": preview_api_exports,
  "storybook/internal/channels": channels_exports,
  "storybook/internal/client-logger": client_logger_exports,
  "storybook/internal/core-events": core_events_exports,
  "storybook/internal/types": types_exports,
  "storybook/internal/preview-errors": preview_errors_exports,
  "storybook/internal/preview-api": preview_api_exports
};

// src/preview/preview-navigator.ts
async function maybeSetupPreviewNavigator() {
  const url = new URL(window.location.href);
  if (url.searchParams.get("navigator") !== "true" || globalThis.__STORYBOOK_PREVIEW_NAVIGATOR__) {
    return;
  }
  globalThis.__STORYBOOK_PREVIEW_NAVIGATOR__ = true;
  const index2 = await (await fetch("/index.json")).json();
  const currentEntryId = url.searchParams.get("id");
  if (!currentEntryId) {
    const firstEntry = Object.values(index2.entries)[0];
    if (firstEntry) {
      url.searchParams.set("id", firstEntry.id);
      url.searchParams.set("viewMode", firstEntry.type);
      window.location.href = url.toString();
    }
    return;
  }
  setupPreviewNavigator(index2, currentEntryId);
}
__name(maybeSetupPreviewNavigator, "maybeSetupPreviewNavigator");
var setupPreviewNavigator = /* @__PURE__ */ __name(async (index2, currentEntryId) => {
  const tree = { title: "", entries: {}, isActive: true };
  for (const entry of Object.values(index2.entries)) {
    const titleParts = entry.title.split("/");
    let currentNode = tree;
    for (const titlePart of titleParts) {
      if (!currentNode.entries) {
        currentNode.entries = {};
      }
      if (!currentNode.entries[titlePart]) {
        currentNode.entries[titlePart] = {
          title: titlePart,
          isActive: currentEntryId === entry.id,
          entries: {}
        };
      } else if (currentEntryId === entry.id) {
        currentNode.entries[titlePart].isActive = true;
      }
      currentNode = currentNode.entries[titlePart];
    }
    if (!currentNode.entries) {
      currentNode.entries = {};
    }
    currentNode.entries[entry.name] = {
      id: entry.id,
      name: entry.name,
      href: `?id=${entry.id}&viewMode=${entry.type}&navigator=true`,
      isActive: currentEntryId === entry.id
    };
  }
  const createHtmlForNode = /* @__PURE__ */ __name((node) => {
    if ("entries" in node && "title" in node) {
      const branchNode = node;
      return `
      <li class="sb-navigator-branch">
        <details${branchNode.isActive ? " open" : ""}>
          <summary class="sb-navigator-title">
            ${branchNode.title}
          </summary>
          <ul class="sb-navigator-entries" aria-label="${branchNode.title}">
            ${Object.values(branchNode.entries).map(createHtmlForNode).join("")}
          </ul>
        </details>
      </li>
      `;
    }
    const leafNode = node;
    return `
      <li class="sb-navigator-story-item">
        <a href="${leafNode.href}" 
           class="sb-navigator-story-link${leafNode.isActive ? " active" : ""}" 
           aria-current="${leafNode.isActive ? "location" : "false"}">${leafNode.name}</a>
      </li>
    `;
  }, "createHtmlForNode");
  const navItems = Object.values(tree.entries).map(createHtmlForNode).join("");
  const nav = document.createElement("nav");
  nav.id = "sb-navigator-container";
  nav.setAttribute("role", "navigation");
  nav.setAttribute("aria-label", "Story navigation");
  nav.innerHTML = `
    <ul class="sb-navigator-list">${navItems}</ul>
  `;
  document.body.insertBefore(nav, document.body.firstChild);
  const style = document.createElement("style");
  style.id = "sb-navigator-style";
  style.textContent = `
    body {
      display: grid !important;
      grid-template-columns: 300px 1fr;
      font-family: 'Nunito', sans-serif;
      height: 100vh;
      margin: 0;

      --text-color: rgb(46, 52, 56);
      --bg-color: rgb(246, 249, 252);

      @media (prefers-color-scheme: dark) {
        --text-color: rgb(201, 205, 207);
        --bg-color: rgb(34, 36, 37);
      }
    }
    #storybook-root, #storybook-docs {
      overflow-y: auto;
      max-height: 100vh;
      max-width: 100%;
    }
    #sb-navigator-container, #sb-navigator-container * {
      box-sizing: border-box;
    }
    #sb-navigator-container {
        height: 100vh;
        overflow-y: auto;
        border-right: 1px solid #eee;
        padding: 1rem;
        font-size: 14px;
        color: var(--text-color);
        background-color: var(--bg-color);
        align-self: start;
        z-index: 1000;
    }
    .sb-main-padded #sb-navigator-container {
      margin: -1rem 1rem -1rem -1rem;
    }
    .sb-navigator-list {
      list-style-type: none;
      padding: 0;
      margin: 0;
    }
    .sb-navigator-branch {
      list-style-type: none;
    }
    .sb-navigator-item {
      margin-bottom: 15px;
    }
    .sb-navigator-title {
      color: var(--text-color);
      text-decoration: none;
      padding-block: 5px;
      cursor: pointer;
    }
    .sb-navigator-entries {
      padding-left: 15px;
    }
    .sb-navigator-story-item {
      margin-bottom: 8px;
      margin-left: 8px;
    }
    .sb-navigator-story-link {
      color: var(--text-color);
    }
    .sb-navigator-story-link.active {
      font-weight: bold;
      color: rgb(2, 156, 253);
    }
  `;
  document.head.appendChild(style);
  nav.querySelector(".sb-navigator-story-link.active")?.closest("details")?.scrollIntoView({ block: "center" });
}, "setupPreviewNavigator");

// src/preview/utils.ts
var import_browser_dtector = __toESM(require_browser_dtector_umd_min(), 1);
var browserInfo;
function getBrowserInfo() {
  if (!browserInfo) {
    browserInfo = new import_browser_dtector.default(scope.navigator?.userAgent).getBrowserInfo();
  }
  return browserInfo;
}
__name(getBrowserInfo, "getBrowserInfo");
function prepareForTelemetry(error) {
  error.browserInfo = getBrowserInfo();
  return error;
}
__name(prepareForTelemetry, "prepareForTelemetry");

// src/preview/runtime.ts
function errorListener(args) {
  const error = args.error || args;
  if (error.fromStorybook) {
    scope.sendTelemetryError(error);
  }
}
__name(errorListener, "errorListener");
function unhandledRejectionListener({ reason }) {
  if (reason.fromStorybook) {
    scope.sendTelemetryError(reason);
  }
}
__name(unhandledRejectionListener, "unhandledRejectionListener");
function setup() {
  globalPackages.forEach((key) => {
    scope[globalsNameReferenceMap[key]] = globalsNameValueMap[key];
  });
  scope.sendTelemetryError = (error) => {
    const channel = scope.__STORYBOOK_ADDONS_CHANNEL__;
    channel.emit(TELEMETRY_ERROR, prepareForTelemetry(error));
  };
  scope.addEventListener("error", errorListener);
  scope.addEventListener("unhandledrejection", unhandledRejectionListener);
  maybeSetupPreviewNavigator();
}
__name(setup, "setup");
setup();
export {
  setup
};
