var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x2) => typeof require < "u" ? require : typeof Proxy < "u" ? new Proxy(x2, {
  get: (a2, b2) => (typeof require < "u" ? require : a2)[b2]
}) : x2)(function(x2) {
  if (typeof require < "u") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x2 + '" is not supported');
});
var __commonJS = (cb, mod) => function() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
));

// ../node_modules/@ngard/tiny-isequal/index.js
var require_tiny_isequal = __commonJS({
  "../node_modules/@ngard/tiny-isequal/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: !0 }), exports.isEqual = /* @__PURE__ */ (function() {
      var e2 = Object.prototype.toString, r2 = Object.getPrototypeOf, t2 = Object.getOwnPropertySymbols ? function(e3) {
        return Object.keys(e3).concat(Object.getOwnPropertySymbols(e3));
      } : Object.keys;
      return function(n2, a2) {
        return (function n3(a3, c2, u3) {
          var i2, s3, l2, o2 = e2.call(a3), f4 = e2.call(c2);
          if (a3 === c2) return !0;
          if (a3 == null || c2 == null) return !1;
          if (u3.indexOf(a3) > -1 && u3.indexOf(c2) > -1) return !0;
          if (u3.push(a3, c2), o2 != f4 || (i2 = t2(a3), s3 = t2(c2), i2.length != s3.length || i2.some(function(e3) {
            return !n3(a3[e3], c2[e3], u3);
          }))) return !1;
          switch (o2.slice(8, -1)) {
            case "Symbol":
              return a3.valueOf() == c2.valueOf();
            case "Date":
            case "Number":
              return +a3 == +c2 || +a3 != +a3 && +c2 != +c2;
            case "RegExp":
            case "Function":
            case "String":
            case "Boolean":
              return "" + a3 == "" + c2;
            case "Set":
            case "Map":
              i2 = a3.entries(), s3 = c2.entries();
              do
                if (!n3((l2 = i2.next()).value, s3.next().value, u3)) return !1;
              while (!l2.done);
              return !0;
            case "ArrayBuffer":
              a3 = new Uint8Array(a3), c2 = new Uint8Array(c2);
            case "DataView":
              a3 = new Uint8Array(a3.buffer), c2 = new Uint8Array(c2.buffer);
            case "Float32Array":
            case "Float64Array":
            case "Int8Array":
            case "Int16Array":
            case "Int32Array":
            case "Uint8Array":
            case "Uint16Array":
            case "Uint32Array":
            case "Uint8ClampedArray":
            case "Arguments":
            case "Array":
              if (a3.length != c2.length) return !1;
              for (l2 = 0; l2 < a3.length; l2++) if ((l2 in a3 || l2 in c2) && (l2 in a3 != l2 in c2 || !n3(a3[l2], c2[l2], u3))) return !1;
              return !0;
            case "Object":
              return n3(r2(a3), r2(c2), u3);
            default:
              return !1;
          }
        })(n2, a2, []);
      };
    })();
  }
});

// ../node_modules/min-indent/index.js
var require_min_indent = __commonJS({
  "../node_modules/min-indent/index.js"(exports, module2) {
    "use strict";
    module2.exports = (string) => {
      let match = string.match(/^[ \t]*(?=\S)/gm);
      return match ? match.reduce((r2, a2) => Math.min(r2, a2.length), 1 / 0) : 0;
    };
  }
});

// ../node_modules/strip-indent/index.js
var require_strip_indent = __commonJS({
  "../node_modules/strip-indent/index.js"(exports, module2) {
    "use strict";
    var minIndent = require_min_indent();
    module2.exports = (string) => {
      let indent2 = minIndent(string);
      if (indent2 === 0)
        return string;
      let regex = new RegExp(`^[ \\t]{${indent2}}`, "gm");
      return string.replace(regex, "");
    };
  }
});

// ../node_modules/indent-string/index.js
var require_indent_string = __commonJS({
  "../node_modules/indent-string/index.js"(exports, module2) {
    "use strict";
    module2.exports = (string, count2 = 1, options) => {
      if (options = {
        indent: " ",
        includeEmptyLines: !1,
        ...options
      }, typeof string != "string")
        throw new TypeError(
          `Expected \`input\` to be a \`string\`, got \`${typeof string}\``
        );
      if (typeof count2 != "number")
        throw new TypeError(
          `Expected \`count\` to be a \`number\`, got \`${typeof count2}\``
        );
      if (typeof options.indent != "string")
        throw new TypeError(
          `Expected \`options.indent\` to be a \`string\`, got \`${typeof options.indent}\``
        );
      if (count2 === 0)
        return string;
      let regex = options.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
      return string.replace(regex, options.indent.repeat(count2));
    };
  }
});

// ../node_modules/redent/index.js
var require_redent = __commonJS({
  "../node_modules/redent/index.js"(exports, module2) {
    "use strict";
    var stripIndent = require_strip_indent(), indentString = require_indent_string();
    module2.exports = (string, count2 = 0, options) => indentString(stripIndent(string), count2, options);
  }
});

// ../node_modules/aria-query/lib/util/iteratorProxy.js
var require_iteratorProxy = __commonJS({
  "../node_modules/aria-query/lib/util/iteratorProxy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    function iteratorProxy() {
      var values = this, index2 = 0, iter = {
        "@@iterator": function() {
          return iter;
        },
        next: function() {
          if (index2 < values.length) {
            var value = values[index2];
            return index2 = index2 + 1, {
              done: !1,
              value
            };
          } else
            return {
              done: !0
            };
        }
      };
      return iter;
    }
    var _default = exports.default = iteratorProxy;
  }
});

// ../node_modules/aria-query/lib/util/iterationDecorator.js
var require_iterationDecorator = __commonJS({
  "../node_modules/aria-query/lib/util/iterationDecorator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = iterationDecorator;
    var _iteratorProxy = _interopRequireDefault(require_iteratorProxy());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    function _typeof5(o2) {
      "@babel/helpers - typeof";
      return _typeof5 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o3) {
        return typeof o3;
      } : function(o3) {
        return o3 && typeof Symbol == "function" && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
      }, _typeof5(o2);
    }
    function iterationDecorator(collection, entries) {
      return typeof Symbol == "function" && _typeof5(Symbol.iterator) === "symbol" && Object.defineProperty(collection, Symbol.iterator, {
        value: _iteratorProxy.default.bind(entries)
      }), collection;
    }
  }
});

// ../node_modules/aria-query/lib/ariaPropsMap.js
var require_ariaPropsMap = __commonJS({
  "../node_modules/aria-query/lib/ariaPropsMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    function _slicedToArray(r2, e2) {
      return _arrayWithHoles(r2) || _iterableToArrayLimit(r2, e2) || _unsupportedIterableToArray(r2, e2) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    function _unsupportedIterableToArray(r2, a2) {
      if (r2) {
        if (typeof r2 == "string") return _arrayLikeToArray(r2, a2);
        var t2 = {}.toString.call(r2).slice(8, -1);
        return t2 === "Object" && r2.constructor && (t2 = r2.constructor.name), t2 === "Map" || t2 === "Set" ? Array.from(r2) : t2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray(r2, a2) : void 0;
      }
    }
    function _arrayLikeToArray(r2, a2) {
      (a2 == null || a2 > r2.length) && (a2 = r2.length);
      for (var e2 = 0, n2 = Array(a2); e2 < a2; e2++) n2[e2] = r2[e2];
      return n2;
    }
    function _iterableToArrayLimit(r2, l2) {
      var t2 = r2 == null ? null : typeof Symbol < "u" && r2[Symbol.iterator] || r2["@@iterator"];
      if (t2 != null) {
        var e2, n2, i2, u3, a2 = [], f4 = !0, o2 = !1;
        try {
          if (i2 = (t2 = t2.call(r2)).next, l2 === 0) {
            if (Object(t2) !== t2) return;
            f4 = !1;
          } else for (; !(f4 = (e2 = i2.call(t2)).done) && (a2.push(e2.value), a2.length !== l2); f4 = !0) ;
        } catch (r3) {
          o2 = !0, n2 = r3;
        } finally {
          try {
            if (!f4 && t2.return != null && (u3 = t2.return(), Object(u3) !== u3)) return;
          } finally {
            if (o2) throw n2;
          }
        }
        return a2;
      }
    }
    function _arrayWithHoles(r2) {
      if (Array.isArray(r2)) return r2;
    }
    var properties = [["aria-activedescendant", {
      type: "id"
    }], ["aria-atomic", {
      type: "boolean"
    }], ["aria-autocomplete", {
      type: "token",
      values: ["inline", "list", "both", "none"]
    }], ["aria-braillelabel", {
      type: "string"
    }], ["aria-brailleroledescription", {
      type: "string"
    }], ["aria-busy", {
      type: "boolean"
    }], ["aria-checked", {
      type: "tristate"
    }], ["aria-colcount", {
      type: "integer"
    }], ["aria-colindex", {
      type: "integer"
    }], ["aria-colspan", {
      type: "integer"
    }], ["aria-controls", {
      type: "idlist"
    }], ["aria-current", {
      type: "token",
      values: ["page", "step", "location", "date", "time", !0, !1]
    }], ["aria-describedby", {
      type: "idlist"
    }], ["aria-description", {
      type: "string"
    }], ["aria-details", {
      type: "id"
    }], ["aria-disabled", {
      type: "boolean"
    }], ["aria-dropeffect", {
      type: "tokenlist",
      values: ["copy", "execute", "link", "move", "none", "popup"]
    }], ["aria-errormessage", {
      type: "id"
    }], ["aria-expanded", {
      type: "boolean",
      allowundefined: !0
    }], ["aria-flowto", {
      type: "idlist"
    }], ["aria-grabbed", {
      type: "boolean",
      allowundefined: !0
    }], ["aria-haspopup", {
      type: "token",
      values: [!1, !0, "menu", "listbox", "tree", "grid", "dialog"]
    }], ["aria-hidden", {
      type: "boolean",
      allowundefined: !0
    }], ["aria-invalid", {
      type: "token",
      values: ["grammar", !1, "spelling", !0]
    }], ["aria-keyshortcuts", {
      type: "string"
    }], ["aria-label", {
      type: "string"
    }], ["aria-labelledby", {
      type: "idlist"
    }], ["aria-level", {
      type: "integer"
    }], ["aria-live", {
      type: "token",
      values: ["assertive", "off", "polite"]
    }], ["aria-modal", {
      type: "boolean"
    }], ["aria-multiline", {
      type: "boolean"
    }], ["aria-multiselectable", {
      type: "boolean"
    }], ["aria-orientation", {
      type: "token",
      values: ["vertical", "undefined", "horizontal"]
    }], ["aria-owns", {
      type: "idlist"
    }], ["aria-placeholder", {
      type: "string"
    }], ["aria-posinset", {
      type: "integer"
    }], ["aria-pressed", {
      type: "tristate"
    }], ["aria-readonly", {
      type: "boolean"
    }], ["aria-relevant", {
      type: "tokenlist",
      values: ["additions", "all", "removals", "text"]
    }], ["aria-required", {
      type: "boolean"
    }], ["aria-roledescription", {
      type: "string"
    }], ["aria-rowcount", {
      type: "integer"
    }], ["aria-rowindex", {
      type: "integer"
    }], ["aria-rowspan", {
      type: "integer"
    }], ["aria-selected", {
      type: "boolean",
      allowundefined: !0
    }], ["aria-setsize", {
      type: "integer"
    }], ["aria-sort", {
      type: "token",
      values: ["ascending", "descending", "none", "other"]
    }], ["aria-valuemax", {
      type: "number"
    }], ["aria-valuemin", {
      type: "number"
    }], ["aria-valuenow", {
      type: "number"
    }], ["aria-valuetext", {
      type: "string"
    }]], ariaPropsMap = {
      entries: function() {
        return properties;
      },
      forEach: function(fn3) {
        for (var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, _i = 0, _properties = properties; _i < _properties.length; _i++) {
          var _properties$_i = _slicedToArray(_properties[_i], 2), key = _properties$_i[0], values = _properties$_i[1];
          fn3.call(thisArg, values, key, properties);
        }
      },
      get: function(key) {
        var item = properties.filter(function(tuple) {
          return tuple[0] === key;
        })[0];
        return item && item[1];
      },
      has: function(key) {
        return !!ariaPropsMap.get(key);
      },
      keys: function() {
        return properties.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key = _ref2[0];
          return key;
        });
      },
      values: function() {
        return properties.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }
    }, _default = exports.default = (0, _iterationDecorator.default)(ariaPropsMap, ariaPropsMap.entries());
  }
});

// ../node_modules/aria-query/lib/domMap.js
var require_domMap = __commonJS({
  "../node_modules/aria-query/lib/domMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    function _slicedToArray(r2, e2) {
      return _arrayWithHoles(r2) || _iterableToArrayLimit(r2, e2) || _unsupportedIterableToArray(r2, e2) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    function _unsupportedIterableToArray(r2, a2) {
      if (r2) {
        if (typeof r2 == "string") return _arrayLikeToArray(r2, a2);
        var t2 = {}.toString.call(r2).slice(8, -1);
        return t2 === "Object" && r2.constructor && (t2 = r2.constructor.name), t2 === "Map" || t2 === "Set" ? Array.from(r2) : t2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray(r2, a2) : void 0;
      }
    }
    function _arrayLikeToArray(r2, a2) {
      (a2 == null || a2 > r2.length) && (a2 = r2.length);
      for (var e2 = 0, n2 = Array(a2); e2 < a2; e2++) n2[e2] = r2[e2];
      return n2;
    }
    function _iterableToArrayLimit(r2, l2) {
      var t2 = r2 == null ? null : typeof Symbol < "u" && r2[Symbol.iterator] || r2["@@iterator"];
      if (t2 != null) {
        var e2, n2, i2, u3, a2 = [], f4 = !0, o2 = !1;
        try {
          if (i2 = (t2 = t2.call(r2)).next, l2 === 0) {
            if (Object(t2) !== t2) return;
            f4 = !1;
          } else for (; !(f4 = (e2 = i2.call(t2)).done) && (a2.push(e2.value), a2.length !== l2); f4 = !0) ;
        } catch (r3) {
          o2 = !0, n2 = r3;
        } finally {
          try {
            if (!f4 && t2.return != null && (u3 = t2.return(), Object(u3) !== u3)) return;
          } finally {
            if (o2) throw n2;
          }
        }
        return a2;
      }
    }
    function _arrayWithHoles(r2) {
      if (Array.isArray(r2)) return r2;
    }
    var dom = [["a", {
      reserved: !1
    }], ["abbr", {
      reserved: !1
    }], ["acronym", {
      reserved: !1
    }], ["address", {
      reserved: !1
    }], ["applet", {
      reserved: !1
    }], ["area", {
      reserved: !1
    }], ["article", {
      reserved: !1
    }], ["aside", {
      reserved: !1
    }], ["audio", {
      reserved: !1
    }], ["b", {
      reserved: !1
    }], ["base", {
      reserved: !0
    }], ["bdi", {
      reserved: !1
    }], ["bdo", {
      reserved: !1
    }], ["big", {
      reserved: !1
    }], ["blink", {
      reserved: !1
    }], ["blockquote", {
      reserved: !1
    }], ["body", {
      reserved: !1
    }], ["br", {
      reserved: !1
    }], ["button", {
      reserved: !1
    }], ["canvas", {
      reserved: !1
    }], ["caption", {
      reserved: !1
    }], ["center", {
      reserved: !1
    }], ["cite", {
      reserved: !1
    }], ["code", {
      reserved: !1
    }], ["col", {
      reserved: !0
    }], ["colgroup", {
      reserved: !0
    }], ["content", {
      reserved: !1
    }], ["data", {
      reserved: !1
    }], ["datalist", {
      reserved: !1
    }], ["dd", {
      reserved: !1
    }], ["del", {
      reserved: !1
    }], ["details", {
      reserved: !1
    }], ["dfn", {
      reserved: !1
    }], ["dialog", {
      reserved: !1
    }], ["dir", {
      reserved: !1
    }], ["div", {
      reserved: !1
    }], ["dl", {
      reserved: !1
    }], ["dt", {
      reserved: !1
    }], ["em", {
      reserved: !1
    }], ["embed", {
      reserved: !1
    }], ["fieldset", {
      reserved: !1
    }], ["figcaption", {
      reserved: !1
    }], ["figure", {
      reserved: !1
    }], ["font", {
      reserved: !1
    }], ["footer", {
      reserved: !1
    }], ["form", {
      reserved: !1
    }], ["frame", {
      reserved: !1
    }], ["frameset", {
      reserved: !1
    }], ["h1", {
      reserved: !1
    }], ["h2", {
      reserved: !1
    }], ["h3", {
      reserved: !1
    }], ["h4", {
      reserved: !1
    }], ["h5", {
      reserved: !1
    }], ["h6", {
      reserved: !1
    }], ["head", {
      reserved: !0
    }], ["header", {
      reserved: !1
    }], ["hgroup", {
      reserved: !1
    }], ["hr", {
      reserved: !1
    }], ["html", {
      reserved: !0
    }], ["i", {
      reserved: !1
    }], ["iframe", {
      reserved: !1
    }], ["img", {
      reserved: !1
    }], ["input", {
      reserved: !1
    }], ["ins", {
      reserved: !1
    }], ["kbd", {
      reserved: !1
    }], ["keygen", {
      reserved: !1
    }], ["label", {
      reserved: !1
    }], ["legend", {
      reserved: !1
    }], ["li", {
      reserved: !1
    }], ["link", {
      reserved: !0
    }], ["main", {
      reserved: !1
    }], ["map", {
      reserved: !1
    }], ["mark", {
      reserved: !1
    }], ["marquee", {
      reserved: !1
    }], ["menu", {
      reserved: !1
    }], ["menuitem", {
      reserved: !1
    }], ["meta", {
      reserved: !0
    }], ["meter", {
      reserved: !1
    }], ["nav", {
      reserved: !1
    }], ["noembed", {
      reserved: !0
    }], ["noscript", {
      reserved: !0
    }], ["object", {
      reserved: !1
    }], ["ol", {
      reserved: !1
    }], ["optgroup", {
      reserved: !1
    }], ["option", {
      reserved: !1
    }], ["output", {
      reserved: !1
    }], ["p", {
      reserved: !1
    }], ["param", {
      reserved: !0
    }], ["picture", {
      reserved: !0
    }], ["pre", {
      reserved: !1
    }], ["progress", {
      reserved: !1
    }], ["q", {
      reserved: !1
    }], ["rp", {
      reserved: !1
    }], ["rt", {
      reserved: !1
    }], ["rtc", {
      reserved: !1
    }], ["ruby", {
      reserved: !1
    }], ["s", {
      reserved: !1
    }], ["samp", {
      reserved: !1
    }], ["script", {
      reserved: !0
    }], ["section", {
      reserved: !1
    }], ["select", {
      reserved: !1
    }], ["small", {
      reserved: !1
    }], ["source", {
      reserved: !0
    }], ["spacer", {
      reserved: !1
    }], ["span", {
      reserved: !1
    }], ["strike", {
      reserved: !1
    }], ["strong", {
      reserved: !1
    }], ["style", {
      reserved: !0
    }], ["sub", {
      reserved: !1
    }], ["summary", {
      reserved: !1
    }], ["sup", {
      reserved: !1
    }], ["table", {
      reserved: !1
    }], ["tbody", {
      reserved: !1
    }], ["td", {
      reserved: !1
    }], ["textarea", {
      reserved: !1
    }], ["tfoot", {
      reserved: !1
    }], ["th", {
      reserved: !1
    }], ["thead", {
      reserved: !1
    }], ["time", {
      reserved: !1
    }], ["title", {
      reserved: !0
    }], ["tr", {
      reserved: !1
    }], ["track", {
      reserved: !0
    }], ["tt", {
      reserved: !1
    }], ["u", {
      reserved: !1
    }], ["ul", {
      reserved: !1
    }], ["var", {
      reserved: !1
    }], ["video", {
      reserved: !1
    }], ["wbr", {
      reserved: !1
    }], ["xmp", {
      reserved: !1
    }]], domMap = {
      entries: function() {
        return dom;
      },
      forEach: function(fn3) {
        for (var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, _i = 0, _dom = dom; _i < _dom.length; _i++) {
          var _dom$_i = _slicedToArray(_dom[_i], 2), key = _dom$_i[0], values = _dom$_i[1];
          fn3.call(thisArg, values, key, dom);
        }
      },
      get: function(key) {
        var item = dom.filter(function(tuple) {
          return tuple[0] === key;
        })[0];
        return item && item[1];
      },
      has: function(key) {
        return !!domMap.get(key);
      },
      keys: function() {
        return dom.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key = _ref2[0];
          return key;
        });
      },
      values: function() {
        return dom.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }
    }, _default = exports.default = (0, _iterationDecorator.default)(domMap, domMap.entries());
  }
});

// ../node_modules/aria-query/lib/etc/roles/abstract/commandRole.js
var require_commandRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/abstract/commandRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var commandRole = {
      abstract: !0,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget"]]
    }, _default = exports.default = commandRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/abstract/compositeRole.js
var require_compositeRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/abstract/compositeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var compositeRole = {
      abstract: !0,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-disabled": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget"]]
    }, _default = exports.default = compositeRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/abstract/inputRole.js
var require_inputRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/abstract/inputRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var inputRole = {
      abstract: !0,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null
      },
      relatedConcepts: [{
        concept: {
          name: "input"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget"]]
    }, _default = exports.default = inputRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/abstract/landmarkRole.js
var require_landmarkRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/abstract/landmarkRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var landmarkRole = {
      abstract: !0,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    }, _default = exports.default = landmarkRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/abstract/rangeRole.js
var require_rangeRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/abstract/rangeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var rangeRole = {
      abstract: !0,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-valuemax": null,
        "aria-valuemin": null,
        "aria-valuenow": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    }, _default = exports.default = rangeRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/abstract/roletypeRole.js
var require_roletypeRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/abstract/roletypeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var roletypeRole = {
      abstract: !0,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: [],
      prohibitedProps: [],
      props: {
        "aria-atomic": null,
        "aria-busy": null,
        "aria-controls": null,
        "aria-current": null,
        "aria-describedby": null,
        "aria-details": null,
        "aria-dropeffect": null,
        "aria-flowto": null,
        "aria-grabbed": null,
        "aria-hidden": null,
        "aria-keyshortcuts": null,
        "aria-label": null,
        "aria-labelledby": null,
        "aria-live": null,
        "aria-owns": null,
        "aria-relevant": null,
        "aria-roledescription": null
      },
      relatedConcepts: [{
        concept: {
          name: "role"
        },
        module: "XHTML"
      }, {
        concept: {
          name: "type"
        },
        module: "Dublin Core"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: []
    }, _default = exports.default = roletypeRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/abstract/sectionRole.js
var require_sectionRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/abstract/sectionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var sectionRole = {
      abstract: !0,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: [],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "frontmatter"
        },
        module: "DTB"
      }, {
        concept: {
          name: "level"
        },
        module: "DTB"
      }, {
        concept: {
          name: "level"
        },
        module: "SMIL"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    }, _default = exports.default = sectionRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/abstract/sectionheadRole.js
var require_sectionheadRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/abstract/sectionheadRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var sectionheadRole = {
      abstract: !0,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    }, _default = exports.default = sectionheadRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/abstract/selectRole.js
var require_selectRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/abstract/selectRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var selectRole = {
      abstract: !0,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-orientation": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite"], ["roletype", "structure", "section", "group"]]
    }, _default = exports.default = selectRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/abstract/structureRole.js
var require_structureRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/abstract/structureRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var structureRole = {
      abstract: !0,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: [],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype"]]
    }, _default = exports.default = structureRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/abstract/widgetRole.js
var require_widgetRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/abstract/widgetRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var widgetRole = {
      abstract: !0,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: [],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype"]]
    }, _default = exports.default = widgetRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/abstract/windowRole.js
var require_windowRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/abstract/windowRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var windowRole = {
      abstract: !0,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-modal": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype"]]
    }, _default = exports.default = windowRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/ariaAbstractRoles.js
var require_ariaAbstractRoles = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/ariaAbstractRoles.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var _commandRole = _interopRequireDefault(require_commandRole()), _compositeRole = _interopRequireDefault(require_compositeRole()), _inputRole = _interopRequireDefault(require_inputRole()), _landmarkRole = _interopRequireDefault(require_landmarkRole()), _rangeRole = _interopRequireDefault(require_rangeRole()), _roletypeRole = _interopRequireDefault(require_roletypeRole()), _sectionRole = _interopRequireDefault(require_sectionRole()), _sectionheadRole = _interopRequireDefault(require_sectionheadRole()), _selectRole = _interopRequireDefault(require_selectRole()), _structureRole = _interopRequireDefault(require_structureRole()), _widgetRole = _interopRequireDefault(require_widgetRole()), _windowRole = _interopRequireDefault(require_windowRole());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    var ariaAbstractRoles = [["command", _commandRole.default], ["composite", _compositeRole.default], ["input", _inputRole.default], ["landmark", _landmarkRole.default], ["range", _rangeRole.default], ["roletype", _roletypeRole.default], ["section", _sectionRole.default], ["sectionhead", _sectionheadRole.default], ["select", _selectRole.default], ["structure", _structureRole.default], ["widget", _widgetRole.default], ["window", _windowRole.default]], _default = exports.default = ariaAbstractRoles;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/alertRole.js
var require_alertRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/alertRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var alertRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-atomic": "true",
        "aria-live": "assertive"
      },
      relatedConcepts: [{
        concept: {
          name: "alert"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    }, _default = exports.default = alertRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/alertdialogRole.js
var require_alertdialogRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/alertdialogRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var alertdialogRole = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "alert"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "alert"], ["roletype", "window", "dialog"]]
    }, _default = exports.default = alertdialogRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/applicationRole.js
var require_applicationRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/applicationRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var applicationRole = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "Device Independence Delivery Unit"
        }
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    }, _default = exports.default = applicationRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/articleRole.js
var require_articleRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/articleRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var articleRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-posinset": null,
        "aria-setsize": null
      },
      relatedConcepts: [{
        concept: {
          name: "article"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "document"]]
    }, _default = exports.default = articleRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/bannerRole.js
var require_bannerRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/bannerRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var bannerRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          constraints: ["scoped to the body element"],
          name: "header"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    }, _default = exports.default = bannerRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/blockquoteRole.js
var require_blockquoteRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/blockquoteRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var blockquoteRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "blockquote"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    }, _default = exports.default = blockquoteRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/buttonRole.js
var require_buttonRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/buttonRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var buttonRole = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-pressed": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "type",
            value: "button"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "type",
            value: "image"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "type",
            value: "reset"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "type",
            value: "submit"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          name: "button"
        },
        module: "HTML"
      }, {
        concept: {
          name: "trigger"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command"]]
    }, _default = exports.default = buttonRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/captionRole.js
var require_captionRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/captionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var captionRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "caption"
        },
        module: "HTML"
      }],
      requireContextRole: ["figure", "grid", "table"],
      requiredContextRole: ["figure", "grid", "table"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    }, _default = exports.default = captionRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/cellRole.js
var require_cellRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/cellRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var cellRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-colindex": null,
        "aria-colspan": null,
        "aria-rowindex": null,
        "aria-rowspan": null
      },
      relatedConcepts: [{
        concept: {
          constraints: ["ancestor table element has table role"],
          name: "td"
        },
        module: "HTML"
      }],
      requireContextRole: ["row"],
      requiredContextRole: ["row"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    }, _default = exports.default = cellRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/checkboxRole.js
var require_checkboxRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/checkboxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var checkboxRole = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-checked": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "type",
            value: "checkbox"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          name: "option"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [["roletype", "widget", "input"]]
    }, _default = exports.default = checkboxRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/codeRole.js
var require_codeRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/codeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var codeRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "code"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    }, _default = exports.default = codeRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/columnheaderRole.js
var require_columnheaderRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/columnheaderRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var columnheaderRole = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-sort": null
      },
      relatedConcepts: [{
        concept: {
          name: "th"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "scope",
            value: "col"
          }],
          name: "th"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "scope",
            value: "colgroup"
          }],
          name: "th"
        },
        module: "HTML"
      }],
      requireContextRole: ["row"],
      requiredContextRole: ["row"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "cell"], ["roletype", "structure", "section", "cell", "gridcell"], ["roletype", "widget", "gridcell"], ["roletype", "structure", "sectionhead"]]
    }, _default = exports.default = columnheaderRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/comboboxRole.js
var require_comboboxRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/comboboxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var comboboxRole = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-autocomplete": null,
        "aria-errormessage": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null,
        "aria-expanded": "false",
        "aria-haspopup": "listbox"
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "email"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "search"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "tel"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "text"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "url"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "url"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "multiple"
          }, {
            constraints: ["undefined"],
            name: "size"
          }],
          constraints: ["the multiple attribute is not set and the size attribute does not have a value greater than 1"],
          name: "select"
        },
        module: "HTML"
      }, {
        concept: {
          name: "select"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-controls": null,
        "aria-expanded": "false"
      },
      superClass: [["roletype", "widget", "input"]]
    }, _default = exports.default = comboboxRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/complementaryRole.js
var require_complementaryRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/complementaryRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var complementaryRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          constraints: ["scoped to the body element", "scoped to the main element"],
          name: "aside"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-label"
          }],
          constraints: ["scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
          name: "aside"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-labelledby"
          }],
          constraints: ["scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
          name: "aside"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    }, _default = exports.default = complementaryRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/contentinfoRole.js
var require_contentinfoRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/contentinfoRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var contentinfoRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          constraints: ["scoped to the body element"],
          name: "footer"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    }, _default = exports.default = contentinfoRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/definitionRole.js
var require_definitionRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/definitionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var definitionRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "dd"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    }, _default = exports.default = definitionRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/deletionRole.js
var require_deletionRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/deletionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var deletionRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "del"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    }, _default = exports.default = deletionRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/dialogRole.js
var require_dialogRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/dialogRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var dialogRole = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "dialog"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "window"]]
    }, _default = exports.default = dialogRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/directoryRole.js
var require_directoryRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/directoryRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var directoryRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        module: "DAISY Guide"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "list"]]
    }, _default = exports.default = directoryRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/documentRole.js
var require_documentRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/documentRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var documentRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "Device Independence Delivery Unit"
        }
      }, {
        concept: {
          name: "html"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    }, _default = exports.default = documentRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/emphasisRole.js
var require_emphasisRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/emphasisRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var emphasisRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "em"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    }, _default = exports.default = emphasisRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/feedRole.js
var require_feedRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/feedRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var feedRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["article"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "list"]]
    }, _default = exports.default = feedRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/figureRole.js
var require_figureRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/figureRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var figureRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "figure"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    }, _default = exports.default = figureRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/formRole.js
var require_formRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/formRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var formRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-label"
          }],
          name: "form"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-labelledby"
          }],
          name: "form"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "name"
          }],
          name: "form"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    }, _default = exports.default = formRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/genericRole.js
var require_genericRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/genericRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var genericRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "a"
        },
        module: "HTML"
      }, {
        concept: {
          name: "area"
        },
        module: "HTML"
      }, {
        concept: {
          name: "aside"
        },
        module: "HTML"
      }, {
        concept: {
          name: "b"
        },
        module: "HTML"
      }, {
        concept: {
          name: "bdo"
        },
        module: "HTML"
      }, {
        concept: {
          name: "body"
        },
        module: "HTML"
      }, {
        concept: {
          name: "data"
        },
        module: "HTML"
      }, {
        concept: {
          name: "div"
        },
        module: "HTML"
      }, {
        concept: {
          constraints: ["scoped to the main element", "scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
          name: "footer"
        },
        module: "HTML"
      }, {
        concept: {
          constraints: ["scoped to the main element", "scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
          name: "header"
        },
        module: "HTML"
      }, {
        concept: {
          name: "hgroup"
        },
        module: "HTML"
      }, {
        concept: {
          name: "i"
        },
        module: "HTML"
      }, {
        concept: {
          name: "pre"
        },
        module: "HTML"
      }, {
        concept: {
          name: "q"
        },
        module: "HTML"
      }, {
        concept: {
          name: "samp"
        },
        module: "HTML"
      }, {
        concept: {
          name: "section"
        },
        module: "HTML"
      }, {
        concept: {
          name: "small"
        },
        module: "HTML"
      }, {
        concept: {
          name: "span"
        },
        module: "HTML"
      }, {
        concept: {
          name: "u"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    }, _default = exports.default = genericRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/gridRole.js
var require_gridRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/gridRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var gridRole = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-multiselectable": null,
        "aria-readonly": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["row"], ["row", "rowgroup"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite"], ["roletype", "structure", "section", "table"]]
    }, _default = exports.default = gridRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/gridcellRole.js
var require_gridcellRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/gridcellRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var gridcellRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null,
        "aria-selected": null
      },
      relatedConcepts: [{
        concept: {
          constraints: ["ancestor table element has grid role", "ancestor table element has treegrid role"],
          name: "td"
        },
        module: "HTML"
      }],
      requireContextRole: ["row"],
      requiredContextRole: ["row"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "cell"], ["roletype", "widget"]]
    }, _default = exports.default = gridcellRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/groupRole.js
var require_groupRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/groupRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var groupRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-disabled": null
      },
      relatedConcepts: [{
        concept: {
          name: "details"
        },
        module: "HTML"
      }, {
        concept: {
          name: "fieldset"
        },
        module: "HTML"
      }, {
        concept: {
          name: "optgroup"
        },
        module: "HTML"
      }, {
        concept: {
          name: "address"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    }, _default = exports.default = groupRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/headingRole.js
var require_headingRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/headingRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var headingRole = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-level": "2"
      },
      relatedConcepts: [{
        concept: {
          name: "h1"
        },
        module: "HTML"
      }, {
        concept: {
          name: "h2"
        },
        module: "HTML"
      }, {
        concept: {
          name: "h3"
        },
        module: "HTML"
      }, {
        concept: {
          name: "h4"
        },
        module: "HTML"
      }, {
        concept: {
          name: "h5"
        },
        module: "HTML"
      }, {
        concept: {
          name: "h6"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-level": "2"
      },
      superClass: [["roletype", "structure", "sectionhead"]]
    }, _default = exports.default = headingRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/imgRole.js
var require_imgRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/imgRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var imgRole = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "alt"
          }],
          name: "img"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "alt"
          }],
          name: "img"
        },
        module: "HTML"
      }, {
        concept: {
          name: "imggroup"
        },
        module: "DTB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    }, _default = exports.default = imgRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/insertionRole.js
var require_insertionRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/insertionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var insertionRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "ins"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    }, _default = exports.default = insertionRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/linkRole.js
var require_linkRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/linkRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var linkRole = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-expanded": null,
        "aria-haspopup": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "href"
          }],
          name: "a"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "href"
          }],
          name: "area"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command"]]
    }, _default = exports.default = linkRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/listRole.js
var require_listRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/listRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var listRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "menu"
        },
        module: "HTML"
      }, {
        concept: {
          name: "ol"
        },
        module: "HTML"
      }, {
        concept: {
          name: "ul"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["listitem"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    }, _default = exports.default = listRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/listboxRole.js
var require_listboxRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/listboxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var listboxRole = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-invalid": null,
        "aria-multiselectable": null,
        "aria-readonly": null,
        "aria-required": null,
        "aria-orientation": "vertical"
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: [">1"],
            name: "size"
          }],
          constraints: ["the size attribute value is greater than 1"],
          name: "select"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "multiple"
          }],
          name: "select"
        },
        module: "HTML"
      }, {
        concept: {
          name: "datalist"
        },
        module: "HTML"
      }, {
        concept: {
          name: "list"
        },
        module: "ARIA"
      }, {
        concept: {
          name: "select"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["option", "group"], ["option"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
    }, _default = exports.default = listboxRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/listitemRole.js
var require_listitemRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/listitemRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var listitemRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-level": null,
        "aria-posinset": null,
        "aria-setsize": null
      },
      relatedConcepts: [{
        concept: {
          constraints: ["direct descendant of ol", "direct descendant of ul", "direct descendant of menu"],
          name: "li"
        },
        module: "HTML"
      }, {
        concept: {
          name: "item"
        },
        module: "XForms"
      }],
      requireContextRole: ["directory", "list"],
      requiredContextRole: ["directory", "list"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    }, _default = exports.default = listitemRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/logRole.js
var require_logRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/logRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var logRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-live": "polite"
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    }, _default = exports.default = logRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/mainRole.js
var require_mainRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/mainRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var mainRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "main"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    }, _default = exports.default = mainRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/markRole.js
var require_markRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/markRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var markRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["prohibited"],
      prohibitedProps: [],
      props: {
        "aria-braillelabel": null,
        "aria-brailleroledescription": null,
        "aria-description": null
      },
      relatedConcepts: [{
        concept: {
          name: "mark"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    }, _default = exports.default = markRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/marqueeRole.js
var require_marqueeRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/marqueeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var marqueeRole = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    }, _default = exports.default = marqueeRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/mathRole.js
var require_mathRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/mathRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var mathRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "math"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    }, _default = exports.default = mathRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/menuRole.js
var require_menuRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/menuRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var menuRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-orientation": "vertical"
      },
      relatedConcepts: [{
        concept: {
          name: "MENU"
        },
        module: "JAPI"
      }, {
        concept: {
          name: "list"
        },
        module: "ARIA"
      }, {
        concept: {
          name: "select"
        },
        module: "XForms"
      }, {
        concept: {
          name: "sidebar"
        },
        module: "DTB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["menuitem", "group"], ["menuitemradio", "group"], ["menuitemcheckbox", "group"], ["menuitem"], ["menuitemcheckbox"], ["menuitemradio"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
    }, _default = exports.default = menuRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/menubarRole.js
var require_menubarRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/menubarRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var menubarRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-orientation": "horizontal"
      },
      relatedConcepts: [{
        concept: {
          name: "toolbar"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["menuitem", "group"], ["menuitemradio", "group"], ["menuitemcheckbox", "group"], ["menuitem"], ["menuitemcheckbox"], ["menuitemradio"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "select", "menu"], ["roletype", "structure", "section", "group", "select", "menu"]]
    }, _default = exports.default = menubarRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/menuitemRole.js
var require_menuitemRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/menuitemRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var menuitemRole = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-posinset": null,
        "aria-setsize": null
      },
      relatedConcepts: [{
        concept: {
          name: "MENU_ITEM"
        },
        module: "JAPI"
      }, {
        concept: {
          name: "listitem"
        },
        module: "ARIA"
      }, {
        concept: {
          name: "option"
        },
        module: "ARIA"
      }],
      requireContextRole: ["group", "menu", "menubar"],
      requiredContextRole: ["group", "menu", "menubar"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command"]]
    }, _default = exports.default = menuitemRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/menuitemcheckboxRole.js
var require_menuitemcheckboxRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/menuitemcheckboxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var menuitemcheckboxRole = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "menuitem"
        },
        module: "ARIA"
      }],
      requireContextRole: ["group", "menu", "menubar"],
      requiredContextRole: ["group", "menu", "menubar"],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [["roletype", "widget", "input", "checkbox"], ["roletype", "widget", "command", "menuitem"]]
    }, _default = exports.default = menuitemcheckboxRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/menuitemradioRole.js
var require_menuitemradioRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/menuitemradioRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var menuitemradioRole = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "menuitem"
        },
        module: "ARIA"
      }],
      requireContextRole: ["group", "menu", "menubar"],
      requiredContextRole: ["group", "menu", "menubar"],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [["roletype", "widget", "input", "checkbox", "menuitemcheckbox"], ["roletype", "widget", "command", "menuitem", "menuitemcheckbox"], ["roletype", "widget", "input", "radio"]]
    }, _default = exports.default = menuitemradioRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/meterRole.js
var require_meterRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/meterRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var meterRole = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-valuetext": null,
        "aria-valuemax": "100",
        "aria-valuemin": "0"
      },
      relatedConcepts: [{
        concept: {
          name: "meter"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-valuenow": null
      },
      superClass: [["roletype", "structure", "range"]]
    }, _default = exports.default = meterRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/navigationRole.js
var require_navigationRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/navigationRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var navigationRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "nav"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    }, _default = exports.default = navigationRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/noneRole.js
var require_noneRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/noneRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var noneRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: [],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: []
    }, _default = exports.default = noneRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/noteRole.js
var require_noteRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/noteRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var noteRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    }, _default = exports.default = noteRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/optionRole.js
var require_optionRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/optionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var optionRole = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-checked": null,
        "aria-posinset": null,
        "aria-setsize": null,
        "aria-selected": "false"
      },
      relatedConcepts: [{
        concept: {
          name: "item"
        },
        module: "XForms"
      }, {
        concept: {
          name: "listitem"
        },
        module: "ARIA"
      }, {
        concept: {
          name: "option"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-selected": "false"
      },
      superClass: [["roletype", "widget", "input"]]
    }, _default = exports.default = optionRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/paragraphRole.js
var require_paragraphRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/paragraphRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var paragraphRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "p"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    }, _default = exports.default = paragraphRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/presentationRole.js
var require_presentationRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/presentationRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var presentationRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "alt",
            value: ""
          }],
          name: "img"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    }, _default = exports.default = presentationRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/progressbarRole.js
var require_progressbarRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/progressbarRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var progressbarRole = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-valuetext": null
      },
      relatedConcepts: [{
        concept: {
          name: "progress"
        },
        module: "HTML"
      }, {
        concept: {
          name: "status"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "range"], ["roletype", "widget"]]
    }, _default = exports.default = progressbarRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/radioRole.js
var require_radioRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/radioRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var radioRole = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-checked": null,
        "aria-posinset": null,
        "aria-setsize": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "type",
            value: "radio"
          }],
          name: "input"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [["roletype", "widget", "input"]]
    }, _default = exports.default = radioRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/radiogroupRole.js
var require_radiogroupRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/radiogroupRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var radiogroupRole = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null
      },
      relatedConcepts: [{
        concept: {
          name: "list"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["radio"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
    }, _default = exports.default = radiogroupRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/regionRole.js
var require_regionRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/regionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var regionRole = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-label"
          }],
          name: "section"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-labelledby"
          }],
          name: "section"
        },
        module: "HTML"
      }, {
        concept: {
          name: "Device Independence Glossart perceivable unit"
        }
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    }, _default = exports.default = regionRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/rowRole.js
var require_rowRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/rowRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var rowRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-colindex": null,
        "aria-expanded": null,
        "aria-level": null,
        "aria-posinset": null,
        "aria-rowindex": null,
        "aria-selected": null,
        "aria-setsize": null
      },
      relatedConcepts: [{
        concept: {
          name: "tr"
        },
        module: "HTML"
      }],
      requireContextRole: ["grid", "rowgroup", "table", "treegrid"],
      requiredContextRole: ["grid", "rowgroup", "table", "treegrid"],
      requiredOwnedElements: [["cell"], ["columnheader"], ["gridcell"], ["rowheader"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "group"], ["roletype", "widget"]]
    }, _default = exports.default = rowRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/rowgroupRole.js
var require_rowgroupRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/rowgroupRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var rowgroupRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "tbody"
        },
        module: "HTML"
      }, {
        concept: {
          name: "tfoot"
        },
        module: "HTML"
      }, {
        concept: {
          name: "thead"
        },
        module: "HTML"
      }],
      requireContextRole: ["grid", "table", "treegrid"],
      requiredContextRole: ["grid", "table", "treegrid"],
      requiredOwnedElements: [["row"]],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    }, _default = exports.default = rowgroupRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/rowheaderRole.js
var require_rowheaderRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/rowheaderRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var rowheaderRole = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-sort": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "scope",
            value: "row"
          }],
          name: "th"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "scope",
            value: "rowgroup"
          }],
          name: "th"
        },
        module: "HTML"
      }],
      requireContextRole: ["row", "rowgroup"],
      requiredContextRole: ["row", "rowgroup"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "cell"], ["roletype", "structure", "section", "cell", "gridcell"], ["roletype", "widget", "gridcell"], ["roletype", "structure", "sectionhead"]]
    }, _default = exports.default = rowheaderRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/scrollbarRole.js
var require_scrollbarRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/scrollbarRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var scrollbarRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-valuetext": null,
        "aria-orientation": "vertical",
        "aria-valuemax": "100",
        "aria-valuemin": "0"
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-controls": null,
        "aria-valuenow": null
      },
      superClass: [["roletype", "structure", "range"], ["roletype", "widget"]]
    }, _default = exports.default = scrollbarRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/searchRole.js
var require_searchRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/searchRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var searchRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    }, _default = exports.default = searchRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/searchboxRole.js
var require_searchboxRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/searchboxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var searchboxRole = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "list"
          }, {
            name: "type",
            value: "search"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "input", "textbox"]]
    }, _default = exports.default = searchboxRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/separatorRole.js
var require_separatorRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/separatorRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var separatorRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-orientation": "horizontal",
        "aria-valuemax": "100",
        "aria-valuemin": "0",
        "aria-valuenow": null,
        "aria-valuetext": null
      },
      relatedConcepts: [{
        concept: {
          name: "hr"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    }, _default = exports.default = separatorRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/sliderRole.js
var require_sliderRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/sliderRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var sliderRole = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-haspopup": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-valuetext": null,
        "aria-orientation": "horizontal",
        "aria-valuemax": "100",
        "aria-valuemin": "0"
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "type",
            value: "range"
          }],
          name: "input"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-valuenow": null
      },
      superClass: [["roletype", "widget", "input"], ["roletype", "structure", "range"]]
    }, _default = exports.default = sliderRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/spinbuttonRole.js
var require_spinbuttonRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/spinbuttonRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var spinbuttonRole = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null,
        "aria-valuetext": null,
        "aria-valuenow": "0"
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "type",
            value: "number"
          }],
          name: "input"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite"], ["roletype", "widget", "input"], ["roletype", "structure", "range"]]
    }, _default = exports.default = spinbuttonRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/statusRole.js
var require_statusRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/statusRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var statusRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-atomic": "true",
        "aria-live": "polite"
      },
      relatedConcepts: [{
        concept: {
          name: "output"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    }, _default = exports.default = statusRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/strongRole.js
var require_strongRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/strongRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var strongRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "strong"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    }, _default = exports.default = strongRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/subscriptRole.js
var require_subscriptRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/subscriptRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var subscriptRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "sub"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    }, _default = exports.default = subscriptRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/superscriptRole.js
var require_superscriptRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/superscriptRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var superscriptRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "sup"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    }, _default = exports.default = superscriptRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/switchRole.js
var require_switchRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/switchRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var switchRole = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "button"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [["roletype", "widget", "input", "checkbox"]]
    }, _default = exports.default = switchRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/tabRole.js
var require_tabRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/tabRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var tabRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-posinset": null,
        "aria-setsize": null,
        "aria-selected": "false"
      },
      relatedConcepts: [],
      requireContextRole: ["tablist"],
      requiredContextRole: ["tablist"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "sectionhead"], ["roletype", "widget"]]
    }, _default = exports.default = tabRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/tableRole.js
var require_tableRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/tableRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var tableRole = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-colcount": null,
        "aria-rowcount": null
      },
      relatedConcepts: [{
        concept: {
          name: "table"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["row"], ["row", "rowgroup"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    }, _default = exports.default = tableRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/tablistRole.js
var require_tablistRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/tablistRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var tablistRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-level": null,
        "aria-multiselectable": null,
        "aria-orientation": "horizontal"
      },
      relatedConcepts: [{
        module: "DAISY",
        concept: {
          name: "guide"
        }
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["tab"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite"]]
    }, _default = exports.default = tablistRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/tabpanelRole.js
var require_tabpanelRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/tabpanelRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var tabpanelRole = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    }, _default = exports.default = tabpanelRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/termRole.js
var require_termRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/termRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var termRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "dfn"
        },
        module: "HTML"
      }, {
        concept: {
          name: "dt"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    }, _default = exports.default = termRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/textboxRole.js
var require_textboxRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/textboxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var textboxRole = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-autocomplete": null,
        "aria-errormessage": null,
        "aria-haspopup": null,
        "aria-invalid": null,
        "aria-multiline": null,
        "aria-placeholder": null,
        "aria-readonly": null,
        "aria-required": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "type"
          }, {
            constraints: ["undefined"],
            name: "list"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "list"
          }, {
            name: "type",
            value: "email"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "list"
          }, {
            name: "type",
            value: "tel"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "list"
          }, {
            name: "type",
            value: "text"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "list"
          }, {
            name: "type",
            value: "url"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          name: "input"
        },
        module: "XForms"
      }, {
        concept: {
          name: "textarea"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "input"]]
    }, _default = exports.default = textboxRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/timeRole.js
var require_timeRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/timeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var timeRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "time"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    }, _default = exports.default = timeRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/timerRole.js
var require_timerRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/timerRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var timerRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "status"]]
    }, _default = exports.default = timerRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/toolbarRole.js
var require_toolbarRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/toolbarRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var toolbarRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-orientation": "horizontal"
      },
      relatedConcepts: [{
        concept: {
          name: "menubar"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "group"]]
    }, _default = exports.default = toolbarRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/tooltipRole.js
var require_tooltipRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/tooltipRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var tooltipRole = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    }, _default = exports.default = tooltipRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/treeRole.js
var require_treeRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/treeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var treeRole = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null,
        "aria-multiselectable": null,
        "aria-required": null,
        "aria-orientation": "vertical"
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["treeitem", "group"], ["treeitem"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
    }, _default = exports.default = treeRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/treegridRole.js
var require_treegridRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/treegridRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var treegridRole = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["row"], ["row", "rowgroup"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "grid"], ["roletype", "structure", "section", "table", "grid"], ["roletype", "widget", "composite", "select", "tree"], ["roletype", "structure", "section", "group", "select", "tree"]]
    }, _default = exports.default = treegridRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/literal/treeitemRole.js
var require_treeitemRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/literal/treeitemRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var treeitemRole = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-expanded": null,
        "aria-haspopup": null
      },
      relatedConcepts: [],
      requireContextRole: ["group", "tree"],
      requiredContextRole: ["group", "tree"],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-selected": null
      },
      superClass: [["roletype", "structure", "section", "listitem"], ["roletype", "widget", "input", "option"]]
    }, _default = exports.default = treeitemRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/ariaLiteralRoles.js
var require_ariaLiteralRoles = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/ariaLiteralRoles.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var _alertRole = _interopRequireDefault(require_alertRole()), _alertdialogRole = _interopRequireDefault(require_alertdialogRole()), _applicationRole = _interopRequireDefault(require_applicationRole()), _articleRole = _interopRequireDefault(require_articleRole()), _bannerRole = _interopRequireDefault(require_bannerRole()), _blockquoteRole = _interopRequireDefault(require_blockquoteRole()), _buttonRole = _interopRequireDefault(require_buttonRole()), _captionRole = _interopRequireDefault(require_captionRole()), _cellRole = _interopRequireDefault(require_cellRole()), _checkboxRole = _interopRequireDefault(require_checkboxRole()), _codeRole = _interopRequireDefault(require_codeRole()), _columnheaderRole = _interopRequireDefault(require_columnheaderRole()), _comboboxRole = _interopRequireDefault(require_comboboxRole()), _complementaryRole = _interopRequireDefault(require_complementaryRole()), _contentinfoRole = _interopRequireDefault(require_contentinfoRole()), _definitionRole = _interopRequireDefault(require_definitionRole()), _deletionRole = _interopRequireDefault(require_deletionRole()), _dialogRole = _interopRequireDefault(require_dialogRole()), _directoryRole = _interopRequireDefault(require_directoryRole()), _documentRole = _interopRequireDefault(require_documentRole()), _emphasisRole = _interopRequireDefault(require_emphasisRole()), _feedRole = _interopRequireDefault(require_feedRole()), _figureRole = _interopRequireDefault(require_figureRole()), _formRole = _interopRequireDefault(require_formRole()), _genericRole = _interopRequireDefault(require_genericRole()), _gridRole = _interopRequireDefault(require_gridRole()), _gridcellRole = _interopRequireDefault(require_gridcellRole()), _groupRole = _interopRequireDefault(require_groupRole()), _headingRole = _interopRequireDefault(require_headingRole()), _imgRole = _interopRequireDefault(require_imgRole()), _insertionRole = _interopRequireDefault(require_insertionRole()), _linkRole = _interopRequireDefault(require_linkRole()), _listRole = _interopRequireDefault(require_listRole()), _listboxRole = _interopRequireDefault(require_listboxRole()), _listitemRole = _interopRequireDefault(require_listitemRole()), _logRole = _interopRequireDefault(require_logRole()), _mainRole = _interopRequireDefault(require_mainRole()), _markRole = _interopRequireDefault(require_markRole()), _marqueeRole = _interopRequireDefault(require_marqueeRole()), _mathRole = _interopRequireDefault(require_mathRole()), _menuRole = _interopRequireDefault(require_menuRole()), _menubarRole = _interopRequireDefault(require_menubarRole()), _menuitemRole = _interopRequireDefault(require_menuitemRole()), _menuitemcheckboxRole = _interopRequireDefault(require_menuitemcheckboxRole()), _menuitemradioRole = _interopRequireDefault(require_menuitemradioRole()), _meterRole = _interopRequireDefault(require_meterRole()), _navigationRole = _interopRequireDefault(require_navigationRole()), _noneRole = _interopRequireDefault(require_noneRole()), _noteRole = _interopRequireDefault(require_noteRole()), _optionRole = _interopRequireDefault(require_optionRole()), _paragraphRole = _interopRequireDefault(require_paragraphRole()), _presentationRole = _interopRequireDefault(require_presentationRole()), _progressbarRole = _interopRequireDefault(require_progressbarRole()), _radioRole = _interopRequireDefault(require_radioRole()), _radiogroupRole = _interopRequireDefault(require_radiogroupRole()), _regionRole = _interopRequireDefault(require_regionRole()), _rowRole = _interopRequireDefault(require_rowRole()), _rowgroupRole = _interopRequireDefault(require_rowgroupRole()), _rowheaderRole = _interopRequireDefault(require_rowheaderRole()), _scrollbarRole = _interopRequireDefault(require_scrollbarRole()), _searchRole = _interopRequireDefault(require_searchRole()), _searchboxRole = _interopRequireDefault(require_searchboxRole()), _separatorRole = _interopRequireDefault(require_separatorRole()), _sliderRole = _interopRequireDefault(require_sliderRole()), _spinbuttonRole = _interopRequireDefault(require_spinbuttonRole()), _statusRole = _interopRequireDefault(require_statusRole()), _strongRole = _interopRequireDefault(require_strongRole()), _subscriptRole = _interopRequireDefault(require_subscriptRole()), _superscriptRole = _interopRequireDefault(require_superscriptRole()), _switchRole = _interopRequireDefault(require_switchRole()), _tabRole = _interopRequireDefault(require_tabRole()), _tableRole = _interopRequireDefault(require_tableRole()), _tablistRole = _interopRequireDefault(require_tablistRole()), _tabpanelRole = _interopRequireDefault(require_tabpanelRole()), _termRole = _interopRequireDefault(require_termRole()), _textboxRole = _interopRequireDefault(require_textboxRole()), _timeRole = _interopRequireDefault(require_timeRole()), _timerRole = _interopRequireDefault(require_timerRole()), _toolbarRole = _interopRequireDefault(require_toolbarRole()), _tooltipRole = _interopRequireDefault(require_tooltipRole()), _treeRole = _interopRequireDefault(require_treeRole()), _treegridRole = _interopRequireDefault(require_treegridRole()), _treeitemRole = _interopRequireDefault(require_treeitemRole());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    var ariaLiteralRoles = [["alert", _alertRole.default], ["alertdialog", _alertdialogRole.default], ["application", _applicationRole.default], ["article", _articleRole.default], ["banner", _bannerRole.default], ["blockquote", _blockquoteRole.default], ["button", _buttonRole.default], ["caption", _captionRole.default], ["cell", _cellRole.default], ["checkbox", _checkboxRole.default], ["code", _codeRole.default], ["columnheader", _columnheaderRole.default], ["combobox", _comboboxRole.default], ["complementary", _complementaryRole.default], ["contentinfo", _contentinfoRole.default], ["definition", _definitionRole.default], ["deletion", _deletionRole.default], ["dialog", _dialogRole.default], ["directory", _directoryRole.default], ["document", _documentRole.default], ["emphasis", _emphasisRole.default], ["feed", _feedRole.default], ["figure", _figureRole.default], ["form", _formRole.default], ["generic", _genericRole.default], ["grid", _gridRole.default], ["gridcell", _gridcellRole.default], ["group", _groupRole.default], ["heading", _headingRole.default], ["img", _imgRole.default], ["insertion", _insertionRole.default], ["link", _linkRole.default], ["list", _listRole.default], ["listbox", _listboxRole.default], ["listitem", _listitemRole.default], ["log", _logRole.default], ["main", _mainRole.default], ["mark", _markRole.default], ["marquee", _marqueeRole.default], ["math", _mathRole.default], ["menu", _menuRole.default], ["menubar", _menubarRole.default], ["menuitem", _menuitemRole.default], ["menuitemcheckbox", _menuitemcheckboxRole.default], ["menuitemradio", _menuitemradioRole.default], ["meter", _meterRole.default], ["navigation", _navigationRole.default], ["none", _noneRole.default], ["note", _noteRole.default], ["option", _optionRole.default], ["paragraph", _paragraphRole.default], ["presentation", _presentationRole.default], ["progressbar", _progressbarRole.default], ["radio", _radioRole.default], ["radiogroup", _radiogroupRole.default], ["region", _regionRole.default], ["row", _rowRole.default], ["rowgroup", _rowgroupRole.default], ["rowheader", _rowheaderRole.default], ["scrollbar", _scrollbarRole.default], ["search", _searchRole.default], ["searchbox", _searchboxRole.default], ["separator", _separatorRole.default], ["slider", _sliderRole.default], ["spinbutton", _spinbuttonRole.default], ["status", _statusRole.default], ["strong", _strongRole.default], ["subscript", _subscriptRole.default], ["superscript", _superscriptRole.default], ["switch", _switchRole.default], ["tab", _tabRole.default], ["table", _tableRole.default], ["tablist", _tablistRole.default], ["tabpanel", _tabpanelRole.default], ["term", _termRole.default], ["textbox", _textboxRole.default], ["time", _timeRole.default], ["timer", _timerRole.default], ["toolbar", _toolbarRole.default], ["tooltip", _tooltipRole.default], ["tree", _treeRole.default], ["treegrid", _treegridRole.default], ["treeitem", _treeitemRole.default]], _default = exports.default = ariaLiteralRoles;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docAbstractRole.js
var require_docAbstractRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docAbstractRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var docAbstractRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "abstract [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    }, _default = exports.default = docAbstractRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docAcknowledgmentsRole.js
var require_docAcknowledgmentsRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docAcknowledgmentsRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var docAcknowledgmentsRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "acknowledgments [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    }, _default = exports.default = docAcknowledgmentsRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docAfterwordRole.js
var require_docAfterwordRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docAfterwordRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var docAfterwordRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "afterword [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    }, _default = exports.default = docAfterwordRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docAppendixRole.js
var require_docAppendixRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docAppendixRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var docAppendixRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "appendix [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    }, _default = exports.default = docAppendixRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docBacklinkRole.js
var require_docBacklinkRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docBacklinkRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var docBacklinkRole = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "referrer [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command", "link"]]
    }, _default = exports.default = docBacklinkRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docBiblioentryRole.js
var require_docBiblioentryRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docBiblioentryRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var docBiblioentryRole = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "EPUB biblioentry [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: ["doc-bibliography"],
      requiredContextRole: ["doc-bibliography"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "listitem"]]
    }, _default = exports.default = docBiblioentryRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docBibliographyRole.js
var require_docBibliographyRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docBibliographyRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var docBibliographyRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "bibliography [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["doc-biblioentry"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    }, _default = exports.default = docBibliographyRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docBibliorefRole.js
var require_docBibliorefRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docBibliorefRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var docBibliorefRole = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "biblioref [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command", "link"]]
    }, _default = exports.default = docBibliorefRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docChapterRole.js
var require_docChapterRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docChapterRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var docChapterRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "chapter [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    }, _default = exports.default = docChapterRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docColophonRole.js
var require_docColophonRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docColophonRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var docColophonRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "colophon [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    }, _default = exports.default = docColophonRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docConclusionRole.js
var require_docConclusionRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docConclusionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var docConclusionRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "conclusion [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    }, _default = exports.default = docConclusionRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docCoverRole.js
var require_docCoverRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docCoverRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var docCoverRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "cover [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "img"]]
    }, _default = exports.default = docCoverRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docCreditRole.js
var require_docCreditRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docCreditRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var docCreditRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "credit [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    }, _default = exports.default = docCreditRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docCreditsRole.js
var require_docCreditsRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docCreditsRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var docCreditsRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "credits [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    }, _default = exports.default = docCreditsRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docDedicationRole.js
var require_docDedicationRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docDedicationRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var docDedicationRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "dedication [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    }, _default = exports.default = docDedicationRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docEndnoteRole.js
var require_docEndnoteRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docEndnoteRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var docEndnoteRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "rearnote [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: ["doc-endnotes"],
      requiredContextRole: ["doc-endnotes"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "listitem"]]
    }, _default = exports.default = docEndnoteRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docEndnotesRole.js
var require_docEndnotesRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docEndnotesRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var docEndnotesRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "rearnotes [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["doc-endnote"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    }, _default = exports.default = docEndnotesRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docEpigraphRole.js
var require_docEpigraphRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docEpigraphRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var docEpigraphRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "epigraph [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    }, _default = exports.default = docEpigraphRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docEpilogueRole.js
var require_docEpilogueRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docEpilogueRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var docEpilogueRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "epilogue [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    }, _default = exports.default = docEpilogueRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docErrataRole.js
var require_docErrataRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docErrataRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var docErrataRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "errata [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    }, _default = exports.default = docErrataRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docExampleRole.js
var require_docExampleRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docExampleRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var docExampleRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    }, _default = exports.default = docExampleRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docFootnoteRole.js
var require_docFootnoteRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docFootnoteRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var docFootnoteRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "footnote [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    }, _default = exports.default = docFootnoteRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docForewordRole.js
var require_docForewordRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docForewordRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var docForewordRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "foreword [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    }, _default = exports.default = docForewordRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docGlossaryRole.js
var require_docGlossaryRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docGlossaryRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var docGlossaryRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "glossary [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["definition"], ["term"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    }, _default = exports.default = docGlossaryRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docGlossrefRole.js
var require_docGlossrefRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docGlossrefRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var docGlossrefRole = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "glossref [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command", "link"]]
    }, _default = exports.default = docGlossrefRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docIndexRole.js
var require_docIndexRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docIndexRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var docIndexRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "index [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark", "navigation"]]
    }, _default = exports.default = docIndexRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docIntroductionRole.js
var require_docIntroductionRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docIntroductionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var docIntroductionRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "introduction [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    }, _default = exports.default = docIntroductionRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docNoterefRole.js
var require_docNoterefRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docNoterefRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var docNoterefRole = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "noteref [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command", "link"]]
    }, _default = exports.default = docNoterefRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docNoticeRole.js
var require_docNoticeRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docNoticeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var docNoticeRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "notice [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "note"]]
    }, _default = exports.default = docNoticeRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docPagebreakRole.js
var require_docPagebreakRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docPagebreakRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var docPagebreakRole = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "pagebreak [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "separator"]]
    }, _default = exports.default = docPagebreakRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docPagefooterRole.js
var require_docPagefooterRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docPagefooterRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var docPagefooterRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["prohibited"],
      prohibitedProps: [],
      props: {
        "aria-braillelabel": null,
        "aria-brailleroledescription": null,
        "aria-description": null,
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    }, _default = exports.default = docPagefooterRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docPageheaderRole.js
var require_docPageheaderRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docPageheaderRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var docPageheaderRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["prohibited"],
      prohibitedProps: [],
      props: {
        "aria-braillelabel": null,
        "aria-brailleroledescription": null,
        "aria-description": null,
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    }, _default = exports.default = docPageheaderRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docPagelistRole.js
var require_docPagelistRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docPagelistRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var docPagelistRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "page-list [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark", "navigation"]]
    }, _default = exports.default = docPagelistRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docPartRole.js
var require_docPartRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docPartRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var docPartRole = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "part [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    }, _default = exports.default = docPartRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docPrefaceRole.js
var require_docPrefaceRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docPrefaceRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var docPrefaceRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "preface [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    }, _default = exports.default = docPrefaceRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docPrologueRole.js
var require_docPrologueRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docPrologueRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var docPrologueRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "prologue [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    }, _default = exports.default = docPrologueRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docPullquoteRole.js
var require_docPullquoteRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docPullquoteRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var docPullquoteRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "pullquote [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["none"]]
    }, _default = exports.default = docPullquoteRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docQnaRole.js
var require_docQnaRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docQnaRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var docQnaRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "qna [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    }, _default = exports.default = docQnaRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docSubtitleRole.js
var require_docSubtitleRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docSubtitleRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var docSubtitleRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "subtitle [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "sectionhead"]]
    }, _default = exports.default = docSubtitleRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docTipRole.js
var require_docTipRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docTipRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var docTipRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "help [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "note"]]
    }, _default = exports.default = docTipRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/dpub/docTocRole.js
var require_docTocRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/dpub/docTocRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var docTocRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "toc [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark", "navigation"]]
    }, _default = exports.default = docTocRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/ariaDpubRoles.js
var require_ariaDpubRoles = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/ariaDpubRoles.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var _docAbstractRole = _interopRequireDefault(require_docAbstractRole()), _docAcknowledgmentsRole = _interopRequireDefault(require_docAcknowledgmentsRole()), _docAfterwordRole = _interopRequireDefault(require_docAfterwordRole()), _docAppendixRole = _interopRequireDefault(require_docAppendixRole()), _docBacklinkRole = _interopRequireDefault(require_docBacklinkRole()), _docBiblioentryRole = _interopRequireDefault(require_docBiblioentryRole()), _docBibliographyRole = _interopRequireDefault(require_docBibliographyRole()), _docBibliorefRole = _interopRequireDefault(require_docBibliorefRole()), _docChapterRole = _interopRequireDefault(require_docChapterRole()), _docColophonRole = _interopRequireDefault(require_docColophonRole()), _docConclusionRole = _interopRequireDefault(require_docConclusionRole()), _docCoverRole = _interopRequireDefault(require_docCoverRole()), _docCreditRole = _interopRequireDefault(require_docCreditRole()), _docCreditsRole = _interopRequireDefault(require_docCreditsRole()), _docDedicationRole = _interopRequireDefault(require_docDedicationRole()), _docEndnoteRole = _interopRequireDefault(require_docEndnoteRole()), _docEndnotesRole = _interopRequireDefault(require_docEndnotesRole()), _docEpigraphRole = _interopRequireDefault(require_docEpigraphRole()), _docEpilogueRole = _interopRequireDefault(require_docEpilogueRole()), _docErrataRole = _interopRequireDefault(require_docErrataRole()), _docExampleRole = _interopRequireDefault(require_docExampleRole()), _docFootnoteRole = _interopRequireDefault(require_docFootnoteRole()), _docForewordRole = _interopRequireDefault(require_docForewordRole()), _docGlossaryRole = _interopRequireDefault(require_docGlossaryRole()), _docGlossrefRole = _interopRequireDefault(require_docGlossrefRole()), _docIndexRole = _interopRequireDefault(require_docIndexRole()), _docIntroductionRole = _interopRequireDefault(require_docIntroductionRole()), _docNoterefRole = _interopRequireDefault(require_docNoterefRole()), _docNoticeRole = _interopRequireDefault(require_docNoticeRole()), _docPagebreakRole = _interopRequireDefault(require_docPagebreakRole()), _docPagefooterRole = _interopRequireDefault(require_docPagefooterRole()), _docPageheaderRole = _interopRequireDefault(require_docPageheaderRole()), _docPagelistRole = _interopRequireDefault(require_docPagelistRole()), _docPartRole = _interopRequireDefault(require_docPartRole()), _docPrefaceRole = _interopRequireDefault(require_docPrefaceRole()), _docPrologueRole = _interopRequireDefault(require_docPrologueRole()), _docPullquoteRole = _interopRequireDefault(require_docPullquoteRole()), _docQnaRole = _interopRequireDefault(require_docQnaRole()), _docSubtitleRole = _interopRequireDefault(require_docSubtitleRole()), _docTipRole = _interopRequireDefault(require_docTipRole()), _docTocRole = _interopRequireDefault(require_docTocRole());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    var ariaDpubRoles = [["doc-abstract", _docAbstractRole.default], ["doc-acknowledgments", _docAcknowledgmentsRole.default], ["doc-afterword", _docAfterwordRole.default], ["doc-appendix", _docAppendixRole.default], ["doc-backlink", _docBacklinkRole.default], ["doc-biblioentry", _docBiblioentryRole.default], ["doc-bibliography", _docBibliographyRole.default], ["doc-biblioref", _docBibliorefRole.default], ["doc-chapter", _docChapterRole.default], ["doc-colophon", _docColophonRole.default], ["doc-conclusion", _docConclusionRole.default], ["doc-cover", _docCoverRole.default], ["doc-credit", _docCreditRole.default], ["doc-credits", _docCreditsRole.default], ["doc-dedication", _docDedicationRole.default], ["doc-endnote", _docEndnoteRole.default], ["doc-endnotes", _docEndnotesRole.default], ["doc-epigraph", _docEpigraphRole.default], ["doc-epilogue", _docEpilogueRole.default], ["doc-errata", _docErrataRole.default], ["doc-example", _docExampleRole.default], ["doc-footnote", _docFootnoteRole.default], ["doc-foreword", _docForewordRole.default], ["doc-glossary", _docGlossaryRole.default], ["doc-glossref", _docGlossrefRole.default], ["doc-index", _docIndexRole.default], ["doc-introduction", _docIntroductionRole.default], ["doc-noteref", _docNoterefRole.default], ["doc-notice", _docNoticeRole.default], ["doc-pagebreak", _docPagebreakRole.default], ["doc-pagefooter", _docPagefooterRole.default], ["doc-pageheader", _docPageheaderRole.default], ["doc-pagelist", _docPagelistRole.default], ["doc-part", _docPartRole.default], ["doc-preface", _docPrefaceRole.default], ["doc-prologue", _docPrologueRole.default], ["doc-pullquote", _docPullquoteRole.default], ["doc-qna", _docQnaRole.default], ["doc-subtitle", _docSubtitleRole.default], ["doc-tip", _docTipRole.default], ["doc-toc", _docTocRole.default]], _default = exports.default = ariaDpubRoles;
  }
});

// ../node_modules/aria-query/lib/etc/roles/graphics/graphicsDocumentRole.js
var require_graphicsDocumentRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/graphics/graphicsDocumentRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var graphicsDocumentRole = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        module: "GRAPHICS",
        concept: {
          name: "graphics-object"
        }
      }, {
        module: "ARIA",
        concept: {
          name: "img"
        }
      }, {
        module: "ARIA",
        concept: {
          name: "article"
        }
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "document"]]
    }, _default = exports.default = graphicsDocumentRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/graphics/graphicsObjectRole.js
var require_graphicsObjectRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/graphics/graphicsObjectRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var graphicsObjectRole = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        module: "GRAPHICS",
        concept: {
          name: "graphics-document"
        }
      }, {
        module: "ARIA",
        concept: {
          name: "group"
        }
      }, {
        module: "ARIA",
        concept: {
          name: "img"
        }
      }, {
        module: "GRAPHICS",
        concept: {
          name: "graphics-symbol"
        }
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "group"]]
    }, _default = exports.default = graphicsObjectRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/graphics/graphicsSymbolRole.js
var require_graphicsSymbolRole = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/graphics/graphicsSymbolRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var graphicsSymbolRole = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "img"]]
    }, _default = exports.default = graphicsSymbolRole;
  }
});

// ../node_modules/aria-query/lib/etc/roles/ariaGraphicsRoles.js
var require_ariaGraphicsRoles = __commonJS({
  "../node_modules/aria-query/lib/etc/roles/ariaGraphicsRoles.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var _graphicsDocumentRole = _interopRequireDefault(require_graphicsDocumentRole()), _graphicsObjectRole = _interopRequireDefault(require_graphicsObjectRole()), _graphicsSymbolRole = _interopRequireDefault(require_graphicsSymbolRole());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    var ariaGraphicsRoles = [["graphics-document", _graphicsDocumentRole.default], ["graphics-object", _graphicsObjectRole.default], ["graphics-symbol", _graphicsSymbolRole.default]], _default = exports.default = ariaGraphicsRoles;
  }
});

// ../node_modules/aria-query/lib/rolesMap.js
var require_rolesMap = __commonJS({
  "../node_modules/aria-query/lib/rolesMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var _ariaAbstractRoles = _interopRequireDefault(require_ariaAbstractRoles()), _ariaLiteralRoles = _interopRequireDefault(require_ariaLiteralRoles()), _ariaDpubRoles = _interopRequireDefault(require_ariaDpubRoles()), _ariaGraphicsRoles = _interopRequireDefault(require_ariaGraphicsRoles()), _iterationDecorator = _interopRequireDefault(require_iterationDecorator());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    function _createForOfIteratorHelper(r2, e2) {
      var t2 = typeof Symbol < "u" && r2[Symbol.iterator] || r2["@@iterator"];
      if (!t2) {
        if (Array.isArray(r2) || (t2 = _unsupportedIterableToArray(r2)) || e2 && r2 && typeof r2.length == "number") {
          t2 && (r2 = t2);
          var _n = 0, F = function() {
          };
          return { s: F, n: function() {
            return _n >= r2.length ? { done: !0 } : { done: !1, value: r2[_n++] };
          }, e: function(r3) {
            throw r3;
          }, f: F };
        }
        throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
      }
      var o2, a2 = !0, u3 = !1;
      return { s: function() {
        t2 = t2.call(r2);
      }, n: function() {
        var r3 = t2.next();
        return a2 = r3.done, r3;
      }, e: function(r3) {
        u3 = !0, o2 = r3;
      }, f: function() {
        try {
          a2 || t2.return == null || t2.return();
        } finally {
          if (u3) throw o2;
        }
      } };
    }
    function _slicedToArray(r2, e2) {
      return _arrayWithHoles(r2) || _iterableToArrayLimit(r2, e2) || _unsupportedIterableToArray(r2, e2) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    function _unsupportedIterableToArray(r2, a2) {
      if (r2) {
        if (typeof r2 == "string") return _arrayLikeToArray(r2, a2);
        var t2 = {}.toString.call(r2).slice(8, -1);
        return t2 === "Object" && r2.constructor && (t2 = r2.constructor.name), t2 === "Map" || t2 === "Set" ? Array.from(r2) : t2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray(r2, a2) : void 0;
      }
    }
    function _arrayLikeToArray(r2, a2) {
      (a2 == null || a2 > r2.length) && (a2 = r2.length);
      for (var e2 = 0, n2 = Array(a2); e2 < a2; e2++) n2[e2] = r2[e2];
      return n2;
    }
    function _iterableToArrayLimit(r2, l2) {
      var t2 = r2 == null ? null : typeof Symbol < "u" && r2[Symbol.iterator] || r2["@@iterator"];
      if (t2 != null) {
        var e2, n2, i2, u3, a2 = [], f4 = !0, o2 = !1;
        try {
          if (i2 = (t2 = t2.call(r2)).next, l2 === 0) {
            if (Object(t2) !== t2) return;
            f4 = !1;
          } else for (; !(f4 = (e2 = i2.call(t2)).done) && (a2.push(e2.value), a2.length !== l2); f4 = !0) ;
        } catch (r3) {
          o2 = !0, n2 = r3;
        } finally {
          try {
            if (!f4 && t2.return != null && (u3 = t2.return(), Object(u3) !== u3)) return;
          } finally {
            if (o2) throw n2;
          }
        }
        return a2;
      }
    }
    function _arrayWithHoles(r2) {
      if (Array.isArray(r2)) return r2;
    }
    var roles3 = [].concat(_ariaAbstractRoles.default, _ariaLiteralRoles.default, _ariaDpubRoles.default, _ariaGraphicsRoles.default);
    roles3.forEach(function(_ref) {
      var _ref2 = _slicedToArray(_ref, 2), roleDefinition = _ref2[1], _iterator = _createForOfIteratorHelper(roleDefinition.superClass), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var superClassIter = _step.value, _iterator2 = _createForOfIteratorHelper(superClassIter), _step2;
          try {
            var _loop = function() {
              var superClassName = _step2.value, superClassRoleTuple = roles3.filter(function(_ref3) {
                var _ref4 = _slicedToArray(_ref3, 1), name = _ref4[0];
                return name === superClassName;
              })[0];
              if (superClassRoleTuple)
                for (var superClassDefinition = superClassRoleTuple[1], _i = 0, _Object$keys = Object.keys(superClassDefinition.props); _i < _Object$keys.length; _i++) {
                  var prop = _Object$keys[_i];
                  Object.prototype.hasOwnProperty.call(roleDefinition.props, prop) || (roleDefinition.props[prop] = superClassDefinition.props[prop]);
                }
            };
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done; )
              _loop();
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    });
    var rolesMap = {
      entries: function() {
        return roles3;
      },
      forEach: function(fn3) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, _iterator3 = _createForOfIteratorHelper(roles3), _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
            var _step3$value = _slicedToArray(_step3.value, 2), key = _step3$value[0], values = _step3$value[1];
            fn3.call(thisArg, values, key, roles3);
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      },
      get: function(key) {
        var item = roles3.filter(function(tuple) {
          return tuple[0] === key;
        })[0];
        return item && item[1];
      },
      has: function(key) {
        return !!rolesMap.get(key);
      },
      keys: function() {
        return roles3.map(function(_ref5) {
          var _ref6 = _slicedToArray(_ref5, 1), key = _ref6[0];
          return key;
        });
      },
      values: function() {
        return roles3.map(function(_ref7) {
          var _ref8 = _slicedToArray(_ref7, 2), values2 = _ref8[1];
          return values2;
        });
      }
    }, _default = exports.default = (0, _iterationDecorator.default)(rolesMap, rolesMap.entries());
  }
});

// ../node_modules/aria-query/lib/elementRoleMap.js
var require_elementRoleMap = __commonJS({
  "../node_modules/aria-query/lib/elementRoleMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator()), _rolesMap = _interopRequireDefault(require_rolesMap());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    function _slicedToArray(r2, e2) {
      return _arrayWithHoles(r2) || _iterableToArrayLimit(r2, e2) || _unsupportedIterableToArray(r2, e2) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    function _unsupportedIterableToArray(r2, a2) {
      if (r2) {
        if (typeof r2 == "string") return _arrayLikeToArray(r2, a2);
        var t2 = {}.toString.call(r2).slice(8, -1);
        return t2 === "Object" && r2.constructor && (t2 = r2.constructor.name), t2 === "Map" || t2 === "Set" ? Array.from(r2) : t2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray(r2, a2) : void 0;
      }
    }
    function _arrayLikeToArray(r2, a2) {
      (a2 == null || a2 > r2.length) && (a2 = r2.length);
      for (var e2 = 0, n2 = Array(a2); e2 < a2; e2++) n2[e2] = r2[e2];
      return n2;
    }
    function _iterableToArrayLimit(r2, l2) {
      var t2 = r2 == null ? null : typeof Symbol < "u" && r2[Symbol.iterator] || r2["@@iterator"];
      if (t2 != null) {
        var e2, n2, i3, u3, a2 = [], f4 = !0, o2 = !1;
        try {
          if (i3 = (t2 = t2.call(r2)).next, l2 === 0) {
            if (Object(t2) !== t2) return;
            f4 = !1;
          } else for (; !(f4 = (e2 = i3.call(t2)).done) && (a2.push(e2.value), a2.length !== l2); f4 = !0) ;
        } catch (r3) {
          o2 = !0, n2 = r3;
        } finally {
          try {
            if (!f4 && t2.return != null && (u3 = t2.return(), Object(u3) !== u3)) return;
          } finally {
            if (o2) throw n2;
          }
        }
        return a2;
      }
    }
    function _arrayWithHoles(r2) {
      if (Array.isArray(r2)) return r2;
    }
    var elementRoles3 = [], keys2 = _rolesMap.default.keys();
    for (i2 = 0; i2 < keys2.length; i2++)
      if (key = keys2[i2], role = _rolesMap.default.get(key), role)
        for (concepts = [].concat(role.baseConcepts, role.relatedConcepts), _loop = function() {
          var relation = concepts[k2];
          if (relation.module === "HTML") {
            var concept = relation.concept;
            if (concept) {
              var elementRoleRelation = elementRoles3.filter(function(relation2) {
                return ariaRoleRelationConceptEquals(relation2[0], concept);
              })[0], roles3;
              elementRoleRelation ? roles3 = elementRoleRelation[1] : roles3 = [];
              for (var isUnique = !0, _i = 0; _i < roles3.length; _i++)
                if (roles3[_i] === key) {
                  isUnique = !1;
                  break;
                }
              isUnique && roles3.push(key), elementRoleRelation || elementRoles3.push([concept, roles3]);
            }
          }
        }, k2 = 0; k2 < concepts.length; k2++)
          _loop();
    var key, role, concepts, _loop, k2, i2, elementRoleMap = {
      entries: function() {
        return elementRoles3;
      },
      forEach: function(fn3) {
        for (var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, _i2 = 0, _elementRoles = elementRoles3; _i2 < _elementRoles.length; _i2++) {
          var _elementRoles$_i = _slicedToArray(_elementRoles[_i2], 2), _key = _elementRoles$_i[0], values = _elementRoles$_i[1];
          fn3.call(thisArg, values, _key, elementRoles3);
        }
      },
      get: function(key2) {
        var item = elementRoles3.filter(function(tuple) {
          return key2.name === tuple[0].name && ariaRoleRelationConceptAttributeEquals(key2.attributes, tuple[0].attributes);
        })[0];
        return item && item[1];
      },
      has: function(key2) {
        return !!elementRoleMap.get(key2);
      },
      keys: function() {
        return elementRoles3.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key2 = _ref2[0];
          return key2;
        });
      },
      values: function() {
        return elementRoles3.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }
    };
    function ariaRoleRelationConceptEquals(a2, b2) {
      return a2.name === b2.name && ariaRoleRelationConstraintsEquals(a2.constraints, b2.constraints) && ariaRoleRelationConceptAttributeEquals(a2.attributes, b2.attributes);
    }
    function ariaRoleRelationConstraintsEquals(a2, b2) {
      if (a2 === void 0 && b2 !== void 0 || a2 !== void 0 && b2 === void 0)
        return !1;
      if (a2 !== void 0 && b2 !== void 0) {
        if (a2.length !== b2.length)
          return !1;
        for (var _i3 = 0; _i3 < a2.length; _i3++)
          if (a2[_i3] !== b2[_i3])
            return !1;
      }
      return !0;
    }
    function ariaRoleRelationConceptAttributeEquals(a2, b2) {
      if (a2 === void 0 && b2 !== void 0 || a2 !== void 0 && b2 === void 0)
        return !1;
      if (a2 !== void 0 && b2 !== void 0) {
        if (a2.length !== b2.length)
          return !1;
        for (var _i4 = 0; _i4 < a2.length; _i4++) {
          if (a2[_i4].name !== b2[_i4].name || a2[_i4].value !== b2[_i4].value || a2[_i4].constraints === void 0 && b2[_i4].constraints !== void 0 || a2[_i4].constraints !== void 0 && b2[_i4].constraints === void 0)
            return !1;
          if (a2[_i4].constraints !== void 0 && b2[_i4].constraints !== void 0) {
            if (a2[_i4].constraints.length !== b2[_i4].constraints.length)
              return !1;
            for (var j2 = 0; j2 < a2[_i4].constraints.length; j2++)
              if (a2[_i4].constraints[j2] !== b2[_i4].constraints[j2])
                return !1;
          }
        }
      }
      return !0;
    }
    var _default = exports.default = (0, _iterationDecorator.default)(elementRoleMap, elementRoleMap.entries());
  }
});

// ../node_modules/aria-query/lib/roleElementMap.js
var require_roleElementMap = __commonJS({
  "../node_modules/aria-query/lib/roleElementMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator()), _rolesMap = _interopRequireDefault(require_rolesMap());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    function _slicedToArray(r2, e2) {
      return _arrayWithHoles(r2) || _iterableToArrayLimit(r2, e2) || _unsupportedIterableToArray(r2, e2) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    function _unsupportedIterableToArray(r2, a2) {
      if (r2) {
        if (typeof r2 == "string") return _arrayLikeToArray(r2, a2);
        var t2 = {}.toString.call(r2).slice(8, -1);
        return t2 === "Object" && r2.constructor && (t2 = r2.constructor.name), t2 === "Map" || t2 === "Set" ? Array.from(r2) : t2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray(r2, a2) : void 0;
      }
    }
    function _arrayLikeToArray(r2, a2) {
      (a2 == null || a2 > r2.length) && (a2 = r2.length);
      for (var e2 = 0, n2 = Array(a2); e2 < a2; e2++) n2[e2] = r2[e2];
      return n2;
    }
    function _iterableToArrayLimit(r2, l2) {
      var t2 = r2 == null ? null : typeof Symbol < "u" && r2[Symbol.iterator] || r2["@@iterator"];
      if (t2 != null) {
        var e2, n2, i3, u3, a2 = [], f4 = !0, o2 = !1;
        try {
          if (i3 = (t2 = t2.call(r2)).next, l2 === 0) {
            if (Object(t2) !== t2) return;
            f4 = !1;
          } else for (; !(f4 = (e2 = i3.call(t2)).done) && (a2.push(e2.value), a2.length !== l2); f4 = !0) ;
        } catch (r3) {
          o2 = !0, n2 = r3;
        } finally {
          try {
            if (!f4 && t2.return != null && (u3 = t2.return(), Object(u3) !== u3)) return;
          } finally {
            if (o2) throw n2;
          }
        }
        return a2;
      }
    }
    function _arrayWithHoles(r2) {
      if (Array.isArray(r2)) return r2;
    }
    var roleElement = [], keys2 = _rolesMap.default.keys();
    for (i2 = 0; i2 < keys2.length; i2++)
      if (key = keys2[i2], role = _rolesMap.default.get(key), relationConcepts = [], role) {
        for (concepts = [].concat(role.baseConcepts, role.relatedConcepts), k2 = 0; k2 < concepts.length; k2++)
          relation = concepts[k2], relation.module === "HTML" && (concept = relation.concept, concept != null && relationConcepts.push(concept));
        relationConcepts.length > 0 && roleElement.push([key, relationConcepts]);
      }
    var key, role, relationConcepts, concepts, relation, concept, k2, i2, roleElementMap = {
      entries: function() {
        return roleElement;
      },
      forEach: function(fn3) {
        for (var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, _i = 0, _roleElement = roleElement; _i < _roleElement.length; _i++) {
          var _roleElement$_i = _slicedToArray(_roleElement[_i], 2), _key = _roleElement$_i[0], values = _roleElement$_i[1];
          fn3.call(thisArg, values, _key, roleElement);
        }
      },
      get: function(key2) {
        var item = roleElement.filter(function(tuple) {
          return tuple[0] === key2;
        })[0];
        return item && item[1];
      },
      has: function(key2) {
        return !!roleElementMap.get(key2);
      },
      keys: function() {
        return roleElement.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key2 = _ref2[0];
          return key2;
        });
      },
      values: function() {
        return roleElement.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }
    }, _default = exports.default = (0, _iterationDecorator.default)(roleElementMap, roleElementMap.entries());
  }
});

// ../node_modules/aria-query/lib/index.js
var require_lib = __commonJS({
  "../node_modules/aria-query/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.roles = exports.roleElements = exports.elementRoles = exports.dom = exports.aria = void 0;
    var _ariaPropsMap = _interopRequireDefault(require_ariaPropsMap()), _domMap = _interopRequireDefault(require_domMap()), _rolesMap = _interopRequireDefault(require_rolesMap()), _elementRoleMap = _interopRequireDefault(require_elementRoleMap()), _roleElementMap = _interopRequireDefault(require_roleElementMap());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    var aria = exports.aria = _ariaPropsMap.default, dom = exports.dom = _domMap.default, roles3 = exports.roles = _rolesMap.default, elementRoles3 = exports.elementRoles = _elementRoleMap.default, roleElements2 = exports.roleElements = _roleElementMap.default;
  }
});

// ../node_modules/picocolors/picocolors.browser.js
var require_picocolors_browser = __commonJS({
  "../node_modules/picocolors/picocolors.browser.js"(exports, module2) {
    var x2 = String, create = function() {
      return { isColorSupported: !1, reset: x2, bold: x2, dim: x2, italic: x2, underline: x2, inverse: x2, hidden: x2, strikethrough: x2, black: x2, red: x2, green: x2, yellow: x2, blue: x2, magenta: x2, cyan: x2, white: x2, gray: x2, bgBlack: x2, bgRed: x2, bgGreen: x2, bgYellow: x2, bgBlue: x2, bgMagenta: x2, bgCyan: x2, bgWhite: x2, blackBright: x2, redBright: x2, greenBright: x2, yellowBright: x2, blueBright: x2, magentaBright: x2, cyanBright: x2, whiteBright: x2, bgBlackBright: x2, bgRedBright: x2, bgGreenBright: x2, bgYellowBright: x2, bgBlueBright: x2, bgMagentaBright: x2, bgCyanBright: x2, bgWhiteBright: x2 };
    };
    module2.exports = create();
    module2.exports.createColors = create;
  }
});

// ../node_modules/css.escape/css.escape.js
var require_css_escape = __commonJS({
  "../node_modules/css.escape/css.escape.js"(exports, module2) {
    (function(root2, factory) {
      typeof exports == "object" ? module2.exports = factory(root2) : typeof define == "function" && define.amd ? define([], factory.bind(root2, root2)) : factory(root2);
    })(typeof global < "u" ? global : exports, function(root2) {
      if (root2.CSS && root2.CSS.escape)
        return root2.CSS.escape;
      var cssEscape = function(value) {
        if (arguments.length == 0)
          throw new TypeError("`CSS.escape` requires an argument.");
        for (var string = String(value), length = string.length, index2 = -1, codeUnit, result = "", firstCodeUnit = string.charCodeAt(0); ++index2 < length; ) {
          if (codeUnit = string.charCodeAt(index2), codeUnit == 0) {
            result += "\uFFFD";
            continue;
          }
          if (
            // If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
            // U+007F, []
            codeUnit >= 1 && codeUnit <= 31 || codeUnit == 127 || // If the character is the first character and is in the range [0-9]
            // (U+0030 to U+0039), []
            index2 == 0 && codeUnit >= 48 && codeUnit <= 57 || // If the character is the second character and is in the range [0-9]
            // (U+0030 to U+0039) and the first character is a `-` (U+002D), []
            index2 == 1 && codeUnit >= 48 && codeUnit <= 57 && firstCodeUnit == 45
          ) {
            result += "\\" + codeUnit.toString(16) + " ";
            continue;
          }
          if (
            // If the character is the first character and is a `-` (U+002D), and
            // there is no second character, []
            index2 == 0 && length == 1 && codeUnit == 45
          ) {
            result += "\\" + string.charAt(index2);
            continue;
          }
          if (codeUnit >= 128 || codeUnit == 45 || codeUnit == 95 || codeUnit >= 48 && codeUnit <= 57 || codeUnit >= 65 && codeUnit <= 90 || codeUnit >= 97 && codeUnit <= 122) {
            result += string.charAt(index2);
            continue;
          }
          result += "\\" + string.charAt(index2);
        }
        return result;
      };
      return root2.CSS || (root2.CSS = {}), root2.CSS.escape = cssEscape, cssEscape;
    });
  }
});

// ../node_modules/pretty-format/node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS({
  "../node_modules/pretty-format/node_modules/ansi-styles/index.js"(exports, module2) {
    "use strict";
    var wrapAnsi256 = (offset2 = 0) => (code) => `\x1B[${38 + offset2};5;${code}m`, wrapAnsi16m = (offset2 = 0) => (red, green, blue) => `\x1B[${38 + offset2};2;${red};${green};${blue}m`;
    function assembleStyles() {
      let codes = /* @__PURE__ */ new Map(), styles3 = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          overline: [53, 55],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          // Bright color
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles3.color.gray = styles3.color.blackBright, styles3.bgColor.bgGray = styles3.bgColor.bgBlackBright, styles3.color.grey = styles3.color.blackBright, styles3.bgColor.bgGrey = styles3.bgColor.bgBlackBright;
      for (let [groupName, group] of Object.entries(styles3)) {
        for (let [styleName, style] of Object.entries(group))
          styles3[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`
          }, group[styleName] = styles3[styleName], codes.set(style[0], style[1]);
        Object.defineProperty(styles3, groupName, {
          value: group,
          enumerable: !1
        });
      }
      return Object.defineProperty(styles3, "codes", {
        value: codes,
        enumerable: !1
      }), styles3.color.close = "\x1B[39m", styles3.bgColor.close = "\x1B[49m", styles3.color.ansi256 = wrapAnsi256(), styles3.color.ansi16m = wrapAnsi16m(), styles3.bgColor.ansi256 = wrapAnsi256(10), styles3.bgColor.ansi16m = wrapAnsi16m(10), Object.defineProperties(styles3, {
        rgbToAnsi256: {
          value: (red, green, blue) => red === green && green === blue ? red < 8 ? 16 : red > 248 ? 231 : Math.round((red - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5),
          enumerable: !1
        },
        hexToRgb: {
          value: (hex3) => {
            let matches5 = /(?<colorString>[a-f\d]{6}|[a-f\d]{3})/i.exec(hex3.toString(16));
            if (!matches5)
              return [0, 0, 0];
            let { colorString } = matches5.groups;
            colorString.length === 3 && (colorString = colorString.split("").map((character) => character + character).join(""));
            let integer = Number.parseInt(colorString, 16);
            return [
              integer >> 16 & 255,
              integer >> 8 & 255,
              integer & 255
            ];
          },
          enumerable: !1
        },
        hexToAnsi256: {
          value: (hex3) => styles3.rgbToAnsi256(...styles3.hexToRgb(hex3)),
          enumerable: !1
        }
      }), styles3;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: !0,
      get: assembleStyles
    });
  }
});

// ../node_modules/pretty-format/build/collections.js
var require_collections = __commonJS({
  "../node_modules/pretty-format/build/collections.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.printIteratorEntries = printIteratorEntries2;
    exports.printIteratorValues = printIteratorValues2;
    exports.printListItems = printListItems2;
    exports.printObjectProperties = printObjectProperties2;
    var getKeysOfEnumerableProperties2 = (object, compareKeys) => {
      let keys2 = Object.keys(object).sort(compareKeys);
      return Object.getOwnPropertySymbols && Object.getOwnPropertySymbols(object).forEach((symbol) => {
        Object.getOwnPropertyDescriptor(object, symbol).enumerable && keys2.push(symbol);
      }), keys2;
    };
    function printIteratorEntries2(iterator, config4, indentation, depth, refs, printer2, separator = ": ") {
      let result = "", current = iterator.next();
      if (!current.done) {
        result += config4.spacingOuter;
        let indentationNext = indentation + config4.indent;
        for (; !current.done; ) {
          let name = printer2(
            current.value[0],
            config4,
            indentationNext,
            depth,
            refs
          ), value = printer2(
            current.value[1],
            config4,
            indentationNext,
            depth,
            refs
          );
          result += indentationNext + name + separator + value, current = iterator.next(), current.done ? config4.min || (result += ",") : result += "," + config4.spacingInner;
        }
        result += config4.spacingOuter + indentation;
      }
      return result;
    }
    function printIteratorValues2(iterator, config4, indentation, depth, refs, printer2) {
      let result = "", current = iterator.next();
      if (!current.done) {
        result += config4.spacingOuter;
        let indentationNext = indentation + config4.indent;
        for (; !current.done; )
          result += indentationNext + printer2(current.value, config4, indentationNext, depth, refs), current = iterator.next(), current.done ? config4.min || (result += ",") : result += "," + config4.spacingInner;
        result += config4.spacingOuter + indentation;
      }
      return result;
    }
    function printListItems2(list, config4, indentation, depth, refs, printer2) {
      let result = "";
      if (list.length) {
        result += config4.spacingOuter;
        let indentationNext = indentation + config4.indent;
        for (let i2 = 0; i2 < list.length; i2++)
          result += indentationNext, i2 in list && (result += printer2(list[i2], config4, indentationNext, depth, refs)), i2 < list.length - 1 ? result += "," + config4.spacingInner : config4.min || (result += ",");
        result += config4.spacingOuter + indentation;
      }
      return result;
    }
    function printObjectProperties2(val, config4, indentation, depth, refs, printer2) {
      let result = "", keys2 = getKeysOfEnumerableProperties2(val, config4.compareKeys);
      if (keys2.length) {
        result += config4.spacingOuter;
        let indentationNext = indentation + config4.indent;
        for (let i2 = 0; i2 < keys2.length; i2++) {
          let key = keys2[i2], name = printer2(key, config4, indentationNext, depth, refs), value = printer2(val[key], config4, indentationNext, depth, refs);
          result += indentationNext + name + ": " + value, i2 < keys2.length - 1 ? result += "," + config4.spacingInner : config4.min || (result += ",");
        }
        result += config4.spacingOuter + indentation;
      }
      return result;
    }
  }
});

// ../node_modules/pretty-format/build/plugins/AsymmetricMatcher.js
var require_AsymmetricMatcher = __commonJS({
  "../node_modules/pretty-format/build/plugins/AsymmetricMatcher.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.test = exports.serialize = exports.default = void 0;
    var _collections = require_collections(), global2 = (function() {
      return typeof globalThis < "u" ? globalThis : typeof global2 < "u" ? global2 : typeof self < "u" ? self : typeof window < "u" ? window : Function("return this")();
    })(), Symbol3 = global2["jest-symbol-do-not-touch"] || global2.Symbol, asymmetricMatcher2 = typeof Symbol3 == "function" && Symbol3.for ? Symbol3.for("jest.asymmetricMatcher") : 1267621, SPACE2 = " ", serialize2 = (val, config4, indentation, depth, refs, printer2) => {
      let stringedValue = val.toString();
      return stringedValue === "ArrayContaining" || stringedValue === "ArrayNotContaining" ? ++depth > config4.maxDepth ? "[" + stringedValue + "]" : stringedValue + SPACE2 + "[" + (0, _collections.printListItems)(
        val.sample,
        config4,
        indentation,
        depth,
        refs,
        printer2
      ) + "]" : stringedValue === "ObjectContaining" || stringedValue === "ObjectNotContaining" ? ++depth > config4.maxDepth ? "[" + stringedValue + "]" : stringedValue + SPACE2 + "{" + (0, _collections.printObjectProperties)(
        val.sample,
        config4,
        indentation,
        depth,
        refs,
        printer2
      ) + "}" : stringedValue === "StringMatching" || stringedValue === "StringNotMatching" || stringedValue === "StringContaining" || stringedValue === "StringNotContaining" ? stringedValue + SPACE2 + printer2(val.sample, config4, indentation, depth, refs) : val.toAsymmetricMatcher();
    };
    exports.serialize = serialize2;
    var test3 = (val) => val && val.$$typeof === asymmetricMatcher2;
    exports.test = test3;
    var plugin2 = {
      serialize: serialize2,
      test: test3
    }, _default = plugin2;
    exports.default = _default;
  }
});

// ../node_modules/pretty-format/node_modules/ansi-regex/index.js
var require_ansi_regex = __commonJS({
  "../node_modules/pretty-format/node_modules/ansi-regex/index.js"(exports, module2) {
    "use strict";
    module2.exports = ({ onlyFirst = !1 } = {}) => {
      let pattern = [
        "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
        "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
      ].join("|");
      return new RegExp(pattern, onlyFirst ? void 0 : "g");
    };
  }
});

// ../node_modules/pretty-format/build/plugins/ConvertAnsi.js
var require_ConvertAnsi = __commonJS({
  "../node_modules/pretty-format/build/plugins/ConvertAnsi.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.test = exports.serialize = exports.default = void 0;
    var _ansiRegex = _interopRequireDefault(require_ansi_regex()), _ansiStyles = _interopRequireDefault(require_ansi_styles());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var toHumanReadableAnsi = (text) => text.replace((0, _ansiRegex.default)(), (match) => {
      switch (match) {
        case _ansiStyles.default.red.close:
        case _ansiStyles.default.green.close:
        case _ansiStyles.default.cyan.close:
        case _ansiStyles.default.gray.close:
        case _ansiStyles.default.white.close:
        case _ansiStyles.default.yellow.close:
        case _ansiStyles.default.bgRed.close:
        case _ansiStyles.default.bgGreen.close:
        case _ansiStyles.default.bgYellow.close:
        case _ansiStyles.default.inverse.close:
        case _ansiStyles.default.dim.close:
        case _ansiStyles.default.bold.close:
        case _ansiStyles.default.reset.open:
        case _ansiStyles.default.reset.close:
          return "</>";
        case _ansiStyles.default.red.open:
          return "<red>";
        case _ansiStyles.default.green.open:
          return "<green>";
        case _ansiStyles.default.cyan.open:
          return "<cyan>";
        case _ansiStyles.default.gray.open:
          return "<gray>";
        case _ansiStyles.default.white.open:
          return "<white>";
        case _ansiStyles.default.yellow.open:
          return "<yellow>";
        case _ansiStyles.default.bgRed.open:
          return "<bgRed>";
        case _ansiStyles.default.bgGreen.open:
          return "<bgGreen>";
        case _ansiStyles.default.bgYellow.open:
          return "<bgYellow>";
        case _ansiStyles.default.inverse.open:
          return "<inverse>";
        case _ansiStyles.default.dim.open:
          return "<dim>";
        case _ansiStyles.default.bold.open:
          return "<bold>";
        default:
          return "";
      }
    }), test3 = (val) => typeof val == "string" && !!val.match((0, _ansiRegex.default)());
    exports.test = test3;
    var serialize2 = (val, config4, indentation, depth, refs, printer2) => printer2(toHumanReadableAnsi(val), config4, indentation, depth, refs);
    exports.serialize = serialize2;
    var plugin2 = {
      serialize: serialize2,
      test: test3
    }, _default = plugin2;
    exports.default = _default;
  }
});

// ../node_modules/pretty-format/build/plugins/DOMCollection.js
var require_DOMCollection = __commonJS({
  "../node_modules/pretty-format/build/plugins/DOMCollection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.test = exports.serialize = exports.default = void 0;
    var _collections = require_collections(), SPACE2 = " ", OBJECT_NAMES2 = ["DOMStringMap", "NamedNodeMap"], ARRAY_REGEXP2 = /^(HTML\w*Collection|NodeList)$/, testName2 = (name) => OBJECT_NAMES2.indexOf(name) !== -1 || ARRAY_REGEXP2.test(name), test3 = (val) => val && val.constructor && !!val.constructor.name && testName2(val.constructor.name);
    exports.test = test3;
    var isNamedNodeMap2 = (collection) => collection.constructor.name === "NamedNodeMap", serialize2 = (collection, config4, indentation, depth, refs, printer2) => {
      let name = collection.constructor.name;
      return ++depth > config4.maxDepth ? "[" + name + "]" : (config4.min ? "" : name + SPACE2) + (OBJECT_NAMES2.indexOf(name) !== -1 ? "{" + (0, _collections.printObjectProperties)(
        isNamedNodeMap2(collection) ? Array.from(collection).reduce((props, attribute) => (props[attribute.name] = attribute.value, props), {}) : { ...collection },
        config4,
        indentation,
        depth,
        refs,
        printer2
      ) + "}" : "[" + (0, _collections.printListItems)(
        Array.from(collection),
        config4,
        indentation,
        depth,
        refs,
        printer2
      ) + "]");
    };
    exports.serialize = serialize2;
    var plugin2 = {
      serialize: serialize2,
      test: test3
    }, _default = plugin2;
    exports.default = _default;
  }
});

// ../node_modules/pretty-format/build/plugins/lib/escapeHTML.js
var require_escapeHTML = __commonJS({
  "../node_modules/pretty-format/build/plugins/lib/escapeHTML.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = escapeHTML3;
    function escapeHTML3(str2) {
      return str2.replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }
  }
});

// ../node_modules/pretty-format/build/plugins/lib/markup.js
var require_markup = __commonJS({
  "../node_modules/pretty-format/build/plugins/lib/markup.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.printText = exports.printProps = exports.printElementAsLeaf = exports.printElement = exports.printComment = exports.printChildren = void 0;
    var _escapeHTML = _interopRequireDefault(require_escapeHTML());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var printProps3 = (keys2, props, config4, indentation, depth, refs, printer2) => {
      let indentationNext = indentation + config4.indent, colors3 = config4.colors;
      return keys2.map((key) => {
        let value = props[key], printed = printer2(value, config4, indentationNext, depth, refs);
        return typeof value != "string" && (printed.indexOf(`
`) !== -1 && (printed = config4.spacingOuter + indentationNext + printed + config4.spacingOuter + indentation), printed = "{" + printed + "}"), config4.spacingInner + indentation + colors3.prop.open + key + colors3.prop.close + "=" + colors3.value.open + printed + colors3.value.close;
      }).join("");
    };
    exports.printProps = printProps3;
    var printChildren3 = (children, config4, indentation, depth, refs, printer2) => children.map(
      (child) => config4.spacingOuter + indentation + (typeof child == "string" ? printText3(child, config4) : printer2(child, config4, indentation, depth, refs))
    ).join("");
    exports.printChildren = printChildren3;
    var printText3 = (text, config4) => {
      let contentColor = config4.colors.content;
      return contentColor.open + (0, _escapeHTML.default)(text) + contentColor.close;
    };
    exports.printText = printText3;
    var printComment3 = (comment, config4) => {
      let commentColor = config4.colors.comment;
      return commentColor.open + "<!--" + (0, _escapeHTML.default)(comment) + "-->" + commentColor.close;
    };
    exports.printComment = printComment3;
    var printElement3 = (type5, printedProps, printedChildren, config4, indentation) => {
      let tagColor = config4.colors.tag;
      return tagColor.open + "<" + type5 + (printedProps && tagColor.close + printedProps + config4.spacingOuter + indentation + tagColor.open) + (printedChildren ? ">" + tagColor.close + printedChildren + config4.spacingOuter + indentation + tagColor.open + "</" + type5 : (printedProps && !config4.min ? "" : " ") + "/") + ">" + tagColor.close;
    };
    exports.printElement = printElement3;
    var printElementAsLeaf3 = (type5, config4) => {
      let tagColor = config4.colors.tag;
      return tagColor.open + "<" + type5 + tagColor.close + " \u2026" + tagColor.open + " />" + tagColor.close;
    };
    exports.printElementAsLeaf = printElementAsLeaf3;
  }
});

// ../node_modules/pretty-format/build/plugins/DOMElement.js
var require_DOMElement = __commonJS({
  "../node_modules/pretty-format/build/plugins/DOMElement.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.test = exports.serialize = exports.default = void 0;
    var _markup = require_markup(), ELEMENT_NODE3 = 1, TEXT_NODE3 = 3, COMMENT_NODE3 = 8, FRAGMENT_NODE3 = 11, ELEMENT_REGEXP3 = /^((HTML|SVG)\w*)?Element$/, testHasAttribute2 = (val) => {
      try {
        return typeof val.hasAttribute == "function" && val.hasAttribute("is");
      } catch {
        return !1;
      }
    }, testNode3 = (val) => {
      let constructorName = val.constructor.name, { nodeType, tagName } = val, isCustomElement3 = typeof tagName == "string" && tagName.includes("-") || testHasAttribute2(val);
      return nodeType === ELEMENT_NODE3 && (ELEMENT_REGEXP3.test(constructorName) || isCustomElement3) || nodeType === TEXT_NODE3 && constructorName === "Text" || nodeType === COMMENT_NODE3 && constructorName === "Comment" || nodeType === FRAGMENT_NODE3 && constructorName === "DocumentFragment";
    }, test3 = (val) => {
      var _val$constructor;
      return (val == null || (_val$constructor = val.constructor) === null || _val$constructor === void 0 ? void 0 : _val$constructor.name) && testNode3(val);
    };
    exports.test = test3;
    function nodeIsText3(node) {
      return node.nodeType === TEXT_NODE3;
    }
    function nodeIsComment3(node) {
      return node.nodeType === COMMENT_NODE3;
    }
    function nodeIsFragment3(node) {
      return node.nodeType === FRAGMENT_NODE3;
    }
    var serialize2 = (node, config4, indentation, depth, refs, printer2) => {
      if (nodeIsText3(node))
        return (0, _markup.printText)(node.data, config4);
      if (nodeIsComment3(node))
        return (0, _markup.printComment)(node.data, config4);
      let type5 = nodeIsFragment3(node) ? "DocumentFragment" : node.tagName.toLowerCase();
      return ++depth > config4.maxDepth ? (0, _markup.printElementAsLeaf)(type5, config4) : (0, _markup.printElement)(
        type5,
        (0, _markup.printProps)(
          nodeIsFragment3(node) ? [] : Array.from(node.attributes).map((attr) => attr.name).sort(),
          nodeIsFragment3(node) ? {} : Array.from(node.attributes).reduce((props, attribute) => (props[attribute.name] = attribute.value, props), {}),
          config4,
          indentation + config4.indent,
          depth,
          refs,
          printer2
        ),
        (0, _markup.printChildren)(
          Array.prototype.slice.call(node.childNodes || node.children),
          config4,
          indentation + config4.indent,
          depth,
          refs,
          printer2
        ),
        config4,
        indentation
      );
    };
    exports.serialize = serialize2;
    var plugin2 = {
      serialize: serialize2,
      test: test3
    }, _default = plugin2;
    exports.default = _default;
  }
});

// ../node_modules/pretty-format/build/plugins/Immutable.js
var require_Immutable = __commonJS({
  "../node_modules/pretty-format/build/plugins/Immutable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.test = exports.serialize = exports.default = void 0;
    var _collections = require_collections(), IS_ITERABLE_SENTINEL2 = "@@__IMMUTABLE_ITERABLE__@@", IS_LIST_SENTINEL3 = "@@__IMMUTABLE_LIST__@@", IS_KEYED_SENTINEL3 = "@@__IMMUTABLE_KEYED__@@", IS_MAP_SENTINEL2 = "@@__IMMUTABLE_MAP__@@", IS_ORDERED_SENTINEL3 = "@@__IMMUTABLE_ORDERED__@@", IS_RECORD_SENTINEL2 = "@@__IMMUTABLE_RECORD__@@", IS_SEQ_SENTINEL2 = "@@__IMMUTABLE_SEQ__@@", IS_SET_SENTINEL3 = "@@__IMMUTABLE_SET__@@", IS_STACK_SENTINEL2 = "@@__IMMUTABLE_STACK__@@", getImmutableName2 = (name) => "Immutable." + name, printAsLeaf2 = (name) => "[" + name + "]", SPACE2 = " ", LAZY2 = "\u2026", printImmutableEntries2 = (val, config4, indentation, depth, refs, printer2, type5) => ++depth > config4.maxDepth ? printAsLeaf2(getImmutableName2(type5)) : getImmutableName2(type5) + SPACE2 + "{" + (0, _collections.printIteratorEntries)(
      val.entries(),
      config4,
      indentation,
      depth,
      refs,
      printer2
    ) + "}";
    function getRecordEntries2(val) {
      let i2 = 0;
      return {
        next() {
          if (i2 < val._keys.length) {
            let key = val._keys[i2++];
            return {
              done: !1,
              value: [key, val.get(key)]
            };
          }
          return {
            done: !0,
            value: void 0
          };
        }
      };
    }
    var printImmutableRecord2 = (val, config4, indentation, depth, refs, printer2) => {
      let name = getImmutableName2(val._name || "Record");
      return ++depth > config4.maxDepth ? printAsLeaf2(name) : name + SPACE2 + "{" + (0, _collections.printIteratorEntries)(
        getRecordEntries2(val),
        config4,
        indentation,
        depth,
        refs,
        printer2
      ) + "}";
    }, printImmutableSeq2 = (val, config4, indentation, depth, refs, printer2) => {
      let name = getImmutableName2("Seq");
      return ++depth > config4.maxDepth ? printAsLeaf2(name) : val[IS_KEYED_SENTINEL3] ? name + SPACE2 + "{" + // from Immutable collection of entries or from ECMAScript object
      (val._iter || val._object ? (0, _collections.printIteratorEntries)(
        val.entries(),
        config4,
        indentation,
        depth,
        refs,
        printer2
      ) : LAZY2) + "}" : name + SPACE2 + "[" + (val._iter || // from Immutable collection of values
      val._array || // from ECMAScript array
      val._collection || // from ECMAScript collection in immutable v4
      val._iterable ? (0, _collections.printIteratorValues)(
        val.values(),
        config4,
        indentation,
        depth,
        refs,
        printer2
      ) : LAZY2) + "]";
    }, printImmutableValues2 = (val, config4, indentation, depth, refs, printer2, type5) => ++depth > config4.maxDepth ? printAsLeaf2(getImmutableName2(type5)) : getImmutableName2(type5) + SPACE2 + "[" + (0, _collections.printIteratorValues)(
      val.values(),
      config4,
      indentation,
      depth,
      refs,
      printer2
    ) + "]", serialize2 = (val, config4, indentation, depth, refs, printer2) => val[IS_MAP_SENTINEL2] ? printImmutableEntries2(
      val,
      config4,
      indentation,
      depth,
      refs,
      printer2,
      val[IS_ORDERED_SENTINEL3] ? "OrderedMap" : "Map"
    ) : val[IS_LIST_SENTINEL3] ? printImmutableValues2(
      val,
      config4,
      indentation,
      depth,
      refs,
      printer2,
      "List"
    ) : val[IS_SET_SENTINEL3] ? printImmutableValues2(
      val,
      config4,
      indentation,
      depth,
      refs,
      printer2,
      val[IS_ORDERED_SENTINEL3] ? "OrderedSet" : "Set"
    ) : val[IS_STACK_SENTINEL2] ? printImmutableValues2(
      val,
      config4,
      indentation,
      depth,
      refs,
      printer2,
      "Stack"
    ) : val[IS_SEQ_SENTINEL2] ? printImmutableSeq2(val, config4, indentation, depth, refs, printer2) : printImmutableRecord2(val, config4, indentation, depth, refs, printer2);
    exports.serialize = serialize2;
    var test3 = (val) => val && (val[IS_ITERABLE_SENTINEL2] === !0 || val[IS_RECORD_SENTINEL2] === !0);
    exports.test = test3;
    var plugin2 = {
      serialize: serialize2,
      test: test3
    }, _default = plugin2;
    exports.default = _default;
  }
});

// ../node_modules/pretty-format/node_modules/react-is/cjs/react-is.production.min.js
var require_react_is_production_min = __commonJS({
  "../node_modules/pretty-format/node_modules/react-is/cjs/react-is.production.min.js"(exports) {
    "use strict";
    var b2 = 60103, c2 = 60106, d = 60107, e2 = 60108, f4 = 60114, g2 = 60109, h3 = 60110, k2 = 60112, l2 = 60113, m3 = 60120, n2 = 60115, p2 = 60116, q = 60121, r2 = 60122, u3 = 60117, v2 = 60129, w2 = 60131;
    typeof Symbol == "function" && Symbol.for && (x2 = Symbol.for, b2 = x2("react.element"), c2 = x2("react.portal"), d = x2("react.fragment"), e2 = x2("react.strict_mode"), f4 = x2("react.profiler"), g2 = x2("react.provider"), h3 = x2("react.context"), k2 = x2("react.forward_ref"), l2 = x2("react.suspense"), m3 = x2("react.suspense_list"), n2 = x2("react.memo"), p2 = x2("react.lazy"), q = x2("react.block"), r2 = x2("react.server.block"), u3 = x2("react.fundamental"), v2 = x2("react.debug_trace_mode"), w2 = x2("react.legacy_hidden"));
    var x2;
    function y2(a2) {
      if (typeof a2 == "object" && a2 !== null) {
        var t2 = a2.$$typeof;
        switch (t2) {
          case b2:
            switch (a2 = a2.type, a2) {
              case d:
              case f4:
              case e2:
              case l2:
              case m3:
                return a2;
              default:
                switch (a2 = a2 && a2.$$typeof, a2) {
                  case h3:
                  case k2:
                  case p2:
                  case n2:
                  case g2:
                    return a2;
                  default:
                    return t2;
                }
            }
          case c2:
            return t2;
        }
      }
    }
    var z = g2, A = b2, B2 = k2, C2 = d, D2 = p2, E2 = n2, F = c2, G = f4, H = e2, I = l2;
    exports.ContextConsumer = h3;
    exports.ContextProvider = z;
    exports.Element = A;
    exports.ForwardRef = B2;
    exports.Fragment = C2;
    exports.Lazy = D2;
    exports.Memo = E2;
    exports.Portal = F;
    exports.Profiler = G;
    exports.StrictMode = H;
    exports.Suspense = I;
    exports.isAsyncMode = function() {
      return !1;
    };
    exports.isConcurrentMode = function() {
      return !1;
    };
    exports.isContextConsumer = function(a2) {
      return y2(a2) === h3;
    };
    exports.isContextProvider = function(a2) {
      return y2(a2) === g2;
    };
    exports.isElement = function(a2) {
      return typeof a2 == "object" && a2 !== null && a2.$$typeof === b2;
    };
    exports.isForwardRef = function(a2) {
      return y2(a2) === k2;
    };
    exports.isFragment = function(a2) {
      return y2(a2) === d;
    };
    exports.isLazy = function(a2) {
      return y2(a2) === p2;
    };
    exports.isMemo = function(a2) {
      return y2(a2) === n2;
    };
    exports.isPortal = function(a2) {
      return y2(a2) === c2;
    };
    exports.isProfiler = function(a2) {
      return y2(a2) === f4;
    };
    exports.isStrictMode = function(a2) {
      return y2(a2) === e2;
    };
    exports.isSuspense = function(a2) {
      return y2(a2) === l2;
    };
    exports.isValidElementType = function(a2) {
      return typeof a2 == "string" || typeof a2 == "function" || a2 === d || a2 === f4 || a2 === v2 || a2 === e2 || a2 === l2 || a2 === m3 || a2 === w2 || typeof a2 == "object" && a2 !== null && (a2.$$typeof === p2 || a2.$$typeof === n2 || a2.$$typeof === g2 || a2.$$typeof === h3 || a2.$$typeof === k2 || a2.$$typeof === u3 || a2.$$typeof === q || a2[0] === r2);
    };
    exports.typeOf = y2;
  }
});

// ../node_modules/pretty-format/node_modules/react-is/index.js
var require_react_is = __commonJS({
  "../node_modules/pretty-format/node_modules/react-is/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_react_is_production_min();
  }
});

// ../node_modules/pretty-format/build/plugins/ReactElement.js
var require_ReactElement = __commonJS({
  "../node_modules/pretty-format/build/plugins/ReactElement.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.test = exports.serialize = exports.default = void 0;
    var ReactIs2 = _interopRequireWildcard(require_react_is()), _markup = require_markup();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap != "function") return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap(), cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule)
        return obj;
      if (obj === null || typeof obj != "object" && typeof obj != "function")
        return { default: obj };
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj))
        return cache.get(obj);
      var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj)
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
        }
      return newObj.default = obj, cache && cache.set(obj, newObj), newObj;
    }
    var getChildren2 = (arg, children = []) => (Array.isArray(arg) ? arg.forEach((item) => {
      getChildren2(item, children);
    }) : arg != null && arg !== !1 && children.push(arg), children), getType4 = (element) => {
      let type5 = element.type;
      if (typeof type5 == "string")
        return type5;
      if (typeof type5 == "function")
        return type5.displayName || type5.name || "Unknown";
      if (ReactIs2.isFragment(element))
        return "React.Fragment";
      if (ReactIs2.isSuspense(element))
        return "React.Suspense";
      if (typeof type5 == "object" && type5 !== null) {
        if (ReactIs2.isContextProvider(element))
          return "Context.Provider";
        if (ReactIs2.isContextConsumer(element))
          return "Context.Consumer";
        if (ReactIs2.isForwardRef(element)) {
          if (type5.displayName)
            return type5.displayName;
          let functionName = type5.render.displayName || type5.render.name || "";
          return functionName !== "" ? "ForwardRef(" + functionName + ")" : "ForwardRef";
        }
        if (ReactIs2.isMemo(element)) {
          let functionName = type5.displayName || type5.type.displayName || type5.type.name || "";
          return functionName !== "" ? "Memo(" + functionName + ")" : "Memo";
        }
      }
      return "UNDEFINED";
    }, getPropKeys2 = (element) => {
      let { props } = element;
      return Object.keys(props).filter((key) => key !== "children" && props[key] !== void 0).sort();
    }, serialize2 = (element, config4, indentation, depth, refs, printer2) => ++depth > config4.maxDepth ? (0, _markup.printElementAsLeaf)(getType4(element), config4) : (0, _markup.printElement)(
      getType4(element),
      (0, _markup.printProps)(
        getPropKeys2(element),
        element.props,
        config4,
        indentation + config4.indent,
        depth,
        refs,
        printer2
      ),
      (0, _markup.printChildren)(
        getChildren2(element.props.children),
        config4,
        indentation + config4.indent,
        depth,
        refs,
        printer2
      ),
      config4,
      indentation
    );
    exports.serialize = serialize2;
    var test3 = (val) => val != null && ReactIs2.isElement(val);
    exports.test = test3;
    var plugin2 = {
      serialize: serialize2,
      test: test3
    }, _default = plugin2;
    exports.default = _default;
  }
});

// ../node_modules/pretty-format/build/plugins/ReactTestComponent.js
var require_ReactTestComponent = __commonJS({
  "../node_modules/pretty-format/build/plugins/ReactTestComponent.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.test = exports.serialize = exports.default = void 0;
    var _markup = require_markup(), global2 = (function() {
      return typeof globalThis < "u" ? globalThis : typeof global2 < "u" ? global2 : typeof self < "u" ? self : typeof window < "u" ? window : Function("return this")();
    })(), Symbol3 = global2["jest-symbol-do-not-touch"] || global2.Symbol, testSymbol2 = typeof Symbol3 == "function" && Symbol3.for ? Symbol3.for("react.test.json") : 245830487, getPropKeys2 = (object) => {
      let { props } = object;
      return props ? Object.keys(props).filter((key) => props[key] !== void 0).sort() : [];
    }, serialize2 = (object, config4, indentation, depth, refs, printer2) => ++depth > config4.maxDepth ? (0, _markup.printElementAsLeaf)(object.type, config4) : (0, _markup.printElement)(
      object.type,
      object.props ? (0, _markup.printProps)(
        getPropKeys2(object),
        object.props,
        config4,
        indentation + config4.indent,
        depth,
        refs,
        printer2
      ) : "",
      object.children ? (0, _markup.printChildren)(
        object.children,
        config4,
        indentation + config4.indent,
        depth,
        refs,
        printer2
      ) : "",
      config4,
      indentation
    );
    exports.serialize = serialize2;
    var test3 = (val) => val && val.$$typeof === testSymbol2;
    exports.test = test3;
    var plugin2 = {
      serialize: serialize2,
      test: test3
    }, _default = plugin2;
    exports.default = _default;
  }
});

// ../node_modules/pretty-format/build/index.js
var require_build = __commonJS({
  "../node_modules/pretty-format/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = exports.DEFAULT_OPTIONS = void 0;
    exports.format = format4;
    exports.plugins = void 0;
    var _ansiStyles = _interopRequireDefault(require_ansi_styles()), _collections = require_collections(), _AsymmetricMatcher = _interopRequireDefault(
      require_AsymmetricMatcher()
    ), _ConvertAnsi = _interopRequireDefault(require_ConvertAnsi()), _DOMCollection = _interopRequireDefault(require_DOMCollection()), _DOMElement = _interopRequireDefault(require_DOMElement()), _Immutable = _interopRequireDefault(require_Immutable()), _ReactElement = _interopRequireDefault(require_ReactElement()), _ReactTestComponent = _interopRequireDefault(
      require_ReactTestComponent()
    );
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var toString5 = Object.prototype.toString, toISOString2 = Date.prototype.toISOString, errorToString2 = Error.prototype.toString, regExpToString2 = RegExp.prototype.toString, getConstructorName3 = (val) => typeof val.constructor == "function" && val.constructor.name || "Object", isWindow2 = (val) => typeof window < "u" && val === window, SYMBOL_REGEXP2 = /^Symbol\((.*)\)(.*)$/, NEWLINE_REGEXP2 = /\n/gi, PrettyFormatPluginError2 = class extends Error {
      constructor(message, stack) {
        super(message), this.stack = stack, this.name = this.constructor.name;
      }
    };
    function isToStringedArrayType2(toStringed) {
      return toStringed === "[object Array]" || toStringed === "[object ArrayBuffer]" || toStringed === "[object DataView]" || toStringed === "[object Float32Array]" || toStringed === "[object Float64Array]" || toStringed === "[object Int8Array]" || toStringed === "[object Int16Array]" || toStringed === "[object Int32Array]" || toStringed === "[object Uint8Array]" || toStringed === "[object Uint8ClampedArray]" || toStringed === "[object Uint16Array]" || toStringed === "[object Uint32Array]";
    }
    function printNumber2(val) {
      return Object.is(val, -0) ? "-0" : String(val);
    }
    function printBigInt2(val) {
      return `${val}n`;
    }
    function printFunction2(val, printFunctionName) {
      return printFunctionName ? "[Function " + (val.name || "anonymous") + "]" : "[Function]";
    }
    function printSymbol2(val) {
      return String(val).replace(SYMBOL_REGEXP2, "Symbol($1)");
    }
    function printError2(val) {
      return "[" + errorToString2.call(val) + "]";
    }
    function printBasicValue2(val, printFunctionName, escapeRegex, escapeString) {
      if (val === !0 || val === !1)
        return "" + val;
      if (val === void 0)
        return "undefined";
      if (val === null)
        return "null";
      let typeOf = typeof val;
      if (typeOf === "number")
        return printNumber2(val);
      if (typeOf === "bigint")
        return printBigInt2(val);
      if (typeOf === "string")
        return escapeString ? '"' + val.replace(/"|\\/g, "\\$&") + '"' : '"' + val + '"';
      if (typeOf === "function")
        return printFunction2(val, printFunctionName);
      if (typeOf === "symbol")
        return printSymbol2(val);
      let toStringed = toString5.call(val);
      return toStringed === "[object WeakMap]" ? "WeakMap {}" : toStringed === "[object WeakSet]" ? "WeakSet {}" : toStringed === "[object Function]" || toStringed === "[object GeneratorFunction]" ? printFunction2(val, printFunctionName) : toStringed === "[object Symbol]" ? printSymbol2(val) : toStringed === "[object Date]" ? isNaN(+val) ? "Date { NaN }" : toISOString2.call(val) : toStringed === "[object Error]" ? printError2(val) : toStringed === "[object RegExp]" ? escapeRegex ? regExpToString2.call(val).replace(/[\\^$*+?.()|[\]{}]/g, "\\$&") : regExpToString2.call(val) : val instanceof Error ? printError2(val) : null;
    }
    function printComplexValue2(val, config4, indentation, depth, refs, hasCalledToJSON) {
      if (refs.indexOf(val) !== -1)
        return "[Circular]";
      refs = refs.slice(), refs.push(val);
      let hitMaxDepth = ++depth > config4.maxDepth, min = config4.min;
      if (config4.callToJSON && !hitMaxDepth && val.toJSON && typeof val.toJSON == "function" && !hasCalledToJSON)
        return printer2(val.toJSON(), config4, indentation, depth, refs, !0);
      let toStringed = toString5.call(val);
      return toStringed === "[object Arguments]" ? hitMaxDepth ? "[Arguments]" : (min ? "" : "Arguments ") + "[" + (0, _collections.printListItems)(
        val,
        config4,
        indentation,
        depth,
        refs,
        printer2
      ) + "]" : isToStringedArrayType2(toStringed) ? hitMaxDepth ? "[" + val.constructor.name + "]" : (min || !config4.printBasicPrototype && val.constructor.name === "Array" ? "" : val.constructor.name + " ") + "[" + (0, _collections.printListItems)(
        val,
        config4,
        indentation,
        depth,
        refs,
        printer2
      ) + "]" : toStringed === "[object Map]" ? hitMaxDepth ? "[Map]" : "Map {" + (0, _collections.printIteratorEntries)(
        val.entries(),
        config4,
        indentation,
        depth,
        refs,
        printer2,
        " => "
      ) + "}" : toStringed === "[object Set]" ? hitMaxDepth ? "[Set]" : "Set {" + (0, _collections.printIteratorValues)(
        val.values(),
        config4,
        indentation,
        depth,
        refs,
        printer2
      ) + "}" : hitMaxDepth || isWindow2(val) ? "[" + getConstructorName3(val) + "]" : (min || !config4.printBasicPrototype && getConstructorName3(val) === "Object" ? "" : getConstructorName3(val) + " ") + "{" + (0, _collections.printObjectProperties)(
        val,
        config4,
        indentation,
        depth,
        refs,
        printer2
      ) + "}";
    }
    function isNewPlugin2(plugin2) {
      return plugin2.serialize != null;
    }
    function printPlugin2(plugin2, val, config4, indentation, depth, refs) {
      let printed;
      try {
        printed = isNewPlugin2(plugin2) ? plugin2.serialize(val, config4, indentation, depth, refs, printer2) : plugin2.print(
          val,
          (valChild) => printer2(valChild, config4, indentation, depth, refs),
          (str2) => {
            let indentationNext = indentation + config4.indent;
            return indentationNext + str2.replace(NEWLINE_REGEXP2, `
` + indentationNext);
          },
          {
            edgeSpacing: config4.spacingOuter,
            min: config4.min,
            spacing: config4.spacingInner
          },
          config4.colors
        );
      } catch (error) {
        throw new PrettyFormatPluginError2(error.message, error.stack);
      }
      if (typeof printed != "string")
        throw new Error(
          `pretty-format: Plugin must return type "string" but instead returned "${typeof printed}".`
        );
      return printed;
    }
    function findPlugin2(plugins4, val) {
      for (let p2 = 0; p2 < plugins4.length; p2++)
        try {
          if (plugins4[p2].test(val))
            return plugins4[p2];
        } catch (error) {
          throw new PrettyFormatPluginError2(error.message, error.stack);
        }
      return null;
    }
    function printer2(val, config4, indentation, depth, refs, hasCalledToJSON) {
      let plugin2 = findPlugin2(config4.plugins, val);
      if (plugin2 !== null)
        return printPlugin2(plugin2, val, config4, indentation, depth, refs);
      let basicResult = printBasicValue2(
        val,
        config4.printFunctionName,
        config4.escapeRegex,
        config4.escapeString
      );
      return basicResult !== null ? basicResult : printComplexValue2(
        val,
        config4,
        indentation,
        depth,
        refs,
        hasCalledToJSON
      );
    }
    var DEFAULT_THEME2 = {
      comment: "gray",
      content: "reset",
      prop: "yellow",
      tag: "cyan",
      value: "green"
    }, DEFAULT_THEME_KEYS2 = Object.keys(DEFAULT_THEME2), DEFAULT_OPTIONS2 = {
      callToJSON: !0,
      compareKeys: void 0,
      escapeRegex: !1,
      escapeString: !0,
      highlight: !1,
      indent: 2,
      maxDepth: 1 / 0,
      min: !1,
      plugins: [],
      printBasicPrototype: !0,
      printFunctionName: !0,
      theme: DEFAULT_THEME2
    };
    exports.DEFAULT_OPTIONS = DEFAULT_OPTIONS2;
    function validateOptions3(options) {
      if (Object.keys(options).forEach((key) => {
        if (!DEFAULT_OPTIONS2.hasOwnProperty(key))
          throw new Error(`pretty-format: Unknown option "${key}".`);
      }), options.min && options.indent !== void 0 && options.indent !== 0)
        throw new Error(
          'pretty-format: Options "min" and "indent" cannot be used together.'
        );
      if (options.theme !== void 0) {
        if (options.theme === null)
          throw new Error('pretty-format: Option "theme" must not be null.');
        if (typeof options.theme != "object")
          throw new Error(
            `pretty-format: Option "theme" must be of type "object" but instead received "${typeof options.theme}".`
          );
      }
    }
    var getColorsHighlight2 = (options) => DEFAULT_THEME_KEYS2.reduce((colors3, key) => {
      let value = options.theme && options.theme[key] !== void 0 ? options.theme[key] : DEFAULT_THEME2[key], color = value && _ansiStyles.default[value];
      if (color && typeof color.close == "string" && typeof color.open == "string")
        colors3[key] = color;
      else
        throw new Error(
          `pretty-format: Option "theme" has a key "${key}" whose value "${value}" is undefined in ansi-styles.`
        );
      return colors3;
    }, /* @__PURE__ */ Object.create(null)), getColorsEmpty2 = () => DEFAULT_THEME_KEYS2.reduce((colors3, key) => (colors3[key] = {
      close: "",
      open: ""
    }, colors3), /* @__PURE__ */ Object.create(null)), getPrintFunctionName2 = (options) => options && options.printFunctionName !== void 0 ? options.printFunctionName : DEFAULT_OPTIONS2.printFunctionName, getEscapeRegex2 = (options) => options && options.escapeRegex !== void 0 ? options.escapeRegex : DEFAULT_OPTIONS2.escapeRegex, getEscapeString2 = (options) => options && options.escapeString !== void 0 ? options.escapeString : DEFAULT_OPTIONS2.escapeString, getConfig4 = (options) => {
      var _options$printBasicPr;
      return {
        callToJSON: options && options.callToJSON !== void 0 ? options.callToJSON : DEFAULT_OPTIONS2.callToJSON,
        colors: options && options.highlight ? getColorsHighlight2(options) : getColorsEmpty2(),
        compareKeys: options && typeof options.compareKeys == "function" ? options.compareKeys : DEFAULT_OPTIONS2.compareKeys,
        escapeRegex: getEscapeRegex2(options),
        escapeString: getEscapeString2(options),
        indent: options && options.min ? "" : createIndent2(
          options && options.indent !== void 0 ? options.indent : DEFAULT_OPTIONS2.indent
        ),
        maxDepth: options && options.maxDepth !== void 0 ? options.maxDepth : DEFAULT_OPTIONS2.maxDepth,
        min: options && options.min !== void 0 ? options.min : DEFAULT_OPTIONS2.min,
        plugins: options && options.plugins !== void 0 ? options.plugins : DEFAULT_OPTIONS2.plugins,
        printBasicPrototype: (_options$printBasicPr = options?.printBasicPrototype) !== null && _options$printBasicPr !== void 0 ? _options$printBasicPr : !0,
        printFunctionName: getPrintFunctionName2(options),
        spacingInner: options && options.min ? " " : `
`,
        spacingOuter: options && options.min ? "" : `
`
      };
    };
    function createIndent2(indent2) {
      return new Array(indent2 + 1).join(" ");
    }
    function format4(val, options) {
      if (options && (validateOptions3(options), options.plugins)) {
        let plugin2 = findPlugin2(options.plugins, val);
        if (plugin2 !== null)
          return printPlugin2(plugin2, val, getConfig4(options), "", 0, []);
      }
      let basicResult = printBasicValue2(
        val,
        getPrintFunctionName2(options),
        getEscapeRegex2(options),
        getEscapeString2(options)
      );
      return basicResult !== null ? basicResult : printComplexValue2(val, getConfig4(options), "", 0, []);
    }
    var plugins3 = {
      AsymmetricMatcher: _AsymmetricMatcher.default,
      ConvertAnsi: _ConvertAnsi.default,
      DOMCollection: _DOMCollection.default,
      DOMElement: _DOMElement.default,
      Immutable: _Immutable.default,
      ReactElement: _ReactElement.default,
      ReactTestComponent: _ReactTestComponent.default
    };
    exports.plugins = plugins3;
    var _default = format4;
    exports.default = _default;
  }
});

// ../node_modules/lz-string/libs/lz-string.js
var require_lz_string = __commonJS({
  "../node_modules/lz-string/libs/lz-string.js"(exports, module2) {
    var LZString = (function() {
      var f4 = String.fromCharCode, keyStrBase64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", keyStrUriSafe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$", baseReverseDic = {};
      function getBaseValue(alphabet, character) {
        if (!baseReverseDic[alphabet]) {
          baseReverseDic[alphabet] = {};
          for (var i2 = 0; i2 < alphabet.length; i2++)
            baseReverseDic[alphabet][alphabet.charAt(i2)] = i2;
        }
        return baseReverseDic[alphabet][character];
      }
      var LZString2 = {
        compressToBase64: function(input2) {
          if (input2 == null) return "";
          var res = LZString2._compress(input2, 6, function(a2) {
            return keyStrBase64.charAt(a2);
          });
          switch (res.length % 4) {
            // To produce valid Base64
            default:
            // When could this happen ?
            case 0:
              return res;
            case 1:
              return res + "===";
            case 2:
              return res + "==";
            case 3:
              return res + "=";
          }
        },
        decompressFromBase64: function(input2) {
          return input2 == null ? "" : input2 == "" ? null : LZString2._decompress(input2.length, 32, function(index2) {
            return getBaseValue(keyStrBase64, input2.charAt(index2));
          });
        },
        compressToUTF16: function(input2) {
          return input2 == null ? "" : LZString2._compress(input2, 15, function(a2) {
            return f4(a2 + 32);
          }) + " ";
        },
        decompressFromUTF16: function(compressed) {
          return compressed == null ? "" : compressed == "" ? null : LZString2._decompress(compressed.length, 16384, function(index2) {
            return compressed.charCodeAt(index2) - 32;
          });
        },
        //compress into uint8array (UCS-2 big endian format)
        compressToUint8Array: function(uncompressed) {
          for (var compressed = LZString2.compress(uncompressed), buf = new Uint8Array(compressed.length * 2), i2 = 0, TotalLen = compressed.length; i2 < TotalLen; i2++) {
            var current_value = compressed.charCodeAt(i2);
            buf[i2 * 2] = current_value >>> 8, buf[i2 * 2 + 1] = current_value % 256;
          }
          return buf;
        },
        //decompress from uint8array (UCS-2 big endian format)
        decompressFromUint8Array: function(compressed) {
          if (compressed == null)
            return LZString2.decompress(compressed);
          for (var buf = new Array(compressed.length / 2), i2 = 0, TotalLen = buf.length; i2 < TotalLen; i2++)
            buf[i2] = compressed[i2 * 2] * 256 + compressed[i2 * 2 + 1];
          var result = [];
          return buf.forEach(function(c2) {
            result.push(f4(c2));
          }), LZString2.decompress(result.join(""));
        },
        //compress into a string that is already URI encoded
        compressToEncodedURIComponent: function(input2) {
          return input2 == null ? "" : LZString2._compress(input2, 6, function(a2) {
            return keyStrUriSafe.charAt(a2);
          });
        },
        //decompress from an output of compressToEncodedURIComponent
        decompressFromEncodedURIComponent: function(input2) {
          return input2 == null ? "" : input2 == "" ? null : (input2 = input2.replace(/ /g, "+"), LZString2._decompress(input2.length, 32, function(index2) {
            return getBaseValue(keyStrUriSafe, input2.charAt(index2));
          }));
        },
        compress: function(uncompressed) {
          return LZString2._compress(uncompressed, 16, function(a2) {
            return f4(a2);
          });
        },
        _compress: function(uncompressed, bitsPerChar, getCharFromInt) {
          if (uncompressed == null) return "";
          var i2, value, context_dictionary = {}, context_dictionaryToCreate = {}, context_c = "", context_wc = "", context_w = "", context_enlargeIn = 2, context_dictSize = 3, context_numBits = 2, context_data = [], context_data_val = 0, context_data_position = 0, ii;
          for (ii = 0; ii < uncompressed.length; ii += 1)
            if (context_c = uncompressed.charAt(ii), Object.prototype.hasOwnProperty.call(context_dictionary, context_c) || (context_dictionary[context_c] = context_dictSize++, context_dictionaryToCreate[context_c] = !0), context_wc = context_w + context_c, Object.prototype.hasOwnProperty.call(context_dictionary, context_wc))
              context_w = context_wc;
            else {
              if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
                if (context_w.charCodeAt(0) < 256) {
                  for (i2 = 0; i2 < context_numBits; i2++)
                    context_data_val = context_data_val << 1, context_data_position == bitsPerChar - 1 ? (context_data_position = 0, context_data.push(getCharFromInt(context_data_val)), context_data_val = 0) : context_data_position++;
                  for (value = context_w.charCodeAt(0), i2 = 0; i2 < 8; i2++)
                    context_data_val = context_data_val << 1 | value & 1, context_data_position == bitsPerChar - 1 ? (context_data_position = 0, context_data.push(getCharFromInt(context_data_val)), context_data_val = 0) : context_data_position++, value = value >> 1;
                } else {
                  for (value = 1, i2 = 0; i2 < context_numBits; i2++)
                    context_data_val = context_data_val << 1 | value, context_data_position == bitsPerChar - 1 ? (context_data_position = 0, context_data.push(getCharFromInt(context_data_val)), context_data_val = 0) : context_data_position++, value = 0;
                  for (value = context_w.charCodeAt(0), i2 = 0; i2 < 16; i2++)
                    context_data_val = context_data_val << 1 | value & 1, context_data_position == bitsPerChar - 1 ? (context_data_position = 0, context_data.push(getCharFromInt(context_data_val)), context_data_val = 0) : context_data_position++, value = value >> 1;
                }
                context_enlargeIn--, context_enlargeIn == 0 && (context_enlargeIn = Math.pow(2, context_numBits), context_numBits++), delete context_dictionaryToCreate[context_w];
              } else
                for (value = context_dictionary[context_w], i2 = 0; i2 < context_numBits; i2++)
                  context_data_val = context_data_val << 1 | value & 1, context_data_position == bitsPerChar - 1 ? (context_data_position = 0, context_data.push(getCharFromInt(context_data_val)), context_data_val = 0) : context_data_position++, value = value >> 1;
              context_enlargeIn--, context_enlargeIn == 0 && (context_enlargeIn = Math.pow(2, context_numBits), context_numBits++), context_dictionary[context_wc] = context_dictSize++, context_w = String(context_c);
            }
          if (context_w !== "") {
            if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
              if (context_w.charCodeAt(0) < 256) {
                for (i2 = 0; i2 < context_numBits; i2++)
                  context_data_val = context_data_val << 1, context_data_position == bitsPerChar - 1 ? (context_data_position = 0, context_data.push(getCharFromInt(context_data_val)), context_data_val = 0) : context_data_position++;
                for (value = context_w.charCodeAt(0), i2 = 0; i2 < 8; i2++)
                  context_data_val = context_data_val << 1 | value & 1, context_data_position == bitsPerChar - 1 ? (context_data_position = 0, context_data.push(getCharFromInt(context_data_val)), context_data_val = 0) : context_data_position++, value = value >> 1;
              } else {
                for (value = 1, i2 = 0; i2 < context_numBits; i2++)
                  context_data_val = context_data_val << 1 | value, context_data_position == bitsPerChar - 1 ? (context_data_position = 0, context_data.push(getCharFromInt(context_data_val)), context_data_val = 0) : context_data_position++, value = 0;
                for (value = context_w.charCodeAt(0), i2 = 0; i2 < 16; i2++)
                  context_data_val = context_data_val << 1 | value & 1, context_data_position == bitsPerChar - 1 ? (context_data_position = 0, context_data.push(getCharFromInt(context_data_val)), context_data_val = 0) : context_data_position++, value = value >> 1;
              }
              context_enlargeIn--, context_enlargeIn == 0 && (context_enlargeIn = Math.pow(2, context_numBits), context_numBits++), delete context_dictionaryToCreate[context_w];
            } else
              for (value = context_dictionary[context_w], i2 = 0; i2 < context_numBits; i2++)
                context_data_val = context_data_val << 1 | value & 1, context_data_position == bitsPerChar - 1 ? (context_data_position = 0, context_data.push(getCharFromInt(context_data_val)), context_data_val = 0) : context_data_position++, value = value >> 1;
            context_enlargeIn--, context_enlargeIn == 0 && (context_enlargeIn = Math.pow(2, context_numBits), context_numBits++);
          }
          for (value = 2, i2 = 0; i2 < context_numBits; i2++)
            context_data_val = context_data_val << 1 | value & 1, context_data_position == bitsPerChar - 1 ? (context_data_position = 0, context_data.push(getCharFromInt(context_data_val)), context_data_val = 0) : context_data_position++, value = value >> 1;
          for (; ; )
            if (context_data_val = context_data_val << 1, context_data_position == bitsPerChar - 1) {
              context_data.push(getCharFromInt(context_data_val));
              break;
            } else context_data_position++;
          return context_data.join("");
        },
        decompress: function(compressed) {
          return compressed == null ? "" : compressed == "" ? null : LZString2._decompress(compressed.length, 32768, function(index2) {
            return compressed.charCodeAt(index2);
          });
        },
        _decompress: function(length, resetValue, getNextValue) {
          var dictionary = [], next, enlargeIn = 4, dictSize = 4, numBits = 3, entry = "", result = [], i2, w2, bits, resb, maxpower, power, c2, data = { val: getNextValue(0), position: resetValue, index: 1 };
          for (i2 = 0; i2 < 3; i2 += 1)
            dictionary[i2] = i2;
          for (bits = 0, maxpower = Math.pow(2, 2), power = 1; power != maxpower; )
            resb = data.val & data.position, data.position >>= 1, data.position == 0 && (data.position = resetValue, data.val = getNextValue(data.index++)), bits |= (resb > 0 ? 1 : 0) * power, power <<= 1;
          switch (next = bits) {
            case 0:
              for (bits = 0, maxpower = Math.pow(2, 8), power = 1; power != maxpower; )
                resb = data.val & data.position, data.position >>= 1, data.position == 0 && (data.position = resetValue, data.val = getNextValue(data.index++)), bits |= (resb > 0 ? 1 : 0) * power, power <<= 1;
              c2 = f4(bits);
              break;
            case 1:
              for (bits = 0, maxpower = Math.pow(2, 16), power = 1; power != maxpower; )
                resb = data.val & data.position, data.position >>= 1, data.position == 0 && (data.position = resetValue, data.val = getNextValue(data.index++)), bits |= (resb > 0 ? 1 : 0) * power, power <<= 1;
              c2 = f4(bits);
              break;
            case 2:
              return "";
          }
          for (dictionary[3] = c2, w2 = c2, result.push(c2); ; ) {
            if (data.index > length)
              return "";
            for (bits = 0, maxpower = Math.pow(2, numBits), power = 1; power != maxpower; )
              resb = data.val & data.position, data.position >>= 1, data.position == 0 && (data.position = resetValue, data.val = getNextValue(data.index++)), bits |= (resb > 0 ? 1 : 0) * power, power <<= 1;
            switch (c2 = bits) {
              case 0:
                for (bits = 0, maxpower = Math.pow(2, 8), power = 1; power != maxpower; )
                  resb = data.val & data.position, data.position >>= 1, data.position == 0 && (data.position = resetValue, data.val = getNextValue(data.index++)), bits |= (resb > 0 ? 1 : 0) * power, power <<= 1;
                dictionary[dictSize++] = f4(bits), c2 = dictSize - 1, enlargeIn--;
                break;
              case 1:
                for (bits = 0, maxpower = Math.pow(2, 16), power = 1; power != maxpower; )
                  resb = data.val & data.position, data.position >>= 1, data.position == 0 && (data.position = resetValue, data.val = getNextValue(data.index++)), bits |= (resb > 0 ? 1 : 0) * power, power <<= 1;
                dictionary[dictSize++] = f4(bits), c2 = dictSize - 1, enlargeIn--;
                break;
              case 2:
                return result.join("");
            }
            if (enlargeIn == 0 && (enlargeIn = Math.pow(2, numBits), numBits++), dictionary[c2])
              entry = dictionary[c2];
            else if (c2 === dictSize)
              entry = w2 + w2.charAt(0);
            else
              return null;
            result.push(entry), dictionary[dictSize++] = w2 + entry.charAt(0), enlargeIn--, w2 = entry, enlargeIn == 0 && (enlargeIn = Math.pow(2, numBits), numBits++);
          }
        }
      };
      return LZString2;
    })();
    typeof define == "function" && define.amd ? define(function() {
      return LZString;
    }) : typeof module2 < "u" && module2 != null ? module2.exports = LZString : typeof angular < "u" && angular != null && angular.module("LZString", []).factory("LZString", function() {
      return LZString;
    });
  }
});

// ../node_modules/memoizerific/memoizerific.js
var require_memoizerific = __commonJS({
  "../node_modules/memoizerific/memoizerific.js"(exports, module2) {
    (function(f4) {
      if (typeof exports == "object" && typeof module2 < "u")
        module2.exports = f4();
      else if (typeof define == "function" && define.amd)
        define([], f4);
      else {
        var g2;
        typeof window < "u" ? g2 = window : typeof global < "u" ? g2 = global : typeof self < "u" ? g2 = self : g2 = this, g2.memoizerific = f4();
      }
    })(function() {
      var define2, module3, exports2;
      return (function e2(t2, n2, r2) {
        function s3(o3, u3) {
          if (!n2[o3]) {
            if (!t2[o3]) {
              var a2 = typeof __require == "function" && __require;
              if (!u3 && a2) return a2(o3, !0);
              if (i2) return i2(o3, !0);
              var f4 = new Error("Cannot find module '" + o3 + "'");
              throw f4.code = "MODULE_NOT_FOUND", f4;
            }
            var l2 = n2[o3] = { exports: {} };
            t2[o3][0].call(l2.exports, function(e3) {
              var n3 = t2[o3][1][e3];
              return s3(n3 || e3);
            }, l2, l2.exports, e2, t2, n2, r2);
          }
          return n2[o3].exports;
        }
        for (var i2 = typeof __require == "function" && __require, o2 = 0; o2 < r2.length; o2++) s3(r2[o2]);
        return s3;
      })({ 1: [function(_dereq_, module4, exports3) {
        module4.exports = function(forceSimilar) {
          if (typeof Map != "function" || forceSimilar) {
            var Similar = _dereq_("./similar");
            return new Similar();
          } else
            return /* @__PURE__ */ new Map();
        };
      }, { "./similar": 2 }], 2: [function(_dereq_, module4, exports3) {
        function Similar() {
          return this.list = [], this.lastItem = void 0, this.size = 0, this;
        }
        Similar.prototype.get = function(key) {
          var index2;
          if (this.lastItem && this.isEqual(this.lastItem.key, key))
            return this.lastItem.val;
          if (index2 = this.indexOf(key), index2 >= 0)
            return this.lastItem = this.list[index2], this.list[index2].val;
        }, Similar.prototype.set = function(key, val) {
          var index2;
          return this.lastItem && this.isEqual(this.lastItem.key, key) ? (this.lastItem.val = val, this) : (index2 = this.indexOf(key), index2 >= 0 ? (this.lastItem = this.list[index2], this.list[index2].val = val, this) : (this.lastItem = { key, val }, this.list.push(this.lastItem), this.size++, this));
        }, Similar.prototype.delete = function(key) {
          var index2;
          if (this.lastItem && this.isEqual(this.lastItem.key, key) && (this.lastItem = void 0), index2 = this.indexOf(key), index2 >= 0)
            return this.size--, this.list.splice(index2, 1)[0];
        }, Similar.prototype.has = function(key) {
          var index2;
          return this.lastItem && this.isEqual(this.lastItem.key, key) ? !0 : (index2 = this.indexOf(key), index2 >= 0 ? (this.lastItem = this.list[index2], !0) : !1);
        }, Similar.prototype.forEach = function(callback, thisArg) {
          var i2;
          for (i2 = 0; i2 < this.size; i2++)
            callback.call(thisArg || this, this.list[i2].val, this.list[i2].key, this);
        }, Similar.prototype.indexOf = function(key) {
          var i2;
          for (i2 = 0; i2 < this.size; i2++)
            if (this.isEqual(this.list[i2].key, key))
              return i2;
          return -1;
        }, Similar.prototype.isEqual = function(val1, val2) {
          return val1 === val2 || val1 !== val1 && val2 !== val2;
        }, module4.exports = Similar;
      }, {}], 3: [function(_dereq_, module4, exports3) {
        var MapOrSimilar = _dereq_("map-or-similar");
        module4.exports = function(limit) {
          var cache = new MapOrSimilar(!1), lru = [];
          return function(fn3) {
            var memoizerific = function() {
              var currentCache = cache, newMap, fnResult, argsLengthMinusOne = arguments.length - 1, lruPath = Array(argsLengthMinusOne + 1), isMemoized = !0, i2;
              if ((memoizerific.numArgs || memoizerific.numArgs === 0) && memoizerific.numArgs !== argsLengthMinusOne + 1)
                throw new Error("Memoizerific functions should always be called with the same number of arguments");
              for (i2 = 0; i2 < argsLengthMinusOne; i2++) {
                if (lruPath[i2] = {
                  cacheItem: currentCache,
                  arg: arguments[i2]
                }, currentCache.has(arguments[i2])) {
                  currentCache = currentCache.get(arguments[i2]);
                  continue;
                }
                isMemoized = !1, newMap = new MapOrSimilar(!1), currentCache.set(arguments[i2], newMap), currentCache = newMap;
              }
              return isMemoized && (currentCache.has(arguments[argsLengthMinusOne]) ? fnResult = currentCache.get(arguments[argsLengthMinusOne]) : isMemoized = !1), isMemoized || (fnResult = fn3.apply(null, arguments), currentCache.set(arguments[argsLengthMinusOne], fnResult)), limit > 0 && (lruPath[argsLengthMinusOne] = {
                cacheItem: currentCache,
                arg: arguments[argsLengthMinusOne]
              }, isMemoized ? moveToMostRecentLru(lru, lruPath) : lru.push(lruPath), lru.length > limit && removeCachedResult(lru.shift())), memoizerific.wasMemoized = isMemoized, memoizerific.numArgs = argsLengthMinusOne + 1, fnResult;
            };
            return memoizerific.limit = limit, memoizerific.wasMemoized = !1, memoizerific.cache = cache, memoizerific.lru = lru, memoizerific;
          };
        };
        function moveToMostRecentLru(lru, lruPath) {
          var lruLen = lru.length, lruPathLen = lruPath.length, isMatch, i2, ii;
          for (i2 = 0; i2 < lruLen; i2++) {
            for (isMatch = !0, ii = 0; ii < lruPathLen; ii++)
              if (!isEqual3(lru[i2][ii].arg, lruPath[ii].arg)) {
                isMatch = !1;
                break;
              }
            if (isMatch)
              break;
          }
          lru.push(lru.splice(i2, 1)[0]);
        }
        function removeCachedResult(removedLru) {
          var removedLruLen = removedLru.length, currentLru = removedLru[removedLruLen - 1], tmp, i2;
          for (currentLru.cacheItem.delete(currentLru.arg), i2 = removedLruLen - 2; i2 >= 0 && (currentLru = removedLru[i2], tmp = currentLru.cacheItem.get(currentLru.arg), !tmp || !tmp.size); i2--)
            currentLru.cacheItem.delete(currentLru.arg);
        }
        function isEqual3(val1, val2) {
          return val1 === val2 || val1 !== val1 && val2 !== val2;
        }
      }, { "map-or-similar": 1 }] }, {}, [3])(3);
    });
  }
});

// ../node_modules/picoquery/lib/string-util.js
var require_string_util = __commonJS({
  "../node_modules/picoquery/lib/string-util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.encodeString = encodeString;
    var hexTable = Array.from({ length: 256 }, (_, i2) => "%" + ((i2 < 16 ? "0" : "") + i2.toString(16)).toUpperCase()), noEscape = new Int8Array([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      0
    ]);
    function encodeString(str2) {
      let len = str2.length;
      if (len === 0)
        return "";
      let out = "", lastPos = 0, i2 = 0;
      outer: for (; i2 < len; i2++) {
        let c2 = str2.charCodeAt(i2);
        for (; c2 < 128; ) {
          if (noEscape[c2] !== 1 && (lastPos < i2 && (out += str2.slice(lastPos, i2)), lastPos = i2 + 1, out += hexTable[c2]), ++i2 === len)
            break outer;
          c2 = str2.charCodeAt(i2);
        }
        if (lastPos < i2 && (out += str2.slice(lastPos, i2)), c2 < 2048) {
          lastPos = i2 + 1, out += hexTable[192 | c2 >> 6] + hexTable[128 | c2 & 63];
          continue;
        }
        if (c2 < 55296 || c2 >= 57344) {
          lastPos = i2 + 1, out += hexTable[224 | c2 >> 12] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63];
          continue;
        }
        if (++i2, i2 >= len)
          throw new Error("URI malformed");
        let c22 = str2.charCodeAt(i2) & 1023;
        lastPos = i2 + 1, c2 = 65536 + ((c2 & 1023) << 10 | c22), out += hexTable[240 | c2 >> 18] + hexTable[128 | c2 >> 12 & 63] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63];
      }
      return lastPos === 0 ? str2 : lastPos < len ? out + str2.slice(lastPos) : out;
    }
  }
});

// ../node_modules/picoquery/lib/shared.js
var require_shared = __commonJS({
  "../node_modules/picoquery/lib/shared.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.defaultOptions = exports.defaultShouldSerializeObject = exports.defaultValueSerializer = void 0;
    var string_util_js_1 = require_string_util(), defaultValueSerializer = (value) => {
      switch (typeof value) {
        case "string":
          return (0, string_util_js_1.encodeString)(value);
        case "bigint":
        case "boolean":
          return "" + value;
        case "number":
          if (Number.isFinite(value))
            return value < 1e21 ? "" + value : (0, string_util_js_1.encodeString)("" + value);
          break;
      }
      return value instanceof Date ? (0, string_util_js_1.encodeString)(value.toISOString()) : "";
    };
    exports.defaultValueSerializer = defaultValueSerializer;
    var defaultShouldSerializeObject = (val) => val instanceof Date;
    exports.defaultShouldSerializeObject = defaultShouldSerializeObject;
    var identityFunc = (v2) => v2;
    exports.defaultOptions = {
      nesting: !0,
      nestingSyntax: "dot",
      arrayRepeat: !1,
      arrayRepeatSyntax: "repeat",
      delimiter: 38,
      valueDeserializer: identityFunc,
      valueSerializer: exports.defaultValueSerializer,
      keyDeserializer: identityFunc,
      shouldSerializeObject: exports.defaultShouldSerializeObject
    };
  }
});

// ../node_modules/picoquery/lib/object-util.js
var require_object_util = __commonJS({
  "../node_modules/picoquery/lib/object-util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.getDeepObject = getDeepObject;
    exports.stringifyObject = stringifyObject;
    var shared_js_1 = require_shared(), string_util_js_1 = require_string_util();
    function isPrototypeKey(value) {
      return value === "__proto__" || value === "constructor" || value === "prototype";
    }
    function getDeepObject(obj, key, nextKey, forceObject, forceArray) {
      if (isPrototypeKey(key))
        return obj;
      let currObj = obj[key];
      return typeof currObj == "object" && currObj !== null ? currObj : !forceObject && (forceArray || typeof nextKey == "number" || typeof nextKey == "string" && nextKey * 0 === 0 && nextKey.indexOf(".") === -1) ? obj[key] = [] : obj[key] = {};
    }
    var MAX_DEPTH = 20, strBracketPair = "[]", strBracketLeft = "[", strBracketRight = "]", strDot = ".";
    function stringifyObject(obj, options, depth = 0, parentKey, isProbableArray) {
      let { nestingSyntax = shared_js_1.defaultOptions.nestingSyntax, arrayRepeat = shared_js_1.defaultOptions.arrayRepeat, arrayRepeatSyntax = shared_js_1.defaultOptions.arrayRepeatSyntax, nesting = shared_js_1.defaultOptions.nesting, delimiter = shared_js_1.defaultOptions.delimiter, valueSerializer = shared_js_1.defaultOptions.valueSerializer, shouldSerializeObject = shared_js_1.defaultOptions.shouldSerializeObject } = options, strDelimiter = typeof delimiter == "number" ? String.fromCharCode(delimiter) : delimiter, useArrayRepeatKey = isProbableArray === !0 && arrayRepeat, shouldUseDot = nestingSyntax === "dot" || nestingSyntax === "js" && !isProbableArray;
      if (depth > MAX_DEPTH)
        return "";
      let result = "", firstKey = !0, valueIsProbableArray = !1;
      for (let key in obj) {
        let value = obj[key];
        if (value === void 0)
          continue;
        let path;
        parentKey ? (path = parentKey, useArrayRepeatKey ? arrayRepeatSyntax === "bracket" && (path += strBracketPair) : shouldUseDot ? (path += strDot, path += key) : (path += strBracketLeft, path += key, path += strBracketRight)) : path = key, firstKey || (result += strDelimiter), typeof value == "object" && value !== null && !shouldSerializeObject(value) ? (valueIsProbableArray = value.pop !== void 0, (nesting || arrayRepeat && valueIsProbableArray) && (result += stringifyObject(value, options, depth + 1, path, valueIsProbableArray))) : (result += (0, string_util_js_1.encodeString)(path), result += "=", result += valueSerializer(value, key)), firstKey && (firstKey = !1);
      }
      return result;
    }
  }
});

// ../node_modules/picoquery/lib/decode-uri-component.js
var require_decode_uri_component = __commonJS({
  "../node_modules/picoquery/lib/decode-uri-component.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.decodeURIComponent = decodeURIComponent2;
    var UTF8_ACCEPT = 12, UTF8_REJECT = 0, UTF8_DATA = [
      // The first part of the table maps bytes to character to a transition.
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      4,
      4,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      6,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      8,
      7,
      7,
      10,
      9,
      9,
      9,
      11,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      // The second part of the table maps a state to a new state when adding a
      // transition.
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      12,
      0,
      0,
      0,
      0,
      24,
      36,
      48,
      60,
      72,
      84,
      96,
      0,
      12,
      12,
      12,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      24,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      24,
      24,
      24,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      24,
      24,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      48,
      48,
      48,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      48,
      48,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      48,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // The third part maps the current transition to a mask that needs to apply
      // to the byte.
      127,
      63,
      63,
      63,
      0,
      31,
      15,
      15,
      15,
      7,
      7,
      7
    ];
    function decodeURIComponent2(uri) {
      let percentPosition = uri.indexOf("%");
      if (percentPosition === -1)
        return uri;
      let length = uri.length, decoded = "", last = 0, codepoint = 0, startOfOctets = percentPosition, state3 = UTF8_ACCEPT;
      for (; percentPosition > -1 && percentPosition < length; ) {
        let high = hexCodeToInt(uri[percentPosition + 1], 4), low = hexCodeToInt(uri[percentPosition + 2], 0), byte = high | low, type5 = UTF8_DATA[byte];
        if (state3 = UTF8_DATA[256 + state3 + type5], codepoint = codepoint << 6 | byte & UTF8_DATA[364 + type5], state3 === UTF8_ACCEPT)
          decoded += uri.slice(last, startOfOctets), decoded += codepoint <= 65535 ? String.fromCharCode(codepoint) : String.fromCharCode(55232 + (codepoint >> 10), 56320 + (codepoint & 1023)), codepoint = 0, last = percentPosition + 3, percentPosition = startOfOctets = uri.indexOf("%", last);
        else {
          if (state3 === UTF8_REJECT)
            return null;
          if (percentPosition += 3, percentPosition < length && uri.charCodeAt(percentPosition) === 37)
            continue;
          return null;
        }
      }
      return decoded + uri.slice(last);
    }
    var HEX = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
      a: 10,
      A: 10,
      b: 11,
      B: 11,
      c: 12,
      C: 12,
      d: 13,
      D: 13,
      e: 14,
      E: 14,
      f: 15,
      F: 15
    };
    function hexCodeToInt(c2, shift) {
      let i2 = HEX[c2];
      return i2 === void 0 ? 255 : i2 << shift;
    }
  }
});

// ../node_modules/picoquery/lib/parse.js
var require_parse = __commonJS({
  "../node_modules/picoquery/lib/parse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.numberValueDeserializer = exports.numberKeyDeserializer = void 0;
    exports.parse = parse6;
    var object_util_js_1 = require_object_util(), shared_js_1 = require_shared(), decode_uri_component_js_1 = require_decode_uri_component(), numberKeyDeserializer = (key) => {
      let asNumber = Number(key);
      return Number.isNaN(asNumber) ? key : asNumber;
    };
    exports.numberKeyDeserializer = numberKeyDeserializer;
    var numberValueDeserializer = (value) => {
      let asNumber = Number(value);
      return Number.isNaN(asNumber) ? value : asNumber;
    };
    exports.numberValueDeserializer = numberValueDeserializer;
    var regexPlus = /\+/g, Empty = function() {
    };
    Empty.prototype = /* @__PURE__ */ Object.create(null);
    function computeKeySlice(input2, startIndex, endIndex, keyHasPlus, shouldDecodeKey) {
      let chunk = input2.substring(startIndex, endIndex);
      return keyHasPlus && (chunk = chunk.replace(regexPlus, " ")), shouldDecodeKey && (chunk = (0, decode_uri_component_js_1.decodeURIComponent)(chunk) || chunk), chunk;
    }
    function parse6(input2, options) {
      let { valueDeserializer = shared_js_1.defaultOptions.valueDeserializer, keyDeserializer = shared_js_1.defaultOptions.keyDeserializer, arrayRepeatSyntax = shared_js_1.defaultOptions.arrayRepeatSyntax, nesting = shared_js_1.defaultOptions.nesting, arrayRepeat = shared_js_1.defaultOptions.arrayRepeat, nestingSyntax = shared_js_1.defaultOptions.nestingSyntax, delimiter = shared_js_1.defaultOptions.delimiter } = options ?? {}, charDelimiter = typeof delimiter == "string" ? delimiter.charCodeAt(0) : delimiter, isJsNestingSyntax = nestingSyntax === "js", result = new Empty();
      if (typeof input2 != "string")
        return result;
      let inputLength = input2.length, value = "", startingIndex = -1, equalityIndex = -1, keySeparatorIndex = -1, currentObj = result, lastKey, currentKey = "", keyChunk = "", shouldDecodeKey = !1, shouldDecodeValue = !1, keyHasPlus = !1, valueHasPlus = !1, keyIsDot = !1, hasBothKeyValuePair = !1, c2 = 0, arrayRepeatBracketIndex = -1, prevIndex = -1, prevChar = -1;
      for (let i2 = 0; i2 < inputLength + 1; i2++) {
        if (c2 = i2 !== inputLength ? input2.charCodeAt(i2) : charDelimiter, c2 === charDelimiter) {
          if (hasBothKeyValuePair = equalityIndex > startingIndex, hasBothKeyValuePair || (equalityIndex = i2), keySeparatorIndex !== equalityIndex - 1 && (keyChunk = computeKeySlice(input2, keySeparatorIndex + 1, arrayRepeatBracketIndex > -1 ? arrayRepeatBracketIndex : equalityIndex, keyHasPlus, shouldDecodeKey), currentKey = keyDeserializer(keyChunk), lastKey !== void 0 && (currentObj = (0, object_util_js_1.getDeepObject)(currentObj, lastKey, currentKey, isJsNestingSyntax && keyIsDot, void 0))), hasBothKeyValuePair || currentKey !== "") {
            hasBothKeyValuePair && (value = input2.slice(equalityIndex + 1, i2), valueHasPlus && (value = value.replace(regexPlus, " ")), shouldDecodeValue && (value = (0, decode_uri_component_js_1.decodeURIComponent)(value) || value));
            let newValue = valueDeserializer(value, currentKey);
            if (arrayRepeat) {
              let currentValue = currentObj[currentKey];
              currentValue === void 0 ? arrayRepeatBracketIndex > -1 ? currentObj[currentKey] = [newValue] : currentObj[currentKey] = newValue : currentValue.pop ? currentValue.push(newValue) : currentObj[currentKey] = [currentValue, newValue];
            } else
              currentObj[currentKey] = newValue;
          }
          value = "", startingIndex = i2, equalityIndex = i2, shouldDecodeKey = !1, shouldDecodeValue = !1, keyHasPlus = !1, valueHasPlus = !1, keyIsDot = !1, arrayRepeatBracketIndex = -1, keySeparatorIndex = i2, currentObj = result, lastKey = void 0, currentKey = "";
        } else c2 === 93 ? (arrayRepeat && arrayRepeatSyntax === "bracket" && prevChar === 91 && (arrayRepeatBracketIndex = prevIndex), nesting && (nestingSyntax === "index" || isJsNestingSyntax) && equalityIndex <= startingIndex && (keySeparatorIndex !== prevIndex && (keyChunk = computeKeySlice(input2, keySeparatorIndex + 1, i2, keyHasPlus, shouldDecodeKey), currentKey = keyDeserializer(keyChunk), lastKey !== void 0 && (currentObj = (0, object_util_js_1.getDeepObject)(currentObj, lastKey, currentKey, void 0, void 0)), lastKey = currentKey, keyHasPlus = !1, shouldDecodeKey = !1), keySeparatorIndex = i2, keyIsDot = !1)) : c2 === 46 ? nesting && (nestingSyntax === "dot" || isJsNestingSyntax) && equalityIndex <= startingIndex && (keySeparatorIndex !== prevIndex && (keyChunk = computeKeySlice(input2, keySeparatorIndex + 1, i2, keyHasPlus, shouldDecodeKey), currentKey = keyDeserializer(keyChunk), lastKey !== void 0 && (currentObj = (0, object_util_js_1.getDeepObject)(currentObj, lastKey, currentKey, isJsNestingSyntax)), lastKey = currentKey, keyHasPlus = !1, shouldDecodeKey = !1), keyIsDot = !0, keySeparatorIndex = i2) : c2 === 91 ? nesting && (nestingSyntax === "index" || isJsNestingSyntax) && equalityIndex <= startingIndex && (keySeparatorIndex !== prevIndex && (keyChunk = computeKeySlice(input2, keySeparatorIndex + 1, i2, keyHasPlus, shouldDecodeKey), currentKey = keyDeserializer(keyChunk), isJsNestingSyntax && lastKey !== void 0 && (currentObj = (0, object_util_js_1.getDeepObject)(currentObj, lastKey, currentKey, isJsNestingSyntax)), lastKey = currentKey, keyHasPlus = !1, shouldDecodeKey = !1, keyIsDot = !1), keySeparatorIndex = i2) : c2 === 61 ? equalityIndex <= startingIndex ? equalityIndex = i2 : shouldDecodeValue = !0 : c2 === 43 ? equalityIndex > startingIndex ? valueHasPlus = !0 : keyHasPlus = !0 : c2 === 37 && (equalityIndex > startingIndex ? shouldDecodeValue = !0 : shouldDecodeKey = !0);
        prevIndex = i2, prevChar = c2;
      }
      return result;
    }
  }
});

// ../node_modules/picoquery/lib/stringify.js
var require_stringify = __commonJS({
  "../node_modules/picoquery/lib/stringify.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.stringify = stringify5;
    var object_util_js_1 = require_object_util();
    function stringify5(input2, options) {
      if (input2 === null || typeof input2 != "object")
        return "";
      let optionsObj = options ?? {};
      return (0, object_util_js_1.stringifyObject)(input2, optionsObj);
    }
  }
});

// ../node_modules/picoquery/lib/main.js
var require_main = __commonJS({
  "../node_modules/picoquery/lib/main.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o2, m3, k2, k22) {
      k22 === void 0 && (k22 = k2);
      var desc = Object.getOwnPropertyDescriptor(m3, k2);
      (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) && (desc = { enumerable: !0, get: function() {
        return m3[k2];
      } }), Object.defineProperty(o2, k22, desc);
    }) : (function(o2, m3, k2, k22) {
      k22 === void 0 && (k22 = k2), o2[k22] = m3[k2];
    })), __exportStar = exports && exports.__exportStar || function(m3, exports2) {
      for (var p2 in m3) p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2) && __createBinding(exports2, m3, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.stringify = exports.parse = void 0;
    var parse_js_1 = require_parse();
    Object.defineProperty(exports, "parse", { enumerable: !0, get: function() {
      return parse_js_1.parse;
    } });
    var stringify_js_1 = require_stringify();
    Object.defineProperty(exports, "stringify", { enumerable: !0, get: function() {
      return stringify_js_1.stringify;
    } });
    __exportStar(require_shared(), exports);
  }
});

// ../node_modules/entities/lib/maps/entities.json
var require_entities = __commonJS({
  "../node_modules/entities/lib/maps/entities.json"(exports, module2) {
    module2.exports = { Aacute: "\xC1", aacute: "\xE1", Abreve: "\u0102", abreve: "\u0103", ac: "\u223E", acd: "\u223F", acE: "\u223E\u0333", Acirc: "\xC2", acirc: "\xE2", acute: "\xB4", Acy: "\u0410", acy: "\u0430", AElig: "\xC6", aelig: "\xE6", af: "\u2061", Afr: "\u{1D504}", afr: "\u{1D51E}", Agrave: "\xC0", agrave: "\xE0", alefsym: "\u2135", aleph: "\u2135", Alpha: "\u0391", alpha: "\u03B1", Amacr: "\u0100", amacr: "\u0101", amalg: "\u2A3F", amp: "&", AMP: "&", andand: "\u2A55", And: "\u2A53", and: "\u2227", andd: "\u2A5C", andslope: "\u2A58", andv: "\u2A5A", ang: "\u2220", ange: "\u29A4", angle: "\u2220", angmsdaa: "\u29A8", angmsdab: "\u29A9", angmsdac: "\u29AA", angmsdad: "\u29AB", angmsdae: "\u29AC", angmsdaf: "\u29AD", angmsdag: "\u29AE", angmsdah: "\u29AF", angmsd: "\u2221", angrt: "\u221F", angrtvb: "\u22BE", angrtvbd: "\u299D", angsph: "\u2222", angst: "\xC5", angzarr: "\u237C", Aogon: "\u0104", aogon: "\u0105", Aopf: "\u{1D538}", aopf: "\u{1D552}", apacir: "\u2A6F", ap: "\u2248", apE: "\u2A70", ape: "\u224A", apid: "\u224B", apos: "'", ApplyFunction: "\u2061", approx: "\u2248", approxeq: "\u224A", Aring: "\xC5", aring: "\xE5", Ascr: "\u{1D49C}", ascr: "\u{1D4B6}", Assign: "\u2254", ast: "*", asymp: "\u2248", asympeq: "\u224D", Atilde: "\xC3", atilde: "\xE3", Auml: "\xC4", auml: "\xE4", awconint: "\u2233", awint: "\u2A11", backcong: "\u224C", backepsilon: "\u03F6", backprime: "\u2035", backsim: "\u223D", backsimeq: "\u22CD", Backslash: "\u2216", Barv: "\u2AE7", barvee: "\u22BD", barwed: "\u2305", Barwed: "\u2306", barwedge: "\u2305", bbrk: "\u23B5", bbrktbrk: "\u23B6", bcong: "\u224C", Bcy: "\u0411", bcy: "\u0431", bdquo: "\u201E", becaus: "\u2235", because: "\u2235", Because: "\u2235", bemptyv: "\u29B0", bepsi: "\u03F6", bernou: "\u212C", Bernoullis: "\u212C", Beta: "\u0392", beta: "\u03B2", beth: "\u2136", between: "\u226C", Bfr: "\u{1D505}", bfr: "\u{1D51F}", bigcap: "\u22C2", bigcirc: "\u25EF", bigcup: "\u22C3", bigodot: "\u2A00", bigoplus: "\u2A01", bigotimes: "\u2A02", bigsqcup: "\u2A06", bigstar: "\u2605", bigtriangledown: "\u25BD", bigtriangleup: "\u25B3", biguplus: "\u2A04", bigvee: "\u22C1", bigwedge: "\u22C0", bkarow: "\u290D", blacklozenge: "\u29EB", blacksquare: "\u25AA", blacktriangle: "\u25B4", blacktriangledown: "\u25BE", blacktriangleleft: "\u25C2", blacktriangleright: "\u25B8", blank: "\u2423", blk12: "\u2592", blk14: "\u2591", blk34: "\u2593", block: "\u2588", bne: "=\u20E5", bnequiv: "\u2261\u20E5", bNot: "\u2AED", bnot: "\u2310", Bopf: "\u{1D539}", bopf: "\u{1D553}", bot: "\u22A5", bottom: "\u22A5", bowtie: "\u22C8", boxbox: "\u29C9", boxdl: "\u2510", boxdL: "\u2555", boxDl: "\u2556", boxDL: "\u2557", boxdr: "\u250C", boxdR: "\u2552", boxDr: "\u2553", boxDR: "\u2554", boxh: "\u2500", boxH: "\u2550", boxhd: "\u252C", boxHd: "\u2564", boxhD: "\u2565", boxHD: "\u2566", boxhu: "\u2534", boxHu: "\u2567", boxhU: "\u2568", boxHU: "\u2569", boxminus: "\u229F", boxplus: "\u229E", boxtimes: "\u22A0", boxul: "\u2518", boxuL: "\u255B", boxUl: "\u255C", boxUL: "\u255D", boxur: "\u2514", boxuR: "\u2558", boxUr: "\u2559", boxUR: "\u255A", boxv: "\u2502", boxV: "\u2551", boxvh: "\u253C", boxvH: "\u256A", boxVh: "\u256B", boxVH: "\u256C", boxvl: "\u2524", boxvL: "\u2561", boxVl: "\u2562", boxVL: "\u2563", boxvr: "\u251C", boxvR: "\u255E", boxVr: "\u255F", boxVR: "\u2560", bprime: "\u2035", breve: "\u02D8", Breve: "\u02D8", brvbar: "\xA6", bscr: "\u{1D4B7}", Bscr: "\u212C", bsemi: "\u204F", bsim: "\u223D", bsime: "\u22CD", bsolb: "\u29C5", bsol: "\\", bsolhsub: "\u27C8", bull: "\u2022", bullet: "\u2022", bump: "\u224E", bumpE: "\u2AAE", bumpe: "\u224F", Bumpeq: "\u224E", bumpeq: "\u224F", Cacute: "\u0106", cacute: "\u0107", capand: "\u2A44", capbrcup: "\u2A49", capcap: "\u2A4B", cap: "\u2229", Cap: "\u22D2", capcup: "\u2A47", capdot: "\u2A40", CapitalDifferentialD: "\u2145", caps: "\u2229\uFE00", caret: "\u2041", caron: "\u02C7", Cayleys: "\u212D", ccaps: "\u2A4D", Ccaron: "\u010C", ccaron: "\u010D", Ccedil: "\xC7", ccedil: "\xE7", Ccirc: "\u0108", ccirc: "\u0109", Cconint: "\u2230", ccups: "\u2A4C", ccupssm: "\u2A50", Cdot: "\u010A", cdot: "\u010B", cedil: "\xB8", Cedilla: "\xB8", cemptyv: "\u29B2", cent: "\xA2", centerdot: "\xB7", CenterDot: "\xB7", cfr: "\u{1D520}", Cfr: "\u212D", CHcy: "\u0427", chcy: "\u0447", check: "\u2713", checkmark: "\u2713", Chi: "\u03A7", chi: "\u03C7", circ: "\u02C6", circeq: "\u2257", circlearrowleft: "\u21BA", circlearrowright: "\u21BB", circledast: "\u229B", circledcirc: "\u229A", circleddash: "\u229D", CircleDot: "\u2299", circledR: "\xAE", circledS: "\u24C8", CircleMinus: "\u2296", CirclePlus: "\u2295", CircleTimes: "\u2297", cir: "\u25CB", cirE: "\u29C3", cire: "\u2257", cirfnint: "\u2A10", cirmid: "\u2AEF", cirscir: "\u29C2", ClockwiseContourIntegral: "\u2232", CloseCurlyDoubleQuote: "\u201D", CloseCurlyQuote: "\u2019", clubs: "\u2663", clubsuit: "\u2663", colon: ":", Colon: "\u2237", Colone: "\u2A74", colone: "\u2254", coloneq: "\u2254", comma: ",", commat: "@", comp: "\u2201", compfn: "\u2218", complement: "\u2201", complexes: "\u2102", cong: "\u2245", congdot: "\u2A6D", Congruent: "\u2261", conint: "\u222E", Conint: "\u222F", ContourIntegral: "\u222E", copf: "\u{1D554}", Copf: "\u2102", coprod: "\u2210", Coproduct: "\u2210", copy: "\xA9", COPY: "\xA9", copysr: "\u2117", CounterClockwiseContourIntegral: "\u2233", crarr: "\u21B5", cross: "\u2717", Cross: "\u2A2F", Cscr: "\u{1D49E}", cscr: "\u{1D4B8}", csub: "\u2ACF", csube: "\u2AD1", csup: "\u2AD0", csupe: "\u2AD2", ctdot: "\u22EF", cudarrl: "\u2938", cudarrr: "\u2935", cuepr: "\u22DE", cuesc: "\u22DF", cularr: "\u21B6", cularrp: "\u293D", cupbrcap: "\u2A48", cupcap: "\u2A46", CupCap: "\u224D", cup: "\u222A", Cup: "\u22D3", cupcup: "\u2A4A", cupdot: "\u228D", cupor: "\u2A45", cups: "\u222A\uFE00", curarr: "\u21B7", curarrm: "\u293C", curlyeqprec: "\u22DE", curlyeqsucc: "\u22DF", curlyvee: "\u22CE", curlywedge: "\u22CF", curren: "\xA4", curvearrowleft: "\u21B6", curvearrowright: "\u21B7", cuvee: "\u22CE", cuwed: "\u22CF", cwconint: "\u2232", cwint: "\u2231", cylcty: "\u232D", dagger: "\u2020", Dagger: "\u2021", daleth: "\u2138", darr: "\u2193", Darr: "\u21A1", dArr: "\u21D3", dash: "\u2010", Dashv: "\u2AE4", dashv: "\u22A3", dbkarow: "\u290F", dblac: "\u02DD", Dcaron: "\u010E", dcaron: "\u010F", Dcy: "\u0414", dcy: "\u0434", ddagger: "\u2021", ddarr: "\u21CA", DD: "\u2145", dd: "\u2146", DDotrahd: "\u2911", ddotseq: "\u2A77", deg: "\xB0", Del: "\u2207", Delta: "\u0394", delta: "\u03B4", demptyv: "\u29B1", dfisht: "\u297F", Dfr: "\u{1D507}", dfr: "\u{1D521}", dHar: "\u2965", dharl: "\u21C3", dharr: "\u21C2", DiacriticalAcute: "\xB4", DiacriticalDot: "\u02D9", DiacriticalDoubleAcute: "\u02DD", DiacriticalGrave: "`", DiacriticalTilde: "\u02DC", diam: "\u22C4", diamond: "\u22C4", Diamond: "\u22C4", diamondsuit: "\u2666", diams: "\u2666", die: "\xA8", DifferentialD: "\u2146", digamma: "\u03DD", disin: "\u22F2", div: "\xF7", divide: "\xF7", divideontimes: "\u22C7", divonx: "\u22C7", DJcy: "\u0402", djcy: "\u0452", dlcorn: "\u231E", dlcrop: "\u230D", dollar: "$", Dopf: "\u{1D53B}", dopf: "\u{1D555}", Dot: "\xA8", dot: "\u02D9", DotDot: "\u20DC", doteq: "\u2250", doteqdot: "\u2251", DotEqual: "\u2250", dotminus: "\u2238", dotplus: "\u2214", dotsquare: "\u22A1", doublebarwedge: "\u2306", DoubleContourIntegral: "\u222F", DoubleDot: "\xA8", DoubleDownArrow: "\u21D3", DoubleLeftArrow: "\u21D0", DoubleLeftRightArrow: "\u21D4", DoubleLeftTee: "\u2AE4", DoubleLongLeftArrow: "\u27F8", DoubleLongLeftRightArrow: "\u27FA", DoubleLongRightArrow: "\u27F9", DoubleRightArrow: "\u21D2", DoubleRightTee: "\u22A8", DoubleUpArrow: "\u21D1", DoubleUpDownArrow: "\u21D5", DoubleVerticalBar: "\u2225", DownArrowBar: "\u2913", downarrow: "\u2193", DownArrow: "\u2193", Downarrow: "\u21D3", DownArrowUpArrow: "\u21F5", DownBreve: "\u0311", downdownarrows: "\u21CA", downharpoonleft: "\u21C3", downharpoonright: "\u21C2", DownLeftRightVector: "\u2950", DownLeftTeeVector: "\u295E", DownLeftVectorBar: "\u2956", DownLeftVector: "\u21BD", DownRightTeeVector: "\u295F", DownRightVectorBar: "\u2957", DownRightVector: "\u21C1", DownTeeArrow: "\u21A7", DownTee: "\u22A4", drbkarow: "\u2910", drcorn: "\u231F", drcrop: "\u230C", Dscr: "\u{1D49F}", dscr: "\u{1D4B9}", DScy: "\u0405", dscy: "\u0455", dsol: "\u29F6", Dstrok: "\u0110", dstrok: "\u0111", dtdot: "\u22F1", dtri: "\u25BF", dtrif: "\u25BE", duarr: "\u21F5", duhar: "\u296F", dwangle: "\u29A6", DZcy: "\u040F", dzcy: "\u045F", dzigrarr: "\u27FF", Eacute: "\xC9", eacute: "\xE9", easter: "\u2A6E", Ecaron: "\u011A", ecaron: "\u011B", Ecirc: "\xCA", ecirc: "\xEA", ecir: "\u2256", ecolon: "\u2255", Ecy: "\u042D", ecy: "\u044D", eDDot: "\u2A77", Edot: "\u0116", edot: "\u0117", eDot: "\u2251", ee: "\u2147", efDot: "\u2252", Efr: "\u{1D508}", efr: "\u{1D522}", eg: "\u2A9A", Egrave: "\xC8", egrave: "\xE8", egs: "\u2A96", egsdot: "\u2A98", el: "\u2A99", Element: "\u2208", elinters: "\u23E7", ell: "\u2113", els: "\u2A95", elsdot: "\u2A97", Emacr: "\u0112", emacr: "\u0113", empty: "\u2205", emptyset: "\u2205", EmptySmallSquare: "\u25FB", emptyv: "\u2205", EmptyVerySmallSquare: "\u25AB", emsp13: "\u2004", emsp14: "\u2005", emsp: "\u2003", ENG: "\u014A", eng: "\u014B", ensp: "\u2002", Eogon: "\u0118", eogon: "\u0119", Eopf: "\u{1D53C}", eopf: "\u{1D556}", epar: "\u22D5", eparsl: "\u29E3", eplus: "\u2A71", epsi: "\u03B5", Epsilon: "\u0395", epsilon: "\u03B5", epsiv: "\u03F5", eqcirc: "\u2256", eqcolon: "\u2255", eqsim: "\u2242", eqslantgtr: "\u2A96", eqslantless: "\u2A95", Equal: "\u2A75", equals: "=", EqualTilde: "\u2242", equest: "\u225F", Equilibrium: "\u21CC", equiv: "\u2261", equivDD: "\u2A78", eqvparsl: "\u29E5", erarr: "\u2971", erDot: "\u2253", escr: "\u212F", Escr: "\u2130", esdot: "\u2250", Esim: "\u2A73", esim: "\u2242", Eta: "\u0397", eta: "\u03B7", ETH: "\xD0", eth: "\xF0", Euml: "\xCB", euml: "\xEB", euro: "\u20AC", excl: "!", exist: "\u2203", Exists: "\u2203", expectation: "\u2130", exponentiale: "\u2147", ExponentialE: "\u2147", fallingdotseq: "\u2252", Fcy: "\u0424", fcy: "\u0444", female: "\u2640", ffilig: "\uFB03", fflig: "\uFB00", ffllig: "\uFB04", Ffr: "\u{1D509}", ffr: "\u{1D523}", filig: "\uFB01", FilledSmallSquare: "\u25FC", FilledVerySmallSquare: "\u25AA", fjlig: "fj", flat: "\u266D", fllig: "\uFB02", fltns: "\u25B1", fnof: "\u0192", Fopf: "\u{1D53D}", fopf: "\u{1D557}", forall: "\u2200", ForAll: "\u2200", fork: "\u22D4", forkv: "\u2AD9", Fouriertrf: "\u2131", fpartint: "\u2A0D", frac12: "\xBD", frac13: "\u2153", frac14: "\xBC", frac15: "\u2155", frac16: "\u2159", frac18: "\u215B", frac23: "\u2154", frac25: "\u2156", frac34: "\xBE", frac35: "\u2157", frac38: "\u215C", frac45: "\u2158", frac56: "\u215A", frac58: "\u215D", frac78: "\u215E", frasl: "\u2044", frown: "\u2322", fscr: "\u{1D4BB}", Fscr: "\u2131", gacute: "\u01F5", Gamma: "\u0393", gamma: "\u03B3", Gammad: "\u03DC", gammad: "\u03DD", gap: "\u2A86", Gbreve: "\u011E", gbreve: "\u011F", Gcedil: "\u0122", Gcirc: "\u011C", gcirc: "\u011D", Gcy: "\u0413", gcy: "\u0433", Gdot: "\u0120", gdot: "\u0121", ge: "\u2265", gE: "\u2267", gEl: "\u2A8C", gel: "\u22DB", geq: "\u2265", geqq: "\u2267", geqslant: "\u2A7E", gescc: "\u2AA9", ges: "\u2A7E", gesdot: "\u2A80", gesdoto: "\u2A82", gesdotol: "\u2A84", gesl: "\u22DB\uFE00", gesles: "\u2A94", Gfr: "\u{1D50A}", gfr: "\u{1D524}", gg: "\u226B", Gg: "\u22D9", ggg: "\u22D9", gimel: "\u2137", GJcy: "\u0403", gjcy: "\u0453", gla: "\u2AA5", gl: "\u2277", glE: "\u2A92", glj: "\u2AA4", gnap: "\u2A8A", gnapprox: "\u2A8A", gne: "\u2A88", gnE: "\u2269", gneq: "\u2A88", gneqq: "\u2269", gnsim: "\u22E7", Gopf: "\u{1D53E}", gopf: "\u{1D558}", grave: "`", GreaterEqual: "\u2265", GreaterEqualLess: "\u22DB", GreaterFullEqual: "\u2267", GreaterGreater: "\u2AA2", GreaterLess: "\u2277", GreaterSlantEqual: "\u2A7E", GreaterTilde: "\u2273", Gscr: "\u{1D4A2}", gscr: "\u210A", gsim: "\u2273", gsime: "\u2A8E", gsiml: "\u2A90", gtcc: "\u2AA7", gtcir: "\u2A7A", gt: ">", GT: ">", Gt: "\u226B", gtdot: "\u22D7", gtlPar: "\u2995", gtquest: "\u2A7C", gtrapprox: "\u2A86", gtrarr: "\u2978", gtrdot: "\u22D7", gtreqless: "\u22DB", gtreqqless: "\u2A8C", gtrless: "\u2277", gtrsim: "\u2273", gvertneqq: "\u2269\uFE00", gvnE: "\u2269\uFE00", Hacek: "\u02C7", hairsp: "\u200A", half: "\xBD", hamilt: "\u210B", HARDcy: "\u042A", hardcy: "\u044A", harrcir: "\u2948", harr: "\u2194", hArr: "\u21D4", harrw: "\u21AD", Hat: "^", hbar: "\u210F", Hcirc: "\u0124", hcirc: "\u0125", hearts: "\u2665", heartsuit: "\u2665", hellip: "\u2026", hercon: "\u22B9", hfr: "\u{1D525}", Hfr: "\u210C", HilbertSpace: "\u210B", hksearow: "\u2925", hkswarow: "\u2926", hoarr: "\u21FF", homtht: "\u223B", hookleftarrow: "\u21A9", hookrightarrow: "\u21AA", hopf: "\u{1D559}", Hopf: "\u210D", horbar: "\u2015", HorizontalLine: "\u2500", hscr: "\u{1D4BD}", Hscr: "\u210B", hslash: "\u210F", Hstrok: "\u0126", hstrok: "\u0127", HumpDownHump: "\u224E", HumpEqual: "\u224F", hybull: "\u2043", hyphen: "\u2010", Iacute: "\xCD", iacute: "\xED", ic: "\u2063", Icirc: "\xCE", icirc: "\xEE", Icy: "\u0418", icy: "\u0438", Idot: "\u0130", IEcy: "\u0415", iecy: "\u0435", iexcl: "\xA1", iff: "\u21D4", ifr: "\u{1D526}", Ifr: "\u2111", Igrave: "\xCC", igrave: "\xEC", ii: "\u2148", iiiint: "\u2A0C", iiint: "\u222D", iinfin: "\u29DC", iiota: "\u2129", IJlig: "\u0132", ijlig: "\u0133", Imacr: "\u012A", imacr: "\u012B", image: "\u2111", ImaginaryI: "\u2148", imagline: "\u2110", imagpart: "\u2111", imath: "\u0131", Im: "\u2111", imof: "\u22B7", imped: "\u01B5", Implies: "\u21D2", incare: "\u2105", in: "\u2208", infin: "\u221E", infintie: "\u29DD", inodot: "\u0131", intcal: "\u22BA", int: "\u222B", Int: "\u222C", integers: "\u2124", Integral: "\u222B", intercal: "\u22BA", Intersection: "\u22C2", intlarhk: "\u2A17", intprod: "\u2A3C", InvisibleComma: "\u2063", InvisibleTimes: "\u2062", IOcy: "\u0401", iocy: "\u0451", Iogon: "\u012E", iogon: "\u012F", Iopf: "\u{1D540}", iopf: "\u{1D55A}", Iota: "\u0399", iota: "\u03B9", iprod: "\u2A3C", iquest: "\xBF", iscr: "\u{1D4BE}", Iscr: "\u2110", isin: "\u2208", isindot: "\u22F5", isinE: "\u22F9", isins: "\u22F4", isinsv: "\u22F3", isinv: "\u2208", it: "\u2062", Itilde: "\u0128", itilde: "\u0129", Iukcy: "\u0406", iukcy: "\u0456", Iuml: "\xCF", iuml: "\xEF", Jcirc: "\u0134", jcirc: "\u0135", Jcy: "\u0419", jcy: "\u0439", Jfr: "\u{1D50D}", jfr: "\u{1D527}", jmath: "\u0237", Jopf: "\u{1D541}", jopf: "\u{1D55B}", Jscr: "\u{1D4A5}", jscr: "\u{1D4BF}", Jsercy: "\u0408", jsercy: "\u0458", Jukcy: "\u0404", jukcy: "\u0454", Kappa: "\u039A", kappa: "\u03BA", kappav: "\u03F0", Kcedil: "\u0136", kcedil: "\u0137", Kcy: "\u041A", kcy: "\u043A", Kfr: "\u{1D50E}", kfr: "\u{1D528}", kgreen: "\u0138", KHcy: "\u0425", khcy: "\u0445", KJcy: "\u040C", kjcy: "\u045C", Kopf: "\u{1D542}", kopf: "\u{1D55C}", Kscr: "\u{1D4A6}", kscr: "\u{1D4C0}", lAarr: "\u21DA", Lacute: "\u0139", lacute: "\u013A", laemptyv: "\u29B4", lagran: "\u2112", Lambda: "\u039B", lambda: "\u03BB", lang: "\u27E8", Lang: "\u27EA", langd: "\u2991", langle: "\u27E8", lap: "\u2A85", Laplacetrf: "\u2112", laquo: "\xAB", larrb: "\u21E4", larrbfs: "\u291F", larr: "\u2190", Larr: "\u219E", lArr: "\u21D0", larrfs: "\u291D", larrhk: "\u21A9", larrlp: "\u21AB", larrpl: "\u2939", larrsim: "\u2973", larrtl: "\u21A2", latail: "\u2919", lAtail: "\u291B", lat: "\u2AAB", late: "\u2AAD", lates: "\u2AAD\uFE00", lbarr: "\u290C", lBarr: "\u290E", lbbrk: "\u2772", lbrace: "{", lbrack: "[", lbrke: "\u298B", lbrksld: "\u298F", lbrkslu: "\u298D", Lcaron: "\u013D", lcaron: "\u013E", Lcedil: "\u013B", lcedil: "\u013C", lceil: "\u2308", lcub: "{", Lcy: "\u041B", lcy: "\u043B", ldca: "\u2936", ldquo: "\u201C", ldquor: "\u201E", ldrdhar: "\u2967", ldrushar: "\u294B", ldsh: "\u21B2", le: "\u2264", lE: "\u2266", LeftAngleBracket: "\u27E8", LeftArrowBar: "\u21E4", leftarrow: "\u2190", LeftArrow: "\u2190", Leftarrow: "\u21D0", LeftArrowRightArrow: "\u21C6", leftarrowtail: "\u21A2", LeftCeiling: "\u2308", LeftDoubleBracket: "\u27E6", LeftDownTeeVector: "\u2961", LeftDownVectorBar: "\u2959", LeftDownVector: "\u21C3", LeftFloor: "\u230A", leftharpoondown: "\u21BD", leftharpoonup: "\u21BC", leftleftarrows: "\u21C7", leftrightarrow: "\u2194", LeftRightArrow: "\u2194", Leftrightarrow: "\u21D4", leftrightarrows: "\u21C6", leftrightharpoons: "\u21CB", leftrightsquigarrow: "\u21AD", LeftRightVector: "\u294E", LeftTeeArrow: "\u21A4", LeftTee: "\u22A3", LeftTeeVector: "\u295A", leftthreetimes: "\u22CB", LeftTriangleBar: "\u29CF", LeftTriangle: "\u22B2", LeftTriangleEqual: "\u22B4", LeftUpDownVector: "\u2951", LeftUpTeeVector: "\u2960", LeftUpVectorBar: "\u2958", LeftUpVector: "\u21BF", LeftVectorBar: "\u2952", LeftVector: "\u21BC", lEg: "\u2A8B", leg: "\u22DA", leq: "\u2264", leqq: "\u2266", leqslant: "\u2A7D", lescc: "\u2AA8", les: "\u2A7D", lesdot: "\u2A7F", lesdoto: "\u2A81", lesdotor: "\u2A83", lesg: "\u22DA\uFE00", lesges: "\u2A93", lessapprox: "\u2A85", lessdot: "\u22D6", lesseqgtr: "\u22DA", lesseqqgtr: "\u2A8B", LessEqualGreater: "\u22DA", LessFullEqual: "\u2266", LessGreater: "\u2276", lessgtr: "\u2276", LessLess: "\u2AA1", lesssim: "\u2272", LessSlantEqual: "\u2A7D", LessTilde: "\u2272", lfisht: "\u297C", lfloor: "\u230A", Lfr: "\u{1D50F}", lfr: "\u{1D529}", lg: "\u2276", lgE: "\u2A91", lHar: "\u2962", lhard: "\u21BD", lharu: "\u21BC", lharul: "\u296A", lhblk: "\u2584", LJcy: "\u0409", ljcy: "\u0459", llarr: "\u21C7", ll: "\u226A", Ll: "\u22D8", llcorner: "\u231E", Lleftarrow: "\u21DA", llhard: "\u296B", lltri: "\u25FA", Lmidot: "\u013F", lmidot: "\u0140", lmoustache: "\u23B0", lmoust: "\u23B0", lnap: "\u2A89", lnapprox: "\u2A89", lne: "\u2A87", lnE: "\u2268", lneq: "\u2A87", lneqq: "\u2268", lnsim: "\u22E6", loang: "\u27EC", loarr: "\u21FD", lobrk: "\u27E6", longleftarrow: "\u27F5", LongLeftArrow: "\u27F5", Longleftarrow: "\u27F8", longleftrightarrow: "\u27F7", LongLeftRightArrow: "\u27F7", Longleftrightarrow: "\u27FA", longmapsto: "\u27FC", longrightarrow: "\u27F6", LongRightArrow: "\u27F6", Longrightarrow: "\u27F9", looparrowleft: "\u21AB", looparrowright: "\u21AC", lopar: "\u2985", Lopf: "\u{1D543}", lopf: "\u{1D55D}", loplus: "\u2A2D", lotimes: "\u2A34", lowast: "\u2217", lowbar: "_", LowerLeftArrow: "\u2199", LowerRightArrow: "\u2198", loz: "\u25CA", lozenge: "\u25CA", lozf: "\u29EB", lpar: "(", lparlt: "\u2993", lrarr: "\u21C6", lrcorner: "\u231F", lrhar: "\u21CB", lrhard: "\u296D", lrm: "\u200E", lrtri: "\u22BF", lsaquo: "\u2039", lscr: "\u{1D4C1}", Lscr: "\u2112", lsh: "\u21B0", Lsh: "\u21B0", lsim: "\u2272", lsime: "\u2A8D", lsimg: "\u2A8F", lsqb: "[", lsquo: "\u2018", lsquor: "\u201A", Lstrok: "\u0141", lstrok: "\u0142", ltcc: "\u2AA6", ltcir: "\u2A79", lt: "<", LT: "<", Lt: "\u226A", ltdot: "\u22D6", lthree: "\u22CB", ltimes: "\u22C9", ltlarr: "\u2976", ltquest: "\u2A7B", ltri: "\u25C3", ltrie: "\u22B4", ltrif: "\u25C2", ltrPar: "\u2996", lurdshar: "\u294A", luruhar: "\u2966", lvertneqq: "\u2268\uFE00", lvnE: "\u2268\uFE00", macr: "\xAF", male: "\u2642", malt: "\u2720", maltese: "\u2720", Map: "\u2905", map: "\u21A6", mapsto: "\u21A6", mapstodown: "\u21A7", mapstoleft: "\u21A4", mapstoup: "\u21A5", marker: "\u25AE", mcomma: "\u2A29", Mcy: "\u041C", mcy: "\u043C", mdash: "\u2014", mDDot: "\u223A", measuredangle: "\u2221", MediumSpace: "\u205F", Mellintrf: "\u2133", Mfr: "\u{1D510}", mfr: "\u{1D52A}", mho: "\u2127", micro: "\xB5", midast: "*", midcir: "\u2AF0", mid: "\u2223", middot: "\xB7", minusb: "\u229F", minus: "\u2212", minusd: "\u2238", minusdu: "\u2A2A", MinusPlus: "\u2213", mlcp: "\u2ADB", mldr: "\u2026", mnplus: "\u2213", models: "\u22A7", Mopf: "\u{1D544}", mopf: "\u{1D55E}", mp: "\u2213", mscr: "\u{1D4C2}", Mscr: "\u2133", mstpos: "\u223E", Mu: "\u039C", mu: "\u03BC", multimap: "\u22B8", mumap: "\u22B8", nabla: "\u2207", Nacute: "\u0143", nacute: "\u0144", nang: "\u2220\u20D2", nap: "\u2249", napE: "\u2A70\u0338", napid: "\u224B\u0338", napos: "\u0149", napprox: "\u2249", natural: "\u266E", naturals: "\u2115", natur: "\u266E", nbsp: "\xA0", nbump: "\u224E\u0338", nbumpe: "\u224F\u0338", ncap: "\u2A43", Ncaron: "\u0147", ncaron: "\u0148", Ncedil: "\u0145", ncedil: "\u0146", ncong: "\u2247", ncongdot: "\u2A6D\u0338", ncup: "\u2A42", Ncy: "\u041D", ncy: "\u043D", ndash: "\u2013", nearhk: "\u2924", nearr: "\u2197", neArr: "\u21D7", nearrow: "\u2197", ne: "\u2260", nedot: "\u2250\u0338", NegativeMediumSpace: "\u200B", NegativeThickSpace: "\u200B", NegativeThinSpace: "\u200B", NegativeVeryThinSpace: "\u200B", nequiv: "\u2262", nesear: "\u2928", nesim: "\u2242\u0338", NestedGreaterGreater: "\u226B", NestedLessLess: "\u226A", NewLine: `
`, nexist: "\u2204", nexists: "\u2204", Nfr: "\u{1D511}", nfr: "\u{1D52B}", ngE: "\u2267\u0338", nge: "\u2271", ngeq: "\u2271", ngeqq: "\u2267\u0338", ngeqslant: "\u2A7E\u0338", nges: "\u2A7E\u0338", nGg: "\u22D9\u0338", ngsim: "\u2275", nGt: "\u226B\u20D2", ngt: "\u226F", ngtr: "\u226F", nGtv: "\u226B\u0338", nharr: "\u21AE", nhArr: "\u21CE", nhpar: "\u2AF2", ni: "\u220B", nis: "\u22FC", nisd: "\u22FA", niv: "\u220B", NJcy: "\u040A", njcy: "\u045A", nlarr: "\u219A", nlArr: "\u21CD", nldr: "\u2025", nlE: "\u2266\u0338", nle: "\u2270", nleftarrow: "\u219A", nLeftarrow: "\u21CD", nleftrightarrow: "\u21AE", nLeftrightarrow: "\u21CE", nleq: "\u2270", nleqq: "\u2266\u0338", nleqslant: "\u2A7D\u0338", nles: "\u2A7D\u0338", nless: "\u226E", nLl: "\u22D8\u0338", nlsim: "\u2274", nLt: "\u226A\u20D2", nlt: "\u226E", nltri: "\u22EA", nltrie: "\u22EC", nLtv: "\u226A\u0338", nmid: "\u2224", NoBreak: "\u2060", NonBreakingSpace: "\xA0", nopf: "\u{1D55F}", Nopf: "\u2115", Not: "\u2AEC", not: "\xAC", NotCongruent: "\u2262", NotCupCap: "\u226D", NotDoubleVerticalBar: "\u2226", NotElement: "\u2209", NotEqual: "\u2260", NotEqualTilde: "\u2242\u0338", NotExists: "\u2204", NotGreater: "\u226F", NotGreaterEqual: "\u2271", NotGreaterFullEqual: "\u2267\u0338", NotGreaterGreater: "\u226B\u0338", NotGreaterLess: "\u2279", NotGreaterSlantEqual: "\u2A7E\u0338", NotGreaterTilde: "\u2275", NotHumpDownHump: "\u224E\u0338", NotHumpEqual: "\u224F\u0338", notin: "\u2209", notindot: "\u22F5\u0338", notinE: "\u22F9\u0338", notinva: "\u2209", notinvb: "\u22F7", notinvc: "\u22F6", NotLeftTriangleBar: "\u29CF\u0338", NotLeftTriangle: "\u22EA", NotLeftTriangleEqual: "\u22EC", NotLess: "\u226E", NotLessEqual: "\u2270", NotLessGreater: "\u2278", NotLessLess: "\u226A\u0338", NotLessSlantEqual: "\u2A7D\u0338", NotLessTilde: "\u2274", NotNestedGreaterGreater: "\u2AA2\u0338", NotNestedLessLess: "\u2AA1\u0338", notni: "\u220C", notniva: "\u220C", notnivb: "\u22FE", notnivc: "\u22FD", NotPrecedes: "\u2280", NotPrecedesEqual: "\u2AAF\u0338", NotPrecedesSlantEqual: "\u22E0", NotReverseElement: "\u220C", NotRightTriangleBar: "\u29D0\u0338", NotRightTriangle: "\u22EB", NotRightTriangleEqual: "\u22ED", NotSquareSubset: "\u228F\u0338", NotSquareSubsetEqual: "\u22E2", NotSquareSuperset: "\u2290\u0338", NotSquareSupersetEqual: "\u22E3", NotSubset: "\u2282\u20D2", NotSubsetEqual: "\u2288", NotSucceeds: "\u2281", NotSucceedsEqual: "\u2AB0\u0338", NotSucceedsSlantEqual: "\u22E1", NotSucceedsTilde: "\u227F\u0338", NotSuperset: "\u2283\u20D2", NotSupersetEqual: "\u2289", NotTilde: "\u2241", NotTildeEqual: "\u2244", NotTildeFullEqual: "\u2247", NotTildeTilde: "\u2249", NotVerticalBar: "\u2224", nparallel: "\u2226", npar: "\u2226", nparsl: "\u2AFD\u20E5", npart: "\u2202\u0338", npolint: "\u2A14", npr: "\u2280", nprcue: "\u22E0", nprec: "\u2280", npreceq: "\u2AAF\u0338", npre: "\u2AAF\u0338", nrarrc: "\u2933\u0338", nrarr: "\u219B", nrArr: "\u21CF", nrarrw: "\u219D\u0338", nrightarrow: "\u219B", nRightarrow: "\u21CF", nrtri: "\u22EB", nrtrie: "\u22ED", nsc: "\u2281", nsccue: "\u22E1", nsce: "\u2AB0\u0338", Nscr: "\u{1D4A9}", nscr: "\u{1D4C3}", nshortmid: "\u2224", nshortparallel: "\u2226", nsim: "\u2241", nsime: "\u2244", nsimeq: "\u2244", nsmid: "\u2224", nspar: "\u2226", nsqsube: "\u22E2", nsqsupe: "\u22E3", nsub: "\u2284", nsubE: "\u2AC5\u0338", nsube: "\u2288", nsubset: "\u2282\u20D2", nsubseteq: "\u2288", nsubseteqq: "\u2AC5\u0338", nsucc: "\u2281", nsucceq: "\u2AB0\u0338", nsup: "\u2285", nsupE: "\u2AC6\u0338", nsupe: "\u2289", nsupset: "\u2283\u20D2", nsupseteq: "\u2289", nsupseteqq: "\u2AC6\u0338", ntgl: "\u2279", Ntilde: "\xD1", ntilde: "\xF1", ntlg: "\u2278", ntriangleleft: "\u22EA", ntrianglelefteq: "\u22EC", ntriangleright: "\u22EB", ntrianglerighteq: "\u22ED", Nu: "\u039D", nu: "\u03BD", num: "#", numero: "\u2116", numsp: "\u2007", nvap: "\u224D\u20D2", nvdash: "\u22AC", nvDash: "\u22AD", nVdash: "\u22AE", nVDash: "\u22AF", nvge: "\u2265\u20D2", nvgt: ">\u20D2", nvHarr: "\u2904", nvinfin: "\u29DE", nvlArr: "\u2902", nvle: "\u2264\u20D2", nvlt: "<\u20D2", nvltrie: "\u22B4\u20D2", nvrArr: "\u2903", nvrtrie: "\u22B5\u20D2", nvsim: "\u223C\u20D2", nwarhk: "\u2923", nwarr: "\u2196", nwArr: "\u21D6", nwarrow: "\u2196", nwnear: "\u2927", Oacute: "\xD3", oacute: "\xF3", oast: "\u229B", Ocirc: "\xD4", ocirc: "\xF4", ocir: "\u229A", Ocy: "\u041E", ocy: "\u043E", odash: "\u229D", Odblac: "\u0150", odblac: "\u0151", odiv: "\u2A38", odot: "\u2299", odsold: "\u29BC", OElig: "\u0152", oelig: "\u0153", ofcir: "\u29BF", Ofr: "\u{1D512}", ofr: "\u{1D52C}", ogon: "\u02DB", Ograve: "\xD2", ograve: "\xF2", ogt: "\u29C1", ohbar: "\u29B5", ohm: "\u03A9", oint: "\u222E", olarr: "\u21BA", olcir: "\u29BE", olcross: "\u29BB", oline: "\u203E", olt: "\u29C0", Omacr: "\u014C", omacr: "\u014D", Omega: "\u03A9", omega: "\u03C9", Omicron: "\u039F", omicron: "\u03BF", omid: "\u29B6", ominus: "\u2296", Oopf: "\u{1D546}", oopf: "\u{1D560}", opar: "\u29B7", OpenCurlyDoubleQuote: "\u201C", OpenCurlyQuote: "\u2018", operp: "\u29B9", oplus: "\u2295", orarr: "\u21BB", Or: "\u2A54", or: "\u2228", ord: "\u2A5D", order: "\u2134", orderof: "\u2134", ordf: "\xAA", ordm: "\xBA", origof: "\u22B6", oror: "\u2A56", orslope: "\u2A57", orv: "\u2A5B", oS: "\u24C8", Oscr: "\u{1D4AA}", oscr: "\u2134", Oslash: "\xD8", oslash: "\xF8", osol: "\u2298", Otilde: "\xD5", otilde: "\xF5", otimesas: "\u2A36", Otimes: "\u2A37", otimes: "\u2297", Ouml: "\xD6", ouml: "\xF6", ovbar: "\u233D", OverBar: "\u203E", OverBrace: "\u23DE", OverBracket: "\u23B4", OverParenthesis: "\u23DC", para: "\xB6", parallel: "\u2225", par: "\u2225", parsim: "\u2AF3", parsl: "\u2AFD", part: "\u2202", PartialD: "\u2202", Pcy: "\u041F", pcy: "\u043F", percnt: "%", period: ".", permil: "\u2030", perp: "\u22A5", pertenk: "\u2031", Pfr: "\u{1D513}", pfr: "\u{1D52D}", Phi: "\u03A6", phi: "\u03C6", phiv: "\u03D5", phmmat: "\u2133", phone: "\u260E", Pi: "\u03A0", pi: "\u03C0", pitchfork: "\u22D4", piv: "\u03D6", planck: "\u210F", planckh: "\u210E", plankv: "\u210F", plusacir: "\u2A23", plusb: "\u229E", pluscir: "\u2A22", plus: "+", plusdo: "\u2214", plusdu: "\u2A25", pluse: "\u2A72", PlusMinus: "\xB1", plusmn: "\xB1", plussim: "\u2A26", plustwo: "\u2A27", pm: "\xB1", Poincareplane: "\u210C", pointint: "\u2A15", popf: "\u{1D561}", Popf: "\u2119", pound: "\xA3", prap: "\u2AB7", Pr: "\u2ABB", pr: "\u227A", prcue: "\u227C", precapprox: "\u2AB7", prec: "\u227A", preccurlyeq: "\u227C", Precedes: "\u227A", PrecedesEqual: "\u2AAF", PrecedesSlantEqual: "\u227C", PrecedesTilde: "\u227E", preceq: "\u2AAF", precnapprox: "\u2AB9", precneqq: "\u2AB5", precnsim: "\u22E8", pre: "\u2AAF", prE: "\u2AB3", precsim: "\u227E", prime: "\u2032", Prime: "\u2033", primes: "\u2119", prnap: "\u2AB9", prnE: "\u2AB5", prnsim: "\u22E8", prod: "\u220F", Product: "\u220F", profalar: "\u232E", profline: "\u2312", profsurf: "\u2313", prop: "\u221D", Proportional: "\u221D", Proportion: "\u2237", propto: "\u221D", prsim: "\u227E", prurel: "\u22B0", Pscr: "\u{1D4AB}", pscr: "\u{1D4C5}", Psi: "\u03A8", psi: "\u03C8", puncsp: "\u2008", Qfr: "\u{1D514}", qfr: "\u{1D52E}", qint: "\u2A0C", qopf: "\u{1D562}", Qopf: "\u211A", qprime: "\u2057", Qscr: "\u{1D4AC}", qscr: "\u{1D4C6}", quaternions: "\u210D", quatint: "\u2A16", quest: "?", questeq: "\u225F", quot: '"', QUOT: '"', rAarr: "\u21DB", race: "\u223D\u0331", Racute: "\u0154", racute: "\u0155", radic: "\u221A", raemptyv: "\u29B3", rang: "\u27E9", Rang: "\u27EB", rangd: "\u2992", range: "\u29A5", rangle: "\u27E9", raquo: "\xBB", rarrap: "\u2975", rarrb: "\u21E5", rarrbfs: "\u2920", rarrc: "\u2933", rarr: "\u2192", Rarr: "\u21A0", rArr: "\u21D2", rarrfs: "\u291E", rarrhk: "\u21AA", rarrlp: "\u21AC", rarrpl: "\u2945", rarrsim: "\u2974", Rarrtl: "\u2916", rarrtl: "\u21A3", rarrw: "\u219D", ratail: "\u291A", rAtail: "\u291C", ratio: "\u2236", rationals: "\u211A", rbarr: "\u290D", rBarr: "\u290F", RBarr: "\u2910", rbbrk: "\u2773", rbrace: "}", rbrack: "]", rbrke: "\u298C", rbrksld: "\u298E", rbrkslu: "\u2990", Rcaron: "\u0158", rcaron: "\u0159", Rcedil: "\u0156", rcedil: "\u0157", rceil: "\u2309", rcub: "}", Rcy: "\u0420", rcy: "\u0440", rdca: "\u2937", rdldhar: "\u2969", rdquo: "\u201D", rdquor: "\u201D", rdsh: "\u21B3", real: "\u211C", realine: "\u211B", realpart: "\u211C", reals: "\u211D", Re: "\u211C", rect: "\u25AD", reg: "\xAE", REG: "\xAE", ReverseElement: "\u220B", ReverseEquilibrium: "\u21CB", ReverseUpEquilibrium: "\u296F", rfisht: "\u297D", rfloor: "\u230B", rfr: "\u{1D52F}", Rfr: "\u211C", rHar: "\u2964", rhard: "\u21C1", rharu: "\u21C0", rharul: "\u296C", Rho: "\u03A1", rho: "\u03C1", rhov: "\u03F1", RightAngleBracket: "\u27E9", RightArrowBar: "\u21E5", rightarrow: "\u2192", RightArrow: "\u2192", Rightarrow: "\u21D2", RightArrowLeftArrow: "\u21C4", rightarrowtail: "\u21A3", RightCeiling: "\u2309", RightDoubleBracket: "\u27E7", RightDownTeeVector: "\u295D", RightDownVectorBar: "\u2955", RightDownVector: "\u21C2", RightFloor: "\u230B", rightharpoondown: "\u21C1", rightharpoonup: "\u21C0", rightleftarrows: "\u21C4", rightleftharpoons: "\u21CC", rightrightarrows: "\u21C9", rightsquigarrow: "\u219D", RightTeeArrow: "\u21A6", RightTee: "\u22A2", RightTeeVector: "\u295B", rightthreetimes: "\u22CC", RightTriangleBar: "\u29D0", RightTriangle: "\u22B3", RightTriangleEqual: "\u22B5", RightUpDownVector: "\u294F", RightUpTeeVector: "\u295C", RightUpVectorBar: "\u2954", RightUpVector: "\u21BE", RightVectorBar: "\u2953", RightVector: "\u21C0", ring: "\u02DA", risingdotseq: "\u2253", rlarr: "\u21C4", rlhar: "\u21CC", rlm: "\u200F", rmoustache: "\u23B1", rmoust: "\u23B1", rnmid: "\u2AEE", roang: "\u27ED", roarr: "\u21FE", robrk: "\u27E7", ropar: "\u2986", ropf: "\u{1D563}", Ropf: "\u211D", roplus: "\u2A2E", rotimes: "\u2A35", RoundImplies: "\u2970", rpar: ")", rpargt: "\u2994", rppolint: "\u2A12", rrarr: "\u21C9", Rrightarrow: "\u21DB", rsaquo: "\u203A", rscr: "\u{1D4C7}", Rscr: "\u211B", rsh: "\u21B1", Rsh: "\u21B1", rsqb: "]", rsquo: "\u2019", rsquor: "\u2019", rthree: "\u22CC", rtimes: "\u22CA", rtri: "\u25B9", rtrie: "\u22B5", rtrif: "\u25B8", rtriltri: "\u29CE", RuleDelayed: "\u29F4", ruluhar: "\u2968", rx: "\u211E", Sacute: "\u015A", sacute: "\u015B", sbquo: "\u201A", scap: "\u2AB8", Scaron: "\u0160", scaron: "\u0161", Sc: "\u2ABC", sc: "\u227B", sccue: "\u227D", sce: "\u2AB0", scE: "\u2AB4", Scedil: "\u015E", scedil: "\u015F", Scirc: "\u015C", scirc: "\u015D", scnap: "\u2ABA", scnE: "\u2AB6", scnsim: "\u22E9", scpolint: "\u2A13", scsim: "\u227F", Scy: "\u0421", scy: "\u0441", sdotb: "\u22A1", sdot: "\u22C5", sdote: "\u2A66", searhk: "\u2925", searr: "\u2198", seArr: "\u21D8", searrow: "\u2198", sect: "\xA7", semi: ";", seswar: "\u2929", setminus: "\u2216", setmn: "\u2216", sext: "\u2736", Sfr: "\u{1D516}", sfr: "\u{1D530}", sfrown: "\u2322", sharp: "\u266F", SHCHcy: "\u0429", shchcy: "\u0449", SHcy: "\u0428", shcy: "\u0448", ShortDownArrow: "\u2193", ShortLeftArrow: "\u2190", shortmid: "\u2223", shortparallel: "\u2225", ShortRightArrow: "\u2192", ShortUpArrow: "\u2191", shy: "\xAD", Sigma: "\u03A3", sigma: "\u03C3", sigmaf: "\u03C2", sigmav: "\u03C2", sim: "\u223C", simdot: "\u2A6A", sime: "\u2243", simeq: "\u2243", simg: "\u2A9E", simgE: "\u2AA0", siml: "\u2A9D", simlE: "\u2A9F", simne: "\u2246", simplus: "\u2A24", simrarr: "\u2972", slarr: "\u2190", SmallCircle: "\u2218", smallsetminus: "\u2216", smashp: "\u2A33", smeparsl: "\u29E4", smid: "\u2223", smile: "\u2323", smt: "\u2AAA", smte: "\u2AAC", smtes: "\u2AAC\uFE00", SOFTcy: "\u042C", softcy: "\u044C", solbar: "\u233F", solb: "\u29C4", sol: "/", Sopf: "\u{1D54A}", sopf: "\u{1D564}", spades: "\u2660", spadesuit: "\u2660", spar: "\u2225", sqcap: "\u2293", sqcaps: "\u2293\uFE00", sqcup: "\u2294", sqcups: "\u2294\uFE00", Sqrt: "\u221A", sqsub: "\u228F", sqsube: "\u2291", sqsubset: "\u228F", sqsubseteq: "\u2291", sqsup: "\u2290", sqsupe: "\u2292", sqsupset: "\u2290", sqsupseteq: "\u2292", square: "\u25A1", Square: "\u25A1", SquareIntersection: "\u2293", SquareSubset: "\u228F", SquareSubsetEqual: "\u2291", SquareSuperset: "\u2290", SquareSupersetEqual: "\u2292", SquareUnion: "\u2294", squarf: "\u25AA", squ: "\u25A1", squf: "\u25AA", srarr: "\u2192", Sscr: "\u{1D4AE}", sscr: "\u{1D4C8}", ssetmn: "\u2216", ssmile: "\u2323", sstarf: "\u22C6", Star: "\u22C6", star: "\u2606", starf: "\u2605", straightepsilon: "\u03F5", straightphi: "\u03D5", strns: "\xAF", sub: "\u2282", Sub: "\u22D0", subdot: "\u2ABD", subE: "\u2AC5", sube: "\u2286", subedot: "\u2AC3", submult: "\u2AC1", subnE: "\u2ACB", subne: "\u228A", subplus: "\u2ABF", subrarr: "\u2979", subset: "\u2282", Subset: "\u22D0", subseteq: "\u2286", subseteqq: "\u2AC5", SubsetEqual: "\u2286", subsetneq: "\u228A", subsetneqq: "\u2ACB", subsim: "\u2AC7", subsub: "\u2AD5", subsup: "\u2AD3", succapprox: "\u2AB8", succ: "\u227B", succcurlyeq: "\u227D", Succeeds: "\u227B", SucceedsEqual: "\u2AB0", SucceedsSlantEqual: "\u227D", SucceedsTilde: "\u227F", succeq: "\u2AB0", succnapprox: "\u2ABA", succneqq: "\u2AB6", succnsim: "\u22E9", succsim: "\u227F", SuchThat: "\u220B", sum: "\u2211", Sum: "\u2211", sung: "\u266A", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", sup: "\u2283", Sup: "\u22D1", supdot: "\u2ABE", supdsub: "\u2AD8", supE: "\u2AC6", supe: "\u2287", supedot: "\u2AC4", Superset: "\u2283", SupersetEqual: "\u2287", suphsol: "\u27C9", suphsub: "\u2AD7", suplarr: "\u297B", supmult: "\u2AC2", supnE: "\u2ACC", supne: "\u228B", supplus: "\u2AC0", supset: "\u2283", Supset: "\u22D1", supseteq: "\u2287", supseteqq: "\u2AC6", supsetneq: "\u228B", supsetneqq: "\u2ACC", supsim: "\u2AC8", supsub: "\u2AD4", supsup: "\u2AD6", swarhk: "\u2926", swarr: "\u2199", swArr: "\u21D9", swarrow: "\u2199", swnwar: "\u292A", szlig: "\xDF", Tab: "	", target: "\u2316", Tau: "\u03A4", tau: "\u03C4", tbrk: "\u23B4", Tcaron: "\u0164", tcaron: "\u0165", Tcedil: "\u0162", tcedil: "\u0163", Tcy: "\u0422", tcy: "\u0442", tdot: "\u20DB", telrec: "\u2315", Tfr: "\u{1D517}", tfr: "\u{1D531}", there4: "\u2234", therefore: "\u2234", Therefore: "\u2234", Theta: "\u0398", theta: "\u03B8", thetasym: "\u03D1", thetav: "\u03D1", thickapprox: "\u2248", thicksim: "\u223C", ThickSpace: "\u205F\u200A", ThinSpace: "\u2009", thinsp: "\u2009", thkap: "\u2248", thksim: "\u223C", THORN: "\xDE", thorn: "\xFE", tilde: "\u02DC", Tilde: "\u223C", TildeEqual: "\u2243", TildeFullEqual: "\u2245", TildeTilde: "\u2248", timesbar: "\u2A31", timesb: "\u22A0", times: "\xD7", timesd: "\u2A30", tint: "\u222D", toea: "\u2928", topbot: "\u2336", topcir: "\u2AF1", top: "\u22A4", Topf: "\u{1D54B}", topf: "\u{1D565}", topfork: "\u2ADA", tosa: "\u2929", tprime: "\u2034", trade: "\u2122", TRADE: "\u2122", triangle: "\u25B5", triangledown: "\u25BF", triangleleft: "\u25C3", trianglelefteq: "\u22B4", triangleq: "\u225C", triangleright: "\u25B9", trianglerighteq: "\u22B5", tridot: "\u25EC", trie: "\u225C", triminus: "\u2A3A", TripleDot: "\u20DB", triplus: "\u2A39", trisb: "\u29CD", tritime: "\u2A3B", trpezium: "\u23E2", Tscr: "\u{1D4AF}", tscr: "\u{1D4C9}", TScy: "\u0426", tscy: "\u0446", TSHcy: "\u040B", tshcy: "\u045B", Tstrok: "\u0166", tstrok: "\u0167", twixt: "\u226C", twoheadleftarrow: "\u219E", twoheadrightarrow: "\u21A0", Uacute: "\xDA", uacute: "\xFA", uarr: "\u2191", Uarr: "\u219F", uArr: "\u21D1", Uarrocir: "\u2949", Ubrcy: "\u040E", ubrcy: "\u045E", Ubreve: "\u016C", ubreve: "\u016D", Ucirc: "\xDB", ucirc: "\xFB", Ucy: "\u0423", ucy: "\u0443", udarr: "\u21C5", Udblac: "\u0170", udblac: "\u0171", udhar: "\u296E", ufisht: "\u297E", Ufr: "\u{1D518}", ufr: "\u{1D532}", Ugrave: "\xD9", ugrave: "\xF9", uHar: "\u2963", uharl: "\u21BF", uharr: "\u21BE", uhblk: "\u2580", ulcorn: "\u231C", ulcorner: "\u231C", ulcrop: "\u230F", ultri: "\u25F8", Umacr: "\u016A", umacr: "\u016B", uml: "\xA8", UnderBar: "_", UnderBrace: "\u23DF", UnderBracket: "\u23B5", UnderParenthesis: "\u23DD", Union: "\u22C3", UnionPlus: "\u228E", Uogon: "\u0172", uogon: "\u0173", Uopf: "\u{1D54C}", uopf: "\u{1D566}", UpArrowBar: "\u2912", uparrow: "\u2191", UpArrow: "\u2191", Uparrow: "\u21D1", UpArrowDownArrow: "\u21C5", updownarrow: "\u2195", UpDownArrow: "\u2195", Updownarrow: "\u21D5", UpEquilibrium: "\u296E", upharpoonleft: "\u21BF", upharpoonright: "\u21BE", uplus: "\u228E", UpperLeftArrow: "\u2196", UpperRightArrow: "\u2197", upsi: "\u03C5", Upsi: "\u03D2", upsih: "\u03D2", Upsilon: "\u03A5", upsilon: "\u03C5", UpTeeArrow: "\u21A5", UpTee: "\u22A5", upuparrows: "\u21C8", urcorn: "\u231D", urcorner: "\u231D", urcrop: "\u230E", Uring: "\u016E", uring: "\u016F", urtri: "\u25F9", Uscr: "\u{1D4B0}", uscr: "\u{1D4CA}", utdot: "\u22F0", Utilde: "\u0168", utilde: "\u0169", utri: "\u25B5", utrif: "\u25B4", uuarr: "\u21C8", Uuml: "\xDC", uuml: "\xFC", uwangle: "\u29A7", vangrt: "\u299C", varepsilon: "\u03F5", varkappa: "\u03F0", varnothing: "\u2205", varphi: "\u03D5", varpi: "\u03D6", varpropto: "\u221D", varr: "\u2195", vArr: "\u21D5", varrho: "\u03F1", varsigma: "\u03C2", varsubsetneq: "\u228A\uFE00", varsubsetneqq: "\u2ACB\uFE00", varsupsetneq: "\u228B\uFE00", varsupsetneqq: "\u2ACC\uFE00", vartheta: "\u03D1", vartriangleleft: "\u22B2", vartriangleright: "\u22B3", vBar: "\u2AE8", Vbar: "\u2AEB", vBarv: "\u2AE9", Vcy: "\u0412", vcy: "\u0432", vdash: "\u22A2", vDash: "\u22A8", Vdash: "\u22A9", VDash: "\u22AB", Vdashl: "\u2AE6", veebar: "\u22BB", vee: "\u2228", Vee: "\u22C1", veeeq: "\u225A", vellip: "\u22EE", verbar: "|", Verbar: "\u2016", vert: "|", Vert: "\u2016", VerticalBar: "\u2223", VerticalLine: "|", VerticalSeparator: "\u2758", VerticalTilde: "\u2240", VeryThinSpace: "\u200A", Vfr: "\u{1D519}", vfr: "\u{1D533}", vltri: "\u22B2", vnsub: "\u2282\u20D2", vnsup: "\u2283\u20D2", Vopf: "\u{1D54D}", vopf: "\u{1D567}", vprop: "\u221D", vrtri: "\u22B3", Vscr: "\u{1D4B1}", vscr: "\u{1D4CB}", vsubnE: "\u2ACB\uFE00", vsubne: "\u228A\uFE00", vsupnE: "\u2ACC\uFE00", vsupne: "\u228B\uFE00", Vvdash: "\u22AA", vzigzag: "\u299A", Wcirc: "\u0174", wcirc: "\u0175", wedbar: "\u2A5F", wedge: "\u2227", Wedge: "\u22C0", wedgeq: "\u2259", weierp: "\u2118", Wfr: "\u{1D51A}", wfr: "\u{1D534}", Wopf: "\u{1D54E}", wopf: "\u{1D568}", wp: "\u2118", wr: "\u2240", wreath: "\u2240", Wscr: "\u{1D4B2}", wscr: "\u{1D4CC}", xcap: "\u22C2", xcirc: "\u25EF", xcup: "\u22C3", xdtri: "\u25BD", Xfr: "\u{1D51B}", xfr: "\u{1D535}", xharr: "\u27F7", xhArr: "\u27FA", Xi: "\u039E", xi: "\u03BE", xlarr: "\u27F5", xlArr: "\u27F8", xmap: "\u27FC", xnis: "\u22FB", xodot: "\u2A00", Xopf: "\u{1D54F}", xopf: "\u{1D569}", xoplus: "\u2A01", xotime: "\u2A02", xrarr: "\u27F6", xrArr: "\u27F9", Xscr: "\u{1D4B3}", xscr: "\u{1D4CD}", xsqcup: "\u2A06", xuplus: "\u2A04", xutri: "\u25B3", xvee: "\u22C1", xwedge: "\u22C0", Yacute: "\xDD", yacute: "\xFD", YAcy: "\u042F", yacy: "\u044F", Ycirc: "\u0176", ycirc: "\u0177", Ycy: "\u042B", ycy: "\u044B", yen: "\xA5", Yfr: "\u{1D51C}", yfr: "\u{1D536}", YIcy: "\u0407", yicy: "\u0457", Yopf: "\u{1D550}", yopf: "\u{1D56A}", Yscr: "\u{1D4B4}", yscr: "\u{1D4CE}", YUcy: "\u042E", yucy: "\u044E", yuml: "\xFF", Yuml: "\u0178", Zacute: "\u0179", zacute: "\u017A", Zcaron: "\u017D", zcaron: "\u017E", Zcy: "\u0417", zcy: "\u0437", Zdot: "\u017B", zdot: "\u017C", zeetrf: "\u2128", ZeroWidthSpace: "\u200B", Zeta: "\u0396", zeta: "\u03B6", zfr: "\u{1D537}", Zfr: "\u2128", ZHcy: "\u0416", zhcy: "\u0436", zigrarr: "\u21DD", zopf: "\u{1D56B}", Zopf: "\u2124", Zscr: "\u{1D4B5}", zscr: "\u{1D4CF}", zwj: "\u200D", zwnj: "\u200C" };
  }
});

// ../node_modules/entities/lib/maps/legacy.json
var require_legacy = __commonJS({
  "../node_modules/entities/lib/maps/legacy.json"(exports, module2) {
    module2.exports = { Aacute: "\xC1", aacute: "\xE1", Acirc: "\xC2", acirc: "\xE2", acute: "\xB4", AElig: "\xC6", aelig: "\xE6", Agrave: "\xC0", agrave: "\xE0", amp: "&", AMP: "&", Aring: "\xC5", aring: "\xE5", Atilde: "\xC3", atilde: "\xE3", Auml: "\xC4", auml: "\xE4", brvbar: "\xA6", Ccedil: "\xC7", ccedil: "\xE7", cedil: "\xB8", cent: "\xA2", copy: "\xA9", COPY: "\xA9", curren: "\xA4", deg: "\xB0", divide: "\xF7", Eacute: "\xC9", eacute: "\xE9", Ecirc: "\xCA", ecirc: "\xEA", Egrave: "\xC8", egrave: "\xE8", ETH: "\xD0", eth: "\xF0", Euml: "\xCB", euml: "\xEB", frac12: "\xBD", frac14: "\xBC", frac34: "\xBE", gt: ">", GT: ">", Iacute: "\xCD", iacute: "\xED", Icirc: "\xCE", icirc: "\xEE", iexcl: "\xA1", Igrave: "\xCC", igrave: "\xEC", iquest: "\xBF", Iuml: "\xCF", iuml: "\xEF", laquo: "\xAB", lt: "<", LT: "<", macr: "\xAF", micro: "\xB5", middot: "\xB7", nbsp: "\xA0", not: "\xAC", Ntilde: "\xD1", ntilde: "\xF1", Oacute: "\xD3", oacute: "\xF3", Ocirc: "\xD4", ocirc: "\xF4", Ograve: "\xD2", ograve: "\xF2", ordf: "\xAA", ordm: "\xBA", Oslash: "\xD8", oslash: "\xF8", Otilde: "\xD5", otilde: "\xF5", Ouml: "\xD6", ouml: "\xF6", para: "\xB6", plusmn: "\xB1", pound: "\xA3", quot: '"', QUOT: '"', raquo: "\xBB", reg: "\xAE", REG: "\xAE", sect: "\xA7", shy: "\xAD", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", szlig: "\xDF", THORN: "\xDE", thorn: "\xFE", times: "\xD7", Uacute: "\xDA", uacute: "\xFA", Ucirc: "\xDB", ucirc: "\xFB", Ugrave: "\xD9", ugrave: "\xF9", uml: "\xA8", Uuml: "\xDC", uuml: "\xFC", Yacute: "\xDD", yacute: "\xFD", yen: "\xA5", yuml: "\xFF" };
  }
});

// ../node_modules/entities/lib/maps/xml.json
var require_xml = __commonJS({
  "../node_modules/entities/lib/maps/xml.json"(exports, module2) {
    module2.exports = { amp: "&", apos: "'", gt: ">", lt: "<", quot: '"' };
  }
});

// ../node_modules/entities/lib/maps/decode.json
var require_decode = __commonJS({
  "../node_modules/entities/lib/maps/decode.json"(exports, module2) {
    module2.exports = { "0": 65533, "128": 8364, "130": 8218, "131": 402, "132": 8222, "133": 8230, "134": 8224, "135": 8225, "136": 710, "137": 8240, "138": 352, "139": 8249, "140": 338, "142": 381, "145": 8216, "146": 8217, "147": 8220, "148": 8221, "149": 8226, "150": 8211, "151": 8212, "152": 732, "153": 8482, "154": 353, "155": 8250, "156": 339, "158": 382, "159": 376 };
  }
});

// ../node_modules/entities/lib/decode_codepoint.js
var require_decode_codepoint = __commonJS({
  "../node_modules/entities/lib/decode_codepoint.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var decode_json_1 = __importDefault(require_decode()), fromCodePoint = (
      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      String.fromCodePoint || function(codePoint) {
        var output = "";
        return codePoint > 65535 && (codePoint -= 65536, output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296), codePoint = 56320 | codePoint & 1023), output += String.fromCharCode(codePoint), output;
      }
    );
    function decodeCodePoint(codePoint) {
      return codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111 ? "\uFFFD" : (codePoint in decode_json_1.default && (codePoint = decode_json_1.default[codePoint]), fromCodePoint(codePoint));
    }
    exports.default = decodeCodePoint;
  }
});

// ../node_modules/entities/lib/decode.js
var require_decode2 = __commonJS({
  "../node_modules/entities/lib/decode.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.decodeHTML = exports.decodeHTMLStrict = exports.decodeXML = void 0;
    var entities_json_1 = __importDefault(require_entities()), legacy_json_1 = __importDefault(require_legacy()), xml_json_1 = __importDefault(require_xml()), decode_codepoint_1 = __importDefault(require_decode_codepoint()), strictEntityRe = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
    exports.decodeXML = getStrictDecoder(xml_json_1.default);
    exports.decodeHTMLStrict = getStrictDecoder(entities_json_1.default);
    function getStrictDecoder(map2) {
      var replace = getReplacer(map2);
      return function(str2) {
        return String(str2).replace(strictEntityRe, replace);
      };
    }
    var sorter = function(a2, b2) {
      return a2 < b2 ? 1 : -1;
    };
    exports.decodeHTML = (function() {
      for (var legacy = Object.keys(legacy_json_1.default).sort(sorter), keys2 = Object.keys(entities_json_1.default).sort(sorter), i2 = 0, j2 = 0; i2 < keys2.length; i2++)
        legacy[j2] === keys2[i2] ? (keys2[i2] += ";?", j2++) : keys2[i2] += ";";
      var re = new RegExp("&(?:" + keys2.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g"), replace = getReplacer(entities_json_1.default);
      function replacer3(str2) {
        return str2.substr(-1) !== ";" && (str2 += ";"), replace(str2);
      }
      return function(str2) {
        return String(str2).replace(re, replacer3);
      };
    })();
    function getReplacer(map2) {
      return function(str2) {
        if (str2.charAt(1) === "#") {
          var secondChar = str2.charAt(2);
          return secondChar === "X" || secondChar === "x" ? decode_codepoint_1.default(parseInt(str2.substr(3), 16)) : decode_codepoint_1.default(parseInt(str2.substr(2), 10));
        }
        return map2[str2.slice(1, -1)] || str2;
      };
    }
  }
});

// ../node_modules/entities/lib/encode.js
var require_encode = __commonJS({
  "../node_modules/entities/lib/encode.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = void 0;
    var xml_json_1 = __importDefault(require_xml()), inverseXML = getInverseObj(xml_json_1.default), xmlReplacer = getInverseReplacer(inverseXML);
    exports.encodeXML = getASCIIEncoder(inverseXML);
    var entities_json_1 = __importDefault(require_entities()), inverseHTML = getInverseObj(entities_json_1.default), htmlReplacer = getInverseReplacer(inverseHTML);
    exports.encodeHTML = getInverse(inverseHTML, htmlReplacer);
    exports.encodeNonAsciiHTML = getASCIIEncoder(inverseHTML);
    function getInverseObj(obj) {
      return Object.keys(obj).sort().reduce(function(inverse, name) {
        return inverse[obj[name]] = "&" + name + ";", inverse;
      }, {});
    }
    function getInverseReplacer(inverse) {
      for (var single = [], multiple = [], _i = 0, _a3 = Object.keys(inverse); _i < _a3.length; _i++) {
        var k2 = _a3[_i];
        k2.length === 1 ? single.push("\\" + k2) : multiple.push(k2);
      }
      single.sort();
      for (var start = 0; start < single.length - 1; start++) {
        for (var end = start; end < single.length - 1 && single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1); )
          end += 1;
        var count2 = 1 + end - start;
        count2 < 3 || single.splice(start, count2, single[start] + "-" + single[end]);
      }
      return multiple.unshift("[" + single.join("") + "]"), new RegExp(multiple.join("|"), "g");
    }
    var reNonASCII = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g, getCodePoint = (
      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      String.prototype.codePointAt != null ? (
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        function(str2) {
          return str2.codePointAt(0);
        }
      ) : (
        // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
        function(c2) {
          return (c2.charCodeAt(0) - 55296) * 1024 + c2.charCodeAt(1) - 56320 + 65536;
        }
      )
    );
    function singleCharReplacer(c2) {
      return "&#x" + (c2.length > 1 ? getCodePoint(c2) : c2.charCodeAt(0)).toString(16).toUpperCase() + ";";
    }
    function getInverse(inverse, re) {
      return function(data) {
        return data.replace(re, function(name) {
          return inverse[name];
        }).replace(reNonASCII, singleCharReplacer);
      };
    }
    var reEscapeChars = new RegExp(xmlReplacer.source + "|" + reNonASCII.source, "g");
    function escape4(data) {
      return data.replace(reEscapeChars, singleCharReplacer);
    }
    exports.escape = escape4;
    function escapeUTF8(data) {
      return data.replace(xmlReplacer, singleCharReplacer);
    }
    exports.escapeUTF8 = escapeUTF8;
    function getASCIIEncoder(obj) {
      return function(data) {
        return data.replace(reEscapeChars, function(c2) {
          return obj[c2] || singleCharReplacer(c2);
        });
      };
    }
  }
});

// ../node_modules/entities/lib/index.js
var require_lib2 = __commonJS({
  "../node_modules/entities/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.encodeHTML5 = exports.encodeHTML4 = exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = void 0;
    var decode_1 = require_decode2(), encode_1 = require_encode();
    function decode(data, level) {
      return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML)(data);
    }
    exports.decode = decode;
    function decodeStrict(data, level) {
      return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict)(data);
    }
    exports.decodeStrict = decodeStrict;
    function encode2(data, level) {
      return (!level || level <= 0 ? encode_1.encodeXML : encode_1.encodeHTML)(data);
    }
    exports.encode = encode2;
    var encode_2 = require_encode();
    Object.defineProperty(exports, "encodeXML", { enumerable: !0, get: function() {
      return encode_2.encodeXML;
    } });
    Object.defineProperty(exports, "encodeHTML", { enumerable: !0, get: function() {
      return encode_2.encodeHTML;
    } });
    Object.defineProperty(exports, "encodeNonAsciiHTML", { enumerable: !0, get: function() {
      return encode_2.encodeNonAsciiHTML;
    } });
    Object.defineProperty(exports, "escape", { enumerable: !0, get: function() {
      return encode_2.escape;
    } });
    Object.defineProperty(exports, "escapeUTF8", { enumerable: !0, get: function() {
      return encode_2.escapeUTF8;
    } });
    Object.defineProperty(exports, "encodeHTML4", { enumerable: !0, get: function() {
      return encode_2.encodeHTML;
    } });
    Object.defineProperty(exports, "encodeHTML5", { enumerable: !0, get: function() {
      return encode_2.encodeHTML;
    } });
    var decode_2 = require_decode2();
    Object.defineProperty(exports, "decodeXML", { enumerable: !0, get: function() {
      return decode_2.decodeXML;
    } });
    Object.defineProperty(exports, "decodeHTML", { enumerable: !0, get: function() {
      return decode_2.decodeHTML;
    } });
    Object.defineProperty(exports, "decodeHTMLStrict", { enumerable: !0, get: function() {
      return decode_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports, "decodeHTML4", { enumerable: !0, get: function() {
      return decode_2.decodeHTML;
    } });
    Object.defineProperty(exports, "decodeHTML5", { enumerable: !0, get: function() {
      return decode_2.decodeHTML;
    } });
    Object.defineProperty(exports, "decodeHTML4Strict", { enumerable: !0, get: function() {
      return decode_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports, "decodeHTML5Strict", { enumerable: !0, get: function() {
      return decode_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports, "decodeXMLStrict", { enumerable: !0, get: function() {
      return decode_2.decodeXML;
    } });
  }
});

// ../node_modules/ansi-to-html/lib/ansi_to_html.js
var require_ansi_to_html = __commonJS({
  "../node_modules/ansi-to-html/lib/ansi_to_html.js"(exports, module2) {
    "use strict";
    function _classCallCheck3(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties3(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass3(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties3(Constructor.prototype, protoProps), staticProps && _defineProperties3(Constructor, staticProps), Constructor;
    }
    function _createForOfIteratorHelper(o2, allowArrayLike) {
      var it = typeof Symbol < "u" && o2[Symbol.iterator] || o2["@@iterator"];
      if (!it) {
        if (Array.isArray(o2) || (it = _unsupportedIterableToArray(o2)) || allowArrayLike && o2 && typeof o2.length == "number") {
          it && (o2 = it);
          var i2 = 0, F = function() {
          };
          return { s: F, n: function() {
            return i2 >= o2.length ? { done: !0 } : { done: !1, value: o2[i2++] };
          }, e: function(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
      }
      var normalCompletion = !0, didErr = !1, err;
      return { s: function() {
        it = it.call(o2);
      }, n: function() {
        var step2 = it.next();
        return normalCompletion = step2.done, step2;
      }, e: function(_e2) {
        didErr = !0, err = _e2;
      }, f: function() {
        try {
          !normalCompletion && it.return != null && it.return();
        } finally {
          if (didErr) throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o2, minLen) {
      if (o2) {
        if (typeof o2 == "string") return _arrayLikeToArray(o2, minLen);
        var n2 = Object.prototype.toString.call(o2).slice(8, -1);
        if (n2 === "Object" && o2.constructor && (n2 = o2.constructor.name), n2 === "Map" || n2 === "Set") return Array.from(o2);
        if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray(o2, minLen);
      }
    }
    function _arrayLikeToArray(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
        arr2[i2] = arr[i2];
      return arr2;
    }
    var entities = require_lib2(), defaults = {
      fg: "#FFF",
      bg: "#000",
      newline: !1,
      escapeXML: !1,
      stream: !1,
      colors: getDefaultColors()
    };
    function getDefaultColors() {
      var colors3 = {
        0: "#000",
        1: "#A00",
        2: "#0A0",
        3: "#A50",
        4: "#00A",
        5: "#A0A",
        6: "#0AA",
        7: "#AAA",
        8: "#555",
        9: "#F55",
        10: "#5F5",
        11: "#FF5",
        12: "#55F",
        13: "#F5F",
        14: "#5FF",
        15: "#FFF"
      };
      return range(0, 5).forEach(function(red) {
        range(0, 5).forEach(function(green) {
          range(0, 5).forEach(function(blue) {
            return setStyleColor(red, green, blue, colors3);
          });
        });
      }), range(0, 23).forEach(function(gray) {
        var c2 = gray + 232, l2 = toHexString(gray * 10 + 8);
        colors3[c2] = "#" + l2 + l2 + l2;
      }), colors3;
    }
    function setStyleColor(red, green, blue, colors3) {
      var c2 = 16 + red * 36 + green * 6 + blue, r2 = red > 0 ? red * 40 + 55 : 0, g2 = green > 0 ? green * 40 + 55 : 0, b2 = blue > 0 ? blue * 40 + 55 : 0;
      colors3[c2] = toColorHexString([r2, g2, b2]);
    }
    function toHexString(num) {
      for (var str2 = num.toString(16); str2.length < 2; )
        str2 = "0" + str2;
      return str2;
    }
    function toColorHexString(ref) {
      var results = [], _iterator = _createForOfIteratorHelper(ref), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var r2 = _step.value;
          results.push(toHexString(r2));
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return "#" + results.join("");
    }
    function generateOutput(stack, token, data, options) {
      var result;
      return token === "text" ? result = pushText(data, options) : token === "display" ? result = handleDisplay(stack, data, options) : token === "xterm256Foreground" ? result = pushForegroundColor(stack, options.colors[data]) : token === "xterm256Background" ? result = pushBackgroundColor(stack, options.colors[data]) : token === "rgb" && (result = handleRgb(stack, data)), result;
    }
    function handleRgb(stack, data) {
      data = data.substring(2).slice(0, -1);
      var operation = +data.substr(0, 2), color = data.substring(5).split(";"), rgb = color.map(function(value) {
        return ("0" + Number(value).toString(16)).substr(-2);
      }).join("");
      return pushStyle(stack, (operation === 38 ? "color:#" : "background-color:#") + rgb);
    }
    function handleDisplay(stack, code, options) {
      code = parseInt(code, 10);
      var codeMap = {
        "-1": function() {
          return "<br/>";
        },
        0: function() {
          return stack.length && resetStyles(stack);
        },
        1: function() {
          return pushTag(stack, "b");
        },
        3: function() {
          return pushTag(stack, "i");
        },
        4: function() {
          return pushTag(stack, "u");
        },
        8: function() {
          return pushStyle(stack, "display:none");
        },
        9: function() {
          return pushTag(stack, "strike");
        },
        22: function() {
          return pushStyle(stack, "font-weight:normal;text-decoration:none;font-style:normal");
        },
        23: function() {
          return closeTag(stack, "i");
        },
        24: function() {
          return closeTag(stack, "u");
        },
        39: function() {
          return pushForegroundColor(stack, options.fg);
        },
        49: function() {
          return pushBackgroundColor(stack, options.bg);
        },
        53: function() {
          return pushStyle(stack, "text-decoration:overline");
        }
      }, result;
      return codeMap[code] ? result = codeMap[code]() : 4 < code && code < 7 ? result = pushTag(stack, "blink") : 29 < code && code < 38 ? result = pushForegroundColor(stack, options.colors[code - 30]) : 39 < code && code < 48 ? result = pushBackgroundColor(stack, options.colors[code - 40]) : 89 < code && code < 98 ? result = pushForegroundColor(stack, options.colors[8 + (code - 90)]) : 99 < code && code < 108 && (result = pushBackgroundColor(stack, options.colors[8 + (code - 100)])), result;
    }
    function resetStyles(stack) {
      var stackClone = stack.slice(0);
      return stack.length = 0, stackClone.reverse().map(function(tag) {
        return "</" + tag + ">";
      }).join("");
    }
    function range(low, high) {
      for (var results = [], j2 = low; j2 <= high; j2++)
        results.push(j2);
      return results;
    }
    function notCategory(category) {
      return function(e2) {
        return (category === null || e2.category !== category) && category !== "all";
      };
    }
    function categoryForCode(code) {
      code = parseInt(code, 10);
      var result = null;
      return code === 0 ? result = "all" : code === 1 ? result = "bold" : 2 < code && code < 5 ? result = "underline" : 4 < code && code < 7 ? result = "blink" : code === 8 ? result = "hide" : code === 9 ? result = "strike" : 29 < code && code < 38 || code === 39 || 89 < code && code < 98 ? result = "foreground-color" : (39 < code && code < 48 || code === 49 || 99 < code && code < 108) && (result = "background-color"), result;
    }
    function pushText(text, options) {
      return options.escapeXML ? entities.encodeXML(text) : text;
    }
    function pushTag(stack, tag, style) {
      return style || (style = ""), stack.push(tag), "<".concat(tag).concat(style ? ' style="'.concat(style, '"') : "", ">");
    }
    function pushStyle(stack, style) {
      return pushTag(stack, "span", style);
    }
    function pushForegroundColor(stack, color) {
      return pushTag(stack, "span", "color:" + color);
    }
    function pushBackgroundColor(stack, color) {
      return pushTag(stack, "span", "background-color:" + color);
    }
    function closeTag(stack, style) {
      var last;
      if (stack.slice(-1)[0] === style && (last = stack.pop()), last)
        return "</" + style + ">";
    }
    function tokenize(text, options, callback) {
      var ansiMatch = !1, ansiHandler = 3;
      function remove() {
        return "";
      }
      function removeXterm256Foreground(m3, g1) {
        return callback("xterm256Foreground", g1), "";
      }
      function removeXterm256Background(m3, g1) {
        return callback("xterm256Background", g1), "";
      }
      function newline(m3) {
        return options.newline ? callback("display", -1) : callback("text", m3), "";
      }
      function ansiMess(m3, g1) {
        ansiMatch = !0, g1.trim().length === 0 && (g1 = "0"), g1 = g1.trimRight(";").split(";");
        var _iterator2 = _createForOfIteratorHelper(g1), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var g2 = _step2.value;
            callback("display", g2);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        return "";
      }
      function realText(m3) {
        return callback("text", m3), "";
      }
      function rgb(m3) {
        return callback("rgb", m3), "";
      }
      var tokens = [{
        pattern: /^\x08+/,
        sub: remove
      }, {
        pattern: /^\x1b\[[012]?K/,
        sub: remove
      }, {
        pattern: /^\x1b\[\(B/,
        sub: remove
      }, {
        pattern: /^\x1b\[[34]8;2;\d+;\d+;\d+m/,
        sub: rgb
      }, {
        pattern: /^\x1b\[38;5;(\d+)m/,
        sub: removeXterm256Foreground
      }, {
        pattern: /^\x1b\[48;5;(\d+)m/,
        sub: removeXterm256Background
      }, {
        pattern: /^\n/,
        sub: newline
      }, {
        pattern: /^\r+\n/,
        sub: newline
      }, {
        pattern: /^\r/,
        sub: newline
      }, {
        pattern: /^\x1b\[((?:\d{1,3};?)+|)m/,
        sub: ansiMess
      }, {
        // CSI n J
        // ED - Erase in Display Clears part of the screen.
        // If n is 0 (or missing), clear from cursor to end of screen.
        // If n is 1, clear from cursor to beginning of the screen.
        // If n is 2, clear entire screen (and moves cursor to upper left on DOS ANSI.SYS).
        // If n is 3, clear entire screen and delete all lines saved in the scrollback buffer
        //   (this feature was added for xterm and is supported by other terminal applications).
        pattern: /^\x1b\[\d?J/,
        sub: remove
      }, {
        // CSI n ; m f
        // HVP - Horizontal Vertical Position Same as CUP
        pattern: /^\x1b\[\d{0,3};\d{0,3}f/,
        sub: remove
      }, {
        // catch-all for CSI sequences?
        pattern: /^\x1b\[?[\d;]{0,3}/,
        sub: remove
      }, {
        /**
         * extracts real text - not containing:
         * - `\x1b' - ESC - escape (Ascii 27)
         * - '\x08' - BS - backspace (Ascii 8)
         * - `\n` - Newline - linefeed (LF) (ascii 10)
         * - `\r` - Windows Carriage Return (CR)
         */
        pattern: /^(([^\x1b\x08\r\n])+)/,
        sub: realText
      }];
      function process2(handler2, i3) {
        i3 > ansiHandler && ansiMatch || (ansiMatch = !1, text = text.replace(handler2.pattern, handler2.sub));
      }
      var results1 = [], _text = text, length = _text.length;
      outer: for (; length > 0; ) {
        for (var i2 = 0, o2 = 0, len = tokens.length; o2 < len; i2 = ++o2) {
          var handler = tokens[i2];
          if (process2(handler, i2), text.length !== length) {
            length = text.length;
            continue outer;
          }
        }
        if (text.length === length)
          break;
        results1.push(0), length = text.length;
      }
      return results1;
    }
    function updateStickyStack(stickyStack, token, data) {
      return token !== "text" && (stickyStack = stickyStack.filter(notCategory(categoryForCode(data))), stickyStack.push({
        token,
        data,
        category: categoryForCode(data)
      })), stickyStack;
    }
    var Filter = (function() {
      function Filter2(options) {
        _classCallCheck3(this, Filter2), options = options || {}, options.colors && (options.colors = Object.assign({}, defaults.colors, options.colors)), this.options = Object.assign({}, defaults, options), this.stack = [], this.stickyStack = [];
      }
      return _createClass3(Filter2, [{
        key: "toHtml",
        value: function(input2) {
          var _this = this;
          input2 = typeof input2 == "string" ? [input2] : input2;
          var stack = this.stack, options = this.options, buf = [];
          return this.stickyStack.forEach(function(element) {
            var output = generateOutput(stack, element.token, element.data, options);
            output && buf.push(output);
          }), tokenize(input2.join(""), options, function(token, data) {
            var output = generateOutput(stack, token, data, options);
            output && buf.push(output), options.stream && (_this.stickyStack = updateStickyStack(_this.stickyStack, token, data));
          }), stack.length && buf.push(resetStyles(stack)), buf.join("");
        }
      }]), Filter2;
    })();
    module2.exports = Filter;
  }
});

// ../node_modules/jsdoc-type-pratt-parser/dist/index.js
var require_dist = __commonJS({
  "../node_modules/jsdoc-type-pratt-parser/dist/index.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports == "object" && typeof module2 < "u" ? factory(exports) : typeof define == "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis < "u" ? globalThis : global2 || self, factory(global2.jtpp = {}));
    })(exports, (function(exports2) {
      "use strict";
      function tokenToString(token) {
        return token.text !== void 0 && token.text !== "" ? `'${token.type}' with value '${token.text}'` : `'${token.type}'`;
      }
      class NoParsletFoundError extends Error {
        constructor(token) {
          super(`No parslet found for token: ${tokenToString(token)}`), this.token = token, Object.setPrototypeOf(this, NoParsletFoundError.prototype);
        }
        getToken() {
          return this.token;
        }
      }
      class EarlyEndOfParseError extends Error {
        constructor(token) {
          super(`The parsing ended early. The next token was: ${tokenToString(token)}`), this.token = token, Object.setPrototypeOf(this, EarlyEndOfParseError.prototype);
        }
        getToken() {
          return this.token;
        }
      }
      class UnexpectedTypeError extends Error {
        constructor(result, message) {
          let error = `Unexpected type: '${result.type}'.`;
          message !== void 0 && (error += ` Message: ${message}`), super(error), Object.setPrototypeOf(this, UnexpectedTypeError.prototype);
        }
      }
      function makePunctuationRule(type5) {
        return (text) => text.startsWith(type5) ? { type: type5, text: type5 } : null;
      }
      function getQuoted(text) {
        let position = 0, char, mark = text[0], escaped = !1;
        if (mark !== "'" && mark !== '"')
          return null;
        for (; position < text.length; ) {
          if (position++, char = text[position], !escaped && char === mark) {
            position++;
            break;
          }
          escaped = !escaped && char === "\\";
        }
        if (char !== mark)
          throw new Error("Unterminated String");
        return text.slice(0, position);
      }
      let identifierStartRegex = new RegExp("[$_\\p{ID_Start}]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}", "u"), identifierContinueRegex = new RegExp("[$\\-\\p{ID_Continue}\\u200C\\u200D]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}", "u");
      function getIdentifier(text) {
        let char = text[0];
        if (!identifierStartRegex.test(char))
          return null;
        let position = 1;
        do {
          if (char = text[position], !identifierContinueRegex.test(char))
            break;
          position++;
        } while (position < text.length);
        return text.slice(0, position);
      }
      let numberRegex = /^(NaN|-?((\d*\.\d+|\d+)([Ee][+-]?\d+)?|Infinity))/;
      function getNumber(text) {
        var _a3, _b;
        return (_b = (_a3 = numberRegex.exec(text)) === null || _a3 === void 0 ? void 0 : _a3[0]) !== null && _b !== void 0 ? _b : null;
      }
      let identifierRule = (text) => {
        let value = getIdentifier(text);
        return value == null ? null : {
          type: "Identifier",
          text: value
        };
      };
      function makeKeyWordRule(type5) {
        return (text) => {
          if (!text.startsWith(type5))
            return null;
          let prepends = text[type5.length];
          return prepends !== void 0 && identifierContinueRegex.test(prepends) ? null : {
            type: type5,
            text: type5
          };
        };
      }
      let stringValueRule = (text) => {
        let value = getQuoted(text);
        return value == null ? null : {
          type: "StringValue",
          text: value
        };
      }, eofRule = (text) => text.length > 0 ? null : {
        type: "EOF",
        text: ""
      }, numberRule = (text) => {
        let value = getNumber(text);
        return value === null ? null : {
          type: "Number",
          text: value
        };
      }, rules = [
        eofRule,
        makePunctuationRule("=>"),
        makePunctuationRule("("),
        makePunctuationRule(")"),
        makePunctuationRule("{"),
        makePunctuationRule("}"),
        makePunctuationRule("["),
        makePunctuationRule("]"),
        makePunctuationRule("|"),
        makePunctuationRule("&"),
        makePunctuationRule("<"),
        makePunctuationRule(">"),
        makePunctuationRule(","),
        makePunctuationRule(";"),
        makePunctuationRule("*"),
        makePunctuationRule("?"),
        makePunctuationRule("!"),
        makePunctuationRule("="),
        makePunctuationRule(":"),
        makePunctuationRule("..."),
        makePunctuationRule("."),
        makePunctuationRule("#"),
        makePunctuationRule("~"),
        makePunctuationRule("/"),
        makePunctuationRule("@"),
        makeKeyWordRule("undefined"),
        makeKeyWordRule("null"),
        makeKeyWordRule("function"),
        makeKeyWordRule("this"),
        makeKeyWordRule("new"),
        makeKeyWordRule("module"),
        makeKeyWordRule("event"),
        makeKeyWordRule("extends"),
        makeKeyWordRule("external"),
        makeKeyWordRule("infer"),
        makeKeyWordRule("typeof"),
        makeKeyWordRule("keyof"),
        makeKeyWordRule("readonly"),
        makeKeyWordRule("import"),
        makeKeyWordRule("is"),
        makeKeyWordRule("in"),
        makeKeyWordRule("asserts"),
        numberRule,
        identifierRule,
        stringValueRule
      ], breakingWhitespaceRegex = /^\s*\n\s*/;
      class Lexer {
        static create(text) {
          let current = this.read(text);
          text = current.text;
          let next = this.read(text);
          return text = next.text, new Lexer(text, void 0, current.token, next.token);
        }
        constructor(text, previous, current, next) {
          this.text = "", this.text = text, this.previous = previous, this.current = current, this.next = next;
        }
        static read(text, startOfLine = !1) {
          startOfLine = startOfLine || breakingWhitespaceRegex.test(text), text = text.trim();
          for (let rule of rules) {
            let partial = rule(text);
            if (partial !== null) {
              let token = Object.assign(Object.assign({}, partial), { startOfLine });
              return text = text.slice(token.text.length), { text, token };
            }
          }
          throw new Error("Unexpected Token " + text);
        }
        advance() {
          let next = Lexer.read(this.text);
          return new Lexer(next.text, this.current, this.next, next.token);
        }
      }
      function assertRootResult(result) {
        if (result === void 0)
          throw new Error("Unexpected undefined");
        if (result.type === "JsdocTypeKeyValue" || result.type === "JsdocTypeParameterList" || result.type === "JsdocTypeProperty" || result.type === "JsdocTypeReadonlyProperty" || result.type === "JsdocTypeObjectField" || result.type === "JsdocTypeJsdocObjectField" || result.type === "JsdocTypeIndexSignature" || result.type === "JsdocTypeMappedType" || result.type === "JsdocTypeTypeParameter")
          throw new UnexpectedTypeError(result);
        return result;
      }
      function assertPlainKeyValueOrRootResult(result) {
        return result.type === "JsdocTypeKeyValue" ? assertPlainKeyValueResult(result) : assertRootResult(result);
      }
      function assertPlainKeyValueOrNameResult(result) {
        return result.type === "JsdocTypeName" ? result : assertPlainKeyValueResult(result);
      }
      function assertPlainKeyValueResult(result) {
        if (result.type !== "JsdocTypeKeyValue")
          throw new UnexpectedTypeError(result);
        return result;
      }
      function assertNumberOrVariadicNameResult(result) {
        var _a3;
        if (result.type === "JsdocTypeVariadic") {
          if (((_a3 = result.element) === null || _a3 === void 0 ? void 0 : _a3.type) === "JsdocTypeName")
            return result;
          throw new UnexpectedTypeError(result);
        }
        if (result.type !== "JsdocTypeNumber" && result.type !== "JsdocTypeName")
          throw new UnexpectedTypeError(result);
        return result;
      }
      function assertArrayOrTupleResult(result) {
        if (result.type === "JsdocTypeTuple" || result.type === "JsdocTypeGeneric" && result.meta.brackets === "square")
          return result;
        throw new UnexpectedTypeError(result);
      }
      function isSquaredProperty(result) {
        return result.type === "JsdocTypeIndexSignature" || result.type === "JsdocTypeMappedType";
      }
      var Precedence;
      (function(Precedence2) {
        Precedence2[Precedence2.ALL = 0] = "ALL", Precedence2[Precedence2.PARAMETER_LIST = 1] = "PARAMETER_LIST", Precedence2[Precedence2.OBJECT = 2] = "OBJECT", Precedence2[Precedence2.KEY_VALUE = 3] = "KEY_VALUE", Precedence2[Precedence2.INDEX_BRACKETS = 4] = "INDEX_BRACKETS", Precedence2[Precedence2.UNION = 5] = "UNION", Precedence2[Precedence2.INTERSECTION = 6] = "INTERSECTION", Precedence2[Precedence2.PREFIX = 7] = "PREFIX", Precedence2[Precedence2.INFIX = 8] = "INFIX", Precedence2[Precedence2.TUPLE = 9] = "TUPLE", Precedence2[Precedence2.SYMBOL = 10] = "SYMBOL", Precedence2[Precedence2.OPTIONAL = 11] = "OPTIONAL", Precedence2[Precedence2.NULLABLE = 12] = "NULLABLE", Precedence2[Precedence2.KEY_OF_TYPE_OF = 13] = "KEY_OF_TYPE_OF", Precedence2[Precedence2.FUNCTION = 14] = "FUNCTION", Precedence2[Precedence2.ARROW = 15] = "ARROW", Precedence2[Precedence2.ARRAY_BRACKETS = 16] = "ARRAY_BRACKETS", Precedence2[Precedence2.GENERIC = 17] = "GENERIC", Precedence2[Precedence2.NAME_PATH = 18] = "NAME_PATH", Precedence2[Precedence2.PARENTHESIS = 19] = "PARENTHESIS", Precedence2[Precedence2.SPECIAL_TYPES = 20] = "SPECIAL_TYPES";
      })(Precedence || (Precedence = {}));
      class Parser {
        constructor(grammar, textOrLexer, baseParser) {
          this.grammar = grammar, typeof textOrLexer == "string" ? this._lexer = Lexer.create(textOrLexer) : this._lexer = textOrLexer, this.baseParser = baseParser;
        }
        get lexer() {
          return this._lexer;
        }
        /**
         * Parses a given string and throws an error if the parse ended before the end of the string.
         */
        parse() {
          let result = this.parseType(Precedence.ALL);
          if (this.lexer.current.type !== "EOF")
            throw new EarlyEndOfParseError(this.lexer.current);
          return result;
        }
        /**
         * Parses with the current lexer and asserts that the result is a {@link RootResult}.
         */
        parseType(precedence) {
          return assertRootResult(this.parseIntermediateType(precedence));
        }
        /**
         * The main parsing function. First it tries to parse the current state in the prefix step, and then it continues
         * to parse the state in the infix step.
         */
        parseIntermediateType(precedence) {
          let result = this.tryParslets(null, precedence);
          if (result === null)
            throw new NoParsletFoundError(this.lexer.current);
          return this.parseInfixIntermediateType(result, precedence);
        }
        /**
         * In the infix parsing step the parser continues to parse the current state with all parslets until none returns
         * a result.
         */
        parseInfixIntermediateType(left, precedence) {
          let result = this.tryParslets(left, precedence);
          for (; result !== null; )
            left = result, result = this.tryParslets(left, precedence);
          return left;
        }
        /**
         * Tries to parse the current state with all parslets in the grammar and returns the first non null result.
         */
        tryParslets(left, precedence) {
          for (let parslet of this.grammar) {
            let result = parslet(this, precedence, left);
            if (result !== null)
              return result;
          }
          return null;
        }
        /**
         * If the given type equals the current type of the {@link Lexer} advance the lexer. Return true if the lexer was
         * advanced.
         */
        consume(types) {
          return Array.isArray(types) || (types = [types]), types.includes(this.lexer.current.type) ? (this._lexer = this.lexer.advance(), !0) : !1;
        }
        acceptLexerState(parser) {
          this._lexer = parser.lexer;
        }
      }
      function isQuestionMarkUnknownType(next) {
        return next === "}" || next === "EOF" || next === "|" || next === "," || next === ")" || next === ">";
      }
      let nullableParslet = (parser, precedence, left) => {
        let type5 = parser.lexer.current.type, next = parser.lexer.next.type;
        return left == null && type5 === "?" && !isQuestionMarkUnknownType(next) || left != null && type5 === "?" ? (parser.consume("?"), left == null ? {
          type: "JsdocTypeNullable",
          element: parser.parseType(Precedence.NULLABLE),
          meta: {
            position: "prefix"
          }
        } : {
          type: "JsdocTypeNullable",
          element: assertRootResult(left),
          meta: {
            position: "suffix"
          }
        }) : null;
      };
      function composeParslet(options) {
        let parslet = (parser, curPrecedence, left) => {
          let type5 = parser.lexer.current.type, next = parser.lexer.next.type;
          if (left === null) {
            if ("parsePrefix" in options && options.accept(type5, next))
              return options.parsePrefix(parser);
          } else if ("parseInfix" in options && options.precedence > curPrecedence && options.accept(type5, next))
            return options.parseInfix(parser, left);
          return null;
        };
        return Object.defineProperty(parslet, "name", {
          value: options.name
        }), parslet;
      }
      let optionalParslet = composeParslet({
        name: "optionalParslet",
        accept: (type5) => type5 === "=",
        precedence: Precedence.OPTIONAL,
        parsePrefix: (parser) => (parser.consume("="), {
          type: "JsdocTypeOptional",
          element: parser.parseType(Precedence.OPTIONAL),
          meta: {
            position: "prefix"
          }
        }),
        parseInfix: (parser, left) => (parser.consume("="), {
          type: "JsdocTypeOptional",
          element: assertRootResult(left),
          meta: {
            position: "suffix"
          }
        })
      }), numberParslet = composeParslet({
        name: "numberParslet",
        accept: (type5) => type5 === "Number",
        parsePrefix: (parser) => {
          let value = parseFloat(parser.lexer.current.text);
          return parser.consume("Number"), {
            type: "JsdocTypeNumber",
            value
          };
        }
      }), parenthesisParslet = composeParslet({
        name: "parenthesisParslet",
        accept: (type5) => type5 === "(",
        parsePrefix: (parser) => {
          if (parser.consume("("), parser.consume(")"))
            return {
              type: "JsdocTypeParameterList",
              elements: []
            };
          let result = parser.parseIntermediateType(Precedence.ALL);
          if (!parser.consume(")"))
            throw new Error("Unterminated parenthesis");
          return result.type === "JsdocTypeParameterList" ? result : result.type === "JsdocTypeKeyValue" ? {
            type: "JsdocTypeParameterList",
            elements: [result]
          } : {
            type: "JsdocTypeParenthesis",
            element: assertRootResult(result)
          };
        }
      }), specialTypesParslet = composeParslet({
        name: "specialTypesParslet",
        accept: (type5, next) => type5 === "?" && isQuestionMarkUnknownType(next) || type5 === "null" || type5 === "undefined" || type5 === "*",
        parsePrefix: (parser) => {
          if (parser.consume("null"))
            return {
              type: "JsdocTypeNull"
            };
          if (parser.consume("undefined"))
            return {
              type: "JsdocTypeUndefined"
            };
          if (parser.consume("*"))
            return {
              type: "JsdocTypeAny"
            };
          if (parser.consume("?"))
            return {
              type: "JsdocTypeUnknown"
            };
          throw new Error("Unacceptable token: " + parser.lexer.current.text);
        }
      }), notNullableParslet = composeParslet({
        name: "notNullableParslet",
        accept: (type5) => type5 === "!",
        precedence: Precedence.NULLABLE,
        parsePrefix: (parser) => (parser.consume("!"), {
          type: "JsdocTypeNotNullable",
          element: parser.parseType(Precedence.NULLABLE),
          meta: {
            position: "prefix"
          }
        }),
        parseInfix: (parser, left) => (parser.consume("!"), {
          type: "JsdocTypeNotNullable",
          element: assertRootResult(left),
          meta: {
            position: "suffix"
          }
        })
      });
      function createParameterListParslet({ allowTrailingComma }) {
        return composeParslet({
          name: "parameterListParslet",
          accept: (type5) => type5 === ",",
          precedence: Precedence.PARAMETER_LIST,
          parseInfix: (parser, left) => {
            let elements = [
              assertPlainKeyValueOrRootResult(left)
            ];
            parser.consume(",");
            do
              try {
                let next = parser.parseIntermediateType(Precedence.PARAMETER_LIST);
                elements.push(assertPlainKeyValueOrRootResult(next));
              } catch (e2) {
                if (e2 instanceof NoParsletFoundError)
                  break;
                throw e2;
              }
            while (parser.consume(","));
            if (elements.length > 0 && elements.slice(0, -1).some((e2) => e2.type === "JsdocTypeVariadic"))
              throw new Error("Only the last parameter may be a rest parameter");
            return {
              type: "JsdocTypeParameterList",
              elements
            };
          }
        });
      }
      let genericParslet = composeParslet({
        name: "genericParslet",
        accept: (type5, next) => type5 === "<" || type5 === "." && next === "<",
        precedence: Precedence.GENERIC,
        parseInfix: (parser, left) => {
          let dot = parser.consume(".");
          parser.consume("<");
          let objects = [], infer = !1;
          if (parser.consume("infer")) {
            infer = !0;
            let left2 = parser.parseIntermediateType(Precedence.SYMBOL);
            if (left2.type !== "JsdocTypeName")
              throw new UnexpectedTypeError(left2, "A typescript asserts always has to have a name on the left side.");
            objects.push(left2);
          } else
            do
              objects.push(parser.parseType(Precedence.PARAMETER_LIST));
            while (parser.consume(","));
          if (!parser.consume(">"))
            throw new Error("Unterminated generic parameter list");
          return Object.assign(Object.assign({ type: "JsdocTypeGeneric", left: assertRootResult(left), elements: objects }, infer ? { infer: !0 } : {}), { meta: {
            brackets: "angle",
            dot
          } });
        }
      }), unionParslet = composeParslet({
        name: "unionParslet",
        accept: (type5) => type5 === "|",
        precedence: Precedence.UNION,
        parseInfix: (parser, left) => {
          parser.consume("|");
          let elements = [];
          do
            elements.push(parser.parseType(Precedence.UNION));
          while (parser.consume("|"));
          return {
            type: "JsdocTypeUnion",
            elements: [assertRootResult(left), ...elements]
          };
        }
      }), baseGrammar = [
        nullableParslet,
        optionalParslet,
        numberParslet,
        parenthesisParslet,
        specialTypesParslet,
        notNullableParslet,
        createParameterListParslet({
          allowTrailingComma: !0
        }),
        genericParslet,
        unionParslet,
        optionalParslet
      ];
      function createNamePathParslet({ allowSquareBracketsOnAnyType, allowJsdocNamePaths, pathGrammar: pathGrammar2 }) {
        return function(parser, precedence, left) {
          if (left == null || precedence >= Precedence.NAME_PATH)
            return null;
          let type5 = parser.lexer.current.type, next = parser.lexer.next.type;
          if (!(type5 === "." && next !== "<" || type5 === "[" && (allowSquareBracketsOnAnyType || left.type === "JsdocTypeName") || allowJsdocNamePaths && (type5 === "~" || type5 === "#")))
            return null;
          let pathType, brackets = !1;
          parser.consume(".") ? pathType = "property" : parser.consume("[") ? (pathType = "property-brackets", brackets = !0) : parser.consume("~") ? pathType = "inner" : (parser.consume("#"), pathType = "instance");
          let pathParser = pathGrammar2 !== null ? new Parser(pathGrammar2, parser.lexer, parser) : parser, parsed = pathParser.parseIntermediateType(Precedence.NAME_PATH);
          parser.acceptLexerState(pathParser);
          let right;
          switch (parsed.type) {
            case "JsdocTypeName":
              right = {
                type: "JsdocTypeProperty",
                value: parsed.value,
                meta: {
                  quote: void 0
                }
              };
              break;
            case "JsdocTypeNumber":
              right = {
                type: "JsdocTypeProperty",
                value: parsed.value.toString(10),
                meta: {
                  quote: void 0
                }
              };
              break;
            case "JsdocTypeStringValue":
              right = {
                type: "JsdocTypeProperty",
                value: parsed.value,
                meta: {
                  quote: parsed.meta.quote
                }
              };
              break;
            case "JsdocTypeSpecialNamePath":
              if (parsed.specialType === "event")
                right = parsed;
              else
                throw new UnexpectedTypeError(parsed, "Type 'JsdocTypeSpecialNamePath' is only allowed with specialType 'event'");
              break;
            default:
              throw new UnexpectedTypeError(parsed, "Expecting 'JsdocTypeName', 'JsdocTypeNumber', 'JsdocStringValue' or 'JsdocTypeSpecialNamePath'");
          }
          if (brackets && !parser.consume("]")) {
            let token = parser.lexer.current;
            throw new Error(`Unterminated square brackets. Next token is '${token.type}' with text '${token.text}'`);
          }
          return {
            type: "JsdocTypeNamePath",
            left: assertRootResult(left),
            right,
            pathType
          };
        };
      }
      function createNameParslet({ allowedAdditionalTokens }) {
        return composeParslet({
          name: "nameParslet",
          accept: (type5) => type5 === "Identifier" || type5 === "this" || type5 === "new" || allowedAdditionalTokens.includes(type5),
          parsePrefix: (parser) => {
            let { type: type5, text } = parser.lexer.current;
            return parser.consume(type5), {
              type: "JsdocTypeName",
              value: text
            };
          }
        });
      }
      let stringValueParslet = composeParslet({
        name: "stringValueParslet",
        accept: (type5) => type5 === "StringValue",
        parsePrefix: (parser) => {
          let text = parser.lexer.current.text;
          return parser.consume("StringValue"), {
            type: "JsdocTypeStringValue",
            value: text.slice(1, -1),
            meta: {
              quote: text[0] === "'" ? "single" : "double"
            }
          };
        }
      });
      function createSpecialNamePathParslet({ pathGrammar: pathGrammar2, allowedTypes }) {
        return composeParslet({
          name: "specialNamePathParslet",
          accept: (type5) => allowedTypes.includes(type5),
          parsePrefix: (parser) => {
            let type5 = parser.lexer.current.type;
            if (parser.consume(type5), !parser.consume(":"))
              return {
                type: "JsdocTypeName",
                value: type5
              };
            let result, token = parser.lexer.current;
            if (parser.consume("StringValue"))
              result = {
                type: "JsdocTypeSpecialNamePath",
                value: token.text.slice(1, -1),
                specialType: type5,
                meta: {
                  quote: token.text[0] === "'" ? "single" : "double"
                }
              };
            else {
              let value = "", allowed = ["Identifier", "@", "/"];
              for (; allowed.some((type6) => parser.consume(type6)); )
                value += token.text, token = parser.lexer.current;
              result = {
                type: "JsdocTypeSpecialNamePath",
                value,
                specialType: type5,
                meta: {
                  quote: void 0
                }
              };
            }
            let moduleParser = new Parser(pathGrammar2, parser.lexer, parser), moduleResult = moduleParser.parseInfixIntermediateType(result, Precedence.ALL);
            return parser.acceptLexerState(moduleParser), assertRootResult(moduleResult);
          }
        });
      }
      let basePathGrammar = [
        createNameParslet({
          allowedAdditionalTokens: ["external", "module"]
        }),
        stringValueParslet,
        numberParslet,
        createNamePathParslet({
          allowSquareBracketsOnAnyType: !1,
          allowJsdocNamePaths: !0,
          pathGrammar: null
        })
      ], pathGrammar = [
        ...basePathGrammar,
        createSpecialNamePathParslet({
          allowedTypes: ["event"],
          pathGrammar: basePathGrammar
        })
      ];
      function getParameters(value) {
        let parameters2;
        if (value.type === "JsdocTypeParameterList")
          parameters2 = value.elements;
        else if (value.type === "JsdocTypeParenthesis")
          parameters2 = [value.element];
        else
          throw new UnexpectedTypeError(value);
        return parameters2.map((p2) => assertPlainKeyValueOrRootResult(p2));
      }
      function getUnnamedParameters(value) {
        let parameters2 = getParameters(value);
        if (parameters2.some((p2) => p2.type === "JsdocTypeKeyValue"))
          throw new Error("No parameter should be named");
        return parameters2;
      }
      function createFunctionParslet({ allowNamedParameters, allowNoReturnType, allowWithoutParenthesis, allowNewAsFunctionKeyword }) {
        return composeParslet({
          name: "functionParslet",
          accept: (type5, next) => type5 === "function" || allowNewAsFunctionKeyword && type5 === "new" && next === "(",
          parsePrefix: (parser) => {
            let newKeyword = parser.consume("new");
            parser.consume("function");
            let hasParenthesis = parser.lexer.current.type === "(";
            if (!hasParenthesis) {
              if (!allowWithoutParenthesis)
                throw new Error("function is missing parameter list");
              return {
                type: "JsdocTypeName",
                value: "function"
              };
            }
            let result = {
              type: "JsdocTypeFunction",
              parameters: [],
              arrow: !1,
              constructor: newKeyword,
              parenthesis: hasParenthesis
            }, value = parser.parseIntermediateType(Precedence.FUNCTION);
            if (allowNamedParameters === void 0)
              result.parameters = getUnnamedParameters(value);
            else {
              if (newKeyword && value.type === "JsdocTypeFunction" && value.arrow)
                return result = value, result.constructor = !0, result;
              result.parameters = getParameters(value);
              for (let p2 of result.parameters)
                if (p2.type === "JsdocTypeKeyValue" && !allowNamedParameters.includes(p2.key))
                  throw new Error(`only allowed named parameters are ${allowNamedParameters.join(", ")} but got ${p2.type}`);
            }
            if (parser.consume(":"))
              result.returnType = parser.parseType(Precedence.PREFIX);
            else if (!allowNoReturnType)
              throw new Error("function is missing return type");
            return result;
          }
        });
      }
      function createVariadicParslet({ allowPostfix, allowEnclosingBrackets }) {
        return composeParslet({
          name: "variadicParslet",
          accept: (type5) => type5 === "...",
          precedence: Precedence.PREFIX,
          parsePrefix: (parser) => {
            parser.consume("...");
            let brackets = allowEnclosingBrackets && parser.consume("[");
            try {
              let element = parser.parseType(Precedence.PREFIX);
              if (brackets && !parser.consume("]"))
                throw new Error("Unterminated variadic type. Missing ']'");
              return {
                type: "JsdocTypeVariadic",
                element: assertRootResult(element),
                meta: {
                  position: "prefix",
                  squareBrackets: brackets
                }
              };
            } catch (e2) {
              if (e2 instanceof NoParsletFoundError) {
                if (brackets)
                  throw new Error("Empty square brackets for variadic are not allowed.");
                return {
                  type: "JsdocTypeVariadic",
                  meta: {
                    position: void 0,
                    squareBrackets: !1
                  }
                };
              } else
                throw e2;
            }
          },
          parseInfix: allowPostfix ? (parser, left) => (parser.consume("..."), {
            type: "JsdocTypeVariadic",
            element: assertRootResult(left),
            meta: {
              position: "suffix",
              squareBrackets: !1
            }
          }) : void 0
        });
      }
      let symbolParslet = composeParslet({
        name: "symbolParslet",
        accept: (type5) => type5 === "(",
        precedence: Precedence.SYMBOL,
        parseInfix: (parser, left) => {
          if (left.type !== "JsdocTypeName")
            throw new Error("Symbol expects a name on the left side. (Reacting on '(')");
          parser.consume("(");
          let result = {
            type: "JsdocTypeSymbol",
            value: left.value
          };
          if (!parser.consume(")")) {
            let next = parser.parseIntermediateType(Precedence.SYMBOL);
            if (result.element = assertNumberOrVariadicNameResult(next), !parser.consume(")"))
              throw new Error("Symbol does not end after value");
          }
          return result;
        }
      }), arrayBracketsParslet = composeParslet({
        name: "arrayBracketsParslet",
        precedence: Precedence.ARRAY_BRACKETS,
        accept: (type5, next) => type5 === "[" && next === "]",
        parseInfix: (parser, left) => (parser.consume("["), parser.consume("]"), {
          type: "JsdocTypeGeneric",
          left: {
            type: "JsdocTypeName",
            value: "Array"
          },
          elements: [
            assertRootResult(left)
          ],
          meta: {
            brackets: "square",
            dot: !1
          }
        })
      });
      function createObjectParslet({ objectFieldGrammar: objectFieldGrammar2, allowKeyTypes }) {
        return composeParslet({
          name: "objectParslet",
          accept: (type5) => type5 === "{",
          parsePrefix: (parser) => {
            parser.consume("{");
            let result = {
              type: "JsdocTypeObject",
              meta: {
                separator: "comma"
              },
              elements: []
            };
            if (!parser.consume("}")) {
              let separator, fieldParser = new Parser(objectFieldGrammar2, parser.lexer, parser);
              for (; ; ) {
                fieldParser.acceptLexerState(parser);
                let field = fieldParser.parseIntermediateType(Precedence.OBJECT);
                parser.acceptLexerState(fieldParser), field === void 0 && allowKeyTypes && (field = parser.parseIntermediateType(Precedence.OBJECT));
                let optional = !1;
                if (field.type === "JsdocTypeNullable" && (optional = !0, field = field.element), field.type === "JsdocTypeNumber" || field.type === "JsdocTypeName" || field.type === "JsdocTypeStringValue") {
                  let quote2;
                  field.type === "JsdocTypeStringValue" && (quote2 = field.meta.quote), result.elements.push({
                    type: "JsdocTypeObjectField",
                    key: field.value.toString(),
                    right: void 0,
                    optional,
                    readonly: !1,
                    meta: {
                      quote: quote2
                    }
                  });
                } else if (field.type === "JsdocTypeObjectField" || field.type === "JsdocTypeJsdocObjectField")
                  result.elements.push(field);
                else
                  throw new UnexpectedTypeError(field);
                if (parser.lexer.current.startOfLine)
                  separator = "linebreak", parser.consume(",") || parser.consume(";");
                else if (parser.consume(","))
                  separator = "comma";
                else if (parser.consume(";"))
                  separator = "semicolon";
                else
                  break;
                if (parser.lexer.current.type === "}")
                  break;
              }
              if (result.meta.separator = separator ?? "comma", separator === "linebreak" && (result.meta.propertyIndent = "  "), !parser.consume("}"))
                throw new Error("Unterminated record type. Missing '}'");
            }
            return result;
          }
        });
      }
      function createObjectFieldParslet({ allowSquaredProperties, allowKeyTypes, allowReadonly, allowOptional }) {
        return composeParslet({
          name: "objectFieldParslet",
          precedence: Precedence.KEY_VALUE,
          accept: (type5) => type5 === ":",
          parseInfix: (parser, left) => {
            var _a3;
            let optional = !1, readonlyProperty = !1;
            allowOptional && left.type === "JsdocTypeNullable" && (optional = !0, left = left.element), allowReadonly && left.type === "JsdocTypeReadonlyProperty" && (readonlyProperty = !0, left = left.element);
            let parentParser = (_a3 = parser.baseParser) !== null && _a3 !== void 0 ? _a3 : parser;
            if (parentParser.acceptLexerState(parser), left.type === "JsdocTypeNumber" || left.type === "JsdocTypeName" || left.type === "JsdocTypeStringValue" || isSquaredProperty(left)) {
              if (isSquaredProperty(left) && !allowSquaredProperties)
                throw new UnexpectedTypeError(left);
              parentParser.consume(":");
              let quote2;
              left.type === "JsdocTypeStringValue" && (quote2 = left.meta.quote);
              let right = parentParser.parseType(Precedence.KEY_VALUE);
              return parser.acceptLexerState(parentParser), {
                type: "JsdocTypeObjectField",
                key: isSquaredProperty(left) ? left : left.value.toString(),
                right,
                optional,
                readonly: readonlyProperty,
                meta: {
                  quote: quote2
                }
              };
            } else {
              if (!allowKeyTypes)
                throw new UnexpectedTypeError(left);
              parentParser.consume(":");
              let right = parentParser.parseType(Precedence.KEY_VALUE);
              return parser.acceptLexerState(parentParser), {
                type: "JsdocTypeJsdocObjectField",
                left: assertRootResult(left),
                right
              };
            }
          }
        });
      }
      function createKeyValueParslet({ allowOptional, allowVariadic }) {
        return composeParslet({
          name: "keyValueParslet",
          precedence: Precedence.KEY_VALUE,
          accept: (type5) => type5 === ":",
          parseInfix: (parser, left) => {
            let optional = !1, variadic = !1;
            if (allowOptional && left.type === "JsdocTypeNullable" && (optional = !0, left = left.element), allowVariadic && left.type === "JsdocTypeVariadic" && left.element !== void 0 && (variadic = !0, left = left.element), left.type !== "JsdocTypeName")
              throw new UnexpectedTypeError(left);
            parser.consume(":");
            let right = parser.parseType(Precedence.KEY_VALUE);
            return {
              type: "JsdocTypeKeyValue",
              key: left.value,
              right,
              optional,
              variadic
            };
          }
        });
      }
      let jsdocBaseGrammar = [
        ...baseGrammar,
        createFunctionParslet({
          allowWithoutParenthesis: !0,
          allowNamedParameters: ["this", "new"],
          allowNoReturnType: !0,
          allowNewAsFunctionKeyword: !1
        }),
        stringValueParslet,
        createSpecialNamePathParslet({
          allowedTypes: ["module", "external", "event"],
          pathGrammar
        }),
        createVariadicParslet({
          allowEnclosingBrackets: !0,
          allowPostfix: !0
        }),
        createNameParslet({
          allowedAdditionalTokens: ["keyof"]
        }),
        symbolParslet,
        arrayBracketsParslet,
        createNamePathParslet({
          allowSquareBracketsOnAnyType: !1,
          allowJsdocNamePaths: !0,
          pathGrammar
        })
      ], jsdocGrammar = [
        ...jsdocBaseGrammar,
        createObjectParslet({
          // jsdoc syntax allows full types as keys, so we need to pull in the full grammar here
          // we leave out the object type deliberately
          objectFieldGrammar: [
            createNameParslet({
              allowedAdditionalTokens: ["typeof", "module", "in"]
            }),
            createObjectFieldParslet({
              allowSquaredProperties: !1,
              allowKeyTypes: !0,
              allowOptional: !1,
              allowReadonly: !1
            }),
            ...jsdocBaseGrammar
          ],
          allowKeyTypes: !0
        }),
        createKeyValueParslet({
          allowOptional: !0,
          allowVariadic: !0
        })
      ], typeOfParslet = composeParslet({
        name: "typeOfParslet",
        accept: (type5) => type5 === "typeof",
        parsePrefix: (parser) => (parser.consume("typeof"), {
          type: "JsdocTypeTypeof",
          element: parser.parseType(Precedence.KEY_OF_TYPE_OF)
        })
      }), objectFieldGrammar$1 = [
        createNameParslet({
          allowedAdditionalTokens: ["typeof", "module", "keyof", "event", "external", "in"]
        }),
        nullableParslet,
        optionalParslet,
        stringValueParslet,
        numberParslet,
        createObjectFieldParslet({
          allowSquaredProperties: !1,
          allowKeyTypes: !1,
          allowOptional: !1,
          allowReadonly: !1
        })
      ], closureGrammar = [
        ...baseGrammar,
        createObjectParslet({
          allowKeyTypes: !1,
          objectFieldGrammar: objectFieldGrammar$1
        }),
        createNameParslet({
          allowedAdditionalTokens: ["event", "external", "in"]
        }),
        typeOfParslet,
        createFunctionParslet({
          allowWithoutParenthesis: !1,
          allowNamedParameters: ["this", "new"],
          allowNoReturnType: !0,
          allowNewAsFunctionKeyword: !1
        }),
        createVariadicParslet({
          allowEnclosingBrackets: !1,
          allowPostfix: !1
        }),
        // additional name parslet is needed for some special cases
        createNameParslet({
          allowedAdditionalTokens: ["keyof"]
        }),
        createSpecialNamePathParslet({
          allowedTypes: ["module"],
          pathGrammar
        }),
        createNamePathParslet({
          allowSquareBracketsOnAnyType: !1,
          allowJsdocNamePaths: !0,
          pathGrammar
        }),
        createKeyValueParslet({
          allowOptional: !1,
          allowVariadic: !1
        }),
        symbolParslet
      ], assertsParslet = composeParslet({
        name: "assertsParslet",
        accept: (type5) => type5 === "asserts",
        parsePrefix: (parser) => {
          parser.consume("asserts");
          let left = parser.parseIntermediateType(Precedence.SYMBOL);
          if (left.type !== "JsdocTypeName")
            throw new UnexpectedTypeError(left, "A typescript asserts always has to have a name on the left side.");
          return parser.consume("is") ? {
            type: "JsdocTypeAsserts",
            left,
            right: assertRootResult(parser.parseIntermediateType(Precedence.INFIX))
          } : {
            type: "JsdocTypeAssertsPlain",
            element: left
          };
        }
      });
      function createTupleParslet({ allowQuestionMark }) {
        return composeParslet({
          name: "tupleParslet",
          accept: (type5) => type5 === "[",
          parsePrefix: (parser) => {
            parser.consume("[");
            let result = {
              type: "JsdocTypeTuple",
              elements: []
            };
            if (parser.consume("]"))
              return result;
            let typeList = parser.parseIntermediateType(Precedence.ALL);
            if (typeList.type === "JsdocTypeParameterList" ? typeList.elements[0].type === "JsdocTypeKeyValue" ? result.elements = typeList.elements.map(assertPlainKeyValueResult) : result.elements = typeList.elements.map(assertRootResult) : typeList.type === "JsdocTypeKeyValue" ? result.elements = [assertPlainKeyValueResult(typeList)] : result.elements = [assertRootResult(typeList)], !parser.consume("]"))
              throw new Error("Unterminated '['");
            if (result.elements.some((e2) => e2.type === "JsdocTypeUnknown"))
              throw new Error("Question mark in tuple not allowed");
            return result;
          }
        });
      }
      let keyOfParslet = composeParslet({
        name: "keyOfParslet",
        accept: (type5) => type5 === "keyof",
        parsePrefix: (parser) => (parser.consume("keyof"), {
          type: "JsdocTypeKeyof",
          element: assertRootResult(parser.parseType(Precedence.KEY_OF_TYPE_OF))
        })
      }), importParslet = composeParslet({
        name: "importParslet",
        accept: (type5) => type5 === "import",
        parsePrefix: (parser) => {
          if (parser.consume("import"), !parser.consume("("))
            throw new Error("Missing parenthesis after import keyword");
          let path = parser.parseType(Precedence.PREFIX);
          if (path.type !== "JsdocTypeStringValue")
            throw new Error("Only string values are allowed as paths for imports");
          if (!parser.consume(")"))
            throw new Error("Missing closing parenthesis after import keyword");
          return {
            type: "JsdocTypeImport",
            element: path
          };
        }
      }), readonlyPropertyParslet = composeParslet({
        name: "readonlyPropertyParslet",
        accept: (type5) => type5 === "readonly",
        parsePrefix: (parser) => (parser.consume("readonly"), {
          type: "JsdocTypeReadonlyProperty",
          element: parser.parseIntermediateType(Precedence.KEY_VALUE)
        })
      }), arrowFunctionParslet = composeParslet({
        name: "arrowFunctionParslet",
        precedence: Precedence.ARROW,
        accept: (type5) => type5 === "=>",
        parseInfix: (parser, left) => (parser.consume("=>"), {
          type: "JsdocTypeFunction",
          parameters: getParameters(left).map(assertPlainKeyValueOrNameResult),
          arrow: !0,
          constructor: !1,
          parenthesis: !0,
          returnType: parser.parseType(Precedence.OBJECT)
        })
      }), genericArrowFunctionParslet = composeParslet({
        name: "genericArrowFunctionParslet",
        accept: (type5) => type5 === "<",
        parsePrefix: (parser) => {
          let typeParameters = [];
          parser.consume("<");
          do {
            let defaultValue, name = parser.parseIntermediateType(Precedence.SYMBOL);
            if (name.type === "JsdocTypeOptional" && (name = name.element, defaultValue = parser.parseType(Precedence.SYMBOL)), name.type !== "JsdocTypeName")
              throw new UnexpectedTypeError(name);
            let constraint;
            parser.consume("extends") && (constraint = parser.parseType(Precedence.SYMBOL), constraint.type === "JsdocTypeOptional" && (constraint = constraint.element, defaultValue = parser.parseType(Precedence.SYMBOL)));
            let typeParameter = {
              type: "JsdocTypeTypeParameter",
              name
            };
            if (constraint !== void 0 && (typeParameter.constraint = constraint), defaultValue !== void 0 && (typeParameter.defaultValue = defaultValue), typeParameters.push(typeParameter), parser.consume(">"))
              break;
          } while (parser.consume(","));
          let functionBase = parser.parseIntermediateType(Precedence.SYMBOL);
          return functionBase.typeParameters = typeParameters, functionBase;
        }
      }), intersectionParslet = composeParslet({
        name: "intersectionParslet",
        accept: (type5) => type5 === "&",
        precedence: Precedence.INTERSECTION,
        parseInfix: (parser, left) => {
          parser.consume("&");
          let elements = [];
          do
            elements.push(parser.parseType(Precedence.INTERSECTION));
          while (parser.consume("&"));
          return {
            type: "JsdocTypeIntersection",
            elements: [assertRootResult(left), ...elements]
          };
        }
      }), predicateParslet = composeParslet({
        name: "predicateParslet",
        precedence: Precedence.INFIX,
        accept: (type5) => type5 === "is",
        parseInfix: (parser, left) => {
          if (left.type !== "JsdocTypeName")
            throw new UnexpectedTypeError(left, "A typescript predicate always has to have a name on the left side.");
          return parser.consume("is"), {
            type: "JsdocTypePredicate",
            left,
            right: assertRootResult(parser.parseIntermediateType(Precedence.INFIX))
          };
        }
      }), objectSquaredPropertyParslet = composeParslet({
        name: "objectSquareBracketPropertyParslet",
        accept: (type5) => type5 === "[",
        parsePrefix: (parser) => {
          if (parser.baseParser === void 0)
            throw new Error("Only allowed inside object grammar");
          parser.consume("[");
          let key = parser.lexer.current.text;
          parser.consume("Identifier");
          let result;
          if (parser.consume(":")) {
            let parentParser = parser.baseParser;
            parentParser.acceptLexerState(parser), result = {
              type: "JsdocTypeIndexSignature",
              key,
              right: parentParser.parseType(Precedence.INDEX_BRACKETS)
            }, parser.acceptLexerState(parentParser);
          } else if (parser.consume("in")) {
            let parentParser = parser.baseParser;
            parentParser.acceptLexerState(parser), result = {
              type: "JsdocTypeMappedType",
              key,
              right: parentParser.parseType(Precedence.ARRAY_BRACKETS)
            }, parser.acceptLexerState(parentParser);
          } else
            throw new Error("Missing ':' or 'in' inside square bracketed property.");
          if (!parser.consume("]"))
            throw new Error("Unterminated square brackets");
          return result;
        }
      }), readonlyArrayParslet = composeParslet({
        name: "readonlyArrayParslet",
        accept: (type5) => type5 === "readonly",
        parsePrefix: (parser) => (parser.consume("readonly"), {
          type: "JsdocTypeReadonlyArray",
          element: assertArrayOrTupleResult(parser.parseIntermediateType(Precedence.ALL))
        })
      }), conditionalParslet = composeParslet({
        name: "conditionalParslet",
        precedence: Precedence.INFIX,
        accept: (type5) => type5 === "extends",
        parseInfix: (parser, left) => {
          parser.consume("extends");
          let extendsType = parser.parseType(Precedence.KEY_OF_TYPE_OF).element, trueType = parser.parseType(Precedence.INFIX);
          return parser.consume(":"), {
            type: "JsdocTypeConditional",
            checksType: assertRootResult(left),
            extendsType,
            trueType,
            falseType: parser.parseType(Precedence.INFIX)
          };
        }
      }), objectFieldGrammar = [
        readonlyPropertyParslet,
        createNameParslet({
          allowedAdditionalTokens: ["typeof", "module", "keyof", "event", "external", "in"]
        }),
        nullableParslet,
        optionalParslet,
        stringValueParslet,
        numberParslet,
        createObjectFieldParslet({
          allowSquaredProperties: !0,
          allowKeyTypes: !1,
          allowOptional: !0,
          allowReadonly: !0
        }),
        objectSquaredPropertyParslet
      ], typescriptGrammar = [
        ...baseGrammar,
        createObjectParslet({
          allowKeyTypes: !1,
          objectFieldGrammar
        }),
        readonlyArrayParslet,
        typeOfParslet,
        keyOfParslet,
        importParslet,
        stringValueParslet,
        createFunctionParslet({
          allowWithoutParenthesis: !0,
          allowNoReturnType: !1,
          allowNamedParameters: ["this", "new", "args"],
          allowNewAsFunctionKeyword: !0
        }),
        createTupleParslet({
          allowQuestionMark: !1
        }),
        createVariadicParslet({
          allowEnclosingBrackets: !1,
          allowPostfix: !1
        }),
        assertsParslet,
        conditionalParslet,
        createNameParslet({
          allowedAdditionalTokens: ["event", "external", "in"]
        }),
        createSpecialNamePathParslet({
          allowedTypes: ["module"],
          pathGrammar
        }),
        arrayBracketsParslet,
        arrowFunctionParslet,
        genericArrowFunctionParslet,
        createNamePathParslet({
          allowSquareBracketsOnAnyType: !0,
          allowJsdocNamePaths: !1,
          pathGrammar
        }),
        intersectionParslet,
        predicateParslet,
        createKeyValueParslet({
          allowVariadic: !0,
          allowOptional: !0
        })
      ];
      function parse6(expression, mode) {
        switch (mode) {
          case "closure":
            return new Parser(closureGrammar, expression).parse();
          case "jsdoc":
            return new Parser(jsdocGrammar, expression).parse();
          case "typescript":
            return new Parser(typescriptGrammar, expression).parse();
        }
      }
      function tryParse(expression, modes = ["typescript", "closure", "jsdoc"]) {
        let error;
        for (let mode of modes)
          try {
            return parse6(expression, mode);
          } catch (e2) {
            error = e2;
          }
        throw error;
      }
      function transform(rules2, parseResult) {
        let rule = rules2[parseResult.type];
        if (rule === void 0)
          throw new Error(`In this set of transform rules exists no rule for type ${parseResult.type}.`);
        return rule(parseResult, (aParseResult) => transform(rules2, aParseResult));
      }
      function notAvailableTransform(parseResult) {
        throw new Error("This transform is not available. Are you trying the correct parsing mode?");
      }
      function extractSpecialParams(source) {
        let result = {
          params: []
        };
        for (let param of source.parameters)
          param.type === "JsdocTypeKeyValue" ? param.key === "this" ? result.this = param.right : param.key === "new" ? result.new = param.right : result.params.push(param) : result.params.push(param);
        return result;
      }
      function applyPosition(position, target, value) {
        return position === "prefix" ? value + target : target + value;
      }
      function quote(value, quote2) {
        switch (quote2) {
          case "double":
            return `"${value}"`;
          case "single":
            return `'${value}'`;
          case void 0:
            return value;
        }
      }
      function stringifyRules2() {
        return {
          JsdocTypeParenthesis: (result, transform2) => `(${result.element !== void 0 ? transform2(result.element) : ""})`,
          JsdocTypeKeyof: (result, transform2) => `keyof ${transform2(result.element)}`,
          JsdocTypeFunction: (result, transform2) => {
            var _a3;
            if (result.arrow) {
              if (result.returnType === void 0)
                throw new Error("Arrow function needs a return type.");
              let stringified = `${result.typeParameters !== void 0 ? `<${(_a3 = result.typeParameters.map(transform2).join(", ")) !== null && _a3 !== void 0 ? _a3 : ""}>` : ""}(${result.parameters.map(transform2).join(", ")}) => ${transform2(result.returnType)}`;
              return result.constructor && (stringified = "new " + stringified), stringified;
            } else {
              let stringified = result.constructor ? "new" : "function";
              return result.parenthesis && (stringified += `(${result.parameters.map(transform2).join(", ")})`, result.returnType !== void 0 && (stringified += `: ${transform2(result.returnType)}`)), stringified;
            }
          },
          JsdocTypeName: (result) => result.value,
          JsdocTypeTuple: (result, transform2) => `[${result.elements.map(transform2).join(", ")}]`,
          JsdocTypeVariadic: (result, transform2) => result.meta.position === void 0 ? "..." : applyPosition(result.meta.position, transform2(result.element), "..."),
          JsdocTypeNamePath: (result, transform2) => {
            let left = transform2(result.left), right = transform2(result.right);
            switch (result.pathType) {
              case "inner":
                return `${left}~${right}`;
              case "instance":
                return `${left}#${right}`;
              case "property":
                return `${left}.${right}`;
              case "property-brackets":
                return `${left}[${right}]`;
            }
          },
          JsdocTypeStringValue: (result) => quote(result.value, result.meta.quote),
          JsdocTypeAny: () => "*",
          JsdocTypeGeneric: (result, transform2) => {
            if (result.meta.brackets === "square") {
              let element = result.elements[0], transformed = transform2(element);
              return element.type === "JsdocTypeUnion" || element.type === "JsdocTypeIntersection" ? `(${transformed})[]` : `${transformed}[]`;
            } else
              return `${transform2(result.left)}${result.meta.dot ? "." : ""}<${result.infer === !0 ? "infer " : ""}${result.elements.map(transform2).join(", ")}>`;
          },
          JsdocTypeImport: (result, transform2) => `import(${transform2(result.element)})`,
          JsdocTypeObjectField: (result, transform2) => {
            let text = "";
            return result.readonly && (text += "readonly "), typeof result.key == "string" ? text += quote(result.key, result.meta.quote) : text += transform2(result.key), result.optional && (text += "?"), result.right === void 0 ? text : text + `: ${transform2(result.right)}`;
          },
          JsdocTypeJsdocObjectField: (result, transform2) => `${transform2(result.left)}: ${transform2(result.right)}`,
          JsdocTypeKeyValue: (result, transform2) => {
            let text = result.key;
            return result.optional && (text += "?"), result.variadic && (text = "..." + text), result.right === void 0 ? text : text + `: ${transform2(result.right)}`;
          },
          JsdocTypeSpecialNamePath: (result) => `${result.specialType}:${quote(result.value, result.meta.quote)}`,
          JsdocTypeNotNullable: (result, transform2) => applyPosition(result.meta.position, transform2(result.element), "!"),
          JsdocTypeNull: () => "null",
          JsdocTypeNullable: (result, transform2) => applyPosition(result.meta.position, transform2(result.element), "?"),
          JsdocTypeNumber: (result) => result.value.toString(),
          JsdocTypeObject: (result, transform2) => {
            var _a3, _b;
            return `{${(result.meta.separator === "linebreak" && result.elements.length > 1 ? `
` + ((_a3 = result.meta.propertyIndent) !== null && _a3 !== void 0 ? _a3 : "") : "") + result.elements.map(transform2).join(result.meta.separator === "comma" ? ", " : result.meta.separator === "linebreak" ? `
` + ((_b = result.meta.propertyIndent) !== null && _b !== void 0 ? _b : "") : "; ") + (result.meta.separator === "linebreak" && result.elements.length > 1 ? `
` : "")}}`;
          },
          JsdocTypeOptional: (result, transform2) => applyPosition(result.meta.position, transform2(result.element), "="),
          JsdocTypeSymbol: (result, transform2) => `${result.value}(${result.element !== void 0 ? transform2(result.element) : ""})`,
          JsdocTypeTypeof: (result, transform2) => `typeof ${transform2(result.element)}`,
          JsdocTypeUndefined: () => "undefined",
          JsdocTypeUnion: (result, transform2) => result.elements.map(transform2).join(" | "),
          JsdocTypeUnknown: () => "?",
          JsdocTypeIntersection: (result, transform2) => result.elements.map(transform2).join(" & "),
          JsdocTypeProperty: (result) => quote(result.value, result.meta.quote),
          JsdocTypePredicate: (result, transform2) => `${transform2(result.left)} is ${transform2(result.right)}`,
          JsdocTypeIndexSignature: (result, transform2) => `[${result.key}: ${transform2(result.right)}]`,
          JsdocTypeMappedType: (result, transform2) => `[${result.key} in ${transform2(result.right)}]`,
          JsdocTypeAsserts: (result, transform2) => `asserts ${transform2(result.left)} is ${transform2(result.right)}`,
          JsdocTypeReadonlyArray: (result, transform2) => `readonly ${transform2(result.element)}`,
          JsdocTypeAssertsPlain: (result, transform2) => `asserts ${transform2(result.element)}`,
          JsdocTypeConditional: (result, transform2) => `${transform2(result.checksType)} extends ${transform2(result.extendsType)} ? ${transform2(result.trueType)} : ${transform2(result.falseType)}`,
          JsdocTypeTypeParameter: (result, transform2) => `${transform2(result.name)}${result.constraint !== void 0 ? ` extends ${transform2(result.constraint)}` : ""}${result.defaultValue !== void 0 ? ` = ${transform2(result.defaultValue)}` : ""}`
        };
      }
      let storedStringifyRules = stringifyRules2();
      function stringify5(result) {
        return transform(storedStringifyRules, result);
      }
      let reservedWords2 = [
        "null",
        "true",
        "false",
        "break",
        "case",
        "catch",
        "class",
        "const",
        "continue",
        "debugger",
        "default",
        "delete",
        "do",
        "else",
        "export",
        "extends",
        "finally",
        "for",
        "function",
        "if",
        "import",
        "in",
        "instanceof",
        "new",
        "return",
        "super",
        "switch",
        "this",
        "throw",
        "try",
        "typeof",
        "var",
        "void",
        "while",
        "with",
        "yield"
      ];
      function makeName(value) {
        let result = {
          type: "NameExpression",
          name: value
        };
        return reservedWords2.includes(value) && (result.reservedWord = !0), result;
      }
      let catharsisTransformRules = {
        JsdocTypeOptional: (result, transform2) => {
          let transformed = transform2(result.element);
          return transformed.optional = !0, transformed;
        },
        JsdocTypeNullable: (result, transform2) => {
          let transformed = transform2(result.element);
          return transformed.nullable = !0, transformed;
        },
        JsdocTypeNotNullable: (result, transform2) => {
          let transformed = transform2(result.element);
          return transformed.nullable = !1, transformed;
        },
        JsdocTypeVariadic: (result, transform2) => {
          if (result.element === void 0)
            throw new Error("dots without value are not allowed in catharsis mode");
          let transformed = transform2(result.element);
          return transformed.repeatable = !0, transformed;
        },
        JsdocTypeAny: () => ({
          type: "AllLiteral"
        }),
        JsdocTypeNull: () => ({
          type: "NullLiteral"
        }),
        JsdocTypeStringValue: (result) => makeName(quote(result.value, result.meta.quote)),
        JsdocTypeUndefined: () => ({
          type: "UndefinedLiteral"
        }),
        JsdocTypeUnknown: () => ({
          type: "UnknownLiteral"
        }),
        JsdocTypeFunction: (result, transform2) => {
          let params = extractSpecialParams(result), transformed = {
            type: "FunctionType",
            params: params.params.map(transform2)
          };
          return params.this !== void 0 && (transformed.this = transform2(params.this)), params.new !== void 0 && (transformed.new = transform2(params.new)), result.returnType !== void 0 && (transformed.result = transform2(result.returnType)), transformed;
        },
        JsdocTypeGeneric: (result, transform2) => ({
          type: "TypeApplication",
          applications: result.elements.map((o2) => transform2(o2)),
          expression: transform2(result.left)
        }),
        JsdocTypeSpecialNamePath: (result) => makeName(result.specialType + ":" + quote(result.value, result.meta.quote)),
        JsdocTypeName: (result) => result.value !== "function" ? makeName(result.value) : {
          type: "FunctionType",
          params: []
        },
        JsdocTypeNumber: (result) => makeName(result.value.toString()),
        JsdocTypeObject: (result, transform2) => {
          let transformed = {
            type: "RecordType",
            fields: []
          };
          for (let field of result.elements)
            field.type !== "JsdocTypeObjectField" && field.type !== "JsdocTypeJsdocObjectField" ? transformed.fields.push({
              type: "FieldType",
              key: transform2(field),
              value: void 0
            }) : transformed.fields.push(transform2(field));
          return transformed;
        },
        JsdocTypeObjectField: (result, transform2) => {
          if (typeof result.key != "string")
            throw new Error("Index signatures and mapped types are not supported");
          return {
            type: "FieldType",
            key: makeName(quote(result.key, result.meta.quote)),
            value: result.right === void 0 ? void 0 : transform2(result.right)
          };
        },
        JsdocTypeJsdocObjectField: (result, transform2) => ({
          type: "FieldType",
          key: transform2(result.left),
          value: transform2(result.right)
        }),
        JsdocTypeUnion: (result, transform2) => ({
          type: "TypeUnion",
          elements: result.elements.map((e2) => transform2(e2))
        }),
        JsdocTypeKeyValue: (result, transform2) => ({
          type: "FieldType",
          key: makeName(result.key),
          value: result.right === void 0 ? void 0 : transform2(result.right)
        }),
        JsdocTypeNamePath: (result, transform2) => {
          let leftResult = transform2(result.left), rightValue;
          result.right.type === "JsdocTypeSpecialNamePath" ? rightValue = transform2(result.right).name : rightValue = quote(result.right.value, result.right.meta.quote);
          let joiner = result.pathType === "inner" ? "~" : result.pathType === "instance" ? "#" : ".";
          return makeName(`${leftResult.name}${joiner}${rightValue}`);
        },
        JsdocTypeSymbol: (result) => {
          let value = "", element = result.element, trailingDots = !1;
          return element?.type === "JsdocTypeVariadic" && (element.meta.position === "prefix" ? value = "..." : trailingDots = !0, element = element.element), element?.type === "JsdocTypeName" ? value += element.value : element?.type === "JsdocTypeNumber" && (value += element.value.toString()), trailingDots && (value += "..."), makeName(`${result.value}(${value})`);
        },
        JsdocTypeParenthesis: (result, transform2) => transform2(assertRootResult(result.element)),
        JsdocTypeMappedType: notAvailableTransform,
        JsdocTypeIndexSignature: notAvailableTransform,
        JsdocTypeImport: notAvailableTransform,
        JsdocTypeKeyof: notAvailableTransform,
        JsdocTypeTuple: notAvailableTransform,
        JsdocTypeTypeof: notAvailableTransform,
        JsdocTypeIntersection: notAvailableTransform,
        JsdocTypeProperty: notAvailableTransform,
        JsdocTypePredicate: notAvailableTransform,
        JsdocTypeAsserts: notAvailableTransform,
        JsdocTypeReadonlyArray: notAvailableTransform,
        JsdocTypeAssertsPlain: notAvailableTransform,
        JsdocTypeConditional: notAvailableTransform,
        JsdocTypeTypeParameter: notAvailableTransform
      };
      function catharsisTransform(result) {
        return transform(catharsisTransformRules, result);
      }
      function getQuoteStyle(quote2) {
        switch (quote2) {
          case void 0:
            return "none";
          case "single":
            return "single";
          case "double":
            return "double";
        }
      }
      function getMemberType(type5) {
        switch (type5) {
          case "inner":
            return "INNER_MEMBER";
          case "instance":
            return "INSTANCE_MEMBER";
          case "property":
            return "MEMBER";
          case "property-brackets":
            return "MEMBER";
        }
      }
      function nestResults(type5, results) {
        return results.length === 2 ? {
          type: type5,
          left: results[0],
          right: results[1]
        } : {
          type: type5,
          left: results[0],
          right: nestResults(type5, results.slice(1))
        };
      }
      let jtpRules = {
        JsdocTypeOptional: (result, transform2) => ({
          type: "OPTIONAL",
          value: transform2(result.element),
          meta: {
            syntax: result.meta.position === "prefix" ? "PREFIX_EQUAL_SIGN" : "SUFFIX_EQUALS_SIGN"
          }
        }),
        JsdocTypeNullable: (result, transform2) => ({
          type: "NULLABLE",
          value: transform2(result.element),
          meta: {
            syntax: result.meta.position === "prefix" ? "PREFIX_QUESTION_MARK" : "SUFFIX_QUESTION_MARK"
          }
        }),
        JsdocTypeNotNullable: (result, transform2) => ({
          type: "NOT_NULLABLE",
          value: transform2(result.element),
          meta: {
            syntax: result.meta.position === "prefix" ? "PREFIX_BANG" : "SUFFIX_BANG"
          }
        }),
        JsdocTypeVariadic: (result, transform2) => {
          let transformed = {
            type: "VARIADIC",
            meta: {
              syntax: result.meta.position === "prefix" ? "PREFIX_DOTS" : result.meta.position === "suffix" ? "SUFFIX_DOTS" : "ONLY_DOTS"
            }
          };
          return result.element !== void 0 && (transformed.value = transform2(result.element)), transformed;
        },
        JsdocTypeName: (result) => ({
          type: "NAME",
          name: result.value
        }),
        JsdocTypeTypeof: (result, transform2) => ({
          type: "TYPE_QUERY",
          name: transform2(result.element)
        }),
        JsdocTypeTuple: (result, transform2) => ({
          type: "TUPLE",
          entries: result.elements.map(transform2)
        }),
        JsdocTypeKeyof: (result, transform2) => ({
          type: "KEY_QUERY",
          value: transform2(result.element)
        }),
        JsdocTypeImport: (result) => ({
          type: "IMPORT",
          path: {
            type: "STRING_VALUE",
            quoteStyle: getQuoteStyle(result.element.meta.quote),
            string: result.element.value
          }
        }),
        JsdocTypeUndefined: () => ({
          type: "NAME",
          name: "undefined"
        }),
        JsdocTypeAny: () => ({
          type: "ANY"
        }),
        JsdocTypeFunction: (result, transform2) => {
          let specialParams = extractSpecialParams(result), transformed = {
            type: result.arrow ? "ARROW" : "FUNCTION",
            params: specialParams.params.map((param) => {
              if (param.type === "JsdocTypeKeyValue") {
                if (param.right === void 0)
                  throw new Error("Function parameter without ':' is not expected to be 'KEY_VALUE'");
                return {
                  type: "NAMED_PARAMETER",
                  name: param.key,
                  typeName: transform2(param.right)
                };
              } else
                return transform2(param);
            }),
            new: null,
            returns: null
          };
          return specialParams.this !== void 0 ? transformed.this = transform2(specialParams.this) : result.arrow || (transformed.this = null), specialParams.new !== void 0 && (transformed.new = transform2(specialParams.new)), result.returnType !== void 0 && (transformed.returns = transform2(result.returnType)), transformed;
        },
        JsdocTypeGeneric: (result, transform2) => {
          let transformed = {
            type: "GENERIC",
            subject: transform2(result.left),
            objects: result.elements.map(transform2),
            meta: {
              syntax: result.meta.brackets === "square" ? "SQUARE_BRACKET" : result.meta.dot ? "ANGLE_BRACKET_WITH_DOT" : "ANGLE_BRACKET"
            }
          };
          return result.meta.brackets === "square" && result.elements[0].type === "JsdocTypeFunction" && !result.elements[0].parenthesis && (transformed.objects[0] = {
            type: "NAME",
            name: "function"
          }), transformed;
        },
        JsdocTypeObjectField: (result, transform2) => {
          if (typeof result.key != "string")
            throw new Error("Index signatures and mapped types are not supported");
          if (result.right === void 0)
            return {
              type: "RECORD_ENTRY",
              key: result.key,
              quoteStyle: getQuoteStyle(result.meta.quote),
              value: null,
              readonly: !1
            };
          let right = transform2(result.right);
          return result.optional && (right = {
            type: "OPTIONAL",
            value: right,
            meta: {
              syntax: "SUFFIX_KEY_QUESTION_MARK"
            }
          }), {
            type: "RECORD_ENTRY",
            key: result.key.toString(),
            quoteStyle: getQuoteStyle(result.meta.quote),
            value: right,
            readonly: !1
          };
        },
        JsdocTypeJsdocObjectField: () => {
          throw new Error("Keys may not be typed in jsdoctypeparser.");
        },
        JsdocTypeKeyValue: (result, transform2) => {
          if (result.right === void 0)
            return {
              type: "RECORD_ENTRY",
              key: result.key,
              quoteStyle: "none",
              value: null,
              readonly: !1
            };
          let right = transform2(result.right);
          return result.optional && (right = {
            type: "OPTIONAL",
            value: right,
            meta: {
              syntax: "SUFFIX_KEY_QUESTION_MARK"
            }
          }), {
            type: "RECORD_ENTRY",
            key: result.key,
            quoteStyle: "none",
            value: right,
            readonly: !1
          };
        },
        JsdocTypeObject: (result, transform2) => {
          let entries = [];
          for (let field of result.elements)
            (field.type === "JsdocTypeObjectField" || field.type === "JsdocTypeJsdocObjectField") && entries.push(transform2(field));
          return {
            type: "RECORD",
            entries
          };
        },
        JsdocTypeSpecialNamePath: (result) => {
          if (result.specialType !== "module")
            throw new Error(`jsdoctypeparser does not support type ${result.specialType} at this point.`);
          return {
            type: "MODULE",
            value: {
              type: "FILE_PATH",
              quoteStyle: getQuoteStyle(result.meta.quote),
              path: result.value
            }
          };
        },
        JsdocTypeNamePath: (result, transform2) => {
          let hasEventPrefix = !1, name, quoteStyle;
          result.right.type === "JsdocTypeSpecialNamePath" && result.right.specialType === "event" ? (hasEventPrefix = !0, name = result.right.value, quoteStyle = getQuoteStyle(result.right.meta.quote)) : (name = result.right.value, quoteStyle = getQuoteStyle(result.right.meta.quote));
          let transformed = {
            type: getMemberType(result.pathType),
            owner: transform2(result.left),
            name,
            quoteStyle,
            hasEventPrefix
          };
          if (transformed.owner.type === "MODULE") {
            let tModule = transformed.owner;
            return transformed.owner = transformed.owner.value, tModule.value = transformed, tModule;
          } else
            return transformed;
        },
        JsdocTypeUnion: (result, transform2) => nestResults("UNION", result.elements.map(transform2)),
        JsdocTypeParenthesis: (result, transform2) => ({
          type: "PARENTHESIS",
          value: transform2(assertRootResult(result.element))
        }),
        JsdocTypeNull: () => ({
          type: "NAME",
          name: "null"
        }),
        JsdocTypeUnknown: () => ({
          type: "UNKNOWN"
        }),
        JsdocTypeStringValue: (result) => ({
          type: "STRING_VALUE",
          quoteStyle: getQuoteStyle(result.meta.quote),
          string: result.value
        }),
        JsdocTypeIntersection: (result, transform2) => nestResults("INTERSECTION", result.elements.map(transform2)),
        JsdocTypeNumber: (result) => ({
          type: "NUMBER_VALUE",
          number: result.value.toString()
        }),
        JsdocTypeSymbol: notAvailableTransform,
        JsdocTypeProperty: notAvailableTransform,
        JsdocTypePredicate: notAvailableTransform,
        JsdocTypeMappedType: notAvailableTransform,
        JsdocTypeIndexSignature: notAvailableTransform,
        JsdocTypeAsserts: notAvailableTransform,
        JsdocTypeReadonlyArray: notAvailableTransform,
        JsdocTypeAssertsPlain: notAvailableTransform,
        JsdocTypeConditional: notAvailableTransform,
        JsdocTypeTypeParameter: notAvailableTransform
      };
      function jtpTransform(result) {
        return transform(jtpRules, result);
      }
      function identityTransformRules() {
        return {
          JsdocTypeIntersection: (result, transform2) => ({
            type: "JsdocTypeIntersection",
            elements: result.elements.map(transform2)
          }),
          JsdocTypeGeneric: (result, transform2) => ({
            type: "JsdocTypeGeneric",
            left: transform2(result.left),
            elements: result.elements.map(transform2),
            meta: {
              dot: result.meta.dot,
              brackets: result.meta.brackets
            }
          }),
          JsdocTypeNullable: (result) => result,
          JsdocTypeUnion: (result, transform2) => ({
            type: "JsdocTypeUnion",
            elements: result.elements.map(transform2)
          }),
          JsdocTypeUnknown: (result) => result,
          JsdocTypeUndefined: (result) => result,
          JsdocTypeTypeof: (result, transform2) => ({
            type: "JsdocTypeTypeof",
            element: transform2(result.element)
          }),
          JsdocTypeSymbol: (result, transform2) => {
            let transformed = {
              type: "JsdocTypeSymbol",
              value: result.value
            };
            return result.element !== void 0 && (transformed.element = transform2(result.element)), transformed;
          },
          JsdocTypeOptional: (result, transform2) => ({
            type: "JsdocTypeOptional",
            element: transform2(result.element),
            meta: {
              position: result.meta.position
            }
          }),
          JsdocTypeObject: (result, transform2) => ({
            type: "JsdocTypeObject",
            meta: {
              separator: "comma"
            },
            elements: result.elements.map(transform2)
          }),
          JsdocTypeNumber: (result) => result,
          JsdocTypeNull: (result) => result,
          JsdocTypeNotNullable: (result, transform2) => ({
            type: "JsdocTypeNotNullable",
            element: transform2(result.element),
            meta: {
              position: result.meta.position
            }
          }),
          JsdocTypeSpecialNamePath: (result) => result,
          JsdocTypeObjectField: (result, transform2) => ({
            type: "JsdocTypeObjectField",
            key: result.key,
            right: result.right === void 0 ? void 0 : transform2(result.right),
            optional: result.optional,
            readonly: result.readonly,
            meta: result.meta
          }),
          JsdocTypeJsdocObjectField: (result, transform2) => ({
            type: "JsdocTypeJsdocObjectField",
            left: transform2(result.left),
            right: transform2(result.right)
          }),
          JsdocTypeKeyValue: (result, transform2) => ({
            type: "JsdocTypeKeyValue",
            key: result.key,
            right: result.right === void 0 ? void 0 : transform2(result.right),
            optional: result.optional,
            variadic: result.variadic
          }),
          JsdocTypeImport: (result, transform2) => ({
            type: "JsdocTypeImport",
            element: transform2(result.element)
          }),
          JsdocTypeAny: (result) => result,
          JsdocTypeStringValue: (result) => result,
          JsdocTypeNamePath: (result) => result,
          JsdocTypeVariadic: (result, transform2) => {
            let transformed = {
              type: "JsdocTypeVariadic",
              meta: {
                position: result.meta.position,
                squareBrackets: result.meta.squareBrackets
              }
            };
            return result.element !== void 0 && (transformed.element = transform2(result.element)), transformed;
          },
          JsdocTypeTuple: (result, transform2) => ({
            type: "JsdocTypeTuple",
            elements: result.elements.map(transform2)
          }),
          JsdocTypeName: (result) => result,
          JsdocTypeFunction: (result, transform2) => {
            let transformed = {
              type: "JsdocTypeFunction",
              arrow: result.arrow,
              parameters: result.parameters.map(transform2),
              constructor: result.constructor,
              parenthesis: result.parenthesis
            };
            return result.returnType !== void 0 && (transformed.returnType = transform2(result.returnType)), transformed;
          },
          JsdocTypeKeyof: (result, transform2) => ({
            type: "JsdocTypeKeyof",
            element: transform2(result.element)
          }),
          JsdocTypeParenthesis: (result, transform2) => ({
            type: "JsdocTypeParenthesis",
            element: transform2(result.element)
          }),
          JsdocTypeProperty: (result) => result,
          JsdocTypePredicate: (result, transform2) => ({
            type: "JsdocTypePredicate",
            left: transform2(result.left),
            right: transform2(result.right)
          }),
          JsdocTypeIndexSignature: (result, transform2) => ({
            type: "JsdocTypeIndexSignature",
            key: result.key,
            right: transform2(result.right)
          }),
          JsdocTypeMappedType: (result, transform2) => ({
            type: "JsdocTypeMappedType",
            key: result.key,
            right: transform2(result.right)
          }),
          JsdocTypeAsserts: (result, transform2) => ({
            type: "JsdocTypeAsserts",
            left: transform2(result.left),
            right: transform2(result.right)
          }),
          JsdocTypeReadonlyArray: (result, transform2) => ({
            type: "JsdocTypeReadonlyArray",
            element: transform2(result.element)
          }),
          JsdocTypeAssertsPlain: (result, transform2) => ({
            type: "JsdocTypeAssertsPlain",
            element: transform2(result.element)
          }),
          JsdocTypeConditional: (result, transform2) => ({
            type: "JsdocTypeConditional",
            checksType: transform2(result.checksType),
            extendsType: transform2(result.extendsType),
            trueType: transform2(result.trueType),
            falseType: transform2(result.falseType)
          }),
          JsdocTypeTypeParameter: (result, transform2) => ({
            type: "JsdocTypeTypeParameter",
            name: transform2(result.name),
            constraint: result.constraint !== void 0 ? transform2(result.constraint) : void 0,
            defaultValue: result.defaultValue !== void 0 ? transform2(result.defaultValue) : void 0
          })
        };
      }
      let visitorKeys = {
        JsdocTypeAny: [],
        JsdocTypeFunction: ["parameters", "returnType"],
        JsdocTypeGeneric: ["left", "elements"],
        JsdocTypeImport: [],
        JsdocTypeIndexSignature: ["right"],
        JsdocTypeIntersection: ["elements"],
        JsdocTypeKeyof: ["element"],
        JsdocTypeKeyValue: ["right"],
        JsdocTypeMappedType: ["right"],
        JsdocTypeName: [],
        JsdocTypeNamePath: ["left", "right"],
        JsdocTypeNotNullable: ["element"],
        JsdocTypeNull: [],
        JsdocTypeNullable: ["element"],
        JsdocTypeNumber: [],
        JsdocTypeObject: ["elements"],
        JsdocTypeObjectField: ["right"],
        JsdocTypeJsdocObjectField: ["left", "right"],
        JsdocTypeOptional: ["element"],
        JsdocTypeParenthesis: ["element"],
        JsdocTypeSpecialNamePath: [],
        JsdocTypeStringValue: [],
        JsdocTypeSymbol: ["element"],
        JsdocTypeTuple: ["elements"],
        JsdocTypeTypeof: ["element"],
        JsdocTypeUndefined: [],
        JsdocTypeUnion: ["elements"],
        JsdocTypeUnknown: [],
        JsdocTypeVariadic: ["element"],
        JsdocTypeProperty: [],
        JsdocTypePredicate: ["left", "right"],
        JsdocTypeAsserts: ["left", "right"],
        JsdocTypeReadonlyArray: ["element"],
        JsdocTypeAssertsPlain: ["element"],
        JsdocTypeConditional: ["checksType", "extendsType", "trueType", "falseType"],
        JsdocTypeTypeParameter: ["name", "constraint", "defaultValue"]
      };
      function _traverse(node, parentNode, property, onEnter, onLeave) {
        onEnter?.(node, parentNode, property);
        let keysToVisit = visitorKeys[node.type];
        for (let key of keysToVisit) {
          let value = node[key];
          if (value !== void 0)
            if (Array.isArray(value))
              for (let element of value)
                _traverse(element, node, key, onEnter, onLeave);
            else
              _traverse(value, node, key, onEnter, onLeave);
        }
        onLeave?.(node, parentNode, property);
      }
      function traverse(node, onEnter, onLeave) {
        _traverse(node, void 0, void 0, onEnter, onLeave);
      }
      exports2.catharsisTransform = catharsisTransform, exports2.identityTransformRules = identityTransformRules, exports2.jtpTransform = jtpTransform, exports2.parse = parse6, exports2.stringify = stringify5, exports2.stringifyRules = stringifyRules2, exports2.transform = transform, exports2.traverse = traverse, exports2.tryParse = tryParse, exports2.visitorKeys = visitorKeys;
    }));
  }
});

// ../node_modules/browser-dtector/browser-dtector.umd.min.js
var require_browser_dtector_umd_min = __commonJS({
  "../node_modules/browser-dtector/browser-dtector.umd.min.js"(exports, module2) {
    (function(e2, o2) {
      typeof exports == "object" && typeof module2 < "u" ? module2.exports = o2() : typeof define == "function" && define.amd ? define(o2) : (e2 = typeof globalThis < "u" ? globalThis : e2 || self).BrowserDetector = o2();
    })(exports, (function() {
      "use strict";
      function e2(e3, o3) {
        for (var r3 = 0; r3 < o3.length; r3++) {
          var n3 = o3[r3];
          n3.enumerable = n3.enumerable || !1, n3.configurable = !0, "value" in n3 && (n3.writable = !0), Object.defineProperty(e3, (i3 = n3.key, t3 = void 0, typeof (t3 = (function(e4, o4) {
            if (typeof e4 != "object" || e4 === null) return e4;
            var r4 = e4[Symbol.toPrimitive];
            if (r4 !== void 0) {
              var n4 = r4.call(e4, o4 || "default");
              if (typeof n4 != "object") return n4;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return (o4 === "string" ? String : Number)(e4);
          })(i3, "string")) == "symbol" ? t3 : String(t3)), n3);
        }
        var i3, t3;
      }
      var o2 = { chrome: "Google Chrome", brave: "Brave", crios: "Google Chrome", edge: "Microsoft Edge", edg: "Microsoft Edge", edgios: "Microsoft Edge", fennec: "Mozilla Firefox", jsdom: "JsDOM", mozilla: "Mozilla Firefox", fxios: "Mozilla Firefox", msie: "Microsoft Internet Explorer", opera: "Opera", opios: "Opera", opr: "Opera", opt: "Opera", rv: "Microsoft Internet Explorer", safari: "Safari", samsungbrowser: "Samsung Browser", electron: "Electron" }, r2 = { android: "Android", androidTablet: "Android Tablet", cros: "Chrome OS", fennec: "Android Tablet", ipad: "IPad", iphone: "IPhone", jsdom: "JsDOM", linux: "Linux", mac: "Macintosh", tablet: "Android Tablet", win: "Windows", "windows phone": "Windows Phone", xbox: "Microsoft Xbox" }, n2 = function(e3) {
        var o3 = new RegExp("^-?\\d+(?:.\\d{0,".concat(arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1, "})?")), r3 = Number(e3).toString().match(o3);
        return r3 ? r3[0] : null;
      }, i2 = function() {
        return typeof window < "u" ? window.navigator : null;
      }, t2 = (function() {
        function t3(e3) {
          var o3;
          (function(e4, o4) {
            if (!(e4 instanceof o4)) throw new TypeError("Cannot call a class as a function");
          })(this, t3), this.userAgent = e3 || ((o3 = i2()) === null || o3 === void 0 ? void 0 : o3.userAgent) || null;
        }
        var a2, l2, s3;
        return a2 = t3, l2 = [{ key: "parseUserAgent", value: function(e3) {
          var t4, a3, l3, s4 = {}, c2 = e3 || this.userAgent || "", d = c2.toLowerCase().replace(/\s\s+/g, " "), u3 = /(edge)\/([\w.]+)/.exec(d) || /(edg)[/]([\w.]+)/.exec(d) || /(opr)[/]([\w.]+)/.exec(d) || /(opt)[/]([\w.]+)/.exec(d) || /(fxios)[/]([\w.]+)/.exec(d) || /(edgios)[/]([\w.]+)/.exec(d) || /(jsdom)[/]([\w.]+)/.exec(d) || /(samsungbrowser)[/]([\w.]+)/.exec(d) || /(electron)[/]([\w.]+)/.exec(d) || /(chrome)[/]([\w.]+)/.exec(d) || /(crios)[/]([\w.]+)/.exec(d) || /(opios)[/]([\w.]+)/.exec(d) || /(version)(applewebkit)[/]([\w.]+).*(safari)[/]([\w.]+)/.exec(d) || /(webkit)[/]([\w.]+).*(version)[/]([\w.]+).*(safari)[/]([\w.]+)/.exec(d) || /(applewebkit)[/]([\w.]+).*(safari)[/]([\w.]+)/.exec(d) || /(webkit)[/]([\w.]+)/.exec(d) || /(opera)(?:.*version|)[/]([\w.]+)/.exec(d) || /(msie) ([\w.]+)/.exec(d) || /(fennec)[/]([\w.]+)/.exec(d) || d.indexOf("trident") >= 0 && /(rv)(?::| )([\w.]+)/.exec(d) || d.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(d) || [], f4 = /(ipad)/.exec(d) || /(ipod)/.exec(d) || /(iphone)/.exec(d) || /(jsdom)/.exec(d) || /(windows phone)/.exec(d) || /(xbox)/.exec(d) || /(win)/.exec(d) || /(tablet)/.exec(d) || /(android)/.test(d) && /(mobile)/.test(d) === !1 && ["androidTablet"] || /(android)/.exec(d) || /(mac)/.exec(d) || /(linux)/.exec(d) || /(cros)/.exec(d) || [], p2 = u3[5] || u3[3] || u3[1] || null, w2 = f4[0] || null, x2 = u3[4] || u3[2] || null, b2 = i2();
          p2 === "chrome" && typeof (b2 == null || (t4 = b2.brave) === null || t4 === void 0 ? void 0 : t4.isBrave) == "function" && (p2 = "brave"), p2 && (s4[p2] = !0), w2 && (s4[w2] = !0);
          var v2 = !!(s4.tablet || s4.android || s4.androidTablet), m3 = !!(s4.ipad || s4.tablet || s4.androidTablet), g2 = !!(s4.android || s4.androidTablet || s4.tablet || s4.ipad || s4.ipod || s4.iphone || s4["windows phone"]), h3 = !!(s4.cros || s4.mac || s4.linux || s4.win), y2 = !!(s4.brave || s4.chrome || s4.crios || s4.opr || s4.safari || s4.edg || s4.electron), A = !!(s4.msie || s4.rv);
          return { name: (a3 = o2[p2]) !== null && a3 !== void 0 ? a3 : null, platform: (l3 = r2[w2]) !== null && l3 !== void 0 ? l3 : null, userAgent: c2, version: x2, shortVersion: x2 ? n2(parseFloat(x2), 2) : null, isAndroid: v2, isTablet: m3, isMobile: g2, isDesktop: h3, isWebkit: y2, isIE: A };
        } }, { key: "getBrowserInfo", value: function() {
          var e3 = this.parseUserAgent();
          return { name: e3.name, platform: e3.platform, userAgent: e3.userAgent, version: e3.version, shortVersion: e3.shortVersion };
        } }], s3 = [{ key: "VERSION", get: function() {
          return "3.4.0";
        } }], l2 && e2(a2.prototype, l2), s3 && e2(a2, s3), Object.defineProperty(a2, "prototype", { writable: !1 }), t3;
      })();
      return t2;
    }));
  }
});

// src/core-events/index.ts
var core_events_exports = {};
__export(core_events_exports, {
  ARGTYPES_INFO_REQUEST: () => ARGTYPES_INFO_REQUEST,
  ARGTYPES_INFO_RESPONSE: () => ARGTYPES_INFO_RESPONSE,
  CHANNEL_CREATED: () => CHANNEL_CREATED,
  CHANNEL_WS_DISCONNECT: () => CHANNEL_WS_DISCONNECT,
  CONFIG_ERROR: () => CONFIG_ERROR,
  CREATE_NEW_STORYFILE_REQUEST: () => CREATE_NEW_STORYFILE_REQUEST,
  CREATE_NEW_STORYFILE_RESPONSE: () => CREATE_NEW_STORYFILE_RESPONSE,
  CURRENT_STORY_WAS_SET: () => CURRENT_STORY_WAS_SET,
  DOCS_PREPARED: () => DOCS_PREPARED,
  DOCS_RENDERED: () => DOCS_RENDERED,
  FILE_COMPONENT_SEARCH_REQUEST: () => FILE_COMPONENT_SEARCH_REQUEST,
  FILE_COMPONENT_SEARCH_RESPONSE: () => FILE_COMPONENT_SEARCH_RESPONSE,
  FORCE_REMOUNT: () => FORCE_REMOUNT,
  FORCE_RE_RENDER: () => FORCE_RE_RENDER,
  GLOBALS_UPDATED: () => GLOBALS_UPDATED,
  MANAGER_INERT_ATTRIBUTE_CHANGED: () => MANAGER_INERT_ATTRIBUTE_CHANGED,
  NAVIGATE_URL: () => NAVIGATE_URL,
  OPEN_IN_EDITOR_REQUEST: () => OPEN_IN_EDITOR_REQUEST,
  OPEN_IN_EDITOR_RESPONSE: () => OPEN_IN_EDITOR_RESPONSE,
  PLAY_FUNCTION_THREW_EXCEPTION: () => PLAY_FUNCTION_THREW_EXCEPTION,
  PRELOAD_ENTRIES: () => PRELOAD_ENTRIES,
  PREVIEW_BUILDER_PROGRESS: () => PREVIEW_BUILDER_PROGRESS,
  PREVIEW_INITIALIZED: () => PREVIEW_INITIALIZED,
  PREVIEW_KEYDOWN: () => PREVIEW_KEYDOWN,
  REGISTER_SUBSCRIPTION: () => REGISTER_SUBSCRIPTION,
  REQUEST_WHATS_NEW_DATA: () => REQUEST_WHATS_NEW_DATA,
  RESET_STORY_ARGS: () => RESET_STORY_ARGS,
  RESULT_WHATS_NEW_DATA: () => RESULT_WHATS_NEW_DATA,
  SAVE_STORY_REQUEST: () => SAVE_STORY_REQUEST,
  SAVE_STORY_RESPONSE: () => SAVE_STORY_RESPONSE,
  SELECT_STORY: () => SELECT_STORY,
  SET_CONFIG: () => SET_CONFIG,
  SET_CURRENT_STORY: () => SET_CURRENT_STORY,
  SET_FILTER: () => SET_FILTER,
  SET_GLOBALS: () => SET_GLOBALS,
  SET_INDEX: () => SET_INDEX,
  SET_STORIES: () => SET_STORIES,
  SET_WHATS_NEW_CACHE: () => SET_WHATS_NEW_CACHE,
  SHARED_STATE_CHANGED: () => SHARED_STATE_CHANGED,
  SHARED_STATE_SET: () => SHARED_STATE_SET,
  STORIES_COLLAPSE_ALL: () => STORIES_COLLAPSE_ALL,
  STORIES_EXPAND_ALL: () => STORIES_EXPAND_ALL,
  STORY_ARGS_UPDATED: () => STORY_ARGS_UPDATED,
  STORY_CHANGED: () => STORY_CHANGED,
  STORY_ERRORED: () => STORY_ERRORED,
  STORY_FINISHED: () => STORY_FINISHED,
  STORY_HOT_UPDATED: () => STORY_HOT_UPDATED,
  STORY_INDEX_INVALIDATED: () => STORY_INDEX_INVALIDATED,
  STORY_MISSING: () => STORY_MISSING,
  STORY_PREPARED: () => STORY_PREPARED,
  STORY_RENDERED: () => STORY_RENDERED,
  STORY_RENDER_PHASE_CHANGED: () => STORY_RENDER_PHASE_CHANGED,
  STORY_SPECIFIED: () => STORY_SPECIFIED,
  STORY_THREW_EXCEPTION: () => STORY_THREW_EXCEPTION,
  STORY_UNCHANGED: () => STORY_UNCHANGED,
  TELEMETRY_ERROR: () => TELEMETRY_ERROR,
  TOGGLE_WHATS_NEW_NOTIFICATIONS: () => TOGGLE_WHATS_NEW_NOTIFICATIONS,
  UNHANDLED_ERRORS_WHILE_PLAYING: () => UNHANDLED_ERRORS_WHILE_PLAYING,
  UPDATE_GLOBALS: () => UPDATE_GLOBALS,
  UPDATE_QUERY_PARAMS: () => UPDATE_QUERY_PARAMS,
  UPDATE_STORY_ARGS: () => UPDATE_STORY_ARGS,
  default: () => core_events_default
});
var events = /* @__PURE__ */ ((events2) => (events2.CHANNEL_WS_DISCONNECT = "channelWSDisconnect", events2.CHANNEL_CREATED = "channelCreated", events2.CONFIG_ERROR = "configError", events2.STORY_INDEX_INVALIDATED = "storyIndexInvalidated", events2.STORY_SPECIFIED = "storySpecified", events2.SET_CONFIG = "setConfig", events2.SET_STORIES = "setStories", events2.SET_INDEX = "setIndex", events2.SET_CURRENT_STORY = "setCurrentStory", events2.CURRENT_STORY_WAS_SET = "currentStoryWasSet", events2.FORCE_RE_RENDER = "forceReRender", events2.FORCE_REMOUNT = "forceRemount", events2.PRELOAD_ENTRIES = "preloadStories", events2.STORY_PREPARED = "storyPrepared", events2.DOCS_PREPARED = "docsPrepared", events2.STORY_CHANGED = "storyChanged", events2.STORY_UNCHANGED = "storyUnchanged", events2.STORY_RENDERED = "storyRendered", events2.STORY_FINISHED = "storyFinished", events2.STORY_MISSING = "storyMissing", events2.STORY_ERRORED = "storyErrored", events2.STORY_THREW_EXCEPTION = "storyThrewException", events2.STORY_RENDER_PHASE_CHANGED = "storyRenderPhaseChanged", events2.STORY_HOT_UPDATED = "storyHotUpdated", events2.PLAY_FUNCTION_THREW_EXCEPTION = "playFunctionThrewException", events2.UNHANDLED_ERRORS_WHILE_PLAYING = "unhandledErrorsWhilePlaying", events2.UPDATE_STORY_ARGS = "updateStoryArgs", events2.STORY_ARGS_UPDATED = "storyArgsUpdated", events2.RESET_STORY_ARGS = "resetStoryArgs", events2.SET_FILTER = "setFilter", events2.SET_GLOBALS = "setGlobals", events2.UPDATE_GLOBALS = "updateGlobals", events2.GLOBALS_UPDATED = "globalsUpdated", events2.REGISTER_SUBSCRIPTION = "registerSubscription", events2.PREVIEW_INITIALIZED = "previewInitialized", events2.PREVIEW_KEYDOWN = "previewKeydown", events2.PREVIEW_BUILDER_PROGRESS = "preview_builder_progress", events2.SELECT_STORY = "selectStory", events2.STORIES_COLLAPSE_ALL = "storiesCollapseAll", events2.STORIES_EXPAND_ALL = "storiesExpandAll", events2.DOCS_RENDERED = "docsRendered", events2.SHARED_STATE_CHANGED = "sharedStateChanged", events2.SHARED_STATE_SET = "sharedStateSet", events2.NAVIGATE_URL = "navigateUrl", events2.UPDATE_QUERY_PARAMS = "updateQueryParams", events2.REQUEST_WHATS_NEW_DATA = "requestWhatsNewData", events2.RESULT_WHATS_NEW_DATA = "resultWhatsNewData", events2.SET_WHATS_NEW_CACHE = "setWhatsNewCache", events2.TOGGLE_WHATS_NEW_NOTIFICATIONS = "toggleWhatsNewNotifications", events2.TELEMETRY_ERROR = "telemetryError", events2.FILE_COMPONENT_SEARCH_REQUEST = "fileComponentSearchRequest", events2.FILE_COMPONENT_SEARCH_RESPONSE = "fileComponentSearchResponse", events2.SAVE_STORY_REQUEST = "saveStoryRequest", events2.SAVE_STORY_RESPONSE = "saveStoryResponse", events2.ARGTYPES_INFO_REQUEST = "argtypesInfoRequest", events2.ARGTYPES_INFO_RESPONSE = "argtypesInfoResponse", events2.CREATE_NEW_STORYFILE_REQUEST = "createNewStoryfileRequest", events2.CREATE_NEW_STORYFILE_RESPONSE = "createNewStoryfileResponse", events2.OPEN_IN_EDITOR_REQUEST = "openInEditorRequest", events2.OPEN_IN_EDITOR_RESPONSE = "openInEditorResponse", events2.MANAGER_INERT_ATTRIBUTE_CHANGED = "managerInertAttributeChanged", events2))(events || {}), core_events_default = events, {
  CHANNEL_WS_DISCONNECT,
  CHANNEL_CREATED,
  CONFIG_ERROR,
  CREATE_NEW_STORYFILE_REQUEST,
  CREATE_NEW_STORYFILE_RESPONSE,
  CURRENT_STORY_WAS_SET,
  DOCS_PREPARED,
  DOCS_RENDERED,
  FILE_COMPONENT_SEARCH_REQUEST,
  FILE_COMPONENT_SEARCH_RESPONSE,
  FORCE_RE_RENDER,
  FORCE_REMOUNT,
  GLOBALS_UPDATED,
  NAVIGATE_URL,
  PLAY_FUNCTION_THREW_EXCEPTION,
  UNHANDLED_ERRORS_WHILE_PLAYING,
  PRELOAD_ENTRIES,
  PREVIEW_INITIALIZED,
  PREVIEW_BUILDER_PROGRESS,
  PREVIEW_KEYDOWN,
  REGISTER_SUBSCRIPTION,
  RESET_STORY_ARGS,
  SELECT_STORY,
  SET_CONFIG,
  SET_CURRENT_STORY,
  SET_FILTER,
  SET_GLOBALS,
  SET_INDEX,
  SET_STORIES,
  SHARED_STATE_CHANGED,
  SHARED_STATE_SET,
  STORIES_COLLAPSE_ALL,
  STORIES_EXPAND_ALL,
  STORY_ARGS_UPDATED,
  STORY_CHANGED,
  STORY_ERRORED,
  STORY_INDEX_INVALIDATED,
  STORY_MISSING,
  STORY_PREPARED,
  STORY_RENDER_PHASE_CHANGED,
  STORY_RENDERED,
  STORY_FINISHED,
  STORY_SPECIFIED,
  STORY_THREW_EXCEPTION,
  STORY_UNCHANGED,
  STORY_HOT_UPDATED,
  UPDATE_GLOBALS,
  UPDATE_QUERY_PARAMS,
  UPDATE_STORY_ARGS,
  REQUEST_WHATS_NEW_DATA,
  RESULT_WHATS_NEW_DATA,
  SET_WHATS_NEW_CACHE,
  TOGGLE_WHATS_NEW_NOTIFICATIONS,
  TELEMETRY_ERROR,
  SAVE_STORY_REQUEST,
  SAVE_STORY_RESPONSE,
  ARGTYPES_INFO_REQUEST,
  ARGTYPES_INFO_RESPONSE,
  OPEN_IN_EDITOR_REQUEST,
  OPEN_IN_EDITOR_RESPONSE,
  MANAGER_INERT_ATTRIBUTE_CHANGED
} = events;

// ../node_modules/@storybook/global/dist/index.mjs
var dist_exports = {};
__export(dist_exports, {
  global: () => scope
});
var scope = (() => {
  let win;
  return typeof window < "u" ? win = window : typeof globalThis < "u" ? win = globalThis : typeof global < "u" ? win = global : typeof self < "u" ? win = self : win = {}, win;
})();

// src/preview/globals/globals.ts
var globalsNameReferenceMap = {
  "@storybook/global": "__STORYBOOK_MODULE_GLOBAL__",
  "storybook/test": "__STORYBOOK_MODULE_TEST__",
  "storybook/actions": "__STORYBOOK_MODULE_ACTIONS__",
  "storybook/preview-api": "__STORYBOOK_MODULE_PREVIEW_API__",
  "storybook/internal/channels": "__STORYBOOK_MODULE_CHANNELS__",
  "storybook/internal/client-logger": "__STORYBOOK_MODULE_CLIENT_LOGGER__",
  "storybook/internal/core-events": "__STORYBOOK_MODULE_CORE_EVENTS__",
  "storybook/internal/preview-errors": "__STORYBOOK_MODULE_CORE_EVENTS_PREVIEW_ERRORS__",
  "storybook/internal/types": "__STORYBOOK_MODULE_TYPES__",
  // @deprecated TODO: Remove in 9.1 or some point in the future, I guess
  "storybook/internal/preview-api": "__STORYBOOK_MODULE_PREVIEW_API__"
}, globalPackages = Object.keys(globalsNameReferenceMap);

// src/channels/index.ts
var channels_exports = {};
__export(channels_exports, {
  Channel: () => Channel,
  HEARTBEAT_INTERVAL: () => HEARTBEAT_INTERVAL,
  HEARTBEAT_MAX_LATENCY: () => HEARTBEAT_MAX_LATENCY,
  PostMessageTransport: () => PostMessageTransport,
  WebsocketTransport: () => WebsocketTransport,
  createBrowserChannel: () => createBrowserChannel,
  default: () => channels_default
});

// ../node_modules/ts-dedent/esm/index.js
function dedent(templ) {
  for (var values = [], _i = 1; _i < arguments.length; _i++)
    values[_i - 1] = arguments[_i];
  var strings = Array.from(typeof templ == "string" ? [templ] : templ);
  strings[strings.length - 1] = strings[strings.length - 1].replace(/\r?\n([\t ]*)$/, "");
  var indentLengths = strings.reduce(function(arr, str2) {
    var matches5 = str2.match(/\n([\t ]+|(?!\s).)/g);
    return matches5 ? arr.concat(matches5.map(function(match) {
      var _a3, _b;
      return (_b = (_a3 = match.match(/[\t ]/g)) === null || _a3 === void 0 ? void 0 : _a3.length) !== null && _b !== void 0 ? _b : 0;
    })) : arr;
  }, []);
  if (indentLengths.length) {
    var pattern_1 = new RegExp(`
[	 ]{` + Math.min.apply(Math, indentLengths) + "}", "g");
    strings = strings.map(function(str2) {
      return str2.replace(pattern_1, `
`);
    });
  }
  strings[0] = strings[0].replace(/^\r?\n/, "");
  var string = strings[0];
  return values.forEach(function(value, i2) {
    var endentations = string.match(/(?:^|\n)( *)$/), endentation = endentations ? endentations[1] : "", indentedValue = value;
    typeof value == "string" && value.includes(`
`) && (indentedValue = String(value).split(`
`).map(function(str2, i3) {
      return i3 === 0 ? str2 : "" + endentation + str2;
    }).join(`
`)), string += indentedValue + strings[i2 + 1];
  }), string;
}

// src/shared/universal-store/instances.ts
var instances = /* @__PURE__ */ new Map();

// src/shared/universal-store/index.ts
var CHANNEL_EVENT_PREFIX = "UNIVERSAL_STORE:", ProgressState = {
  PENDING: "PENDING",
  RESOLVED: "RESOLVED",
  REJECTED: "REJECTED"
}, _UniversalStore = class _UniversalStore {
  constructor(options, environmentOverrides) {
    /** Enable debug logs for this store */
    this.debugging = !1;
    // TODO: narrow type of listeners based on event type
    this.listeners = /* @__PURE__ */ new Map([["*", /* @__PURE__ */ new Set()]]);
    /** Gets the current state */
    this.getState = () => (this.debug("getState", { state: this.state }), this.state);
    /**
     * Subscribes to store events
     *
     * @returns A function to unsubscribe
     */
    this.subscribe = (eventTypeOrListener, maybeListener) => {
      let subscribesToAllEvents = typeof eventTypeOrListener == "function", eventType = subscribesToAllEvents ? "*" : eventTypeOrListener, listener = subscribesToAllEvents ? eventTypeOrListener : maybeListener;
      if (this.debug("subscribe", { eventType, listener }), !listener)
        throw new TypeError(
          `Missing first subscribe argument, or second if first is the event type, when subscribing to a UniversalStore with id '${this.id}'`
        );
      return this.listeners.has(eventType) || this.listeners.set(eventType, /* @__PURE__ */ new Set()), this.listeners.get(eventType).add(listener), () => {
        this.debug("unsubscribe", { eventType, listener }), this.listeners.has(eventType) && (this.listeners.get(eventType).delete(listener), this.listeners.get(eventType)?.size === 0 && this.listeners.delete(eventType));
      };
    };
    /** Sends a custom event to the other stores */
    this.send = (event) => {
      if (this.debug("send", { event }), this.status !== _UniversalStore.Status.READY)
        throw new TypeError(
          dedent`Cannot send event before store is ready. You can get the current status with store.status,
        or await store.readyPromise to wait for the store to be ready before sending events.
        ${JSON.stringify(
            {
              event,
              id: this.id,
              actor: this.actor,
              environment: this.environment
            },
            null,
            2
          )}`
        );
      this.emitToListeners(event, { actor: this.actor }), this.emitToChannel(event, { actor: this.actor });
    };
    if (this.debugging = options.debug ?? !1, !_UniversalStore.isInternalConstructing)
      throw new TypeError(
        "UniversalStore is not constructable - use UniversalStore.create() instead"
      );
    if (_UniversalStore.isInternalConstructing = !1, this.id = options.id, this.actorId = Date.now().toString(36) + Math.random().toString(36).substring(2), this.actorType = options.leader ? _UniversalStore.ActorType.LEADER : _UniversalStore.ActorType.FOLLOWER, this.state = options.initialState, this.channelEventName = `${CHANNEL_EVENT_PREFIX}${this.id}`, this.debug("constructor", {
      options,
      environmentOverrides,
      channelEventName: this.channelEventName
    }), this.actor.type === _UniversalStore.ActorType.LEADER)
      this.syncing = {
        state: ProgressState.RESOLVED,
        promise: Promise.resolve()
      };
    else {
      let syncingResolve, syncingReject, syncingPromise = new Promise((resolve, reject) => {
        syncingResolve = () => {
          this.syncing.state === ProgressState.PENDING && (this.syncing.state = ProgressState.RESOLVED, resolve());
        }, syncingReject = (reason) => {
          this.syncing.state === ProgressState.PENDING && (this.syncing.state = ProgressState.REJECTED, reject(reason));
        };
      });
      this.syncing = {
        state: ProgressState.PENDING,
        promise: syncingPromise,
        resolve: syncingResolve,
        reject: syncingReject
      };
    }
    this.getState = this.getState.bind(this), this.setState = this.setState.bind(this), this.subscribe = this.subscribe.bind(this), this.onStateChange = this.onStateChange.bind(this), this.send = this.send.bind(this), this.emitToChannel = this.emitToChannel.bind(this), this.prepareThis = this.prepareThis.bind(this), this.emitToListeners = this.emitToListeners.bind(this), this.handleChannelEvents = this.handleChannelEvents.bind(this), this.debug = this.debug.bind(this), this.channel = environmentOverrides?.channel ?? _UniversalStore.preparation.channel, this.environment = environmentOverrides?.environment ?? _UniversalStore.preparation.environment, this.channel && this.environment ? (_UniversalStore.preparation.resolve({ channel: this.channel, environment: this.environment }), this.prepareThis({ channel: this.channel, environment: this.environment })) : _UniversalStore.preparation.promise.then(this.prepareThis);
  }
  static setupPreparationPromise() {
    let resolveRef, rejectRef, promise = new Promise(
      (resolve, reject) => {
        resolveRef = (args) => {
          resolve(args);
        }, rejectRef = (...args) => {
          reject(args);
        };
      }
    );
    _UniversalStore.preparation = {
      resolve: resolveRef,
      reject: rejectRef,
      promise
    };
  }
  /** The actor object representing the store instance with a unique ID and a type */
  get actor() {
    return Object.freeze({
      id: this.actorId,
      type: this.actorType,
      environment: this.environment ?? _UniversalStore.Environment.UNKNOWN
    });
  }
  /**
   * The current state of the store, that signals both if the store is prepared by Storybook and
   * also - in the case of a follower - if the state has been synced with the leader's state.
   */
  get status() {
    if (!this.channel || !this.environment)
      return _UniversalStore.Status.UNPREPARED;
    switch (this.syncing?.state) {
      case ProgressState.PENDING:
      case void 0:
        return _UniversalStore.Status.SYNCING;
      case ProgressState.REJECTED:
        return _UniversalStore.Status.ERROR;
      case ProgressState.RESOLVED:
      default:
        return _UniversalStore.Status.READY;
    }
  }
  /**
   * A promise that resolves when the store is fully ready. A leader will be ready when the store
   * has been prepared by Storybook, which is almost instantly.
   *
   * A follower will be ready when the state has been synced with the leader's state, within a few
   * hundred milliseconds.
   */
  untilReady() {
    return Promise.all([_UniversalStore.preparation.promise, this.syncing?.promise]);
  }
  /** Creates a new instance of UniversalStore */
  static create(options) {
    if (!options || typeof options?.id != "string")
      throw new TypeError("id is required and must be a string, when creating a UniversalStore");
    options.debug && console.debug(
      dedent`[UniversalStore]
        create`,
      { options }
    );
    let existing = instances.get(options.id);
    if (existing)
      return console.warn(dedent`UniversalStore with id "${options.id}" already exists in this environment, re-using existing.
        You should reuse the existing instance instead of trying to create a new one.`), existing;
    _UniversalStore.isInternalConstructing = !0;
    let store = new _UniversalStore(options);
    return instances.set(options.id, store), store;
  }
  /**
   * Used by Storybook to set the channel for all instances of UniversalStore in the given
   * environment.
   *
   * @internal
   */
  static __prepare(channel, environment) {
    _UniversalStore.preparation.channel = channel, _UniversalStore.preparation.environment = environment, _UniversalStore.preparation.resolve({ channel, environment });
  }
  /**
   * Updates the store's state
   *
   * Either a new state or a state updater function can be passed to the method.
   */
  setState(updater) {
    let previousState = this.state, newState = typeof updater == "function" ? updater(previousState) : updater;
    if (this.debug("setState", { newState, previousState, updater }), this.status !== _UniversalStore.Status.READY)
      throw new TypeError(
        dedent`Cannot set state before store is ready. You can get the current status with store.status,
        or await store.readyPromise to wait for the store to be ready before sending events.
        ${JSON.stringify(
          {
            newState,
            id: this.id,
            actor: this.actor,
            environment: this.environment
          },
          null,
          2
        )}`
      );
    this.state = newState;
    let event = {
      type: _UniversalStore.InternalEventType.SET_STATE,
      payload: {
        state: newState,
        previousState
      }
    };
    this.emitToChannel(event, { actor: this.actor }), this.emitToListeners(event, { actor: this.actor });
  }
  /**
   * Subscribes to state changes
   *
   * @returns Unsubscribe function
   */
  onStateChange(listener) {
    return this.debug("onStateChange", { listener }), this.subscribe(
      _UniversalStore.InternalEventType.SET_STATE,
      ({ payload }, eventInfo) => {
        listener(payload.state, payload.previousState, eventInfo);
      }
    );
  }
  emitToChannel(event, eventInfo) {
    this.debug("emitToChannel", { event, eventInfo, channel: !!this.channel }), this.channel?.emit(this.channelEventName, {
      event,
      eventInfo
    });
  }
  prepareThis({
    channel,
    environment
  }) {
    this.channel = channel, this.environment = environment, this.debug("prepared", { channel: !!channel, environment }), this.channel.on(this.channelEventName, this.handleChannelEvents), this.actor.type === _UniversalStore.ActorType.LEADER ? this.emitToChannel(
      { type: _UniversalStore.InternalEventType.LEADER_CREATED },
      { actor: this.actor }
    ) : (this.emitToChannel(
      { type: _UniversalStore.InternalEventType.FOLLOWER_CREATED },
      { actor: this.actor }
    ), this.emitToChannel(
      { type: _UniversalStore.InternalEventType.EXISTING_STATE_REQUEST },
      { actor: this.actor }
    ), setTimeout(() => {
      this.syncing.reject(
        new TypeError(
          `No existing state found for follower with id: '${this.id}'. Make sure a leader with the same id exists before creating a follower.`
        )
      );
    }, 1e3));
  }
  emitToListeners(event, eventInfo) {
    let eventTypeListeners = this.listeners.get(event.type), everythingListeners = this.listeners.get("*");
    this.debug("emitToListeners", {
      event,
      eventInfo,
      eventTypeListeners,
      everythingListeners
    }), [...eventTypeListeners ?? [], ...everythingListeners ?? []].forEach(
      (listener) => listener(event, eventInfo)
    );
  }
  handleChannelEvents(channelEvent) {
    let { event, eventInfo } = channelEvent;
    if ([eventInfo.actor.id, eventInfo.forwardingActor?.id].includes(this.actor.id)) {
      this.debug("handleChannelEvents: Ignoring event from self", { channelEvent });
      return;
    } else if (this.syncing?.state === ProgressState.PENDING && event.type !== _UniversalStore.InternalEventType.EXISTING_STATE_RESPONSE) {
      this.debug("handleChannelEvents: Ignoring event while syncing", { channelEvent });
      return;
    }
    if (this.debug("handleChannelEvents", { channelEvent }), this.actor.type === _UniversalStore.ActorType.LEADER) {
      let shouldForwardEvent = !0;
      switch (event.type) {
        case _UniversalStore.InternalEventType.EXISTING_STATE_REQUEST:
          shouldForwardEvent = !1;
          let responseEvent = {
            type: _UniversalStore.InternalEventType.EXISTING_STATE_RESPONSE,
            payload: this.state
          };
          this.debug("handleChannelEvents: responding to existing state request", {
            responseEvent
          }), this.emitToChannel(responseEvent, { actor: this.actor }), this.emitToListeners(responseEvent, { actor: this.actor });
          break;
        case _UniversalStore.InternalEventType.LEADER_CREATED:
          shouldForwardEvent = !1, this.syncing.state = ProgressState.REJECTED, this.debug("handleChannelEvents: erroring due to second leader being created", {
            event
          }), console.error(
            dedent`Detected multiple UniversalStore leaders created with the same id "${this.id}".
            Only one leader can exists at a time, your stores are now in an invalid state.
            Leaders detected:
            this: ${JSON.stringify(this.actor, null, 2)}
            other: ${JSON.stringify(eventInfo.actor, null, 2)}`
          );
          break;
      }
      shouldForwardEvent && (this.debug("handleChannelEvents: forwarding event", { channelEvent }), this.emitToChannel(event, { actor: eventInfo.actor, forwardingActor: this.actor }));
    }
    if (this.actor.type === _UniversalStore.ActorType.FOLLOWER)
      switch (event.type) {
        case _UniversalStore.InternalEventType.EXISTING_STATE_RESPONSE:
          if (this.debug("handleChannelEvents: Setting state from leader's existing state response", {
            event
          }), this.syncing?.state !== ProgressState.PENDING)
            break;
          this.syncing.resolve?.();
          let setStateEvent = {
            type: _UniversalStore.InternalEventType.SET_STATE,
            payload: {
              state: event.payload,
              previousState: this.state
            }
          };
          this.state = event.payload, this.emitToListeners(setStateEvent, eventInfo);
          break;
      }
    switch (event.type) {
      case _UniversalStore.InternalEventType.SET_STATE:
        this.debug("handleChannelEvents: Setting state", { event }), this.state = event.payload.state;
        break;
    }
    this.emitToListeners(event, { actor: eventInfo.actor });
  }
  debug(message, data) {
    this.debugging && console.debug(
      dedent`[UniversalStore::${this.id}::${this.environment ?? _UniversalStore.Environment.UNKNOWN}]
        ${message}`,
      JSON.stringify(
        {
          data,
          actor: this.actor,
          state: this.state,
          status: this.status
        },
        null,
        2
      )
    );
  }
  /**
   * Used to reset the static fields of the UniversalStore class when cleaning up tests
   *
   * @internal
   */
  static __reset() {
    _UniversalStore.preparation.reject(new Error("reset")), _UniversalStore.setupPreparationPromise(), _UniversalStore.isInternalConstructing = !1;
  }
};
/**
 * Defines the possible actor types in the store system
 *
 * @readonly
 */
_UniversalStore.ActorType = {
  LEADER: "LEADER",
  FOLLOWER: "FOLLOWER"
}, /**
 * Defines the possible environments the store can run in
 *
 * @readonly
 */
_UniversalStore.Environment = {
  SERVER: "SERVER",
  MANAGER: "MANAGER",
  PREVIEW: "PREVIEW",
  UNKNOWN: "UNKNOWN",
  MOCK: "MOCK"
}, /**
 * Internal event types used for store synchronization
 *
 * @readonly
 */
_UniversalStore.InternalEventType = {
  EXISTING_STATE_REQUEST: "__EXISTING_STATE_REQUEST",
  EXISTING_STATE_RESPONSE: "__EXISTING_STATE_RESPONSE",
  SET_STATE: "__SET_STATE",
  LEADER_CREATED: "__LEADER_CREATED",
  FOLLOWER_CREATED: "__FOLLOWER_CREATED"
}, _UniversalStore.Status = {
  UNPREPARED: "UNPREPARED",
  SYNCING: "SYNCING",
  READY: "READY",
  ERROR: "ERROR"
}, // This is used to check if constructor was called from the static factory create()
_UniversalStore.isInternalConstructing = !1, _UniversalStore.setupPreparationPromise();
var UniversalStore = _UniversalStore;

// src/channels/main.ts
var isMulti = (args) => args.transports !== void 0, generateRandomId = () => Math.random().toString(16).slice(2), Channel = class {
  constructor(input2 = {}) {
    this.sender = generateRandomId();
    this.events = {};
    this.data = {};
    this.transports = [];
    this.isAsync = input2.async || !1, isMulti(input2) ? (this.transports = input2.transports || [], this.transports.forEach((t2) => {
      t2.setHandler((event) => this.handleEvent(event));
    })) : this.transports = input2.transport ? [input2.transport] : [], this.transports.forEach((t2) => {
      t2.setHandler((event) => this.handleEvent(event));
    });
  }
  get hasTransport() {
    return this.transports.length > 0;
  }
  addListener(eventName, listener) {
    this.events[eventName] = this.events[eventName] || [], this.events[eventName].push(listener);
  }
  emit(eventName, ...args) {
    let event = { type: eventName, args, from: this.sender }, options = {};
    args.length >= 1 && args[0] && args[0].options && (options = args[0].options);
    let handler = () => {
      this.transports.forEach((t2) => {
        t2.send(event, options);
      }), this.handleEvent(event);
    };
    this.isAsync ? setImmediate(handler) : handler();
  }
  last(eventName) {
    return this.data[eventName];
  }
  eventNames() {
    return Object.keys(this.events);
  }
  listenerCount(eventName) {
    let listeners3 = this.listeners(eventName);
    return listeners3 ? listeners3.length : 0;
  }
  listeners(eventName) {
    return this.events[eventName] || void 0;
  }
  once(eventName, listener) {
    let onceListener = this.onceListener(eventName, listener);
    this.addListener(eventName, onceListener);
  }
  removeAllListeners(eventName) {
    eventName ? this.events[eventName] && delete this.events[eventName] : this.events = {};
  }
  removeListener(eventName, listener) {
    let listeners3 = this.listeners(eventName);
    listeners3 && (this.events[eventName] = listeners3.filter((l2) => l2 !== listener));
  }
  on(eventName, listener) {
    this.addListener(eventName, listener);
  }
  off(eventName, listener) {
    this.removeListener(eventName, listener);
  }
  handleEvent(event) {
    let listeners3 = this.listeners(event.type);
    listeners3 && listeners3.length && listeners3.forEach((fn3) => {
      fn3.apply(event, event.args);
    }), this.data[event.type] = event.args;
  }
  onceListener(eventName, listener) {
    let onceListener = (...args) => (this.removeListener(eventName, onceListener), listener(...args));
    return onceListener;
  }
};

// src/client-logger/index.ts
var client_logger_exports = {};
__export(client_logger_exports, {
  deprecate: () => deprecate,
  logger: () => logger,
  once: () => once,
  pretty: () => pretty
});
var { LOGLEVEL } = scope, levels = {
  trace: 1,
  debug: 2,
  info: 3,
  warn: 4,
  error: 5,
  silent: 10
}, currentLogLevelString = LOGLEVEL, currentLogLevelNumber = levels[currentLogLevelString] || levels.info, logger = {
  trace: (message, ...rest) => {
    currentLogLevelNumber <= levels.trace && console.trace(message, ...rest);
  },
  debug: (message, ...rest) => {
    currentLogLevelNumber <= levels.debug && console.debug(message, ...rest);
  },
  info: (message, ...rest) => {
    currentLogLevelNumber <= levels.info && console.info(message, ...rest);
  },
  warn: (message, ...rest) => {
    currentLogLevelNumber <= levels.warn && console.warn(message, ...rest);
  },
  error: (message, ...rest) => {
    currentLogLevelNumber <= levels.error && console.error(message, ...rest);
  },
  log: (message, ...rest) => {
    currentLogLevelNumber < levels.silent && console.log(message, ...rest);
  }
}, logged = /* @__PURE__ */ new Set(), once = (type5) => (message, ...rest) => {
  if (!logged.has(message))
    return logged.add(message), logger[type5](message, ...rest);
};
once.clear = () => logged.clear();
once.trace = once("trace");
once.debug = once("debug");
once.info = once("info");
once.warn = once("warn");
once.error = once("error");
once.log = once("log");
var deprecate = once("warn"), pretty = (type5) => (...args) => {
  let argArray = [];
  if (args.length) {
    let startTagRe = /<span\s+style=(['"])([^'"]*)\1\s*>/gi, endTagRe = /<\/span>/gi, reResultArray;
    for (argArray.push(args[0].replace(startTagRe, "%c").replace(endTagRe, "%c")); reResultArray = startTagRe.exec(args[0]); )
      argArray.push(reResultArray[2]), argArray.push("");
    for (let j2 = 1; j2 < args.length; j2++)
      argArray.push(args[j2]);
  }
  logger[type5].apply(logger, argArray);
};
pretty.trace = pretty("trace");
pretty.debug = pretty("debug");
pretty.info = pretty("info");
pretty.warn = pretty("warn");
pretty.error = pretty("error");

// ../node_modules/telejson/dist/chunk-EAFQLD22.mjs
var __create2 = Object.create, __defProp2 = Object.defineProperty, __getOwnPropDesc2 = Object.getOwnPropertyDescriptor, __getOwnPropNames2 = Object.getOwnPropertyNames, __getProtoOf2 = Object.getPrototypeOf, __hasOwnProp2 = Object.prototype.hasOwnProperty, __commonJS2 = (cb, mod) => function() {
  return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
}, __copyProps2 = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames2(from))
      !__hasOwnProp2.call(to, key) && key !== except && __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
  return to;
}, __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
)), eventProperties = [
  "bubbles",
  "cancelBubble",
  "cancelable",
  "composed",
  "currentTarget",
  "defaultPrevented",
  "eventPhase",
  "isTrusted",
  "returnValue",
  "srcElement",
  "target",
  "timeStamp",
  "type"
], customEventSpecificProperties = ["detail"];
function extractEventHiddenProperties(event) {
  let rebuildEvent = eventProperties.filter((value) => event[value] !== void 0).reduce((acc, value) => (acc[value] = event[value], acc), {});
  if (event instanceof CustomEvent)
    for (let value of customEventSpecificProperties.filter(
      (value2) => event[value2] !== void 0
    ))
      rebuildEvent[value] = event[value];
  return rebuildEvent;
}

// ../node_modules/telejson/dist/index.mjs
var require_es_object_atoms = __commonJS2({
  "node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js"(exports, module2) {
    "use strict";
    module2.exports = Object;
  }
}), require_es_errors = __commonJS2({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/index.js"(exports, module2) {
    "use strict";
    module2.exports = Error;
  }
}), require_eval = __commonJS2({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/eval.js"(exports, module2) {
    "use strict";
    module2.exports = EvalError;
  }
}), require_range = __commonJS2({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/range.js"(exports, module2) {
    "use strict";
    module2.exports = RangeError;
  }
}), require_ref = __commonJS2({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/ref.js"(exports, module2) {
    "use strict";
    module2.exports = ReferenceError;
  }
}), require_syntax = __commonJS2({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js"(exports, module2) {
    "use strict";
    module2.exports = SyntaxError;
  }
}), require_type = __commonJS2({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js"(exports, module2) {
    "use strict";
    module2.exports = TypeError;
  }
}), require_uri = __commonJS2({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/uri.js"(exports, module2) {
    "use strict";
    module2.exports = URIError;
  }
}), require_abs = __commonJS2({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/abs.js"(exports, module2) {
    "use strict";
    module2.exports = Math.abs;
  }
}), require_floor = __commonJS2({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/floor.js"(exports, module2) {
    "use strict";
    module2.exports = Math.floor;
  }
}), require_max = __commonJS2({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/max.js"(exports, module2) {
    "use strict";
    module2.exports = Math.max;
  }
}), require_min = __commonJS2({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/min.js"(exports, module2) {
    "use strict";
    module2.exports = Math.min;
  }
}), require_pow = __commonJS2({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/pow.js"(exports, module2) {
    "use strict";
    module2.exports = Math.pow;
  }
}), require_round = __commonJS2({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/round.js"(exports, module2) {
    "use strict";
    module2.exports = Math.round;
  }
}), require_isNaN = __commonJS2({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/isNaN.js"(exports, module2) {
    "use strict";
    module2.exports = Number.isNaN || function(a2) {
      return a2 !== a2;
    };
  }
}), require_sign = __commonJS2({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/sign.js"(exports, module2) {
    "use strict";
    var $isNaN = require_isNaN();
    module2.exports = function(number) {
      return $isNaN(number) || number === 0 ? number : number < 0 ? -1 : 1;
    };
  }
}), require_gOPD = __commonJS2({
  "node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/gOPD.js"(exports, module2) {
    "use strict";
    module2.exports = Object.getOwnPropertyDescriptor;
  }
}), require_gopd = __commonJS2({
  "node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js"(exports, module2) {
    "use strict";
    var $gOPD = require_gOPD();
    if ($gOPD)
      try {
        $gOPD([], "length");
      } catch {
        $gOPD = null;
      }
    module2.exports = $gOPD;
  }
}), require_es_define_property = __commonJS2({
  "node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js"(exports, module2) {
    "use strict";
    var $defineProperty = Object.defineProperty || !1;
    if ($defineProperty)
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch {
        $defineProperty = !1;
      }
    module2.exports = $defineProperty;
  }
}), require_shams = __commonJS2({
  "node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js"(exports, module2) {
    "use strict";
    module2.exports = function() {
      if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
        return !1;
      if (typeof Symbol.iterator == "symbol")
        return !0;
      var obj = {}, sym = Symbol("test"), symObj = Object(sym);
      if (typeof sym == "string" || Object.prototype.toString.call(sym) !== "[object Symbol]" || Object.prototype.toString.call(symObj) !== "[object Symbol]")
        return !1;
      var symVal = 42;
      obj[sym] = symVal;
      for (var _ in obj)
        return !1;
      if (typeof Object.keys == "function" && Object.keys(obj).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(obj).length !== 0)
        return !1;
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym || !Object.prototype.propertyIsEnumerable.call(obj, sym))
        return !1;
      if (typeof Object.getOwnPropertyDescriptor == "function") {
        var descriptor = (
          /** @type {PropertyDescriptor} */
          Object.getOwnPropertyDescriptor(obj, sym)
        );
        if (descriptor.value !== symVal || descriptor.enumerable !== !0)
          return !1;
      }
      return !0;
    };
  }
}), require_has_symbols = __commonJS2({
  "node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/index.js"(exports, module2) {
    "use strict";
    var origSymbol = typeof Symbol < "u" && Symbol, hasSymbolSham = require_shams();
    module2.exports = function() {
      return typeof origSymbol != "function" || typeof Symbol != "function" || typeof origSymbol("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : hasSymbolSham();
    };
  }
}), require_Reflect_getPrototypeOf = __commonJS2({
  "node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js"(exports, module2) {
    "use strict";
    module2.exports = typeof Reflect < "u" && Reflect.getPrototypeOf || null;
  }
}), require_Object_getPrototypeOf = __commonJS2({
  "node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js"(exports, module2) {
    "use strict";
    var $Object = require_es_object_atoms();
    module2.exports = $Object.getPrototypeOf || null;
  }
}), require_implementation = __commonJS2({
  "node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js"(exports, module2) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ", toStr3 = Object.prototype.toString, max = Math.max, funcType = "[object Function]", concatty = function(a2, b2) {
      for (var arr = [], i2 = 0; i2 < a2.length; i2 += 1)
        arr[i2] = a2[i2];
      for (var j2 = 0; j2 < b2.length; j2 += 1)
        arr[j2 + a2.length] = b2[j2];
      return arr;
    }, slicy = function(arrLike, offset2) {
      for (var arr = [], i2 = offset2 || 0, j2 = 0; i2 < arrLike.length; i2 += 1, j2 += 1)
        arr[j2] = arrLike[i2];
      return arr;
    }, joiny = function(arr, joiner) {
      for (var str2 = "", i2 = 0; i2 < arr.length; i2 += 1)
        str2 += arr[i2], i2 + 1 < arr.length && (str2 += joiner);
      return str2;
    };
    module2.exports = function(that) {
      var target = this;
      if (typeof target != "function" || toStr3.apply(target) !== funcType)
        throw new TypeError(ERROR_MESSAGE + target);
      for (var args = slicy(arguments, 1), bound, binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          return Object(result) === result ? result : this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      }, boundLength = max(0, target.length - args.length), boundArgs = [], i2 = 0; i2 < boundLength; i2++)
        boundArgs[i2] = "$" + i2;
      if (bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder), target.prototype) {
        var Empty = function() {
        };
        Empty.prototype = target.prototype, bound.prototype = new Empty(), Empty.prototype = null;
      }
      return bound;
    };
  }
}), require_function_bind = __commonJS2({
  "node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js"(exports, module2) {
    "use strict";
    var implementation = require_implementation();
    module2.exports = Function.prototype.bind || implementation;
  }
}), require_functionCall = __commonJS2({
  "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js"(exports, module2) {
    "use strict";
    module2.exports = Function.prototype.call;
  }
}), require_functionApply = __commonJS2({
  "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js"(exports, module2) {
    "use strict";
    module2.exports = Function.prototype.apply;
  }
}), require_reflectApply = __commonJS2({
  "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/reflectApply.js"(exports, module2) {
    "use strict";
    module2.exports = typeof Reflect < "u" && Reflect && Reflect.apply;
  }
}), require_actualApply = __commonJS2({
  "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/actualApply.js"(exports, module2) {
    "use strict";
    var bind = require_function_bind(), $apply = require_functionApply(), $call = require_functionCall(), $reflectApply = require_reflectApply();
    module2.exports = $reflectApply || bind.call($call, $apply);
  }
}), require_call_bind_apply_helpers = __commonJS2({
  "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js"(exports, module2) {
    "use strict";
    var bind = require_function_bind(), $TypeError = require_type(), $call = require_functionCall(), $actualApply = require_actualApply();
    module2.exports = function(args) {
      if (args.length < 1 || typeof args[0] != "function")
        throw new $TypeError("a function is required");
      return $actualApply(bind, $call, args);
    };
  }
}), require_get = __commonJS2({
  "node_modules/.pnpm/dunder-proto@1.0.1/node_modules/dunder-proto/get.js"(exports, module2) {
    "use strict";
    var callBind = require_call_bind_apply_helpers(), gOPD = require_gopd(), hasProtoAccessor;
    try {
      hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
      [].__proto__ === Array.prototype;
    } catch (e2) {
      if (!e2 || typeof e2 != "object" || !("code" in e2) || e2.code !== "ERR_PROTO_ACCESS")
        throw e2;
    }
    var desc = !!hasProtoAccessor && gOPD && gOPD(
      Object.prototype,
      /** @type {keyof typeof Object.prototype} */
      "__proto__"
    ), $Object = Object, $getPrototypeOf = $Object.getPrototypeOf;
    module2.exports = desc && typeof desc.get == "function" ? callBind([desc.get]) : typeof $getPrototypeOf == "function" ? (
      /** @type {import('./get')} */
      (function(value) {
        return $getPrototypeOf(value == null ? value : $Object(value));
      })
    ) : !1;
  }
}), require_get_proto = __commonJS2({
  "node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js"(exports, module2) {
    "use strict";
    var reflectGetProto = require_Reflect_getPrototypeOf(), originalGetProto = require_Object_getPrototypeOf(), getDunderProto = require_get();
    module2.exports = reflectGetProto ? function(O) {
      return reflectGetProto(O);
    } : originalGetProto ? function(O) {
      if (!O || typeof O != "object" && typeof O != "function")
        throw new TypeError("getProto: not an object");
      return originalGetProto(O);
    } : getDunderProto ? function(O) {
      return getDunderProto(O);
    } : null;
  }
}), require_hasown = __commonJS2({
  "node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js"(exports, module2) {
    "use strict";
    var call2 = Function.prototype.call, $hasOwn = Object.prototype.hasOwnProperty, bind = require_function_bind();
    module2.exports = bind.call(call2, $hasOwn);
  }
}), require_get_intrinsic = __commonJS2({
  "node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js"(exports, module2) {
    "use strict";
    var undefined2, $Object = require_es_object_atoms(), $Error = require_es_errors(), $EvalError = require_eval(), $RangeError = require_range(), $ReferenceError = require_ref(), $SyntaxError = require_syntax(), $TypeError = require_type(), $URIError = require_uri(), abs = require_abs(), floor = require_floor(), max = require_max(), min = require_min(), pow = require_pow(), round2 = require_round(), sign = require_sign(), $Function = Function, getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch {
      }
    }, $gOPD = require_gopd(), $defineProperty = require_es_define_property(), throwTypeError = function() {
      throw new $TypeError();
    }, ThrowTypeError = $gOPD ? (function() {
      try {
        return arguments.callee, throwTypeError;
      } catch {
        try {
          return $gOPD(arguments, "callee").get;
        } catch {
          return throwTypeError;
        }
      }
    })() : throwTypeError, hasSymbols = require_has_symbols()(), getProto = require_get_proto(), $ObjectGPO = require_Object_getPrototypeOf(), $ReflectGPO = require_Reflect_getPrototypeOf(), $apply = require_functionApply(), $call = require_functionCall(), needsEval = {}, TypedArray = typeof Uint8Array > "u" || !getProto ? undefined2 : getProto(Uint8Array), INTRINSICS = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError > "u" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer > "u" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics > "u" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt > "u" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array > "u" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array > "u" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView > "u" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": $Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": $EvalError,
      "%Float16Array%": typeof Float16Array > "u" ? undefined2 : Float16Array,
      "%Float32Array%": typeof Float32Array > "u" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array > "u" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array > "u" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array > "u" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array > "u" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON == "object" ? JSON : undefined2,
      "%Map%": typeof Map > "u" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map > "u" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": $Object,
      "%Object.getOwnPropertyDescriptor%": $gOPD,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise > "u" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy > "u" ? undefined2 : Proxy,
      "%RangeError%": $RangeError,
      "%ReferenceError%": $ReferenceError,
      "%Reflect%": typeof Reflect > "u" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set > "u" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set > "u" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array > "u" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array > "u" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array > "u" ? undefined2 : Uint32Array,
      "%URIError%": $URIError,
      "%WeakMap%": typeof WeakMap > "u" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef > "u" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet > "u" ? undefined2 : WeakSet,
      "%Function.prototype.call%": $call,
      "%Function.prototype.apply%": $apply,
      "%Object.defineProperty%": $defineProperty,
      "%Object.getPrototypeOf%": $ObjectGPO,
      "%Math.abs%": abs,
      "%Math.floor%": floor,
      "%Math.max%": max,
      "%Math.min%": min,
      "%Math.pow%": pow,
      "%Math.round%": round2,
      "%Math.sign%": sign,
      "%Reflect.getPrototypeOf%": $ReflectGPO
    };
    if (getProto)
      try {
        null.error;
      } catch (e2) {
        errorProto = getProto(getProto(e2)), INTRINSICS["%Error.prototype%"] = errorProto;
      }
    var errorProto, doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%")
        value = getEvalledConstructor("async function () {}");
      else if (name === "%GeneratorFunction%")
        value = getEvalledConstructor("function* () {}");
      else if (name === "%AsyncGeneratorFunction%")
        value = getEvalledConstructor("async function* () {}");
      else if (name === "%AsyncGenerator%") {
        var fn3 = doEval2("%AsyncGeneratorFunction%");
        fn3 && (value = fn3.prototype);
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        gen && getProto && (value = getProto(gen.prototype));
      }
      return INTRINSICS[name] = value, value;
    }, LEGACY_ALIASES = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    }, bind = require_function_bind(), hasOwn = require_hasown(), $concat = bind.call($call, Array.prototype.concat), $spliceApply = bind.call($apply, Array.prototype.splice), $replace = bind.call($call, String.prototype.replace), $strSlice = bind.call($call, String.prototype.slice), $exec = bind.call($call, RegExp.prototype.exec), rePropName2 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, reEscapeChar2 = /\\(\\)?/g, stringToPath2 = function(string) {
      var first = $strSlice(string, 0, 1), last = $strSlice(string, -1);
      if (first === "%" && last !== "%")
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      if (last === "%" && first !== "%")
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      var result = [];
      return $replace(string, rePropName2, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar2, "$1") : number || match;
      }), result;
    }, getBaseIntrinsic = function(name, allowMissing) {
      var intrinsicName = name, alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName) && (alias = LEGACY_ALIASES[intrinsicName], intrinsicName = "%" + alias[0] + "%"), hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval && (value = doEval(intrinsicName)), typeof value > "u" && !allowMissing)
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module2.exports = function(name, allowMissing) {
      if (typeof name != "string" || name.length === 0)
        throw new $TypeError("intrinsic name must be a non-empty string");
      if (arguments.length > 1 && typeof allowMissing != "boolean")
        throw new $TypeError('"allowMissing" argument must be a boolean');
      if ($exec(/^%?[^%]*%?$/, name) === null)
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      var parts = stringToPath2(name), intrinsicBaseName = parts.length > 0 ? parts[0] : "", intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing), intrinsicRealName = intrinsic.name, value = intrinsic.value, skipFurtherCaching = !1, alias = intrinsic.alias;
      alias && (intrinsicBaseName = alias[0], $spliceApply(parts, $concat([0, 1], alias)));
      for (var i2 = 1, isOwn = !0; i2 < parts.length; i2 += 1) {
        var part = parts[i2], first = $strSlice(part, 0, 1), last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || last === '"' || last === "'" || last === "`") && first !== last)
          throw new $SyntaxError("property names with quotes must have matching quotes");
        if ((part === "constructor" || !isOwn) && (skipFurtherCaching = !0), intrinsicBaseName += "." + part, intrinsicRealName = "%" + intrinsicBaseName + "%", hasOwn(INTRINSICS, intrinsicRealName))
          value = INTRINSICS[intrinsicRealName];
        else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing)
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            return;
          }
          if ($gOPD && i2 + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc, isOwn && "get" in desc && !("originalValue" in desc.get) ? value = desc.get : value = value[part];
          } else
            isOwn = hasOwn(value, part), value = value[part];
          isOwn && !skipFurtherCaching && (INTRINSICS[intrinsicRealName] = value);
        }
      }
      return value;
    };
  }
}), require_call_bound = __commonJS2({
  "node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic(), callBindBasic = require_call_bind_apply_helpers(), $indexOf = callBindBasic([GetIntrinsic("%String.prototype.indexOf%")]);
    module2.exports = function(name, allowMissing) {
      var intrinsic = (
        /** @type {(this: unknown, ...args: unknown[]) => unknown} */
        GetIntrinsic(name, !!allowMissing)
      );
      return typeof intrinsic == "function" && $indexOf(name, ".prototype.") > -1 ? callBindBasic(
        /** @type {const} */
        [intrinsic]
      ) : intrinsic;
    };
  }
}), require_shams2 = __commonJS2({
  "node_modules/.pnpm/has-tostringtag@1.0.2/node_modules/has-tostringtag/shams.js"(exports, module2) {
    "use strict";
    var hasSymbols = require_shams();
    module2.exports = function() {
      return hasSymbols() && !!Symbol.toStringTag;
    };
  }
}), require_is_regex = __commonJS2({
  "node_modules/.pnpm/is-regex@1.2.1/node_modules/is-regex/index.js"(exports, module2) {
    "use strict";
    var callBound = require_call_bound(), hasToStringTag = require_shams2()(), hasOwn = require_hasown(), gOPD = require_gopd(), fn3;
    hasToStringTag ? ($exec = callBound("RegExp.prototype.exec"), isRegexMarker = {}, throwRegexMarker = function() {
      throw isRegexMarker;
    }, badStringifier = {
      toString: throwRegexMarker,
      valueOf: throwRegexMarker
    }, typeof Symbol.toPrimitive == "symbol" && (badStringifier[Symbol.toPrimitive] = throwRegexMarker), fn3 = function(value) {
      if (!value || typeof value != "object")
        return !1;
      var descriptor = (
        /** @type {NonNullable<typeof gOPD>} */
        gOPD(
          /** @type {{ lastIndex?: unknown }} */
          value,
          "lastIndex"
        )
      ), hasLastIndexDataProperty = descriptor && hasOwn(descriptor, "value");
      if (!hasLastIndexDataProperty)
        return !1;
      try {
        $exec(
          value,
          /** @type {string} */
          /** @type {unknown} */
          badStringifier
        );
      } catch (e2) {
        return e2 === isRegexMarker;
      }
    }) : ($toString = callBound("Object.prototype.toString"), regexClass = "[object RegExp]", fn3 = function(value) {
      return !value || typeof value != "object" && typeof value != "function" ? !1 : $toString(value) === regexClass;
    });
    var $exec, isRegexMarker, throwRegexMarker, badStringifier, $toString, regexClass;
    module2.exports = fn3;
  }
}), require_is_function = __commonJS2({
  "node_modules/.pnpm/is-function@1.0.2/node_modules/is-function/index.js"(exports, module2) {
    module2.exports = isFunction32;
    var toString22 = Object.prototype.toString;
    function isFunction32(fn3) {
      if (!fn3)
        return !1;
      var string = toString22.call(fn3);
      return string === "[object Function]" || typeof fn3 == "function" && string !== "[object RegExp]" || typeof window < "u" && // IE8 and below
      (fn3 === window.setTimeout || fn3 === window.alert || fn3 === window.confirm || fn3 === window.prompt);
    }
  }
}), require_safe_regex_test = __commonJS2({
  "node_modules/.pnpm/safe-regex-test@1.1.0/node_modules/safe-regex-test/index.js"(exports, module2) {
    "use strict";
    var callBound = require_call_bound(), isRegex = require_is_regex(), $exec = callBound("RegExp.prototype.exec"), $TypeError = require_type();
    module2.exports = function(regex) {
      if (!isRegex(regex))
        throw new $TypeError("`regex` must be a RegExp");
      return function(s3) {
        return $exec(regex, s3) !== null;
      };
    };
  }
}), require_is_symbol = __commonJS2({
  "node_modules/.pnpm/is-symbol@1.1.1/node_modules/is-symbol/index.js"(exports, module2) {
    "use strict";
    var callBound = require_call_bound(), $toString = callBound("Object.prototype.toString"), hasSymbols = require_has_symbols()(), safeRegexTest = require_safe_regex_test();
    hasSymbols ? ($symToStr = callBound("Symbol.prototype.toString"), isSymString = safeRegexTest(/^Symbol\(.*\)$/), isSymbolObject = function(value) {
      return typeof value.valueOf() != "symbol" ? !1 : isSymString($symToStr(value));
    }, module2.exports = function(value) {
      if (typeof value == "symbol")
        return !0;
      if (!value || typeof value != "object" || $toString(value) !== "[object Symbol]")
        return !1;
      try {
        return isSymbolObject(value);
      } catch {
        return !1;
      }
    }) : module2.exports = function(value) {
      return !1;
    };
    var $symToStr, isSymString, isSymbolObject;
  }
}), import_is_regex = __toESM2(require_is_regex()), import_is_function = __toESM2(require_is_function()), import_is_symbol = __toESM2(require_is_symbol());
function isObject(val) {
  return val != null && typeof val == "object" && Array.isArray(val) === !1;
}
var freeGlobal = typeof global == "object" && global && global.Object === Object && global, freeGlobal_default = freeGlobal, freeSelf = typeof self == "object" && self && self.Object === Object && self, root = freeGlobal_default || freeSelf || Function("return this")(), root_default = root, Symbol2 = root_default.Symbol, Symbol_default = Symbol2, objectProto = Object.prototype, hasOwnProperty = objectProto.hasOwnProperty, nativeObjectToString = objectProto.toString, symToStringTag = Symbol_default ? Symbol_default.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
  try {
    value[symToStringTag] = void 0;
    var unmasked = !0;
  } catch {
  }
  var result = nativeObjectToString.call(value);
  return unmasked && (isOwn ? value[symToStringTag] = tag : delete value[symToStringTag]), result;
}
var getRawTag_default = getRawTag, objectProto2 = Object.prototype, nativeObjectToString2 = objectProto2.toString;
function objectToString(value) {
  return nativeObjectToString2.call(value);
}
var objectToString_default = objectToString, nullTag = "[object Null]", undefinedTag = "[object Undefined]", symToStringTag2 = Symbol_default ? Symbol_default.toStringTag : void 0;
function baseGetTag(value) {
  return value == null ? value === void 0 ? undefinedTag : nullTag : symToStringTag2 && symToStringTag2 in Object(value) ? getRawTag_default(value) : objectToString_default(value);
}
var baseGetTag_default = baseGetTag;
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_default = isObjectLike, symbolTag = "[object Symbol]";
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike_default(value) && baseGetTag_default(value) == symbolTag;
}
var isSymbol_default = isSymbol;
function arrayMap(array, iteratee) {
  for (var index2 = -1, length = array == null ? 0 : array.length, result = Array(length); ++index2 < length; )
    result[index2] = iteratee(array[index2], index2, array);
  return result;
}
var arrayMap_default = arrayMap, isArray = Array.isArray, isArray_default = isArray, INFINITY = 1 / 0, symbolProto = Symbol_default ? Symbol_default.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString(value) {
  if (typeof value == "string")
    return value;
  if (isArray_default(value))
    return arrayMap_default(value, baseToString) + "";
  if (isSymbol_default(value))
    return symbolToString ? symbolToString.call(value) : "";
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
var baseToString_default = baseToString;
function isObject2(value) {
  var type5 = typeof value;
  return value != null && (type5 == "object" || type5 == "function");
}
var isObject_default = isObject2, asyncTag = "[object AsyncFunction]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction(value) {
  if (!isObject_default(value))
    return !1;
  var tag = baseGetTag_default(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var isFunction_default = isFunction, coreJsData = root_default["__core-js_shared__"], coreJsData_default = coreJsData, maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData_default && coreJsData_default.keys && coreJsData_default.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
})();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var isMasked_default = isMasked, funcProto = Function.prototype, funcToString = funcProto.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch {
    }
    try {
      return func + "";
    } catch {
    }
  }
  return "";
}
var toSource_default = toSource, reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reIsHostCtor = /^\[object .+?Constructor\]$/, funcProto2 = Function.prototype, objectProto3 = Object.prototype, funcToString2 = funcProto2.toString, hasOwnProperty2 = objectProto3.hasOwnProperty, reIsNative = RegExp(
  "^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(value) {
  if (!isObject_default(value) || isMasked_default(value))
    return !1;
  var pattern = isFunction_default(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource_default(value));
}
var baseIsNative_default = baseIsNative;
function getValue(object, key) {
  return object?.[key];
}
var getValue_default = getValue;
function getNative(object, key) {
  var value = getValue_default(object, key);
  return baseIsNative_default(value) ? value : void 0;
}
var getNative_default = getNative;
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_default = eq, reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
function isKey(value, object) {
  if (isArray_default(value))
    return !1;
  var type5 = typeof value;
  return type5 == "number" || type5 == "symbol" || type5 == "boolean" || value == null || isSymbol_default(value) ? !0 : reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
var isKey_default = isKey, nativeCreate = getNative_default(Object, "create"), nativeCreate_default = nativeCreate;
function hashClear() {
  this.__data__ = nativeCreate_default ? nativeCreate_default(null) : {}, this.size = 0;
}
var hashClear_default = hashClear;
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  return this.size -= result ? 1 : 0, result;
}
var hashDelete_default = hashDelete, HASH_UNDEFINED = "__lodash_hash_undefined__", objectProto4 = Object.prototype, hasOwnProperty3 = objectProto4.hasOwnProperty;
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate_default) {
    var result = data[key];
    return result === HASH_UNDEFINED ? void 0 : result;
  }
  return hasOwnProperty3.call(data, key) ? data[key] : void 0;
}
var hashGet_default = hashGet, objectProto5 = Object.prototype, hasOwnProperty4 = objectProto5.hasOwnProperty;
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate_default ? data[key] !== void 0 : hasOwnProperty4.call(data, key);
}
var hashHas_default = hashHas, HASH_UNDEFINED2 = "__lodash_hash_undefined__";
function hashSet(key, value) {
  var data = this.__data__;
  return this.size += this.has(key) ? 0 : 1, data[key] = nativeCreate_default && value === void 0 ? HASH_UNDEFINED2 : value, this;
}
var hashSet_default = hashSet;
function Hash(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  for (this.clear(); ++index2 < length; ) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear_default;
Hash.prototype.delete = hashDelete_default;
Hash.prototype.get = hashGet_default;
Hash.prototype.has = hashHas_default;
Hash.prototype.set = hashSet_default;
var Hash_default = Hash;
function listCacheClear() {
  this.__data__ = [], this.size = 0;
}
var listCacheClear_default = listCacheClear;
function assocIndexOf(array, key) {
  for (var length = array.length; length--; )
    if (eq_default(array[length][0], key))
      return length;
  return -1;
}
var assocIndexOf_default = assocIndexOf, arrayProto = Array.prototype, splice = arrayProto.splice;
function listCacheDelete(key) {
  var data = this.__data__, index2 = assocIndexOf_default(data, key);
  if (index2 < 0)
    return !1;
  var lastIndex = data.length - 1;
  return index2 == lastIndex ? data.pop() : splice.call(data, index2, 1), --this.size, !0;
}
var listCacheDelete_default = listCacheDelete;
function listCacheGet(key) {
  var data = this.__data__, index2 = assocIndexOf_default(data, key);
  return index2 < 0 ? void 0 : data[index2][1];
}
var listCacheGet_default = listCacheGet;
function listCacheHas(key) {
  return assocIndexOf_default(this.__data__, key) > -1;
}
var listCacheHas_default = listCacheHas;
function listCacheSet(key, value) {
  var data = this.__data__, index2 = assocIndexOf_default(data, key);
  return index2 < 0 ? (++this.size, data.push([key, value])) : data[index2][1] = value, this;
}
var listCacheSet_default = listCacheSet;
function ListCache(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  for (this.clear(); ++index2 < length; ) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear_default;
ListCache.prototype.delete = listCacheDelete_default;
ListCache.prototype.get = listCacheGet_default;
ListCache.prototype.has = listCacheHas_default;
ListCache.prototype.set = listCacheSet_default;
var ListCache_default = ListCache, Map2 = getNative_default(root_default, "Map"), Map_default = Map2;
function mapCacheClear() {
  this.size = 0, this.__data__ = {
    hash: new Hash_default(),
    map: new (Map_default || ListCache_default)(),
    string: new Hash_default()
  };
}
var mapCacheClear_default = mapCacheClear;
function isKeyable(value) {
  var type5 = typeof value;
  return type5 == "string" || type5 == "number" || type5 == "symbol" || type5 == "boolean" ? value !== "__proto__" : value === null;
}
var isKeyable_default = isKeyable;
function getMapData(map2, key) {
  var data = map2.__data__;
  return isKeyable_default(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var getMapData_default = getMapData;
function mapCacheDelete(key) {
  var result = getMapData_default(this, key).delete(key);
  return this.size -= result ? 1 : 0, result;
}
var mapCacheDelete_default = mapCacheDelete;
function mapCacheGet(key) {
  return getMapData_default(this, key).get(key);
}
var mapCacheGet_default = mapCacheGet;
function mapCacheHas(key) {
  return getMapData_default(this, key).has(key);
}
var mapCacheHas_default = mapCacheHas;
function mapCacheSet(key, value) {
  var data = getMapData_default(this, key), size = data.size;
  return data.set(key, value), this.size += data.size == size ? 0 : 1, this;
}
var mapCacheSet_default = mapCacheSet;
function MapCache(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  for (this.clear(); ++index2 < length; ) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear_default;
MapCache.prototype.delete = mapCacheDelete_default;
MapCache.prototype.get = mapCacheGet_default;
MapCache.prototype.has = mapCacheHas_default;
MapCache.prototype.set = mapCacheSet_default;
var MapCache_default = MapCache, FUNC_ERROR_TEXT = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function")
    throw new TypeError(FUNC_ERROR_TEXT);
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key))
      return cache.get(key);
    var result = func.apply(this, args);
    return memoized.cache = cache.set(key, result) || cache, result;
  };
  return memoized.cache = new (memoize.Cache || MapCache_default)(), memoized;
}
memoize.Cache = MapCache_default;
var memoize_default = memoize, MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result = memoize_default(func, function(key) {
    return cache.size === MAX_MEMOIZE_SIZE && cache.clear(), key;
  }), cache = result.cache;
  return result;
}
var memoizeCapped_default = memoizeCapped, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, reEscapeChar = /\\(\\)?/g, stringToPath = memoizeCapped_default(function(string) {
  var result = [];
  return string.charCodeAt(0) === 46 && result.push(""), string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
  }), result;
}), stringToPath_default = stringToPath;
function toString(value) {
  return value == null ? "" : baseToString_default(value);
}
var toString_default = toString;
function castPath(value, object) {
  return isArray_default(value) ? value : isKey_default(value, object) ? [value] : stringToPath_default(toString_default(value));
}
var castPath_default = castPath, INFINITY2 = 1 / 0;
function toKey(value) {
  if (typeof value == "string" || isSymbol_default(value))
    return value;
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY2 ? "-0" : result;
}
var toKey_default = toKey;
function baseGet(object, path) {
  path = castPath_default(path, object);
  for (var index2 = 0, length = path.length; object != null && index2 < length; )
    object = object[toKey_default(path[index2++])];
  return index2 && index2 == length ? object : void 0;
}
var baseGet_default = baseGet;
function get(object, path, defaultValue) {
  var result = object == null ? void 0 : baseGet_default(object, path);
  return result === void 0 ? defaultValue : result;
}
var get_default = get, isObject3 = isObject, dateFormat = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d{3})?Z$/, isJSON = (input2) => input2.match(/^[\[\{\"\}].*[\]\}\"]$/);
function convertUnconventionalData(data) {
  if (!isObject3(data))
    return data;
  let result = data, wasMutated = !1;
  return typeof Event < "u" && data instanceof Event && (result = extractEventHiddenProperties(result), wasMutated = !0), result = Object.keys(result).reduce((acc, key) => {
    try {
      result[key] && result[key].toJSON, acc[key] = result[key];
    } catch {
      wasMutated = !0;
    }
    return acc;
  }, {}), wasMutated ? result : data;
}
var replacer = function(options) {
  let objects, map2, stack, keys2;
  return function(key, value) {
    try {
      if (key === "")
        return keys2 = [], objects = /* @__PURE__ */ new Map([[value, "[]"]]), map2 = /* @__PURE__ */ new Map(), stack = [], value;
      let origin = map2.get(this) || this;
      for (; stack.length && origin !== stack[0]; )
        stack.shift(), keys2.pop();
      if (typeof value == "boolean")
        return value;
      if (value === void 0)
        return options.allowUndefined ? "_undefined_" : void 0;
      if (value === null)
        return null;
      if (typeof value == "number")
        return value === Number.NEGATIVE_INFINITY ? "_-Infinity_" : value === Number.POSITIVE_INFINITY ? "_Infinity_" : Number.isNaN(value) ? "_NaN_" : value;
      if (typeof value == "bigint")
        return `_bigint_${value.toString()}`;
      if (typeof value == "string")
        return dateFormat.test(value) ? options.allowDate ? `_date_${value}` : void 0 : value;
      if ((0, import_is_regex.default)(value))
        return options.allowRegExp ? `_regexp_${value.flags}|${value.source}` : void 0;
      if ((0, import_is_function.default)(value))
        return;
      if ((0, import_is_symbol.default)(value)) {
        if (!options.allowSymbol)
          return;
        let globalRegistryKey = Symbol.keyFor(value);
        return globalRegistryKey !== void 0 ? `_gsymbol_${globalRegistryKey}` : `_symbol_${value.toString().slice(7, -1)}`;
      }
      if (stack.length >= options.maxDepth)
        return Array.isArray(value) ? `[Array(${value.length})]` : "[Object]";
      if (value === this)
        return `_duplicate_${JSON.stringify(keys2)}`;
      if (value instanceof Error && options.allowError)
        return {
          __isConvertedError__: !0,
          errorProperties: {
            // @ts-expect-error cause is not defined in the current tsconfig target(es2020)
            ...value.cause ? { cause: value.cause } : {},
            ...value,
            name: value.name,
            message: value.message,
            stack: value.stack,
            "_constructor-name_": value.constructor.name
          }
        };
      if (value?.constructor?.name && value.constructor.name !== "Object" && !Array.isArray(value)) {
        let found2 = objects.get(value);
        if (!found2) {
          let plainObject = {
            __isClassInstance__: !0,
            __className__: value.constructor.name,
            ...Object.getOwnPropertyNames(value).reduce(
              (acc, prop) => {
                try {
                  acc[prop] = value[prop];
                } catch {
                }
                return acc;
              },
              {}
            )
          };
          return keys2.push(key), stack.unshift(plainObject), objects.set(value, JSON.stringify(keys2)), value !== plainObject && map2.set(value, plainObject), plainObject;
        }
        return `_duplicate_${found2}`;
      }
      let found = objects.get(value);
      if (!found) {
        let converted = Array.isArray(value) ? value : convertUnconventionalData(value);
        return keys2.push(key), stack.unshift(converted), objects.set(value, JSON.stringify(keys2)), value !== converted && map2.set(value, converted), converted;
      }
      return `_duplicate_${found}`;
    } catch {
      return;
    }
  };
}, reviver = function(options) {
  let refs = [], root2;
  return function(key, value) {
    if (key === "" && (root2 = value, refs.forEach(({ target, container, replacement }) => {
      let replacementArr = isJSON(replacement) ? JSON.parse(replacement) : replacement.split(".");
      replacementArr.length === 0 ? container[target] = root2 : container[target] = get_default(root2, replacementArr);
    })), key === "_constructor-name_")
      return value;
    if (isObject3(value) && value.__isConvertedError__) {
      let { message, ...properties } = value.errorProperties, error = new Error(message);
      return Object.assign(error, properties), error;
    }
    if (typeof value == "string" && value.startsWith("_regexp_") && options.allowRegExp) {
      let [, flags, source] = value.match(/_regexp_([^|]*)\|(.*)/) || [];
      return new RegExp(source, flags);
    }
    return typeof value == "string" && value.startsWith("_date_") && options.allowDate ? new Date(value.replace("_date_", "")) : typeof value == "string" && value.startsWith("_duplicate_") ? (refs.push({ target: key, container: this, replacement: value.replace(/^_duplicate_/, "") }), null) : typeof value == "string" && value.startsWith("_symbol_") && options.allowSymbol ? Symbol(value.replace("_symbol_", "")) : typeof value == "string" && value.startsWith("_gsymbol_") && options.allowSymbol ? Symbol.for(value.replace("_gsymbol_", "")) : typeof value == "string" && value === "_-Infinity_" ? Number.NEGATIVE_INFINITY : typeof value == "string" && value === "_Infinity_" ? Number.POSITIVE_INFINITY : typeof value == "string" && value === "_NaN_" ? Number.NaN : typeof value == "string" && value.startsWith("_bigint_") && typeof BigInt == "function" ? BigInt(value.replace("_bigint_", "")) : value;
  };
}, defaultOptions = {
  maxDepth: 10,
  space: void 0,
  allowRegExp: !0,
  allowDate: !0,
  allowError: !0,
  allowUndefined: !0,
  allowSymbol: !0
}, stringify = (data, options = {}) => {
  let mergedOptions = { ...defaultOptions, ...options };
  return JSON.stringify(convertUnconventionalData(data), replacer(mergedOptions), options.space);
}, mutator = () => {
  let mutated = /* @__PURE__ */ new Map();
  return function mutateUndefined(value) {
    isObject3(value) && Object.entries(value).forEach(([k2, v2]) => {
      v2 === "_undefined_" ? value[k2] = void 0 : mutated.get(v2) || (mutated.set(v2, !0), mutateUndefined(v2));
    }), Array.isArray(value) && value.forEach((v2, index2) => {
      v2 === "_undefined_" ? (mutated.set(v2, !0), value[index2] = void 0) : mutated.get(v2) || (mutated.set(v2, !0), mutateUndefined(v2));
    });
  };
}, parse = (data, options = {}) => {
  let mergedOptions = { ...defaultOptions, ...options }, result = JSON.parse(data, reviver(mergedOptions));
  return mutator()(result), result;
};

// ../node_modules/tiny-invariant/dist/esm/tiny-invariant.js
var isProduction = !0, prefix = "Invariant failed";
function invariant(condition, message) {
  if (!condition) {
    if (isProduction)
      throw new Error(prefix);
    var provided = typeof message == "function" ? message() : message, value = provided ? "".concat(prefix, ": ").concat(provided) : prefix;
    throw new Error(value);
  }
}

// src/channels/postmessage/getEventSourceUrl.ts
var getEventSourceUrl = (event) => {
  let frames = Array.from(
    document.querySelectorAll("iframe[data-is-storybook]")
  ), [frame, ...remainder] = frames.filter((element) => {
    try {
      return element.contentWindow?.location.origin === event.source.location.origin && element.contentWindow?.location.pathname === event.source.location.pathname;
    } catch {
    }
    try {
      return element.contentWindow === event.source;
    } catch {
    }
    let src2 = element.getAttribute("src"), origin;
    try {
      if (!src2)
        return !1;
      ({ origin } = new URL(src2, document.location.toString()));
    } catch {
      return !1;
    }
    return origin === event.origin;
  }), src = frame?.getAttribute("src");
  if (src && remainder.length === 0) {
    let { protocol, host, pathname } = new URL(src, document.location.toString());
    return `${protocol}//${host}${pathname}`;
  }
  return remainder.length > 0 && logger.error("found multiple candidates for event source"), null;
};

// src/channels/postmessage/index.ts
var { document: document2, location } = scope, KEY = "storybook-channel", defaultEventOptions = { maxDepth: 25 }, PostMessageTransport = class {
  constructor(config4) {
    this.config = config4;
    this.connected = !1;
    if (this.buffer = [], typeof scope?.addEventListener == "function" && scope.addEventListener("message", this.handleEvent.bind(this), !1), config4.page !== "manager" && config4.page !== "preview")
      throw new Error(`postmsg-channel: "config.page" cannot be "${config4.page}"`);
  }
  setHandler(handler) {
    this.handler = (...args) => {
      handler.apply(this, args), !this.connected && this.getLocalFrame().length && (this.flush(), this.connected = !0);
    };
  }
  /**
   * Sends `event` to the associated window. If the window does not yet exist the event will be
   * stored in a buffer and sent when the window exists.
   *
   * @param event
   */
  send(event, options) {
    let {
      target,
      // telejson options
      allowRegExp,
      allowSymbol,
      allowDate,
      allowError,
      allowUndefined,
      maxDepth,
      space
    } = options || {}, eventOptions = Object.fromEntries(
      Object.entries({
        allowRegExp,
        allowSymbol,
        allowDate,
        allowError,
        allowUndefined,
        maxDepth,
        space
      }).filter(([k2, v2]) => typeof v2 < "u")
    ), stringifyOptions = {
      ...defaultEventOptions,
      ...scope.CHANNEL_OPTIONS || {},
      ...eventOptions
    }, frames = this.getFrames(target), query = new URLSearchParams(location?.search || ""), data = stringify(
      {
        key: KEY,
        event,
        refId: query.get("refId")
      },
      stringifyOptions
    );
    return frames.length ? (this.buffer.length && this.flush(), frames.forEach((f4) => {
      try {
        f4.postMessage(data, "*");
      } catch {
        logger.error("sending over postmessage fail");
      }
    }), Promise.resolve(null)) : new Promise((resolve, reject) => {
      this.buffer.push({ event, resolve, reject });
    });
  }
  flush() {
    let { buffer } = this;
    this.buffer = [], buffer.forEach((item) => {
      this.send(item.event).then(item.resolve).catch(item.reject);
    });
  }
  getFrames(target) {
    if (this.config.page === "manager") {
      let list = Array.from(
        document2.querySelectorAll("iframe[data-is-storybook][data-is-loaded]")
      ).flatMap((e2) => {
        try {
          return e2.contentWindow && e2.dataset.isStorybook !== void 0 && e2.id === target ? [e2.contentWindow] : [];
        } catch {
          return [];
        }
      });
      return list?.length ? list : this.getCurrentFrames();
    }
    return scope && scope.parent && scope.parent !== scope.self ? [scope.parent] : [];
  }
  getCurrentFrames() {
    return this.config.page === "manager" ? Array.from(
      document2.querySelectorAll('[data-is-storybook="true"]')
    ).flatMap((e2) => e2.contentWindow ? [e2.contentWindow] : []) : scope && scope.parent ? [scope.parent] : [];
  }
  getLocalFrame() {
    return this.config.page === "manager" ? Array.from(
      document2.querySelectorAll("#storybook-preview-iframe")
    ).flatMap((e2) => e2.contentWindow ? [e2.contentWindow] : []) : scope && scope.parent ? [scope.parent] : [];
  }
  handleEvent(rawEvent) {
    try {
      let { data } = rawEvent, { key, event, refId } = typeof data == "string" && isJSON(data) ? parse(data, scope.CHANNEL_OPTIONS || {}) : data;
      if (key === KEY) {
        let pageString = this.config.page === "manager" ? '<span style="color: #37D5D3; background: black"> manager </span>' : '<span style="color: #1EA7FD; background: black"> preview </span>', eventString = Object.values(core_events_exports).includes(event.type) ? `<span style="color: #FF4785">${event.type}</span>` : `<span style="color: #FFAE00">${event.type}</span>`;
        if (refId && (event.refId = refId), event.source = this.config.page === "preview" ? rawEvent.origin : getEventSourceUrl(rawEvent), !event.source) {
          pretty.error(
            `${pageString} received ${eventString} but was unable to determine the source of the event`
          );
          return;
        }
        let message = `${pageString} received ${eventString} (${data.length})`;
        pretty.debug(
          location.origin !== event.source ? message : `${message} <span style="color: gray">(on ${location.origin} from ${event.source})</span>`,
          ...event.args
        ), invariant(this.handler, "ChannelHandler should be set"), this.handler(event);
      }
    } catch (error) {
      logger.error(error);
    }
  }
};

// src/channels/websocket/index.ts
var { WebSocket } = scope, HEARTBEAT_INTERVAL = 15e3, HEARTBEAT_MAX_LATENCY = 5e3, WebsocketTransport = class {
  constructor({ url, onError, page }) {
    this.buffer = [];
    this.isReady = !1;
    this.isClosed = !1;
    this.pingTimeout = 0;
    this.socket = new WebSocket(url), this.socket.onopen = () => {
      this.isReady = !0, this.heartbeat(), this.flush();
    }, this.socket.onmessage = ({ data }) => {
      let event = typeof data == "string" && isJSON(data) ? parse(data) : data;
      invariant(this.handler, "WebsocketTransport handler should be set"), this.handler(event), event.type === "ping" && (this.heartbeat(), this.send({ type: "pong" }));
    }, this.socket.onerror = (e2) => {
      onError && onError(e2);
    }, this.socket.onclose = (ev) => {
      invariant(this.handler, "WebsocketTransport handler should be set"), this.handler({
        type: CHANNEL_WS_DISCONNECT,
        args: [{ reason: ev.reason, code: ev.code }],
        from: page || "preview"
      }), this.isClosed = !0, clearTimeout(this.pingTimeout);
    };
  }
  heartbeat() {
    clearTimeout(this.pingTimeout), this.pingTimeout = setTimeout(() => {
      this.socket.close(3008, "timeout");
    }, HEARTBEAT_INTERVAL + HEARTBEAT_MAX_LATENCY);
  }
  setHandler(handler) {
    this.handler = handler;
  }
  send(event) {
    this.isClosed || (this.isReady ? this.sendNow(event) : this.sendLater(event));
  }
  sendLater(event) {
    this.buffer.push(event);
  }
  sendNow(event) {
    let data = stringify(event, {
      maxDepth: 15,
      ...scope.CHANNEL_OPTIONS
    });
    this.socket.send(data);
  }
  flush() {
    let { buffer } = this;
    this.buffer = [], buffer.forEach((event) => this.send(event));
  }
};

// src/channels/index.ts
var { CONFIG_TYPE } = scope, channels_default = Channel;
function createBrowserChannel({ page, extraTransports = [] }) {
  let transports = [new PostMessageTransport({ page }), ...extraTransports];
  if (CONFIG_TYPE === "DEVELOPMENT") {
    let protocol = window.location.protocol === "http:" ? "ws" : "wss", { hostname, port } = window.location, channelUrl = `${protocol}://${hostname}:${port}/storybook-server-channel`;
    transports.push(new WebsocketTransport({ url: channelUrl, onError: () => {
    }, page }));
  }
  let channel = new Channel({ transports });
  return UniversalStore.__prepare(
    channel,
    page === "manager" ? UniversalStore.Environment.MANAGER : UniversalStore.Environment.PREVIEW
  ), channel;
}

// src/preview-errors.ts
var preview_errors_exports = {};
__export(preview_errors_exports, {
  CalledExtractOnStoreError: () => CalledExtractOnStoreError,
  CalledPreviewMethodBeforeInitializationError: () => CalledPreviewMethodBeforeInitializationError,
  Category: () => Category,
  ElementA11yParameterError: () => ElementA11yParameterError,
  EmptyIndexError: () => EmptyIndexError,
  ImplicitActionsDuringRendering: () => ImplicitActionsDuringRendering,
  MdxFileWithNoCsfReferencesError: () => MdxFileWithNoCsfReferencesError,
  MissingRenderToCanvasError: () => MissingRenderToCanvasError,
  MissingStoryAfterHmrError: () => MissingStoryAfterHmrError,
  MissingStoryFromCsfFileError: () => MissingStoryFromCsfFileError,
  MountMustBeDestructuredError: () => MountMustBeDestructuredError,
  NextJsSharpError: () => NextJsSharpError,
  NextjsRouterMocksNotAvailable: () => NextjsRouterMocksNotAvailable,
  NoRenderFunctionError: () => NoRenderFunctionError,
  NoStoryMatchError: () => NoStoryMatchError,
  NoStoryMountedError: () => NoStoryMountedError,
  StatusTypeIdMismatchError: () => StatusTypeIdMismatchError,
  StoryIndexFetchError: () => StoryIndexFetchError,
  StoryStoreAccessedBeforeInitializationError: () => StoryStoreAccessedBeforeInitializationError,
  UnknownArgTypesError: () => UnknownArgTypesError,
  UnsupportedViewportDimensionError: () => UnsupportedViewportDimensionError
});

// src/storybook-error.ts
function parseErrorCode({
  code,
  category
}) {
  let paddedCode = String(code).padStart(4, "0");
  return `SB_${category}_${paddedCode}`;
}
function appendErrorRef(url) {
  if (/^(?!.*storybook\.js\.org)|[?&]ref=error\b/.test(url))
    return url;
  try {
    let urlObj = new URL(url);
    return urlObj.searchParams.set("ref", "error"), urlObj.toString();
  } catch {
    return url;
  }
}
var StorybookError = class _StorybookError extends Error {
  constructor(props) {
    super(_StorybookError.getFullMessage(props));
    /**
     * Data associated with the error. Used to provide additional information in the error message or
     * to be passed to telemetry.
     */
    this.data = {};
    /** Flag used to easily determine if the error originates from Storybook. */
    this.fromStorybook = !0;
    /**
     * Flag used to determine if the error is handled by us and should therefore not be shown to the
     * user.
     */
    this.isHandledError = !1;
    /**
     * A collection of sub errors which relate to a parent error.
     *
     * Sub-errors are used to represent multiple related errors that occurred together. When a
     * StorybookError with sub-errors is sent to telemetry, both the parent error and each sub-error
     * are sent as separate telemetry events. This allows for better error tracking and debugging.
     *
     * @example
     *
     * ```ts
     * const error1 = new SomeError();
     * const error2 = new AnotherError();
     * const parentError = new ParentError({
     *   // ... other props
     *   subErrors: [error1, error2],
     * });
     * ```
     */
    this.subErrors = [];
    this.category = props.category, this.documentation = props.documentation ?? !1, this.code = props.code, this.isHandledError = props.isHandledError ?? !1, this.name = props.name, this.subErrors = props.subErrors ?? [];
  }
  get fullErrorCode() {
    return parseErrorCode({ code: this.code, category: this.category });
  }
  /** Overrides the default `Error.name` property in the format: SB_<CATEGORY>_<CODE>. */
  get name() {
    let errorName = this._name || this.constructor.name;
    return `${this.fullErrorCode} (${errorName})`;
  }
  set name(name) {
    this._name = name;
  }
  /** Generates the error message along with additional documentation link (if applicable). */
  static getFullMessage({
    documentation,
    code,
    category,
    message
  }) {
    let page;
    return documentation === !0 ? page = `https://storybook.js.org/error/${parseErrorCode({ code, category })}?ref=error` : typeof documentation == "string" ? page = appendErrorRef(documentation) : Array.isArray(documentation) && (page = `
${documentation.map((doc) => `	- ${appendErrorRef(doc)}`).join(`
`)}`), `${message}${page != null ? `

More info: ${page}
` : ""}`;
  }
};

// src/preview-errors.ts
var Category = /* @__PURE__ */ ((Category2) => (Category2.BLOCKS = "BLOCKS", Category2.DOCS_TOOLS = "DOCS-TOOLS", Category2.PREVIEW_CLIENT_LOGGER = "PREVIEW_CLIENT-LOGGER", Category2.PREVIEW_CHANNELS = "PREVIEW_CHANNELS", Category2.PREVIEW_CORE_EVENTS = "PREVIEW_CORE-EVENTS", Category2.PREVIEW_INSTRUMENTER = "PREVIEW_INSTRUMENTER", Category2.PREVIEW_API = "PREVIEW_API", Category2.PREVIEW_REACT_DOM_SHIM = "PREVIEW_REACT-DOM-SHIM", Category2.PREVIEW_ROUTER = "PREVIEW_ROUTER", Category2.PREVIEW_THEMING = "PREVIEW_THEMING", Category2.RENDERER_HTML = "RENDERER_HTML", Category2.RENDERER_PREACT = "RENDERER_PREACT", Category2.RENDERER_REACT = "RENDERER_REACT", Category2.RENDERER_SERVER = "RENDERER_SERVER", Category2.RENDERER_SVELTE = "RENDERER_SVELTE", Category2.RENDERER_VUE = "RENDERER_VUE", Category2.RENDERER_VUE3 = "RENDERER_VUE3", Category2.RENDERER_WEB_COMPONENTS = "RENDERER_WEB-COMPONENTS", Category2.FRAMEWORK_NEXTJS = "FRAMEWORK_NEXTJS", Category2.ADDON_VITEST = "ADDON_VITEST", Category2.ADDON_A11Y = "ADDON_A11Y", Category2))(Category || {}), MissingStoryAfterHmrError = class extends StorybookError {
  constructor(data) {
    super({
      name: "MissingStoryAfterHmrError",
      category: "PREVIEW_API" /* PREVIEW_API */,
      code: 1,
      message: dedent`
        Couldn't find story matching id '${data.storyId}' after HMR.
        - Did you just rename a story?
        - Did you remove it from your CSF file?
        - Are you sure a story with the id '${data.storyId}' exists?
        - Please check the values in the stories field of your main.js config and see if they would match your CSF File.
        - Also check the browser console and terminal for potential error messages.`
    });
    this.data = data;
  }
}, ImplicitActionsDuringRendering = class extends StorybookError {
  constructor(data) {
    super({
      name: "ImplicitActionsDuringRendering",
      category: "PREVIEW_API" /* PREVIEW_API */,
      code: 2,
      documentation: "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#using-implicit-actions-during-rendering-is-deprecated-for-example-in-the-play-function",
      message: dedent`
        We detected that you use an implicit action arg while ${data.phase} of your story.  
        ${data.deprecated ? `
This is deprecated and won't work in Storybook 8 anymore.
` : ""}
        Please provide an explicit spy to your args like this:
          import { fn } from 'storybook/test';
          ... 
          args: {
           ${data.name}: fn()
          }`
    });
    this.data = data;
  }
}, CalledExtractOnStoreError = class extends StorybookError {
  constructor() {
    super({
      name: "CalledExtractOnStoreError",
      category: "PREVIEW_API" /* PREVIEW_API */,
      code: 3,
      message: dedent`
        Cannot call \`storyStore.extract()\` without calling \`storyStore.cacheAllCsfFiles()\` first.

        You probably meant to call \`await preview.extract()\` which does the above for you.`
    });
  }
}, MissingRenderToCanvasError = class extends StorybookError {
  constructor() {
    super({
      name: "MissingRenderToCanvasError",
      category: "PREVIEW_API" /* PREVIEW_API */,
      code: 4,
      message: dedent`
        Expected your framework's preset to export a \`renderToCanvas\` field.

        Perhaps it needs to be upgraded for Storybook 7.0?`,
      documentation: "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#mainjs-framework-field"
    });
  }
}, CalledPreviewMethodBeforeInitializationError = class extends StorybookError {
  constructor(data) {
    super({
      name: "CalledPreviewMethodBeforeInitializationError",
      category: "PREVIEW_API" /* PREVIEW_API */,
      code: 5,
      message: dedent`
        Called \`Preview.${data.methodName}()\` before initialization.
        
        The preview needs to load the story index before most methods can be called. If you want
        to call \`${data.methodName}\`, try \`await preview.initializationPromise;\` first.
        
        If you didn't call the above code, then likely it was called by an addon that needs to
        do the above.`
    });
    this.data = data;
  }
}, StoryIndexFetchError = class extends StorybookError {
  constructor(data) {
    super({
      name: "StoryIndexFetchError",
      category: "PREVIEW_API" /* PREVIEW_API */,
      code: 6,
      message: dedent`
        Error fetching \`/index.json\`:
        
        ${data.text}

        If you are in development, this likely indicates a problem with your Storybook process,
        check the terminal for errors.

        If you are in a deployed Storybook, there may have been an issue deploying the full Storybook
        build.`
    });
    this.data = data;
  }
}, MdxFileWithNoCsfReferencesError = class extends StorybookError {
  constructor(data) {
    super({
      name: "MdxFileWithNoCsfReferencesError",
      category: "PREVIEW_API" /* PREVIEW_API */,
      code: 7,
      message: dedent`
        Tried to render docs entry ${data.storyId} but it is a MDX file that has no CSF
        references, or autodocs for a CSF file that some doesn't refer to itself.
        
        This likely is an internal error in Storybook's indexing, or you've attached the
        \`attached-mdx\` tag to an MDX file that is not attached.`
    });
    this.data = data;
  }
}, EmptyIndexError = class extends StorybookError {
  constructor() {
    super({
      name: "EmptyIndexError",
      category: "PREVIEW_API" /* PREVIEW_API */,
      code: 8,
      message: dedent`
        Couldn't find any stories in your Storybook.

        - Please check your stories field of your main.js config: does it match correctly?
        - Also check the browser console and terminal for error messages.`
    });
  }
}, NoStoryMatchError = class extends StorybookError {
  constructor(data) {
    super({
      name: "NoStoryMatchError",
      category: "PREVIEW_API" /* PREVIEW_API */,
      code: 9,
      message: dedent`
        Couldn't find story matching '${data.storySpecifier}'.

        - Are you sure a story with that id exists?
        - Please check your stories field of your main.js config.
        - Also check the browser console and terminal for error messages.`
    });
    this.data = data;
  }
}, MissingStoryFromCsfFileError = class extends StorybookError {
  constructor(data) {
    super({
      name: "MissingStoryFromCsfFileError",
      category: "PREVIEW_API" /* PREVIEW_API */,
      code: 10,
      message: dedent`
        Couldn't find story matching id '${data.storyId}' after importing a CSF file.

        The file was indexed as if the story was there, but then after importing the file in the browser
        we didn't find the story. Possible reasons:
        - You are using a custom story indexer that is misbehaving.
        - You have a custom file loader that is removing or renaming exports.

        Please check your browser console and terminal for errors that may explain the issue.`
    });
    this.data = data;
  }
}, StoryStoreAccessedBeforeInitializationError = class extends StorybookError {
  constructor() {
    super({
      name: "StoryStoreAccessedBeforeInitializationError",
      category: "PREVIEW_API" /* PREVIEW_API */,
      code: 11,
      message: dedent`
        Cannot access the Story Store until the index is ready.

        It is not recommended to use methods directly on the Story Store anyway, in Storybook 9 we will
        remove access to the store entirely`
    });
  }
}, MountMustBeDestructuredError = class extends StorybookError {
  // name: 'MountMustBeDestructuredError';
  constructor(data) {
    super({
      name: "MountMustBeDestructuredError",
      category: "PREVIEW_API" /* PREVIEW_API */,
      code: 12,
      message: dedent`
      Incorrect use of mount in the play function.
      
      To use mount in the play function, you must satisfy the following two requirements: 
      
      1. You *must* destructure the mount property from the \`context\` (the argument passed to your play function). 
         This makes sure that Storybook does not start rendering the story before the play function begins.
      
      2. Your Storybook framework or builder must be configured to transpile to ES2017 or newer. 
         This is because destructuring statements and async/await usages are otherwise transpiled away, 
         which prevents Storybook from recognizing your usage of \`mount\`.
      
      Note that Angular is not supported. As async/await is transpiled to support the zone.js polyfill. 
      
      More info: https://storybook.js.org/docs/writing-tests/interaction-testing?ref=error#run-code-before-the-component-gets-rendered
      
      Received the following play function:
      ${data.playFunction}`
    });
    this.data = data;
  }
}, NoRenderFunctionError = class extends StorybookError {
  constructor(data) {
    super({
      name: "NoRenderFunctionError",
      category: "PREVIEW_API" /* PREVIEW_API */,
      code: 14,
      message: dedent`
        No render function available for storyId '${data.id}'
      `
    });
    this.data = data;
  }
}, NoStoryMountedError = class extends StorybookError {
  constructor() {
    super({
      name: "NoStoryMountedError",
      category: "PREVIEW_API" /* PREVIEW_API */,
      code: 15,
      message: dedent`
        No component is mounted in your story.
        
        This usually occurs when you destructure mount in the play function, but forget to call it.
        
        For example:

        async play({ mount, canvasElement }) {
          //  mount should be called: await mount(); 
          const canvas = within(canvasElement);
          const button = await canvas.findByRole('button');
          await userEvent.click(button);
        };

        Make sure to either remove it or call mount in your play function.
      `
    });
  }
}, StatusTypeIdMismatchError = class extends StorybookError {
  constructor(data) {
    super({
      name: "StatusTypeIdMismatchError",
      category: "PREVIEW_API" /* PREVIEW_API */,
      code: 16,
      message: `Status has typeId "${data.status.typeId}" but was added to store with typeId "${data.typeId}". Full status: ${JSON.stringify(
        data.status,
        null,
        2
      )}`
    });
    this.data = data;
  }
}, NextJsSharpError = class extends StorybookError {
  constructor() {
    super({
      name: "NextJsSharpError",
      category: "FRAMEWORK_NEXTJS" /* FRAMEWORK_NEXTJS */,
      code: 1,
      documentation: "https://storybook.js.org/docs/get-started/nextjs#faq",
      message: dedent`
      You are importing avif images, but you don't have sharp installed.

      You have to install sharp in order to use image optimization features in Next.js.
      `
    });
  }
}, NextjsRouterMocksNotAvailable = class extends StorybookError {
  constructor(data) {
    super({
      name: "NextjsRouterMocksNotAvailable",
      category: "FRAMEWORK_NEXTJS" /* FRAMEWORK_NEXTJS */,
      code: 2,
      message: dedent`
        Tried to access router mocks from "${data.importType}" but they were not created yet. You might be running code in an unsupported environment.
      `
    });
    this.data = data;
  }
}, UnknownArgTypesError = class extends StorybookError {
  constructor(data) {
    super({
      name: "UnknownArgTypesError",
      category: "DOCS-TOOLS" /* DOCS_TOOLS */,
      code: 1,
      documentation: "https://github.com/storybookjs/storybook/issues/26606",
      message: dedent`
        There was a failure when generating detailed ArgTypes in ${data.language} for:
        ${JSON.stringify(data.type, null, 2)} 
        
        Storybook will fall back to use a generic type description instead.

        This type is either not supported or it is a bug in the docgen generation in Storybook.
        If you think this is a bug, please detail it as much as possible in the Github issue.
      `
    });
    this.data = data;
  }
}, UnsupportedViewportDimensionError = class extends StorybookError {
  constructor(data) {
    super({
      name: "UnsupportedViewportDimensionError",
      category: "ADDON_VITEST" /* ADDON_VITEST */,
      code: 1,
      // TODO: Add documentation about viewports support
      // documentation: '',
      message: dedent`
        Encountered an unsupported value "${data.value}" when setting the viewport ${data.dimension} dimension.
        
        The Storybook plugin only supports values in the following units:
        - px, vh, vw, em, rem and %.
        
        You can either change the viewport for this story to use one of the supported units or skip the test by adding '!test' to the story's tags per https://storybook.js.org/docs/writing-stories/tags
      `
    });
    this.data = data;
  }
}, ElementA11yParameterError = class extends StorybookError {
  constructor() {
    super({
      name: "ElementA11yParameterError",
      category: "ADDON_A11Y" /* ADDON_A11Y */,
      code: 1,
      documentation: "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#a11y-addon-replace-element-parameter-with-context-parameter",
      message: 'The "element" parameter in parameters.a11y has been removed. Use "context" instead.'
    });
  }
};

// src/types/index.ts
var types_exports = {};
__export(types_exports, {
  Addon_TypesEnum: () => Addon_TypesEnum,
  CoreWebpackCompiler: () => CoreWebpackCompiler,
  Feature: () => Feature,
  SupportedBuilder: () => SupportedBuilder,
  SupportedFramework: () => SupportedFramework,
  SupportedLanguage: () => SupportedLanguage,
  SupportedRenderer: () => SupportedRenderer
});

// src/types/modules/addons.ts
var Addon_TypesEnum = /* @__PURE__ */ ((Addon_TypesEnum2) => (Addon_TypesEnum2.TAB = "tab", Addon_TypesEnum2.PANEL = "panel", Addon_TypesEnum2.TOOL = "tool", Addon_TypesEnum2.TOOLEXTRA = "toolextra", Addon_TypesEnum2.PREVIEW = "preview", Addon_TypesEnum2.experimental_PAGE = "page", Addon_TypesEnum2.experimental_TEST_PROVIDER = "test-provider", Addon_TypesEnum2))(Addon_TypesEnum || {});

// src/types/modules/frameworks.ts
var SupportedFramework = /* @__PURE__ */ ((SupportedFramework2) => (SupportedFramework2.ANGULAR = "angular", SupportedFramework2.EMBER = "ember", SupportedFramework2.HTML_VITE = "html-vite", SupportedFramework2.NEXTJS = "nextjs", SupportedFramework2.NEXTJS_VITE = "nextjs-vite", SupportedFramework2.PREACT_VITE = "preact-vite", SupportedFramework2.REACT_NATIVE_WEB_VITE = "react-native-web-vite", SupportedFramework2.REACT_VITE = "react-vite", SupportedFramework2.REACT_WEBPACK5 = "react-webpack5", SupportedFramework2.SERVER_WEBPACK5 = "server-webpack5", SupportedFramework2.SVELTE_VITE = "svelte-vite", SupportedFramework2.SVELTEKIT = "sveltekit", SupportedFramework2.VUE3_VITE = "vue3-vite", SupportedFramework2.WEB_COMPONENTS_VITE = "web-components-vite", SupportedFramework2.HTML_RSBUILD = "html-rsbuild", SupportedFramework2.NUXT = "nuxt", SupportedFramework2.QWIK = "qwik", SupportedFramework2.REACT_RSBUILD = "react-rsbuild", SupportedFramework2.SOLID = "solid", SupportedFramework2.VUE3_RSBUILD = "vue3-rsbuild", SupportedFramework2.WEB_COMPONENTS_RSBUILD = "web-components-rsbuild", SupportedFramework2))(SupportedFramework || {});

// src/types/modules/renderers.ts
var SupportedRenderer = /* @__PURE__ */ ((SupportedRenderer2) => (SupportedRenderer2.REACT = "react", SupportedRenderer2.REACT_NATIVE = "react-native", SupportedRenderer2.VUE3 = "vue3", SupportedRenderer2.ANGULAR = "angular", SupportedRenderer2.EMBER = "ember", SupportedRenderer2.PREACT = "preact", SupportedRenderer2.SVELTE = "svelte", SupportedRenderer2.QWIK = "qwik", SupportedRenderer2.HTML = "html", SupportedRenderer2.WEB_COMPONENTS = "web-components", SupportedRenderer2.SERVER = "server", SupportedRenderer2.SOLID = "solid", SupportedRenderer2.NUXT = "nuxt", SupportedRenderer2))(SupportedRenderer || {});

// src/types/modules/webpack.ts
var CoreWebpackCompiler = /* @__PURE__ */ ((CoreWebpackCompiler2) => (CoreWebpackCompiler2.Babel = "babel", CoreWebpackCompiler2.SWC = "swc", CoreWebpackCompiler2))(CoreWebpackCompiler || {});

// src/types/modules/builders.ts
var SupportedBuilder = /* @__PURE__ */ ((SupportedBuilder2) => (SupportedBuilder2.WEBPACK5 = "webpack5", SupportedBuilder2.VITE = "vite", SupportedBuilder2.RSBUILD = "rsbuild", SupportedBuilder2))(SupportedBuilder || {});

// src/types/modules/features.ts
var Feature = /* @__PURE__ */ ((Feature2) => (Feature2.DOCS = "docs", Feature2.TEST = "test", Feature2.ONBOARDING = "onboarding", Feature2.A11Y = "a11y", Feature2))(Feature || {});

// src/types/modules/languages.ts
var SupportedLanguage = /* @__PURE__ */ ((SupportedLanguage2) => (SupportedLanguage2.JAVASCRIPT = "javascript", SupportedLanguage2.TYPESCRIPT = "typescript", SupportedLanguage2))(SupportedLanguage || {});

// src/actions/index.ts
var actions_exports = {};
__export(actions_exports, {
  ADDON_ID: () => ADDON_ID,
  CLEAR_ID: () => CLEAR_ID,
  CYCLIC_KEY: () => CYCLIC_KEY,
  EVENT_ID: () => EVENT_ID,
  PANEL_ID: () => PANEL_ID,
  PARAM_KEY: () => PARAM_KEY,
  action: () => action,
  actions: () => actions,
  config: () => config3,
  configureActions: () => configureActions
});

// src/actions/constants.ts
var PARAM_KEY = "actions", ADDON_ID = "storybook/actions", PANEL_ID = `${ADDON_ID}/panel`, EVENT_ID = `${ADDON_ID}/action-event`, CLEAR_ID = `${ADDON_ID}/action-clear`, CYCLIC_KEY = "$___storybook.isCyclic";

// src/preview-api/index.ts
var preview_api_exports = {};
__export(preview_api_exports, {
  DocsContext: () => DocsContext,
  HooksContext: () => HooksContext,
  Preview: () => Preview,
  PreviewWeb: () => PreviewWeb,
  PreviewWithSelection: () => PreviewWithSelection,
  ReporterAPI: () => ReporterAPI,
  StoryStore: () => StoryStore,
  UrlStore: () => UrlStore,
  WebView: () => WebView,
  addons: () => addons,
  applyHooks: () => applyHooks,
  combineArgs: () => combineArgs,
  combineParameters: () => combineParameters,
  composeConfigs: () => composeConfigs,
  composeStepRunners: () => composeStepRunners,
  composeStories: () => composeStories,
  composeStory: () => composeStory,
  createPlaywrightTest: () => createPlaywrightTest,
  decorateStory: () => decorateStory,
  defaultDecorateStory: () => defaultDecorateStory,
  emitTransformCode: () => emitTransformCode,
  filterArgTypes: () => filterArgTypes,
  getCsfFactoryAnnotations: () => getCsfFactoryAnnotations,
  inferControls: () => inferControls,
  makeDecorator: () => makeDecorator,
  mockChannel: () => mockChannel,
  normalizeArrays: () => normalizeArrays,
  normalizeProjectAnnotations: () => normalizeProjectAnnotations,
  normalizeStory: () => normalizeStory,
  pauseAnimations: () => pauseAnimations,
  prepareMeta: () => prepareMeta,
  prepareStory: () => prepareStory,
  sanitizeStoryContextUpdate: () => sanitizeStoryContextUpdate,
  setDefaultProjectAnnotations: () => setDefaultProjectAnnotations,
  setProjectAnnotations: () => setProjectAnnotations,
  simulateDOMContentLoaded: () => simulateDOMContentLoaded,
  simulatePageLoad: () => simulatePageLoad,
  sortStoriesV7: () => sortStoriesV7,
  useArgs: () => useArgs,
  useCallback: () => useCallback,
  useChannel: () => useChannel,
  useEffect: () => useEffect,
  useGlobals: () => useGlobals,
  useMemo: () => useMemo,
  useParameter: () => useParameter,
  useReducer: () => useReducer,
  useRef: () => useRef,
  useState: () => useState,
  useStoryContext: () => useStoryContext,
  userOrAutoTitle: () => userOrAutoTitle,
  userOrAutoTitleFromSpecifier: () => userOrAutoTitleFromSpecifier,
  waitForAnimations: () => waitForAnimations
});

// src/preview-api/modules/addons/storybook-channel-mock.ts
function mockChannel() {
  let transport = {
    setHandler: () => {
    },
    send: () => {
    }
  };
  return new Channel({ transport });
}

// src/preview-api/modules/addons/main.ts
var AddonStore = class {
  constructor() {
    this.getChannel = () => {
      if (!this.channel) {
        let channel = mockChannel();
        return this.setChannel(channel), channel;
      }
      return this.channel;
    };
    this.ready = () => this.promise;
    this.hasChannel = () => !!this.channel;
    this.setChannel = (channel) => {
      this.channel = channel, this.resolve();
    };
    this.promise = new Promise((res) => {
      this.resolve = () => res(this.getChannel());
    });
  }
}, KEY2 = "__STORYBOOK_ADDONS_PREVIEW";
function getAddonsStore() {
  return scope[KEY2] || (scope[KEY2] = new AddonStore()), scope[KEY2];
}
var addons = getAddonsStore();

// src/preview-api/modules/addons/hooks.ts
var HooksContext = class {
  constructor() {
    this.hookListsMap = void 0;
    this.mountedDecorators = void 0;
    this.prevMountedDecorators = void 0;
    this.currentHooks = void 0;
    this.nextHookIndex = void 0;
    this.currentPhase = void 0;
    this.currentEffects = void 0;
    this.prevEffects = void 0;
    this.currentDecoratorName = void 0;
    this.hasUpdates = void 0;
    this.currentContext = void 0;
    this.renderListener = (storyId) => {
      storyId === this.currentContext?.id && (this.triggerEffects(), this.currentContext = null, this.removeRenderListeners());
    };
    this.init();
  }
  init() {
    this.hookListsMap = /* @__PURE__ */ new WeakMap(), this.mountedDecorators = /* @__PURE__ */ new Set(), this.prevMountedDecorators = /* @__PURE__ */ new Set(), this.currentHooks = [], this.nextHookIndex = 0, this.currentPhase = "NONE", this.currentEffects = [], this.prevEffects = [], this.currentDecoratorName = null, this.hasUpdates = !1, this.currentContext = null;
  }
  clean() {
    this.prevEffects.forEach((effect) => {
      effect.destroy && effect.destroy();
    }), this.init(), this.removeRenderListeners();
  }
  getNextHook() {
    let hook = this.currentHooks[this.nextHookIndex];
    return this.nextHookIndex += 1, hook;
  }
  triggerEffects() {
    this.prevEffects.forEach((effect) => {
      !this.currentEffects.includes(effect) && effect.destroy && effect.destroy();
    }), this.currentEffects.forEach((effect) => {
      this.prevEffects.includes(effect) || (effect.destroy = effect.create());
    }), this.prevEffects = this.currentEffects, this.currentEffects = [];
  }
  addRenderListeners() {
    this.removeRenderListeners(), addons.getChannel().on(STORY_RENDERED, this.renderListener);
  }
  removeRenderListeners() {
    addons.getChannel().removeListener(STORY_RENDERED, this.renderListener);
  }
};
function hookify(fn3) {
  let hookified = (...args) => {
    let { hooks } = typeof args[0] == "function" ? args[1] : args[0], prevPhase = hooks.currentPhase, prevHooks = hooks.currentHooks, prevNextHookIndex = hooks.nextHookIndex, prevDecoratorName = hooks.currentDecoratorName;
    hooks.currentDecoratorName = fn3.name, hooks.prevMountedDecorators.has(fn3) ? (hooks.currentPhase = "UPDATE", hooks.currentHooks = hooks.hookListsMap.get(fn3) || []) : (hooks.currentPhase = "MOUNT", hooks.currentHooks = [], hooks.hookListsMap.set(fn3, hooks.currentHooks), hooks.prevMountedDecorators.add(fn3)), hooks.nextHookIndex = 0;
    let prevContext = scope.STORYBOOK_HOOKS_CONTEXT;
    scope.STORYBOOK_HOOKS_CONTEXT = hooks;
    let result = fn3(...args);
    if (scope.STORYBOOK_HOOKS_CONTEXT = prevContext, hooks.currentPhase === "UPDATE" && hooks.getNextHook() != null)
      throw new Error(
        "Rendered fewer hooks than expected. This may be caused by an accidental early return statement."
      );
    return hooks.currentPhase = prevPhase, hooks.currentHooks = prevHooks, hooks.nextHookIndex = prevNextHookIndex, hooks.currentDecoratorName = prevDecoratorName, result;
  };
  return hookified.originalFn = fn3, hookified;
}
var numberOfRenders = 0, RENDER_LIMIT = 25, applyHooks = (applyDecorators) => (storyFn, decorators4) => {
  let decorated = applyDecorators(
    hookify(storyFn),
    decorators4.map((decorator) => hookify(decorator))
  );
  return (context) => {
    let { hooks } = context;
    hooks.prevMountedDecorators ??= /* @__PURE__ */ new Set(), hooks.mountedDecorators = /* @__PURE__ */ new Set([storyFn, ...decorators4]), hooks.currentContext = context, hooks.hasUpdates = !1;
    let result = decorated(context);
    for (numberOfRenders = 1; hooks.hasUpdates; )
      if (hooks.hasUpdates = !1, hooks.currentEffects = [], result = decorated(context), numberOfRenders += 1, numberOfRenders > RENDER_LIMIT)
        throw new Error(
          "Too many re-renders. Storybook limits the number of renders to prevent an infinite loop."
        );
    return hooks.addRenderListeners(), result;
  };
}, areDepsEqual = (deps, nextDeps) => deps.length === nextDeps.length && deps.every((dep, i2) => dep === nextDeps[i2]), invalidHooksError = () => new Error("Storybook preview hooks can only be called inside decorators and story functions.");
function getHooksContextOrNull() {
  return scope.STORYBOOK_HOOKS_CONTEXT || null;
}
function getHooksContextOrThrow() {
  let hooks = getHooksContextOrNull();
  if (hooks == null)
    throw invalidHooksError();
  return hooks;
}
function useHook(name, callback, deps) {
  let hooks = getHooksContextOrThrow();
  if (hooks.currentPhase === "MOUNT") {
    deps != null && !Array.isArray(deps) && logger.warn(
      `${name} received a final argument that is not an array (instead, received ${deps}). When specified, the final argument must be an array.`
    );
    let hook = { name, deps };
    return hooks.currentHooks.push(hook), callback(hook), hook;
  }
  if (hooks.currentPhase === "UPDATE") {
    let hook = hooks.getNextHook();
    if (hook == null)
      throw new Error("Rendered more hooks than during the previous render.");
    return hook.name !== name && logger.warn(
      `Storybook has detected a change in the order of Hooks${hooks.currentDecoratorName ? ` called by ${hooks.currentDecoratorName}` : ""}. This will lead to bugs and errors if not fixed.`
    ), deps != null && hook.deps == null && logger.warn(
      `${name} received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.`
    ), deps != null && hook.deps != null && deps.length !== hook.deps.length && logger.warn(`The final argument passed to ${name} changed size between renders. The order and size of this array must remain constant.
Previous: ${hook.deps}
Incoming: ${deps}`), (deps == null || hook.deps == null || !areDepsEqual(deps, hook.deps)) && (callback(hook), hook.deps = deps), hook;
  }
  throw invalidHooksError();
}
function useMemoLike(name, nextCreate, deps) {
  let { memoizedState } = useHook(
    name,
    (hook) => {
      hook.memoizedState = nextCreate();
    },
    deps
  );
  return memoizedState;
}
function useMemo(nextCreate, deps) {
  return useMemoLike("useMemo", nextCreate, deps);
}
function useCallback(callback, deps) {
  return useMemoLike("useCallback", () => callback, deps);
}
function useRefLike(name, initialValue2) {
  return useMemoLike(name, () => ({ current: initialValue2 }), []);
}
function useRef(initialValue2) {
  return useRefLike("useRef", initialValue2);
}
function triggerUpdate() {
  let hooks = getHooksContextOrNull();
  if (hooks != null && hooks.currentPhase !== "NONE")
    hooks.hasUpdates = !0;
  else
    try {
      addons.getChannel().emit(FORCE_RE_RENDER);
    } catch {
      logger.warn("State updates of Storybook preview hooks work only in browser");
    }
}
function useStateLike(name, initialState) {
  let stateRef = useRefLike(
    name,
    // @ts-expect-error S type should never be function, but there's no way to tell that to TypeScript
    typeof initialState == "function" ? initialState() : initialState
  ), setState2 = (update) => {
    stateRef.current = typeof update == "function" ? update(stateRef.current) : update, triggerUpdate();
  };
  return [stateRef.current, setState2];
}
function useState(initialState) {
  return useStateLike("useState", initialState);
}
function useReducer(reducer, initialArg, init2) {
  let initialState = init2 != null ? () => init2(initialArg) : initialArg, [state3, setState2] = useStateLike("useReducer", initialState);
  return [state3, (action2) => setState2((prevState) => reducer(prevState, action2))];
}
function useEffect(create, deps) {
  let hooks = getHooksContextOrThrow(), effect = useMemoLike("useEffect", () => ({ create }), deps);
  hooks.currentEffects.includes(effect) || hooks.currentEffects.push(effect);
}
function useChannel(eventMap3, deps = []) {
  let channel = addons.getChannel();
  return useEffect(() => (Object.entries(eventMap3).forEach(([type5, listener]) => channel.on(type5, listener)), () => {
    Object.entries(eventMap3).forEach(
      ([type5, listener]) => channel.removeListener(type5, listener)
    );
  }), [...Object.keys(eventMap3), ...deps]), useCallback(channel.emit.bind(channel), [channel]);
}
function useStoryContext() {
  let { currentContext } = getHooksContextOrThrow();
  if (currentContext == null)
    throw invalidHooksError();
  return currentContext;
}
function useParameter(parameterKey, defaultValue) {
  let { parameters: parameters2 } = useStoryContext();
  if (parameterKey)
    return parameters2[parameterKey] ?? defaultValue;
}
function useArgs() {
  let channel = addons.getChannel(), { id: storyId, args } = useStoryContext(), updateArgs = useCallback(
    (updatedArgs) => channel.emit(UPDATE_STORY_ARGS, { storyId, updatedArgs }),
    [channel, storyId]
  ), resetArgs = useCallback(
    (argNames) => channel.emit(RESET_STORY_ARGS, { storyId, argNames }),
    [channel, storyId]
  );
  return [args, updateArgs, resetArgs];
}
function useGlobals() {
  let channel = addons.getChannel(), { globals } = useStoryContext(), updateGlobals = useCallback(
    (newGlobals) => channel.emit(UPDATE_GLOBALS, { globals: newGlobals }),
    [channel]
  );
  return [globals, updateGlobals];
}

// src/preview-api/modules/addons/make-decorator.ts
var makeDecorator = ({
  name,
  parameterName,
  wrapper,
  skipIfNoParametersOrOptions = !1
}) => {
  let decorator = (options) => (storyFn, context) => {
    let parameters2 = context.parameters && context.parameters[parameterName];
    return parameters2 && parameters2.disable || skipIfNoParametersOrOptions && !options && !parameters2 ? storyFn(context) : wrapper(storyFn, context, {
      options,
      parameters: parameters2
    });
  };
  return (...args) => typeof args[0] == "function" ? decorator()(...args) : (...innerArgs) => {
    if (innerArgs.length > 1)
      return args.length > 1 ? decorator(args)(...innerArgs) : decorator(...args)(...innerArgs);
    throw new Error(
      `Passing stories directly into ${name}() is not allowed,
        instead use addDecorator(${name}) and pass options with the '${parameterName}' parameter`
    );
  };
};

// src/csf/toStartCaseStr.ts
function toStartCaseStr(str2) {
  return str2.replace(/_/g, " ").replace(/-/g, " ").replace(/\./g, " ").replace(/([^\n])([A-Z])([a-z])/g, (str22, $1, $2, $3) => `${$1} ${$2}${$3}`).replace(/([a-z])([A-Z])/g, (str22, $1, $2) => `${$1} ${$2}`).replace(/([a-z])([0-9])/gi, (str22, $1, $2) => `${$1} ${$2}`).replace(/([0-9])([a-z])/gi, (str22, $1, $2) => `${$1} ${$2}`).replace(/(\s|^)(\w)/g, (str22, $1, $2) => `${$1}${$2.toUpperCase()}`).replace(/ +/g, " ").trim();
}

// src/csf/includeConditionalArg.ts
var import_tiny_isequal = __toESM(require_tiny_isequal(), 1), count = (vals) => vals.map((v2) => typeof v2 < "u").filter(Boolean).length, testValue = (cond, value) => {
  let { exists, eq: eq4, neq, truthy } = cond;
  if (count([exists, eq4, neq, truthy]) > 1)
    throw new Error(`Invalid conditional test ${JSON.stringify({ exists, eq: eq4, neq })}`);
  if (typeof eq4 < "u")
    return (0, import_tiny_isequal.isEqual)(value, eq4);
  if (typeof neq < "u")
    return !(0, import_tiny_isequal.isEqual)(value, neq);
  if (typeof exists < "u") {
    let valueExists = typeof value < "u";
    return exists ? valueExists : !valueExists;
  }
  return (typeof truthy > "u" ? !0 : truthy) ? !!value : !value;
}, includeConditionalArg = (argType, args, globals) => {
  if (!argType.if)
    return !0;
  let { arg, global: global2 } = argType.if;
  if (count([arg, global2]) !== 1)
    throw new Error(`Invalid conditional value ${JSON.stringify({ arg, global: global2 })}`);
  let value = arg ? args[arg] : globals[global2];
  return testValue(argType.if, value);
};

// src/preview-api/modules/preview-web/render/mount-utils.ts
function mountDestructured(playFunction) {
  return playFunction != null && getUsedProps(playFunction).includes("mount");
}
function getUsedProps(fn3) {
  let match = fn3.toString().match(/[^(]*\(([^)]*)/);
  if (!match)
    return [];
  let args = splitByComma(match[1]);
  if (!args.length)
    return [];
  let first = args[0];
  return first.startsWith("{") && first.endsWith("}") ? splitByComma(first.slice(1, -1).replace(/\s/g, "")).map((prop) => prop.replace(/:.*|=.*/g, "")) : [];
}
function splitByComma(s3) {
  let result = [], stack = [], start = 0;
  for (let i2 = 0; i2 < s3.length; i2++)
    if (s3[i2] === "{" || s3[i2] === "[")
      stack.push(s3[i2] === "{" ? "}" : "]");
    else if (s3[i2] === stack[stack.length - 1])
      stack.pop();
    else if (!stack.length && s3[i2] === ",") {
      let token = s3.substring(start, i2).trim();
      token && result.push(token), start = i2 + 1;
    }
  let lastToken = s3.substring(start).trim();
  return lastToken && result.push(lastToken), result;
}

// src/actions/addArgs.ts
var addArgs_exports = {};
__export(addArgs_exports, {
  argsEnhancers: () => argsEnhancers
});

// src/actions/addArgsHelpers.ts
var isInInitialArgs = (name, initialArgs) => typeof initialArgs[name] > "u" && !(name in initialArgs), inferActionsFromArgTypesRegex = (context) => {
  let {
    initialArgs,
    argTypes,
    id,
    parameters: { actions: actions2 }
  } = context;
  if (!actions2 || actions2.disable || !actions2.argTypesRegex || !argTypes)
    return {};
  let argTypesRegex = new RegExp(actions2.argTypesRegex);
  return Object.entries(argTypes).filter(
    ([name]) => !!argTypesRegex.test(name)
  ).reduce((acc, [name, argType]) => (isInInitialArgs(name, initialArgs) && (acc[name] = action(name, { implicit: !0, id })), acc), {});
}, addActionsFromArgTypes = (context) => {
  let {
    initialArgs,
    argTypes,
    parameters: { actions: actions2 }
  } = context;
  return actions2?.disable || !argTypes ? {} : Object.entries(argTypes).filter(([name, argType]) => !!argType.action).reduce((acc, [name, argType]) => (isInInitialArgs(name, initialArgs) && (acc[name] = action(typeof argType.action == "string" ? argType.action : name)), acc), {});
};

// src/actions/addArgs.ts
var argsEnhancers = [
  addActionsFromArgTypes,
  inferActionsFromArgTypesRegex
];

// src/actions/loaders.ts
var loaders_exports = {};
__export(loaders_exports, {
  loaders: () => loaders
});

// src/test/index.ts
var test_exports = {};
__export(test_exports, {
  buildQueries: () => buildQueries2,
  clearAllMocks: () => clearAllMocks,
  configure: () => configure2,
  createEvent: () => createEvent3,
  expect: () => expect3,
  findAllByAltText: () => findAllByAltText2,
  findAllByDisplayValue: () => findAllByDisplayValue2,
  findAllByLabelText: () => findAllByLabelText2,
  findAllByPlaceholderText: () => findAllByPlaceholderText2,
  findAllByRole: () => findAllByRole2,
  findAllByTestId: () => findAllByTestId2,
  findAllByText: () => findAllByText2,
  findAllByTitle: () => findAllByTitle2,
  findByAltText: () => findByAltText2,
  findByDisplayValue: () => findByDisplayValue2,
  findByLabelText: () => findByLabelText2,
  findByPlaceholderText: () => findByPlaceholderText2,
  findByRole: () => findByRole2,
  findByTestId: () => findByTestId2,
  findByText: () => findByText2,
  findByTitle: () => findByTitle2,
  fireEvent: () => fireEvent2,
  fn: () => fn2,
  getAllByAltText: () => getAllByAltText2,
  getAllByDisplayValue: () => getAllByDisplayValue2,
  getAllByLabelText: () => getAllByLabelText2,
  getAllByPlaceholderText: () => getAllByPlaceholderText2,
  getAllByRole: () => getAllByRole2,
  getAllByTestId: () => getAllByTestId2,
  getAllByText: () => getAllByText2,
  getAllByTitle: () => getAllByTitle2,
  getByAltText: () => getByAltText2,
  getByDisplayValue: () => getByDisplayValue2,
  getByLabelText: () => getByLabelText2,
  getByPlaceholderText: () => getByPlaceholderText2,
  getByRole: () => getByRole2,
  getByTestId: () => getByTestId2,
  getByText: () => getByText2,
  getByTitle: () => getByTitle2,
  getConfig: () => getConfig3,
  getDefaultNormalizer: () => getDefaultNormalizer2,
  getElementError: () => getElementError2,
  getNodeText: () => getNodeText2,
  getQueriesForElement: () => getQueriesForElement2,
  getRoles: () => getRoles2,
  getSuggestedQuery: () => getSuggestedQuery2,
  isInaccessible: () => isInaccessible2,
  isMockFunction: () => isMockFunction,
  logDOM: () => logDOM2,
  logRoles: () => logRoles2,
  mocked: () => mocked,
  mocks: () => mocks,
  onMockCall: () => onMockCall,
  prettyDOM: () => prettyDOM2,
  prettyFormat: () => prettyFormat2,
  queries: () => queries2,
  queryAllByAltText: () => queryAllByAltText2,
  queryAllByAttribute: () => queryAllByAttribute2,
  queryAllByDisplayValue: () => queryAllByDisplayValue2,
  queryAllByLabelText: () => queryAllByLabelText2,
  queryAllByPlaceholderText: () => queryAllByPlaceholderText2,
  queryAllByRole: () => queryAllByRole2,
  queryAllByTestId: () => queryAllByTestId2,
  queryAllByText: () => queryAllByText2,
  queryAllByTitle: () => queryAllByTitle2,
  queryByAltText: () => queryByAltText2,
  queryByAttribute: () => queryByAttribute2,
  queryByDisplayValue: () => queryByDisplayValue2,
  queryByLabelText: () => queryByLabelText2,
  queryByPlaceholderText: () => queryByPlaceholderText2,
  queryByRole: () => queryByRole2,
  queryByTestId: () => queryByTestId2,
  queryByText: () => queryByText2,
  queryByTitle: () => queryByTitle2,
  queryHelpers: () => queryHelpers2,
  resetAllMocks: () => resetAllMocks,
  restoreAllMocks: () => restoreAllMocks,
  sb: () => sb,
  screen: () => screen2,
  spyOn: () => spyOn2,
  uninstrumentedUserEvent: () => uninstrumentedUserEvent,
  userEvent: () => userEvent2,
  waitFor: () => waitFor2,
  waitForElementToBeRemoved: () => waitForElementToBeRemoved2,
  within: () => within
});

// ../node_modules/tinyrainbow/dist/chunk-BVHSVHOK.js
var f = {
  reset: [0, 0],
  bold: [1, 22, "\x1B[22m\x1B[1m"],
  dim: [2, 22, "\x1B[22m\x1B[2m"],
  italic: [3, 23],
  underline: [4, 24],
  inverse: [7, 27],
  hidden: [8, 28],
  strikethrough: [9, 29],
  black: [30, 39],
  red: [31, 39],
  green: [32, 39],
  yellow: [33, 39],
  blue: [34, 39],
  magenta: [35, 39],
  cyan: [36, 39],
  white: [37, 39],
  gray: [90, 39],
  bgBlack: [40, 49],
  bgRed: [41, 49],
  bgGreen: [42, 49],
  bgYellow: [43, 49],
  bgBlue: [44, 49],
  bgMagenta: [45, 49],
  bgCyan: [46, 49],
  bgWhite: [47, 49],
  blackBright: [90, 39],
  redBright: [91, 39],
  greenBright: [92, 39],
  yellowBright: [93, 39],
  blueBright: [94, 39],
  magentaBright: [95, 39],
  cyanBright: [96, 39],
  whiteBright: [97, 39],
  bgBlackBright: [100, 49],
  bgRedBright: [101, 49],
  bgGreenBright: [102, 49],
  bgYellowBright: [103, 49],
  bgBlueBright: [104, 49],
  bgMagentaBright: [105, 49],
  bgCyanBright: [106, 49],
  bgWhiteBright: [107, 49]
}, h = Object.entries(f);
function a(n2) {
  return String(n2);
}
a.open = "";
a.close = "";
var B = h.reduce(
  (n2, [e2]) => (n2[e2] = a, n2),
  { isColorSupported: !1 }
);
function C(n2 = !1) {
  let e2 = typeof process < "u" ? process : void 0, i2 = e2?.env || {}, g2 = e2?.argv || [];
  return !("NO_COLOR" in i2 || g2.includes("--no-color")) && ("FORCE_COLOR" in i2 || g2.includes("--color") || e2?.platform === "win32" || n2 && i2.TERM !== "dumb" || "CI" in i2) || typeof window < "u" && !!window.chrome;
}
function p(n2 = !1) {
  let e2 = C(n2), i2 = (r2, t2, c2, o2) => {
    let l2 = "", s3 = 0;
    do
      l2 += r2.substring(s3, o2) + c2, s3 = o2 + t2.length, o2 = r2.indexOf(t2, s3);
    while (~o2);
    return l2 + r2.substring(s3);
  }, g2 = (r2, t2, c2 = r2) => {
    let o2 = (l2) => {
      let s3 = String(l2), b2 = s3.indexOf(t2, r2.length);
      return ~b2 ? r2 + i2(s3, t2, c2, b2) + t2 : r2 + s3 + t2;
    };
    return o2.open = r2, o2.close = t2, o2;
  }, u3 = {
    isColorSupported: e2
  }, d = (r2) => `\x1B[${r2}m`;
  for (let [r2, t2] of h)
    u3[r2] = e2 ? g2(
      d(t2[0]),
      d(t2[1]),
      t2[2]
    ) : a;
  return u3;
}

// ../node_modules/tinyrainbow/dist/browser.js
var s = p();

// ../node_modules/@vitest/pretty-format/dist/index.js
function _mergeNamespaces(n2, m3) {
  return m3.forEach(function(e2) {
    e2 && typeof e2 != "string" && !Array.isArray(e2) && Object.keys(e2).forEach(function(k2) {
      if (k2 !== "default" && !(k2 in n2)) {
        var d = Object.getOwnPropertyDescriptor(e2, k2);
        Object.defineProperty(n2, k2, d.get ? d : {
          enumerable: !0,
          get: function() {
            return e2[k2];
          }
        });
      }
    });
  }), Object.freeze(n2);
}
function getKeysOfEnumerableProperties(object, compareKeys) {
  let rawKeys = Object.keys(object), keys2 = compareKeys === null ? rawKeys : rawKeys.sort(compareKeys);
  if (Object.getOwnPropertySymbols)
    for (let symbol of Object.getOwnPropertySymbols(object))
      Object.getOwnPropertyDescriptor(object, symbol).enumerable && keys2.push(symbol);
  return keys2;
}
function printIteratorEntries(iterator, config4, indentation, depth, refs, printer2, separator = ": ") {
  let result = "", width = 0, current = iterator.next();
  if (!current.done) {
    result += config4.spacingOuter;
    let indentationNext = indentation + config4.indent;
    for (; !current.done; ) {
      if (result += indentationNext, width++ === config4.maxWidth) {
        result += "\u2026";
        break;
      }
      let name = printer2(current.value[0], config4, indentationNext, depth, refs), value = printer2(current.value[1], config4, indentationNext, depth, refs);
      result += name + separator + value, current = iterator.next(), current.done ? config4.min || (result += ",") : result += `,${config4.spacingInner}`;
    }
    result += config4.spacingOuter + indentation;
  }
  return result;
}
function printIteratorValues(iterator, config4, indentation, depth, refs, printer2) {
  let result = "", width = 0, current = iterator.next();
  if (!current.done) {
    result += config4.spacingOuter;
    let indentationNext = indentation + config4.indent;
    for (; !current.done; ) {
      if (result += indentationNext, width++ === config4.maxWidth) {
        result += "\u2026";
        break;
      }
      result += printer2(current.value, config4, indentationNext, depth, refs), current = iterator.next(), current.done ? config4.min || (result += ",") : result += `,${config4.spacingInner}`;
    }
    result += config4.spacingOuter + indentation;
  }
  return result;
}
function printListItems(list, config4, indentation, depth, refs, printer2) {
  let result = "";
  list = list instanceof ArrayBuffer ? new DataView(list) : list;
  let isDataView = (l2) => l2 instanceof DataView, length = isDataView(list) ? list.byteLength : list.length;
  if (length > 0) {
    result += config4.spacingOuter;
    let indentationNext = indentation + config4.indent;
    for (let i2 = 0; i2 < length; i2++) {
      if (result += indentationNext, i2 === config4.maxWidth) {
        result += "\u2026";
        break;
      }
      (isDataView(list) || i2 in list) && (result += printer2(isDataView(list) ? list.getInt8(i2) : list[i2], config4, indentationNext, depth, refs)), i2 < length - 1 ? result += `,${config4.spacingInner}` : config4.min || (result += ",");
    }
    result += config4.spacingOuter + indentation;
  }
  return result;
}
function printObjectProperties(val, config4, indentation, depth, refs, printer2) {
  let result = "", keys2 = getKeysOfEnumerableProperties(val, config4.compareKeys);
  if (keys2.length > 0) {
    result += config4.spacingOuter;
    let indentationNext = indentation + config4.indent;
    for (let i2 = 0; i2 < keys2.length; i2++) {
      let key = keys2[i2], name = printer2(key, config4, indentationNext, depth, refs), value = printer2(val[key], config4, indentationNext, depth, refs);
      result += `${indentationNext + name}: ${value}`, i2 < keys2.length - 1 ? result += `,${config4.spacingInner}` : config4.min || (result += ",");
    }
    result += config4.spacingOuter + indentation;
  }
  return result;
}
var asymmetricMatcher = typeof Symbol == "function" && Symbol.for ? Symbol.for("jest.asymmetricMatcher") : 1267621, SPACE$2 = " ", serialize$5 = (val, config4, indentation, depth, refs, printer2) => {
  let stringedValue = val.toString();
  if (stringedValue === "ArrayContaining" || stringedValue === "ArrayNotContaining")
    return ++depth > config4.maxDepth ? `[${stringedValue}]` : `${stringedValue + SPACE$2}[${printListItems(val.sample, config4, indentation, depth, refs, printer2)}]`;
  if (stringedValue === "ObjectContaining" || stringedValue === "ObjectNotContaining")
    return ++depth > config4.maxDepth ? `[${stringedValue}]` : `${stringedValue + SPACE$2}{${printObjectProperties(val.sample, config4, indentation, depth, refs, printer2)}}`;
  if (stringedValue === "StringMatching" || stringedValue === "StringNotMatching" || stringedValue === "StringContaining" || stringedValue === "StringNotContaining")
    return stringedValue + SPACE$2 + printer2(val.sample, config4, indentation, depth, refs);
  if (typeof val.toAsymmetricMatcher != "function")
    throw new TypeError(`Asymmetric matcher ${val.constructor.name} does not implement toAsymmetricMatcher()`);
  return val.toAsymmetricMatcher();
}, test$5 = (val) => val && val.$$typeof === asymmetricMatcher, plugin$5 = {
  serialize: serialize$5,
  test: test$5
}, SPACE$1 = " ", OBJECT_NAMES = /* @__PURE__ */ new Set(["DOMStringMap", "NamedNodeMap"]), ARRAY_REGEXP = /^(?:HTML\w*Collection|NodeList)$/;
function testName(name) {
  return OBJECT_NAMES.has(name) || ARRAY_REGEXP.test(name);
}
var test$4 = (val) => val && val.constructor && !!val.constructor.name && testName(val.constructor.name);
function isNamedNodeMap(collection) {
  return collection.constructor.name === "NamedNodeMap";
}
var serialize$4 = (collection, config4, indentation, depth, refs, printer2) => {
  let name = collection.constructor.name;
  return ++depth > config4.maxDepth ? `[${name}]` : (config4.min ? "" : name + SPACE$1) + (OBJECT_NAMES.has(name) ? `{${printObjectProperties(isNamedNodeMap(collection) ? [...collection].reduce((props, attribute) => (props[attribute.name] = attribute.value, props), {}) : { ...collection }, config4, indentation, depth, refs, printer2)}}` : `[${printListItems([...collection], config4, indentation, depth, refs, printer2)}]`);
}, plugin$4 = {
  serialize: serialize$4,
  test: test$4
};
function escapeHTML(str2) {
  return str2.replaceAll("<", "&lt;").replaceAll(">", "&gt;");
}
function printProps(keys2, props, config4, indentation, depth, refs, printer2) {
  let indentationNext = indentation + config4.indent, colors3 = config4.colors;
  return keys2.map((key) => {
    let value = props[key], printed = printer2(value, config4, indentationNext, depth, refs);
    return typeof value != "string" && (printed.includes(`
`) && (printed = config4.spacingOuter + indentationNext + printed + config4.spacingOuter + indentation), printed = `{${printed}}`), `${config4.spacingInner + indentation + colors3.prop.open + key + colors3.prop.close}=${colors3.value.open}${printed}${colors3.value.close}`;
  }).join("");
}
function printChildren(children, config4, indentation, depth, refs, printer2) {
  return children.map((child) => config4.spacingOuter + indentation + (typeof child == "string" ? printText(child, config4) : printer2(child, config4, indentation, depth, refs))).join("");
}
function printText(text, config4) {
  let contentColor = config4.colors.content;
  return contentColor.open + escapeHTML(text) + contentColor.close;
}
function printComment(comment, config4) {
  let commentColor = config4.colors.comment;
  return `${commentColor.open}<!--${escapeHTML(comment)}-->${commentColor.close}`;
}
function printElement(type5, printedProps, printedChildren, config4, indentation) {
  let tagColor = config4.colors.tag;
  return `${tagColor.open}<${type5}${printedProps && tagColor.close + printedProps + config4.spacingOuter + indentation + tagColor.open}${printedChildren ? `>${tagColor.close}${printedChildren}${config4.spacingOuter}${indentation}${tagColor.open}</${type5}` : `${printedProps && !config4.min ? "" : " "}/`}>${tagColor.close}`;
}
function printElementAsLeaf(type5, config4) {
  let tagColor = config4.colors.tag;
  return `${tagColor.open}<${type5}${tagColor.close} \u2026${tagColor.open} />${tagColor.close}`;
}
var ELEMENT_NODE = 1, TEXT_NODE = 3, COMMENT_NODE = 8, FRAGMENT_NODE = 11, ELEMENT_REGEXP = /^(?:(?:HTML|SVG)\w*)?Element$/;
function testHasAttribute(val) {
  try {
    return typeof val.hasAttribute == "function" && val.hasAttribute("is");
  } catch {
    return !1;
  }
}
function testNode(val) {
  let constructorName = val.constructor.name, { nodeType, tagName } = val, isCustomElement3 = typeof tagName == "string" && tagName.includes("-") || testHasAttribute(val);
  return nodeType === ELEMENT_NODE && (ELEMENT_REGEXP.test(constructorName) || isCustomElement3) || nodeType === TEXT_NODE && constructorName === "Text" || nodeType === COMMENT_NODE && constructorName === "Comment" || nodeType === FRAGMENT_NODE && constructorName === "DocumentFragment";
}
var test$3 = (val) => {
  var _val$constructor;
  return (val == null || (_val$constructor = val.constructor) === null || _val$constructor === void 0 ? void 0 : _val$constructor.name) && testNode(val);
};
function nodeIsText(node) {
  return node.nodeType === TEXT_NODE;
}
function nodeIsComment(node) {
  return node.nodeType === COMMENT_NODE;
}
function nodeIsFragment(node) {
  return node.nodeType === FRAGMENT_NODE;
}
var serialize$3 = (node, config4, indentation, depth, refs, printer2) => {
  if (nodeIsText(node))
    return printText(node.data, config4);
  if (nodeIsComment(node))
    return printComment(node.data, config4);
  let type5 = nodeIsFragment(node) ? "DocumentFragment" : node.tagName.toLowerCase();
  return ++depth > config4.maxDepth ? printElementAsLeaf(type5, config4) : printElement(type5, printProps(nodeIsFragment(node) ? [] : Array.from(node.attributes, (attr) => attr.name).sort(), nodeIsFragment(node) ? {} : [...node.attributes].reduce((props, attribute) => (props[attribute.name] = attribute.value, props), {}), config4, indentation + config4.indent, depth, refs, printer2), printChildren(Array.prototype.slice.call(node.childNodes || node.children), config4, indentation + config4.indent, depth, refs, printer2), config4, indentation);
}, plugin$3 = {
  serialize: serialize$3,
  test: test$3
}, IS_ITERABLE_SENTINEL = "@@__IMMUTABLE_ITERABLE__@@", IS_LIST_SENTINEL = "@@__IMMUTABLE_LIST__@@", IS_KEYED_SENTINEL = "@@__IMMUTABLE_KEYED__@@", IS_MAP_SENTINEL = "@@__IMMUTABLE_MAP__@@", IS_ORDERED_SENTINEL = "@@__IMMUTABLE_ORDERED__@@", IS_RECORD_SENTINEL = "@@__IMMUTABLE_RECORD__@@", IS_SEQ_SENTINEL = "@@__IMMUTABLE_SEQ__@@", IS_SET_SENTINEL = "@@__IMMUTABLE_SET__@@", IS_STACK_SENTINEL = "@@__IMMUTABLE_STACK__@@", getImmutableName = (name) => `Immutable.${name}`, printAsLeaf = (name) => `[${name}]`, SPACE = " ", LAZY = "\u2026";
function printImmutableEntries(val, config4, indentation, depth, refs, printer2, type5) {
  return ++depth > config4.maxDepth ? printAsLeaf(getImmutableName(type5)) : `${getImmutableName(type5) + SPACE}{${printIteratorEntries(val.entries(), config4, indentation, depth, refs, printer2)}}`;
}
function getRecordEntries(val) {
  let i2 = 0;
  return { next() {
    if (i2 < val._keys.length) {
      let key = val._keys[i2++];
      return {
        done: !1,
        value: [key, val.get(key)]
      };
    }
    return {
      done: !0,
      value: void 0
    };
  } };
}
function printImmutableRecord(val, config4, indentation, depth, refs, printer2) {
  let name = getImmutableName(val._name || "Record");
  return ++depth > config4.maxDepth ? printAsLeaf(name) : `${name + SPACE}{${printIteratorEntries(getRecordEntries(val), config4, indentation, depth, refs, printer2)}}`;
}
function printImmutableSeq(val, config4, indentation, depth, refs, printer2) {
  let name = getImmutableName("Seq");
  return ++depth > config4.maxDepth ? printAsLeaf(name) : val[IS_KEYED_SENTINEL] ? `${name + SPACE}{${val._iter || val._object ? printIteratorEntries(val.entries(), config4, indentation, depth, refs, printer2) : LAZY}}` : `${name + SPACE}[${val._iter || val._array || val._collection || val._iterable ? printIteratorValues(val.values(), config4, indentation, depth, refs, printer2) : LAZY}]`;
}
function printImmutableValues(val, config4, indentation, depth, refs, printer2, type5) {
  return ++depth > config4.maxDepth ? printAsLeaf(getImmutableName(type5)) : `${getImmutableName(type5) + SPACE}[${printIteratorValues(val.values(), config4, indentation, depth, refs, printer2)}]`;
}
var serialize$2 = (val, config4, indentation, depth, refs, printer2) => val[IS_MAP_SENTINEL] ? printImmutableEntries(val, config4, indentation, depth, refs, printer2, val[IS_ORDERED_SENTINEL] ? "OrderedMap" : "Map") : val[IS_LIST_SENTINEL] ? printImmutableValues(val, config4, indentation, depth, refs, printer2, "List") : val[IS_SET_SENTINEL] ? printImmutableValues(val, config4, indentation, depth, refs, printer2, val[IS_ORDERED_SENTINEL] ? "OrderedSet" : "Set") : val[IS_STACK_SENTINEL] ? printImmutableValues(val, config4, indentation, depth, refs, printer2, "Stack") : val[IS_SEQ_SENTINEL] ? printImmutableSeq(val, config4, indentation, depth, refs, printer2) : printImmutableRecord(val, config4, indentation, depth, refs, printer2), test$2 = (val) => val && (val[IS_ITERABLE_SENTINEL] === !0 || val[IS_RECORD_SENTINEL] === !0), plugin$2 = {
  serialize: serialize$2,
  test: test$2
};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2.default : x2;
}
var reactIs$1 = { exports: {} }, reactIs_production = {};
var hasRequiredReactIs_production;
function requireReactIs_production() {
  if (hasRequiredReactIs_production) return reactIs_production;
  hasRequiredReactIs_production = 1;
  var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
  function typeOf(object) {
    if (typeof object == "object" && object !== null) {
      var $$typeof = object.$$typeof;
      switch ($$typeof) {
        case REACT_ELEMENT_TYPE:
          switch (object = object.type, object) {
            case REACT_FRAGMENT_TYPE:
            case REACT_PROFILER_TYPE:
            case REACT_STRICT_MODE_TYPE:
            case REACT_SUSPENSE_TYPE:
            case REACT_SUSPENSE_LIST_TYPE:
            case REACT_VIEW_TRANSITION_TYPE:
              return object;
            default:
              switch (object = object && object.$$typeof, object) {
                case REACT_CONTEXT_TYPE:
                case REACT_FORWARD_REF_TYPE:
                case REACT_LAZY_TYPE:
                case REACT_MEMO_TYPE:
                  return object;
                case REACT_CONSUMER_TYPE:
                  return object;
                default:
                  return $$typeof;
              }
          }
        case REACT_PORTAL_TYPE:
          return $$typeof;
      }
    }
  }
  return reactIs_production.ContextConsumer = REACT_CONSUMER_TYPE, reactIs_production.ContextProvider = REACT_CONTEXT_TYPE, reactIs_production.Element = REACT_ELEMENT_TYPE, reactIs_production.ForwardRef = REACT_FORWARD_REF_TYPE, reactIs_production.Fragment = REACT_FRAGMENT_TYPE, reactIs_production.Lazy = REACT_LAZY_TYPE, reactIs_production.Memo = REACT_MEMO_TYPE, reactIs_production.Portal = REACT_PORTAL_TYPE, reactIs_production.Profiler = REACT_PROFILER_TYPE, reactIs_production.StrictMode = REACT_STRICT_MODE_TYPE, reactIs_production.Suspense = REACT_SUSPENSE_TYPE, reactIs_production.SuspenseList = REACT_SUSPENSE_LIST_TYPE, reactIs_production.isContextConsumer = function(object) {
    return typeOf(object) === REACT_CONSUMER_TYPE;
  }, reactIs_production.isContextProvider = function(object) {
    return typeOf(object) === REACT_CONTEXT_TYPE;
  }, reactIs_production.isElement = function(object) {
    return typeof object == "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
  }, reactIs_production.isForwardRef = function(object) {
    return typeOf(object) === REACT_FORWARD_REF_TYPE;
  }, reactIs_production.isFragment = function(object) {
    return typeOf(object) === REACT_FRAGMENT_TYPE;
  }, reactIs_production.isLazy = function(object) {
    return typeOf(object) === REACT_LAZY_TYPE;
  }, reactIs_production.isMemo = function(object) {
    return typeOf(object) === REACT_MEMO_TYPE;
  }, reactIs_production.isPortal = function(object) {
    return typeOf(object) === REACT_PORTAL_TYPE;
  }, reactIs_production.isProfiler = function(object) {
    return typeOf(object) === REACT_PROFILER_TYPE;
  }, reactIs_production.isStrictMode = function(object) {
    return typeOf(object) === REACT_STRICT_MODE_TYPE;
  }, reactIs_production.isSuspense = function(object) {
    return typeOf(object) === REACT_SUSPENSE_TYPE;
  }, reactIs_production.isSuspenseList = function(object) {
    return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
  }, reactIs_production.isValidElementType = function(type5) {
    return typeof type5 == "string" || typeof type5 == "function" || type5 === REACT_FRAGMENT_TYPE || type5 === REACT_PROFILER_TYPE || type5 === REACT_STRICT_MODE_TYPE || type5 === REACT_SUSPENSE_TYPE || type5 === REACT_SUSPENSE_LIST_TYPE || typeof type5 == "object" && type5 !== null && (type5.$$typeof === REACT_LAZY_TYPE || type5.$$typeof === REACT_MEMO_TYPE || type5.$$typeof === REACT_CONTEXT_TYPE || type5.$$typeof === REACT_CONSUMER_TYPE || type5.$$typeof === REACT_FORWARD_REF_TYPE || type5.$$typeof === REACT_CLIENT_REFERENCE || type5.getModuleId !== void 0);
  }, reactIs_production.typeOf = typeOf, reactIs_production;
}
var hasRequiredReactIs$1;
function requireReactIs$1() {
  return hasRequiredReactIs$1 || (hasRequiredReactIs$1 = 1, reactIs$1.exports = requireReactIs_production()), reactIs$1.exports;
}
var reactIsExports$1 = requireReactIs$1(), index$1 = getDefaultExportFromCjs(reactIsExports$1), ReactIs19 = _mergeNamespaces({
  __proto__: null,
  default: index$1
}, [reactIsExports$1]), reactIs = { exports: {} }, reactIs_production_min = {};
var hasRequiredReactIs_production_min;
function requireReactIs_production_min() {
  if (hasRequiredReactIs_production_min) return reactIs_production_min;
  hasRequiredReactIs_production_min = 1;
  var b2 = Symbol.for("react.element"), c2 = Symbol.for("react.portal"), d = Symbol.for("react.fragment"), e2 = Symbol.for("react.strict_mode"), f4 = Symbol.for("react.profiler"), g2 = Symbol.for("react.provider"), h3 = Symbol.for("react.context"), k2 = Symbol.for("react.server_context"), l2 = Symbol.for("react.forward_ref"), m3 = Symbol.for("react.suspense"), n2 = Symbol.for("react.suspense_list"), p2 = Symbol.for("react.memo"), q = Symbol.for("react.lazy"), t2 = Symbol.for("react.offscreen"), u3;
  u3 = Symbol.for("react.module.reference");
  function v2(a2) {
    if (typeof a2 == "object" && a2 !== null) {
      var r2 = a2.$$typeof;
      switch (r2) {
        case b2:
          switch (a2 = a2.type, a2) {
            case d:
            case f4:
            case e2:
            case m3:
            case n2:
              return a2;
            default:
              switch (a2 = a2 && a2.$$typeof, a2) {
                case k2:
                case h3:
                case l2:
                case q:
                case p2:
                case g2:
                  return a2;
                default:
                  return r2;
              }
          }
        case c2:
          return r2;
      }
    }
  }
  return reactIs_production_min.ContextConsumer = h3, reactIs_production_min.ContextProvider = g2, reactIs_production_min.Element = b2, reactIs_production_min.ForwardRef = l2, reactIs_production_min.Fragment = d, reactIs_production_min.Lazy = q, reactIs_production_min.Memo = p2, reactIs_production_min.Portal = c2, reactIs_production_min.Profiler = f4, reactIs_production_min.StrictMode = e2, reactIs_production_min.Suspense = m3, reactIs_production_min.SuspenseList = n2, reactIs_production_min.isAsyncMode = function() {
    return !1;
  }, reactIs_production_min.isConcurrentMode = function() {
    return !1;
  }, reactIs_production_min.isContextConsumer = function(a2) {
    return v2(a2) === h3;
  }, reactIs_production_min.isContextProvider = function(a2) {
    return v2(a2) === g2;
  }, reactIs_production_min.isElement = function(a2) {
    return typeof a2 == "object" && a2 !== null && a2.$$typeof === b2;
  }, reactIs_production_min.isForwardRef = function(a2) {
    return v2(a2) === l2;
  }, reactIs_production_min.isFragment = function(a2) {
    return v2(a2) === d;
  }, reactIs_production_min.isLazy = function(a2) {
    return v2(a2) === q;
  }, reactIs_production_min.isMemo = function(a2) {
    return v2(a2) === p2;
  }, reactIs_production_min.isPortal = function(a2) {
    return v2(a2) === c2;
  }, reactIs_production_min.isProfiler = function(a2) {
    return v2(a2) === f4;
  }, reactIs_production_min.isStrictMode = function(a2) {
    return v2(a2) === e2;
  }, reactIs_production_min.isSuspense = function(a2) {
    return v2(a2) === m3;
  }, reactIs_production_min.isSuspenseList = function(a2) {
    return v2(a2) === n2;
  }, reactIs_production_min.isValidElementType = function(a2) {
    return typeof a2 == "string" || typeof a2 == "function" || a2 === d || a2 === f4 || a2 === e2 || a2 === m3 || a2 === n2 || a2 === t2 || typeof a2 == "object" && a2 !== null && (a2.$$typeof === q || a2.$$typeof === p2 || a2.$$typeof === g2 || a2.$$typeof === h3 || a2.$$typeof === l2 || a2.$$typeof === u3 || a2.getModuleId !== void 0);
  }, reactIs_production_min.typeOf = v2, reactIs_production_min;
}
var hasRequiredReactIs;
function requireReactIs() {
  return hasRequiredReactIs || (hasRequiredReactIs = 1, reactIs.exports = requireReactIs_production_min()), reactIs.exports;
}
var reactIsExports = requireReactIs(), index = getDefaultExportFromCjs(reactIsExports), ReactIs18 = _mergeNamespaces({
  __proto__: null,
  default: index
}, [reactIsExports]), reactIsMethods = [
  "isAsyncMode",
  "isConcurrentMode",
  "isContextConsumer",
  "isContextProvider",
  "isElement",
  "isForwardRef",
  "isFragment",
  "isLazy",
  "isMemo",
  "isPortal",
  "isProfiler",
  "isStrictMode",
  "isSuspense",
  "isSuspenseList",
  "isValidElementType"
], ReactIs = Object.fromEntries(reactIsMethods.map((m3) => [m3, (v2) => ReactIs18[m3](v2) || ReactIs19[m3](v2)]));
function getChildren(arg, children = []) {
  if (Array.isArray(arg))
    for (let item of arg)
      getChildren(item, children);
  else arg != null && arg !== !1 && arg !== "" && children.push(arg);
  return children;
}
function getType(element) {
  let type5 = element.type;
  if (typeof type5 == "string")
    return type5;
  if (typeof type5 == "function")
    return type5.displayName || type5.name || "Unknown";
  if (ReactIs.isFragment(element))
    return "React.Fragment";
  if (ReactIs.isSuspense(element))
    return "React.Suspense";
  if (typeof type5 == "object" && type5 !== null) {
    if (ReactIs.isContextProvider(element))
      return "Context.Provider";
    if (ReactIs.isContextConsumer(element))
      return "Context.Consumer";
    if (ReactIs.isForwardRef(element)) {
      if (type5.displayName)
        return type5.displayName;
      let functionName = type5.render.displayName || type5.render.name || "";
      return functionName === "" ? "ForwardRef" : `ForwardRef(${functionName})`;
    }
    if (ReactIs.isMemo(element)) {
      let functionName = type5.displayName || type5.type.displayName || type5.type.name || "";
      return functionName === "" ? "Memo" : `Memo(${functionName})`;
    }
  }
  return "UNDEFINED";
}
function getPropKeys$1(element) {
  let { props } = element;
  return Object.keys(props).filter((key) => key !== "children" && props[key] !== void 0).sort();
}
var serialize$1 = (element, config4, indentation, depth, refs, printer2) => ++depth > config4.maxDepth ? printElementAsLeaf(getType(element), config4) : printElement(getType(element), printProps(getPropKeys$1(element), element.props, config4, indentation + config4.indent, depth, refs, printer2), printChildren(getChildren(element.props.children), config4, indentation + config4.indent, depth, refs, printer2), config4, indentation), test$1 = (val) => val != null && ReactIs.isElement(val), plugin$1 = {
  serialize: serialize$1,
  test: test$1
}, testSymbol = typeof Symbol == "function" && Symbol.for ? Symbol.for("react.test.json") : 245830487;
function getPropKeys(object) {
  let { props } = object;
  return props ? Object.keys(props).filter((key) => props[key] !== void 0).sort() : [];
}
var serialize = (object, config4, indentation, depth, refs, printer2) => ++depth > config4.maxDepth ? printElementAsLeaf(object.type, config4) : printElement(object.type, object.props ? printProps(getPropKeys(object), object.props, config4, indentation + config4.indent, depth, refs, printer2) : "", object.children ? printChildren(object.children, config4, indentation + config4.indent, depth, refs, printer2) : "", config4, indentation), test = (val) => val && val.$$typeof === testSymbol, plugin = {
  serialize,
  test
}, toString2 = Object.prototype.toString, toISOString = Date.prototype.toISOString, errorToString = Error.prototype.toString, regExpToString = RegExp.prototype.toString;
function getConstructorName(val) {
  return typeof val.constructor == "function" && val.constructor.name || "Object";
}
function isWindow(val) {
  return typeof window < "u" && val === window;
}
var SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/, NEWLINE_REGEXP = /\n/g, PrettyFormatPluginError = class extends Error {
  constructor(message, stack) {
    super(message), this.stack = stack, this.name = this.constructor.name;
  }
};
function isToStringedArrayType(toStringed) {
  return toStringed === "[object Array]" || toStringed === "[object ArrayBuffer]" || toStringed === "[object DataView]" || toStringed === "[object Float32Array]" || toStringed === "[object Float64Array]" || toStringed === "[object Int8Array]" || toStringed === "[object Int16Array]" || toStringed === "[object Int32Array]" || toStringed === "[object Uint8Array]" || toStringed === "[object Uint8ClampedArray]" || toStringed === "[object Uint16Array]" || toStringed === "[object Uint32Array]";
}
function printNumber(val) {
  return Object.is(val, -0) ? "-0" : String(val);
}
function printBigInt(val) {
  return `${val}n`;
}
function printFunction(val, printFunctionName) {
  return printFunctionName ? `[Function ${val.name || "anonymous"}]` : "[Function]";
}
function printSymbol(val) {
  return String(val).replace(SYMBOL_REGEXP, "Symbol($1)");
}
function printError(val) {
  return `[${errorToString.call(val)}]`;
}
function printBasicValue(val, printFunctionName, escapeRegex, escapeString) {
  if (val === !0 || val === !1)
    return `${val}`;
  if (val === void 0)
    return "undefined";
  if (val === null)
    return "null";
  let typeOf = typeof val;
  if (typeOf === "number")
    return printNumber(val);
  if (typeOf === "bigint")
    return printBigInt(val);
  if (typeOf === "string")
    return escapeString ? `"${val.replaceAll(/"|\\/g, "\\$&")}"` : `"${val}"`;
  if (typeOf === "function")
    return printFunction(val, printFunctionName);
  if (typeOf === "symbol")
    return printSymbol(val);
  let toStringed = toString2.call(val);
  return toStringed === "[object WeakMap]" ? "WeakMap {}" : toStringed === "[object WeakSet]" ? "WeakSet {}" : toStringed === "[object Function]" || toStringed === "[object GeneratorFunction]" ? printFunction(val, printFunctionName) : toStringed === "[object Symbol]" ? printSymbol(val) : toStringed === "[object Date]" ? Number.isNaN(+val) ? "Date { NaN }" : toISOString.call(val) : toStringed === "[object Error]" ? printError(val) : toStringed === "[object RegExp]" ? escapeRegex ? regExpToString.call(val).replaceAll(/[$()*+.?[\\\]^{|}]/g, "\\$&") : regExpToString.call(val) : val instanceof Error ? printError(val) : null;
}
function printComplexValue(val, config4, indentation, depth, refs, hasCalledToJSON) {
  if (refs.includes(val))
    return "[Circular]";
  refs = [...refs], refs.push(val);
  let hitMaxDepth = ++depth > config4.maxDepth, min = config4.min;
  if (config4.callToJSON && !hitMaxDepth && val.toJSON && typeof val.toJSON == "function" && !hasCalledToJSON)
    return printer(val.toJSON(), config4, indentation, depth, refs, !0);
  let toStringed = toString2.call(val);
  return toStringed === "[object Arguments]" ? hitMaxDepth ? "[Arguments]" : `${min ? "" : "Arguments "}[${printListItems(val, config4, indentation, depth, refs, printer)}]` : isToStringedArrayType(toStringed) ? hitMaxDepth ? `[${val.constructor.name}]` : `${min || !config4.printBasicPrototype && val.constructor.name === "Array" ? "" : `${val.constructor.name} `}[${printListItems(val, config4, indentation, depth, refs, printer)}]` : toStringed === "[object Map]" ? hitMaxDepth ? "[Map]" : `Map {${printIteratorEntries(val.entries(), config4, indentation, depth, refs, printer, " => ")}}` : toStringed === "[object Set]" ? hitMaxDepth ? "[Set]" : `Set {${printIteratorValues(val.values(), config4, indentation, depth, refs, printer)}}` : hitMaxDepth || isWindow(val) ? `[${getConstructorName(val)}]` : `${min || !config4.printBasicPrototype && getConstructorName(val) === "Object" ? "" : `${getConstructorName(val)} `}{${printObjectProperties(val, config4, indentation, depth, refs, printer)}}`;
}
var ErrorPlugin = {
  test: (val) => val && val instanceof Error,
  serialize(val, config4, indentation, depth, refs, printer2) {
    if (refs.includes(val))
      return "[Circular]";
    refs = [...refs, val];
    let hitMaxDepth = ++depth > config4.maxDepth, { message, cause, ...rest } = val, entries = {
      message,
      ...typeof cause < "u" ? { cause } : {},
      ...val instanceof AggregateError ? { errors: val.errors } : {},
      ...rest
    }, name = val.name !== "Error" ? val.name : getConstructorName(val);
    return hitMaxDepth ? `[${name}]` : `${name} {${printIteratorEntries(Object.entries(entries).values(), config4, indentation, depth, refs, printer2)}}`;
  }
};
function isNewPlugin(plugin2) {
  return plugin2.serialize != null;
}
function printPlugin(plugin2, val, config4, indentation, depth, refs) {
  let printed;
  try {
    printed = isNewPlugin(plugin2) ? plugin2.serialize(val, config4, indentation, depth, refs, printer) : plugin2.print(val, (valChild) => printer(valChild, config4, indentation, depth, refs), (str2) => {
      let indentationNext = indentation + config4.indent;
      return indentationNext + str2.replaceAll(NEWLINE_REGEXP, `
${indentationNext}`);
    }, {
      edgeSpacing: config4.spacingOuter,
      min: config4.min,
      spacing: config4.spacingInner
    }, config4.colors);
  } catch (error) {
    throw new PrettyFormatPluginError(error.message, error.stack);
  }
  if (typeof printed != "string")
    throw new TypeError(`pretty-format: Plugin must return type "string" but instead returned "${typeof printed}".`);
  return printed;
}
function findPlugin(plugins3, val) {
  for (let plugin2 of plugins3)
    try {
      if (plugin2.test(val))
        return plugin2;
    } catch (error) {
      throw new PrettyFormatPluginError(error.message, error.stack);
    }
  return null;
}
function printer(val, config4, indentation, depth, refs, hasCalledToJSON) {
  let plugin2 = findPlugin(config4.plugins, val);
  if (plugin2 !== null)
    return printPlugin(plugin2, val, config4, indentation, depth, refs);
  let basicResult = printBasicValue(val, config4.printFunctionName, config4.escapeRegex, config4.escapeString);
  return basicResult !== null ? basicResult : printComplexValue(val, config4, indentation, depth, refs, hasCalledToJSON);
}
var DEFAULT_THEME = {
  comment: "gray",
  content: "reset",
  prop: "yellow",
  tag: "cyan",
  value: "green"
}, DEFAULT_THEME_KEYS = Object.keys(DEFAULT_THEME), DEFAULT_OPTIONS = {
  callToJSON: !0,
  compareKeys: void 0,
  escapeRegex: !1,
  escapeString: !0,
  highlight: !1,
  indent: 2,
  maxDepth: Number.POSITIVE_INFINITY,
  maxWidth: Number.POSITIVE_INFINITY,
  min: !1,
  plugins: [],
  printBasicPrototype: !0,
  printFunctionName: !0,
  theme: DEFAULT_THEME
};
function validateOptions(options) {
  for (let key of Object.keys(options))
    if (!Object.prototype.hasOwnProperty.call(DEFAULT_OPTIONS, key))
      throw new Error(`pretty-format: Unknown option "${key}".`);
  if (options.min && options.indent !== void 0 && options.indent !== 0)
    throw new Error('pretty-format: Options "min" and "indent" cannot be used together.');
}
function getColorsHighlight() {
  return DEFAULT_THEME_KEYS.reduce((colors3, key) => {
    let value = DEFAULT_THEME[key], color = value && s[value];
    if (color && typeof color.close == "string" && typeof color.open == "string")
      colors3[key] = color;
    else
      throw new Error(`pretty-format: Option "theme" has a key "${key}" whose value "${value}" is undefined in ansi-styles.`);
    return colors3;
  }, /* @__PURE__ */ Object.create(null));
}
function getColorsEmpty() {
  return DEFAULT_THEME_KEYS.reduce((colors3, key) => (colors3[key] = {
    close: "",
    open: ""
  }, colors3), /* @__PURE__ */ Object.create(null));
}
function getPrintFunctionName(options) {
  return options?.printFunctionName ?? DEFAULT_OPTIONS.printFunctionName;
}
function getEscapeRegex(options) {
  return options?.escapeRegex ?? DEFAULT_OPTIONS.escapeRegex;
}
function getEscapeString(options) {
  return options?.escapeString ?? DEFAULT_OPTIONS.escapeString;
}
function getConfig(options) {
  return {
    callToJSON: options?.callToJSON ?? DEFAULT_OPTIONS.callToJSON,
    colors: options?.highlight ? getColorsHighlight() : getColorsEmpty(),
    compareKeys: typeof options?.compareKeys == "function" || options?.compareKeys === null ? options.compareKeys : DEFAULT_OPTIONS.compareKeys,
    escapeRegex: getEscapeRegex(options),
    escapeString: getEscapeString(options),
    indent: options?.min ? "" : createIndent(options?.indent ?? DEFAULT_OPTIONS.indent),
    maxDepth: options?.maxDepth ?? DEFAULT_OPTIONS.maxDepth,
    maxWidth: options?.maxWidth ?? DEFAULT_OPTIONS.maxWidth,
    min: options?.min ?? DEFAULT_OPTIONS.min,
    plugins: options?.plugins ?? DEFAULT_OPTIONS.plugins,
    printBasicPrototype: options?.printBasicPrototype ?? !0,
    printFunctionName: getPrintFunctionName(options),
    spacingInner: options?.min ? " " : `
`,
    spacingOuter: options?.min ? "" : `
`
  };
}
function createIndent(indent2) {
  return Array.from({ length: indent2 + 1 }).join(" ");
}
function format(val, options) {
  if (options && (validateOptions(options), options.plugins)) {
    let plugin2 = findPlugin(options.plugins, val);
    if (plugin2 !== null)
      return printPlugin(plugin2, val, getConfig(options), "", 0, []);
  }
  let basicResult = printBasicValue(val, getPrintFunctionName(options), getEscapeRegex(options), getEscapeString(options));
  return basicResult !== null ? basicResult : printComplexValue(val, getConfig(options), "", 0, []);
}
var plugins = {
  AsymmetricMatcher: plugin$5,
  DOMCollection: plugin$4,
  DOMElement: plugin$3,
  Immutable: plugin$2,
  ReactElement: plugin$1,
  ReactTestComponent: plugin,
  Error: ErrorPlugin
};

// ../node_modules/loupe/lib/helpers.js
var ansiColors = {
  bold: ["1", "22"],
  dim: ["2", "22"],
  italic: ["3", "23"],
  underline: ["4", "24"],
  // 5 & 6 are blinking
  inverse: ["7", "27"],
  hidden: ["8", "28"],
  strike: ["9", "29"],
  // 10-20 are fonts
  // 21-29 are resets for 1-9
  black: ["30", "39"],
  red: ["31", "39"],
  green: ["32", "39"],
  yellow: ["33", "39"],
  blue: ["34", "39"],
  magenta: ["35", "39"],
  cyan: ["36", "39"],
  white: ["37", "39"],
  brightblack: ["30;1", "39"],
  brightred: ["31;1", "39"],
  brightgreen: ["32;1", "39"],
  brightyellow: ["33;1", "39"],
  brightblue: ["34;1", "39"],
  brightmagenta: ["35;1", "39"],
  brightcyan: ["36;1", "39"],
  brightwhite: ["37;1", "39"],
  grey: ["90", "39"]
}, styles = {
  special: "cyan",
  number: "yellow",
  bigint: "yellow",
  boolean: "yellow",
  undefined: "grey",
  null: "bold",
  string: "green",
  symbol: "green",
  date: "magenta",
  regexp: "red"
}, truncator = "\u2026";
function colorise(value, styleType) {
  let color = ansiColors[styles[styleType]] || ansiColors[styleType] || "";
  return color ? `\x1B[${color[0]}m${String(value)}\x1B[${color[1]}m` : String(value);
}
function normaliseOptions({
  showHidden = !1,
  depth = 2,
  colors: colors3 = !1,
  customInspect = !0,
  showProxy = !1,
  maxArrayLength = 1 / 0,
  breakLength = 1 / 0,
  seen = [],
  // eslint-disable-next-line no-shadow
  truncate: truncate3 = 1 / 0,
  stylize = String
} = {}, inspect5) {
  let options = {
    showHidden: !!showHidden,
    depth: Number(depth),
    colors: !!colors3,
    customInspect: !!customInspect,
    showProxy: !!showProxy,
    maxArrayLength: Number(maxArrayLength),
    breakLength: Number(breakLength),
    truncate: Number(truncate3),
    seen,
    inspect: inspect5,
    stylize
  };
  return options.colors && (options.stylize = colorise), options;
}
function isHighSurrogate(char) {
  return char >= "\uD800" && char <= "\uDBFF";
}
function truncate(string, length, tail = truncator) {
  string = String(string);
  let tailLength = tail.length, stringLength = string.length;
  if (tailLength > length && stringLength > tailLength)
    return tail;
  if (stringLength > length && stringLength > tailLength) {
    let end = length - tailLength;
    return end > 0 && isHighSurrogate(string[end - 1]) && (end = end - 1), `${string.slice(0, end)}${tail}`;
  }
  return string;
}
function inspectList(list, options, inspectItem, separator = ", ") {
  inspectItem = inspectItem || options.inspect;
  let size = list.length;
  if (size === 0)
    return "";
  let originalLength = options.truncate, output = "", peek = "", truncated = "";
  for (let i2 = 0; i2 < size; i2 += 1) {
    let last = i2 + 1 === list.length, secondToLast = i2 + 2 === list.length;
    truncated = `${truncator}(${list.length - i2})`;
    let value = list[i2];
    options.truncate = originalLength - output.length - (last ? 0 : separator.length);
    let string = peek || inspectItem(value, options) + (last ? "" : separator), nextLength = output.length + string.length, truncatedLength = nextLength + truncated.length;
    if (last && nextLength > originalLength && output.length + truncated.length <= originalLength || !last && !secondToLast && truncatedLength > originalLength || (peek = last ? "" : inspectItem(list[i2 + 1], options) + (secondToLast ? "" : separator), !last && secondToLast && truncatedLength > originalLength && nextLength + peek.length > originalLength))
      break;
    if (output += string, !last && !secondToLast && nextLength + peek.length >= originalLength) {
      truncated = `${truncator}(${list.length - i2 - 1})`;
      break;
    }
    truncated = "";
  }
  return `${output}${truncated}`;
}
function quoteComplexKey(key) {
  return key.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/) ? key : JSON.stringify(key).replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
}
function inspectProperty([key, value], options) {
  return options.truncate -= 2, typeof key == "string" ? key = quoteComplexKey(key) : typeof key != "number" && (key = `[${options.inspect(key, options)}]`), options.truncate -= key.length, value = options.inspect(value, options), `${key}: ${value}`;
}

// ../node_modules/loupe/lib/array.js
function inspectArray(array, options) {
  let nonIndexProperties = Object.keys(array).slice(array.length);
  if (!array.length && !nonIndexProperties.length)
    return "[]";
  options.truncate -= 4;
  let listContents = inspectList(array, options);
  options.truncate -= listContents.length;
  let propertyContents = "";
  return nonIndexProperties.length && (propertyContents = inspectList(nonIndexProperties.map((key) => [key, array[key]]), options, inspectProperty)), `[ ${listContents}${propertyContents ? `, ${propertyContents}` : ""} ]`;
}

// ../node_modules/loupe/lib/typedarray.js
var getArrayName = (array) => typeof Buffer == "function" && array instanceof Buffer ? "Buffer" : array[Symbol.toStringTag] ? array[Symbol.toStringTag] : array.constructor.name;
function inspectTypedArray(array, options) {
  let name = getArrayName(array);
  options.truncate -= name.length + 4;
  let nonIndexProperties = Object.keys(array).slice(array.length);
  if (!array.length && !nonIndexProperties.length)
    return `${name}[]`;
  let output = "";
  for (let i2 = 0; i2 < array.length; i2++) {
    let string = `${options.stylize(truncate(array[i2], options.truncate), "number")}${i2 === array.length - 1 ? "" : ", "}`;
    if (options.truncate -= string.length, array[i2] !== array.length && options.truncate <= 3) {
      output += `${truncator}(${array.length - array[i2] + 1})`;
      break;
    }
    output += string;
  }
  let propertyContents = "";
  return nonIndexProperties.length && (propertyContents = inspectList(nonIndexProperties.map((key) => [key, array[key]]), options, inspectProperty)), `${name}[ ${output}${propertyContents ? `, ${propertyContents}` : ""} ]`;
}

// ../node_modules/loupe/lib/date.js
function inspectDate(dateObject, options) {
  let stringRepresentation = dateObject.toJSON();
  if (stringRepresentation === null)
    return "Invalid Date";
  let split = stringRepresentation.split("T"), date = split[0];
  return options.stylize(`${date}T${truncate(split[1], options.truncate - date.length - 1)}`, "date");
}

// ../node_modules/loupe/lib/function.js
function inspectFunction(func, options) {
  let functionType = func[Symbol.toStringTag] || "Function", name = func.name;
  return name ? options.stylize(`[${functionType} ${truncate(name, options.truncate - 11)}]`, "special") : options.stylize(`[${functionType}]`, "special");
}

// ../node_modules/loupe/lib/map.js
function inspectMapEntry([key, value], options) {
  return options.truncate -= 4, key = options.inspect(key, options), options.truncate -= key.length, value = options.inspect(value, options), `${key} => ${value}`;
}
function mapToEntries(map2) {
  let entries = [];
  return map2.forEach((value, key) => {
    entries.push([key, value]);
  }), entries;
}
function inspectMap(map2, options) {
  return map2.size === 0 ? "Map{}" : (options.truncate -= 7, `Map{ ${inspectList(mapToEntries(map2), options, inspectMapEntry)} }`);
}

// ../node_modules/loupe/lib/number.js
var isNaN2 = Number.isNaN || ((i2) => i2 !== i2);
function inspectNumber(number, options) {
  return isNaN2(number) ? options.stylize("NaN", "number") : number === 1 / 0 ? options.stylize("Infinity", "number") : number === -1 / 0 ? options.stylize("-Infinity", "number") : number === 0 ? options.stylize(1 / number === 1 / 0 ? "+0" : "-0", "number") : options.stylize(truncate(String(number), options.truncate), "number");
}

// ../node_modules/loupe/lib/bigint.js
function inspectBigInt(number, options) {
  let nums = truncate(number.toString(), options.truncate - 1);
  return nums !== truncator && (nums += "n"), options.stylize(nums, "bigint");
}

// ../node_modules/loupe/lib/regexp.js
function inspectRegExp(value, options) {
  let flags = value.toString().split("/")[2], sourceLength = options.truncate - (2 + flags.length), source = value.source;
  return options.stylize(`/${truncate(source, sourceLength)}/${flags}`, "regexp");
}

// ../node_modules/loupe/lib/set.js
function arrayFromSet(set2) {
  let values = [];
  return set2.forEach((value) => {
    values.push(value);
  }), values;
}
function inspectSet(set2, options) {
  return set2.size === 0 ? "Set{}" : (options.truncate -= 7, `Set{ ${inspectList(arrayFromSet(set2), options)} }`);
}

// ../node_modules/loupe/lib/string.js
var stringEscapeChars = new RegExp("['\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]", "g"), escapeCharacters = {
  "\b": "\\b",
  "	": "\\t",
  "\n": "\\n",
  "\f": "\\f",
  "\r": "\\r",
  "'": "\\'",
  "\\": "\\\\"
}, hex = 16, unicodeLength = 4;
function escape(char) {
  return escapeCharacters[char] || `\\u${`0000${char.charCodeAt(0).toString(hex)}`.slice(-unicodeLength)}`;
}
function inspectString(string, options) {
  return stringEscapeChars.test(string) && (string = string.replace(stringEscapeChars, escape)), options.stylize(`'${truncate(string, options.truncate - 2)}'`, "string");
}

// ../node_modules/loupe/lib/symbol.js
function inspectSymbol(value) {
  return "description" in Symbol.prototype ? value.description ? `Symbol(${value.description})` : "Symbol()" : value.toString();
}

// ../node_modules/loupe/lib/promise.js
var getPromiseValue = () => "Promise{\u2026}", promise_default = getPromiseValue;

// ../node_modules/loupe/lib/object.js
function inspectObject(object, options) {
  let properties = Object.getOwnPropertyNames(object), symbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(object) : [];
  if (properties.length === 0 && symbols.length === 0)
    return "{}";
  if (options.truncate -= 4, options.seen = options.seen || [], options.seen.includes(object))
    return "[Circular]";
  options.seen.push(object);
  let propertyContents = inspectList(properties.map((key) => [key, object[key]]), options, inspectProperty), symbolContents = inspectList(symbols.map((key) => [key, object[key]]), options, inspectProperty);
  options.seen.pop();
  let sep = "";
  return propertyContents && symbolContents && (sep = ", "), `{ ${propertyContents}${sep}${symbolContents} }`;
}

// ../node_modules/loupe/lib/class.js
var toStringTag = typeof Symbol < "u" && Symbol.toStringTag ? Symbol.toStringTag : !1;
function inspectClass(value, options) {
  let name = "";
  return toStringTag && toStringTag in value && (name = value[toStringTag]), name = name || value.constructor.name, (!name || name === "_class") && (name = "<Anonymous Class>"), options.truncate -= name.length, `${name}${inspectObject(value, options)}`;
}

// ../node_modules/loupe/lib/arguments.js
function inspectArguments(args, options) {
  return args.length === 0 ? "Arguments[]" : (options.truncate -= 13, `Arguments[ ${inspectList(args, options)} ]`);
}

// ../node_modules/loupe/lib/error.js
var errorKeys = [
  "stack",
  "line",
  "column",
  "name",
  "message",
  "fileName",
  "lineNumber",
  "columnNumber",
  "number",
  "description",
  "cause"
];
function inspectObject2(error, options) {
  let properties = Object.getOwnPropertyNames(error).filter((key) => errorKeys.indexOf(key) === -1), name = error.name;
  options.truncate -= name.length;
  let message = "";
  if (typeof error.message == "string" ? message = truncate(error.message, options.truncate) : properties.unshift("message"), message = message ? `: ${message}` : "", options.truncate -= message.length + 5, options.seen = options.seen || [], options.seen.includes(error))
    return "[Circular]";
  options.seen.push(error);
  let propertyContents = inspectList(properties.map((key) => [key, error[key]]), options, inspectProperty);
  return `${name}${message}${propertyContents ? ` { ${propertyContents} }` : ""}`;
}

// ../node_modules/loupe/lib/html.js
function inspectAttribute([key, value], options) {
  return options.truncate -= 3, value ? `${options.stylize(String(key), "yellow")}=${options.stylize(`"${value}"`, "string")}` : `${options.stylize(String(key), "yellow")}`;
}
function inspectNodeCollection(collection, options) {
  return inspectList(collection, options, inspectNode, `
`);
}
function inspectNode(node, options) {
  switch (node.nodeType) {
    case 1:
      return inspectHTML(node, options);
    case 3:
      return options.inspect(node.data, options);
    default:
      return options.inspect(node, options);
  }
}
function inspectHTML(element, options) {
  let properties = element.getAttributeNames(), name = element.tagName.toLowerCase(), head = options.stylize(`<${name}`, "special"), headClose = options.stylize(">", "special"), tail = options.stylize(`</${name}>`, "special");
  options.truncate -= name.length * 2 + 5;
  let propertyContents = "";
  properties.length > 0 && (propertyContents += " ", propertyContents += inspectList(properties.map((key) => [key, element.getAttribute(key)]), options, inspectAttribute, " ")), options.truncate -= propertyContents.length;
  let truncate3 = options.truncate, children = inspectNodeCollection(element.children, options);
  return children && children.length > truncate3 && (children = `${truncator}(${element.children.length})`), `${head}${propertyContents}${headClose}${children}${tail}`;
}

// ../node_modules/loupe/lib/index.js
var symbolsSupported = typeof Symbol == "function" && typeof Symbol.for == "function", chaiInspect = symbolsSupported ? Symbol.for("chai/inspect") : "@@chai/inspect", nodeInspect = Symbol.for("nodejs.util.inspect.custom"), constructorMap = /* @__PURE__ */ new WeakMap(), stringTagMap = {}, baseTypesMap = {
  undefined: (value, options) => options.stylize("undefined", "undefined"),
  null: (value, options) => options.stylize("null", "null"),
  boolean: (value, options) => options.stylize(String(value), "boolean"),
  Boolean: (value, options) => options.stylize(String(value), "boolean"),
  number: inspectNumber,
  Number: inspectNumber,
  bigint: inspectBigInt,
  BigInt: inspectBigInt,
  string: inspectString,
  String: inspectString,
  function: inspectFunction,
  Function: inspectFunction,
  symbol: inspectSymbol,
  // A Symbol polyfill will return `Symbol` not `symbol` from typedetect
  Symbol: inspectSymbol,
  Array: inspectArray,
  Date: inspectDate,
  Map: inspectMap,
  Set: inspectSet,
  RegExp: inspectRegExp,
  Promise: promise_default,
  // WeakSet, WeakMap are totally opaque to us
  WeakSet: (value, options) => options.stylize("WeakSet{\u2026}", "special"),
  WeakMap: (value, options) => options.stylize("WeakMap{\u2026}", "special"),
  Arguments: inspectArguments,
  Int8Array: inspectTypedArray,
  Uint8Array: inspectTypedArray,
  Uint8ClampedArray: inspectTypedArray,
  Int16Array: inspectTypedArray,
  Uint16Array: inspectTypedArray,
  Int32Array: inspectTypedArray,
  Uint32Array: inspectTypedArray,
  Float32Array: inspectTypedArray,
  Float64Array: inspectTypedArray,
  Generator: () => "",
  DataView: () => "",
  ArrayBuffer: () => "",
  Error: inspectObject2,
  HTMLCollection: inspectNodeCollection,
  NodeList: inspectNodeCollection
}, inspectCustom = (value, options, type5, inspectFn) => chaiInspect in value && typeof value[chaiInspect] == "function" ? value[chaiInspect](options) : nodeInspect in value && typeof value[nodeInspect] == "function" ? value[nodeInspect](options.depth, options, inspectFn) : "inspect" in value && typeof value.inspect == "function" ? value.inspect(options.depth, options) : "constructor" in value && constructorMap.has(value.constructor) ? constructorMap.get(value.constructor)(value, options) : stringTagMap[type5] ? stringTagMap[type5](value, options) : "", toString3 = Object.prototype.toString;
function inspect(value, opts = {}) {
  let options = normaliseOptions(opts, inspect), { customInspect } = options, type5 = value === null ? "null" : typeof value;
  if (type5 === "object" && (type5 = toString3.call(value).slice(8, -1)), type5 in baseTypesMap)
    return baseTypesMap[type5](value, options);
  if (customInspect && value) {
    let output = inspectCustom(value, options, type5, inspect);
    if (output)
      return typeof output == "string" ? output : inspect(output, options);
  }
  let proto = value ? Object.getPrototypeOf(value) : !1;
  return proto === Object.prototype || proto === null ? inspectObject(value, options) : value && typeof HTMLElement == "function" && value instanceof HTMLElement ? inspectHTML(value, options) : "constructor" in value ? value.constructor !== Object ? inspectClass(value, options) : inspectObject(value, options) : value === Object(value) ? inspectObject(value, options) : options.stylize(String(value), type5);
}

// ../node_modules/@vitest/utils/dist/chunk-_commonjsHelpers.js
var { AsymmetricMatcher, DOMCollection, DOMElement, Immutable, ReactElement, ReactTestComponent } = plugins, PLUGINS = [
  ReactTestComponent,
  ReactElement,
  DOMElement,
  DOMCollection,
  Immutable,
  AsymmetricMatcher
];
function stringify2(object, maxDepth = 10, { maxLength, ...options } = {}) {
  let MAX_LENGTH = maxLength ?? 1e4, result;
  try {
    result = format(object, {
      maxDepth,
      escapeString: !1,
      plugins: PLUGINS,
      ...options
    });
  } catch {
    result = format(object, {
      callToJSON: !1,
      maxDepth,
      escapeString: !1,
      plugins: PLUGINS,
      ...options
    });
  }
  return result.length >= MAX_LENGTH && maxDepth > 1 ? stringify2(object, Math.floor(Math.min(maxDepth, Number.MAX_SAFE_INTEGER) / 2), {
    maxLength,
    ...options
  }) : result;
}
var formatRegExp = /%[sdjifoOc%]/g;
function format2(...args) {
  if (typeof args[0] != "string") {
    let objects = [];
    for (let i3 = 0; i3 < args.length; i3++)
      objects.push(inspect2(args[i3], {
        depth: 0,
        colors: !1
      }));
    return objects.join(" ");
  }
  let len = args.length, i2 = 1, template = args[0], str2 = String(template).replace(formatRegExp, (x2) => {
    if (x2 === "%%")
      return "%";
    if (i2 >= len)
      return x2;
    switch (x2) {
      case "%s": {
        let value = args[i2++];
        return typeof value == "bigint" ? `${value.toString()}n` : typeof value == "number" && value === 0 && 1 / value < 0 ? "-0" : typeof value == "object" && value !== null ? typeof value.toString == "function" && value.toString !== Object.prototype.toString ? value.toString() : inspect2(value, {
          depth: 0,
          colors: !1
        }) : String(value);
      }
      case "%d": {
        let value = args[i2++];
        return typeof value == "bigint" ? `${value.toString()}n` : Number(value).toString();
      }
      case "%i": {
        let value = args[i2++];
        return typeof value == "bigint" ? `${value.toString()}n` : Number.parseInt(String(value)).toString();
      }
      case "%f":
        return Number.parseFloat(String(args[i2++])).toString();
      case "%o":
        return inspect2(args[i2++], {
          showHidden: !0,
          showProxy: !0
        });
      case "%O":
        return inspect2(args[i2++]);
      case "%c":
        return i2++, "";
      case "%j":
        try {
          return JSON.stringify(args[i2++]);
        } catch (err) {
          let m3 = err.message;
          if (m3.includes("circular structure") || m3.includes("cyclic structures") || m3.includes("cyclic object"))
            return "[Circular]";
          throw err;
        }
      default:
        return x2;
    }
  });
  for (let x2 = args[i2]; i2 < len; x2 = args[++i2])
    x2 === null || typeof x2 != "object" ? str2 += ` ${x2}` : str2 += ` ${inspect2(x2)}`;
  return str2;
}
function inspect2(obj, options = {}) {
  return options.truncate === 0 && (options.truncate = Number.POSITIVE_INFINITY), inspect(obj, options);
}
function getDefaultExportFromCjs2(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2.default : x2;
}

// ../node_modules/@vitest/utils/dist/helpers.js
function assertTypes(value, name, types) {
  let receivedType = typeof value;
  if (!types.includes(receivedType))
    throw new TypeError(`${name} value must be ${types.join(" or ")}, received "${receivedType}"`);
}
function isObject4(item) {
  return item != null && typeof item == "object" && !Array.isArray(item);
}
function isFinalObj(obj) {
  return obj === Object.prototype || obj === Function.prototype || obj === RegExp.prototype;
}
function getType2(value) {
  return Object.prototype.toString.apply(value).slice(8, -1);
}
function collectOwnProperties(obj, collector) {
  let collect = typeof collector == "function" ? collector : (key) => collector.add(key);
  Object.getOwnPropertyNames(obj).forEach(collect), Object.getOwnPropertySymbols(obj).forEach(collect);
}
function getOwnProperties(obj) {
  let ownProps = /* @__PURE__ */ new Set();
  return isFinalObj(obj) ? [] : (collectOwnProperties(obj, ownProps), Array.from(ownProps));
}
var defaultCloneOptions = { forceWritable: !1 };
function deepClone(val, options = defaultCloneOptions) {
  return clone(val, /* @__PURE__ */ new WeakMap(), options);
}
function clone(val, seen, options = defaultCloneOptions) {
  let k2, out;
  if (seen.has(val))
    return seen.get(val);
  if (Array.isArray(val)) {
    for (out = Array.from({ length: k2 = val.length }), seen.set(val, out); k2--; )
      out[k2] = clone(val[k2], seen, options);
    return out;
  }
  if (Object.prototype.toString.call(val) === "[object Object]") {
    out = Object.create(Object.getPrototypeOf(val)), seen.set(val, out);
    let props = getOwnProperties(val);
    for (let k3 of props) {
      let descriptor = Object.getOwnPropertyDescriptor(val, k3);
      if (!descriptor)
        continue;
      let cloned = clone(val[k3], seen, options);
      options.forceWritable ? Object.defineProperty(out, k3, {
        enumerable: descriptor.enumerable,
        configurable: !0,
        writable: !0,
        value: cloned
      }) : "get" in descriptor ? Object.defineProperty(out, k3, {
        ...descriptor,
        get() {
          return cloned;
        }
      }) : Object.defineProperty(out, k3, {
        ...descriptor,
        value: cloned
      });
    }
    return out;
  }
  return val;
}
function noop() {
}

// ../node_modules/@vitest/utils/dist/diff.js
var DIFF_DELETE = -1, DIFF_INSERT = 1, DIFF_EQUAL = 0, Diff = class {
  0;
  1;
  constructor(op, text) {
    this[0] = op, this[1] = text;
  }
};
function diff_commonPrefix(text1, text2) {
  if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0))
    return 0;
  let pointermin = 0, pointermax = Math.min(text1.length, text2.length), pointermid = pointermax, pointerstart = 0;
  for (; pointermin < pointermid; )
    text1.substring(pointerstart, pointermid) === text2.substring(pointerstart, pointermid) ? (pointermin = pointermid, pointerstart = pointermin) : pointermax = pointermid, pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  return pointermid;
}
function diff_commonSuffix(text1, text2) {
  if (!text1 || !text2 || text1.charAt(text1.length - 1) !== text2.charAt(text2.length - 1))
    return 0;
  let pointermin = 0, pointermax = Math.min(text1.length, text2.length), pointermid = pointermax, pointerend = 0;
  for (; pointermin < pointermid; )
    text1.substring(text1.length - pointermid, text1.length - pointerend) === text2.substring(text2.length - pointermid, text2.length - pointerend) ? (pointermin = pointermid, pointerend = pointermin) : pointermax = pointermid, pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  return pointermid;
}
function diff_commonOverlap_(text1, text2) {
  let text1_length = text1.length, text2_length = text2.length;
  if (text1_length === 0 || text2_length === 0)
    return 0;
  text1_length > text2_length ? text1 = text1.substring(text1_length - text2_length) : text1_length < text2_length && (text2 = text2.substring(0, text1_length));
  let text_length = Math.min(text1_length, text2_length);
  if (text1 === text2)
    return text_length;
  let best = 0, length = 1;
  for (; ; ) {
    let pattern = text1.substring(text_length - length), found = text2.indexOf(pattern);
    if (found === -1)
      return best;
    length += found, (found === 0 || text1.substring(text_length - length) === text2.substring(0, length)) && (best = length, length++);
  }
}
function diff_cleanupSemantic(diffs) {
  let changes = !1, equalities = [], equalitiesLength = 0, lastEquality = null, pointer4 = 0, length_insertions1 = 0, length_deletions1 = 0, length_insertions2 = 0, length_deletions2 = 0;
  for (; pointer4 < diffs.length; )
    diffs[pointer4][0] === DIFF_EQUAL ? (equalities[equalitiesLength++] = pointer4, length_insertions1 = length_insertions2, length_deletions1 = length_deletions2, length_insertions2 = 0, length_deletions2 = 0, lastEquality = diffs[pointer4][1]) : (diffs[pointer4][0] === DIFF_INSERT ? length_insertions2 += diffs[pointer4][1].length : length_deletions2 += diffs[pointer4][1].length, lastEquality && lastEquality.length <= Math.max(length_insertions1, length_deletions1) && lastEquality.length <= Math.max(length_insertions2, length_deletions2) && (diffs.splice(equalities[equalitiesLength - 1], 0, new Diff(DIFF_DELETE, lastEquality)), diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT, equalitiesLength--, equalitiesLength--, pointer4 = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1, length_insertions1 = 0, length_deletions1 = 0, length_insertions2 = 0, length_deletions2 = 0, lastEquality = null, changes = !0)), pointer4++;
  for (changes && diff_cleanupMerge(diffs), diff_cleanupSemanticLossless(diffs), pointer4 = 1; pointer4 < diffs.length; ) {
    if (diffs[pointer4 - 1][0] === DIFF_DELETE && diffs[pointer4][0] === DIFF_INSERT) {
      let deletion = diffs[pointer4 - 1][1], insertion = diffs[pointer4][1], overlap_length1 = diff_commonOverlap_(deletion, insertion), overlap_length2 = diff_commonOverlap_(insertion, deletion);
      overlap_length1 >= overlap_length2 ? (overlap_length1 >= deletion.length / 2 || overlap_length1 >= insertion.length / 2) && (diffs.splice(pointer4, 0, new Diff(DIFF_EQUAL, insertion.substring(0, overlap_length1))), diffs[pointer4 - 1][1] = deletion.substring(0, deletion.length - overlap_length1), diffs[pointer4 + 1][1] = insertion.substring(overlap_length1), pointer4++) : (overlap_length2 >= deletion.length / 2 || overlap_length2 >= insertion.length / 2) && (diffs.splice(pointer4, 0, new Diff(DIFF_EQUAL, deletion.substring(0, overlap_length2))), diffs[pointer4 - 1][0] = DIFF_INSERT, diffs[pointer4 - 1][1] = insertion.substring(0, insertion.length - overlap_length2), diffs[pointer4 + 1][0] = DIFF_DELETE, diffs[pointer4 + 1][1] = deletion.substring(overlap_length2), pointer4++), pointer4++;
    }
    pointer4++;
  }
}
var nonAlphaNumericRegex_ = /[^a-z0-9]/i, whitespaceRegex_ = /\s/, linebreakRegex_ = /[\r\n]/, blanklineEndRegex_ = /\n\r?\n$/, blanklineStartRegex_ = /^\r?\n\r?\n/;
function diff_cleanupSemanticLossless(diffs) {
  let pointer4 = 1;
  for (; pointer4 < diffs.length - 1; ) {
    if (diffs[pointer4 - 1][0] === DIFF_EQUAL && diffs[pointer4 + 1][0] === DIFF_EQUAL) {
      let equality1 = diffs[pointer4 - 1][1], edit = diffs[pointer4][1], equality2 = diffs[pointer4 + 1][1], commonOffset = diff_commonSuffix(equality1, edit);
      if (commonOffset) {
        let commonString = edit.substring(edit.length - commonOffset);
        equality1 = equality1.substring(0, equality1.length - commonOffset), edit = commonString + edit.substring(0, edit.length - commonOffset), equality2 = commonString + equality2;
      }
      let bestEquality1 = equality1, bestEdit = edit, bestEquality2 = equality2, bestScore = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
      for (; edit.charAt(0) === equality2.charAt(0); ) {
        equality1 += edit.charAt(0), edit = edit.substring(1) + equality2.charAt(0), equality2 = equality2.substring(1);
        let score = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
        score >= bestScore && (bestScore = score, bestEquality1 = equality1, bestEdit = edit, bestEquality2 = equality2);
      }
      diffs[pointer4 - 1][1] !== bestEquality1 && (bestEquality1 ? diffs[pointer4 - 1][1] = bestEquality1 : (diffs.splice(pointer4 - 1, 1), pointer4--), diffs[pointer4][1] = bestEdit, bestEquality2 ? diffs[pointer4 + 1][1] = bestEquality2 : (diffs.splice(pointer4 + 1, 1), pointer4--));
    }
    pointer4++;
  }
}
function diff_cleanupMerge(diffs) {
  diffs.push(new Diff(DIFF_EQUAL, ""));
  let pointer4 = 0, count_delete = 0, count_insert = 0, text_delete = "", text_insert = "", commonlength;
  for (; pointer4 < diffs.length; )
    switch (diffs[pointer4][0]) {
      case DIFF_INSERT:
        count_insert++, text_insert += diffs[pointer4][1], pointer4++;
        break;
      case DIFF_DELETE:
        count_delete++, text_delete += diffs[pointer4][1], pointer4++;
        break;
      case DIFF_EQUAL:
        count_delete + count_insert > 1 ? (count_delete !== 0 && count_insert !== 0 && (commonlength = diff_commonPrefix(text_insert, text_delete), commonlength !== 0 && (pointer4 - count_delete - count_insert > 0 && diffs[pointer4 - count_delete - count_insert - 1][0] === DIFF_EQUAL ? diffs[pointer4 - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength) : (diffs.splice(0, 0, new Diff(DIFF_EQUAL, text_insert.substring(0, commonlength))), pointer4++), text_insert = text_insert.substring(commonlength), text_delete = text_delete.substring(commonlength)), commonlength = diff_commonSuffix(text_insert, text_delete), commonlength !== 0 && (diffs[pointer4][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer4][1], text_insert = text_insert.substring(0, text_insert.length - commonlength), text_delete = text_delete.substring(0, text_delete.length - commonlength))), pointer4 -= count_delete + count_insert, diffs.splice(pointer4, count_delete + count_insert), text_delete.length && (diffs.splice(pointer4, 0, new Diff(DIFF_DELETE, text_delete)), pointer4++), text_insert.length && (diffs.splice(pointer4, 0, new Diff(DIFF_INSERT, text_insert)), pointer4++), pointer4++) : pointer4 !== 0 && diffs[pointer4 - 1][0] === DIFF_EQUAL ? (diffs[pointer4 - 1][1] += diffs[pointer4][1], diffs.splice(pointer4, 1)) : pointer4++, count_insert = 0, count_delete = 0, text_delete = "", text_insert = "";
        break;
    }
  diffs[diffs.length - 1][1] === "" && diffs.pop();
  let changes = !1;
  for (pointer4 = 1; pointer4 < diffs.length - 1; )
    diffs[pointer4 - 1][0] === DIFF_EQUAL && diffs[pointer4 + 1][0] === DIFF_EQUAL && (diffs[pointer4][1].substring(diffs[pointer4][1].length - diffs[pointer4 - 1][1].length) === diffs[pointer4 - 1][1] ? (diffs[pointer4][1] = diffs[pointer4 - 1][1] + diffs[pointer4][1].substring(0, diffs[pointer4][1].length - diffs[pointer4 - 1][1].length), diffs[pointer4 + 1][1] = diffs[pointer4 - 1][1] + diffs[pointer4 + 1][1], diffs.splice(pointer4 - 1, 1), changes = !0) : diffs[pointer4][1].substring(0, diffs[pointer4 + 1][1].length) === diffs[pointer4 + 1][1] && (diffs[pointer4 - 1][1] += diffs[pointer4 + 1][1], diffs[pointer4][1] = diffs[pointer4][1].substring(diffs[pointer4 + 1][1].length) + diffs[pointer4 + 1][1], diffs.splice(pointer4 + 1, 1), changes = !0)), pointer4++;
  changes && diff_cleanupMerge(diffs);
}
function diff_cleanupSemanticScore_(one, two) {
  if (!one || !two)
    return 6;
  let char1 = one.charAt(one.length - 1), char2 = two.charAt(0), nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex_), nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex_), whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex_), whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex_), lineBreak1 = whitespace1 && char1.match(linebreakRegex_), lineBreak2 = whitespace2 && char2.match(linebreakRegex_), blankLine1 = lineBreak1 && one.match(blanklineEndRegex_), blankLine2 = lineBreak2 && two.match(blanklineStartRegex_);
  return blankLine1 || blankLine2 ? 5 : lineBreak1 || lineBreak2 ? 4 : nonAlphaNumeric1 && !whitespace1 && whitespace2 ? 3 : whitespace1 || whitespace2 ? 2 : nonAlphaNumeric1 || nonAlphaNumeric2 ? 1 : 0;
}
var NO_DIFF_MESSAGE = "Compared values have no visual difference.", SIMILAR_MESSAGE = "Compared values serialize to the same structure.\nPrinting internal object structure without calling `toJSON` instead.", build = {}, hasRequiredBuild;
function requireBuild() {
  if (hasRequiredBuild) return build;
  hasRequiredBuild = 1, Object.defineProperty(build, "__esModule", {
    value: !0
  }), build.default = diffSequence;
  let pkg = "diff-sequences", NOT_YET_SET = 0, countCommonItemsF = (aIndex, aEnd, bIndex, bEnd, isCommon) => {
    let nCommon = 0;
    for (; aIndex < aEnd && bIndex < bEnd && isCommon(aIndex, bIndex); )
      aIndex += 1, bIndex += 1, nCommon += 1;
    return nCommon;
  }, countCommonItemsR = (aStart, aIndex, bStart, bIndex, isCommon) => {
    let nCommon = 0;
    for (; aStart <= aIndex && bStart <= bIndex && isCommon(aIndex, bIndex); )
      aIndex -= 1, bIndex -= 1, nCommon += 1;
    return nCommon;
  }, extendPathsF = (d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF) => {
    let iF = 0, kF = -d, aFirst = aIndexesF[iF], aIndexPrev1 = aFirst;
    aIndexesF[iF] += countCommonItemsF(
      aFirst + 1,
      aEnd,
      bF + aFirst - kF + 1,
      bEnd,
      isCommon
    );
    let nF = d < iMaxF ? d : iMaxF;
    for (iF += 1, kF += 2; iF <= nF; iF += 1, kF += 2) {
      if (iF !== d && aIndexPrev1 < aIndexesF[iF])
        aFirst = aIndexesF[iF];
      else if (aFirst = aIndexPrev1 + 1, aEnd <= aFirst)
        return iF - 1;
      aIndexPrev1 = aIndexesF[iF], aIndexesF[iF] = aFirst + countCommonItemsF(aFirst + 1, aEnd, bF + aFirst - kF + 1, bEnd, isCommon);
    }
    return iMaxF;
  }, extendPathsR = (d, aStart, bStart, bR, isCommon, aIndexesR, iMaxR) => {
    let iR = 0, kR = d, aFirst = aIndexesR[iR], aIndexPrev1 = aFirst;
    aIndexesR[iR] -= countCommonItemsR(
      aStart,
      aFirst - 1,
      bStart,
      bR + aFirst - kR - 1,
      isCommon
    );
    let nR = d < iMaxR ? d : iMaxR;
    for (iR += 1, kR -= 2; iR <= nR; iR += 1, kR -= 2) {
      if (iR !== d && aIndexesR[iR] < aIndexPrev1)
        aFirst = aIndexesR[iR];
      else if (aFirst = aIndexPrev1 - 1, aFirst < aStart)
        return iR - 1;
      aIndexPrev1 = aIndexesR[iR], aIndexesR[iR] = aFirst - countCommonItemsR(
        aStart,
        aFirst - 1,
        bStart,
        bR + aFirst - kR - 1,
        isCommon
      );
    }
    return iMaxR;
  }, extendOverlappablePathsF = (d, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division) => {
    let bF = bStart - aStart, aLength = aEnd - aStart, baDeltaLength = bEnd - bStart - aLength, kMinOverlapF = -baDeltaLength - (d - 1), kMaxOverlapF = -baDeltaLength + (d - 1), aIndexPrev1 = NOT_YET_SET, nF = d < iMaxF ? d : iMaxF;
    for (let iF = 0, kF = -d; iF <= nF; iF += 1, kF += 2) {
      let insert = iF === 0 || iF !== d && aIndexPrev1 < aIndexesF[iF], aLastPrev = insert ? aIndexesF[iF] : aIndexPrev1, aFirst = insert ? aLastPrev : aLastPrev + 1, bFirst = bF + aFirst - kF, nCommonF = countCommonItemsF(
        aFirst + 1,
        aEnd,
        bFirst + 1,
        bEnd,
        isCommon
      ), aLast = aFirst + nCommonF;
      if (aIndexPrev1 = aIndexesF[iF], aIndexesF[iF] = aLast, kMinOverlapF <= kF && kF <= kMaxOverlapF) {
        let iR = (d - 1 - (kF + baDeltaLength)) / 2;
        if (iR <= iMaxR && aIndexesR[iR] - 1 <= aLast) {
          let bLastPrev = bF + aLastPrev - (insert ? kF + 1 : kF - 1), nCommonR = countCommonItemsR(
            aStart,
            aLastPrev,
            bStart,
            bLastPrev,
            isCommon
          ), aIndexPrevFirst = aLastPrev - nCommonR, bIndexPrevFirst = bLastPrev - nCommonR, aEndPreceding = aIndexPrevFirst + 1, bEndPreceding = bIndexPrevFirst + 1;
          division.nChangePreceding = d - 1, d - 1 === aEndPreceding + bEndPreceding - aStart - bStart ? (division.aEndPreceding = aStart, division.bEndPreceding = bStart) : (division.aEndPreceding = aEndPreceding, division.bEndPreceding = bEndPreceding), division.nCommonPreceding = nCommonR, nCommonR !== 0 && (division.aCommonPreceding = aEndPreceding, division.bCommonPreceding = bEndPreceding), division.nCommonFollowing = nCommonF, nCommonF !== 0 && (division.aCommonFollowing = aFirst + 1, division.bCommonFollowing = bFirst + 1);
          let aStartFollowing = aLast + 1, bStartFollowing = bFirst + nCommonF + 1;
          return division.nChangeFollowing = d - 1, d - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing ? (division.aStartFollowing = aEnd, division.bStartFollowing = bEnd) : (division.aStartFollowing = aStartFollowing, division.bStartFollowing = bStartFollowing), !0;
        }
      }
    }
    return !1;
  }, extendOverlappablePathsR = (d, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division) => {
    let bR = bEnd - aEnd, aLength = aEnd - aStart, baDeltaLength = bEnd - bStart - aLength, kMinOverlapR = baDeltaLength - d, kMaxOverlapR = baDeltaLength + d, aIndexPrev1 = NOT_YET_SET, nR = d < iMaxR ? d : iMaxR;
    for (let iR = 0, kR = d; iR <= nR; iR += 1, kR -= 2) {
      let insert = iR === 0 || iR !== d && aIndexesR[iR] < aIndexPrev1, aLastPrev = insert ? aIndexesR[iR] : aIndexPrev1, aFirst = insert ? aLastPrev : aLastPrev - 1, bFirst = bR + aFirst - kR, nCommonR = countCommonItemsR(
        aStart,
        aFirst - 1,
        bStart,
        bFirst - 1,
        isCommon
      ), aLast = aFirst - nCommonR;
      if (aIndexPrev1 = aIndexesR[iR], aIndexesR[iR] = aLast, kMinOverlapR <= kR && kR <= kMaxOverlapR) {
        let iF = (d + (kR - baDeltaLength)) / 2;
        if (iF <= iMaxF && aLast - 1 <= aIndexesF[iF]) {
          let bLast = bFirst - nCommonR;
          if (division.nChangePreceding = d, d === aLast + bLast - aStart - bStart ? (division.aEndPreceding = aStart, division.bEndPreceding = bStart) : (division.aEndPreceding = aLast, division.bEndPreceding = bLast), division.nCommonPreceding = nCommonR, nCommonR !== 0 && (division.aCommonPreceding = aLast, division.bCommonPreceding = bLast), division.nChangeFollowing = d - 1, d === 1)
            division.nCommonFollowing = 0, division.aStartFollowing = aEnd, division.bStartFollowing = bEnd;
          else {
            let bLastPrev = bR + aLastPrev - (insert ? kR - 1 : kR + 1), nCommonF = countCommonItemsF(
              aLastPrev,
              aEnd,
              bLastPrev,
              bEnd,
              isCommon
            );
            division.nCommonFollowing = nCommonF, nCommonF !== 0 && (division.aCommonFollowing = aLastPrev, division.bCommonFollowing = bLastPrev);
            let aStartFollowing = aLastPrev + nCommonF, bStartFollowing = bLastPrev + nCommonF;
            d - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing ? (division.aStartFollowing = aEnd, division.bStartFollowing = bEnd) : (division.aStartFollowing = aStartFollowing, division.bStartFollowing = bStartFollowing);
          }
          return !0;
        }
      }
    }
    return !1;
  }, divide = (nChange, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, aIndexesR, division) => {
    let bF = bStart - aStart, bR = bEnd - aEnd, aLength = aEnd - aStart, bLength = bEnd - bStart, baDeltaLength = bLength - aLength, iMaxF = aLength, iMaxR = aLength;
    if (aIndexesF[0] = aStart - 1, aIndexesR[0] = aEnd, baDeltaLength % 2 === 0) {
      let dMin = (nChange || baDeltaLength) / 2, dMax = (aLength + bLength) / 2;
      for (let d = 1; d <= dMax; d += 1)
        if (iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF), d < dMin)
          iMaxR = extendPathsR(d, aStart, bStart, bR, isCommon, aIndexesR, iMaxR);
        else if (
          // If a reverse path overlaps a forward path in the same diagonal,
          // return a division of the index intervals at the middle change.
          extendOverlappablePathsR(
            d,
            aStart,
            aEnd,
            bStart,
            bEnd,
            isCommon,
            aIndexesF,
            iMaxF,
            aIndexesR,
            iMaxR,
            division
          )
        )
          return;
    } else {
      let dMin = ((nChange || baDeltaLength) + 1) / 2, dMax = (aLength + bLength + 1) / 2, d = 1;
      for (iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF), d += 1; d <= dMax; d += 1)
        if (iMaxR = extendPathsR(
          d - 1,
          aStart,
          bStart,
          bR,
          isCommon,
          aIndexesR,
          iMaxR
        ), d < dMin)
          iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);
        else if (
          // If a forward path overlaps a reverse path in the same diagonal,
          // return a division of the index intervals at the middle change.
          extendOverlappablePathsF(
            d,
            aStart,
            aEnd,
            bStart,
            bEnd,
            isCommon,
            aIndexesF,
            iMaxF,
            aIndexesR,
            iMaxR,
            division
          )
        )
          return;
    }
    throw new Error(
      `${pkg}: no overlap aStart=${aStart} aEnd=${aEnd} bStart=${bStart} bEnd=${bEnd}`
    );
  }, findSubsequences = (nChange, aStart, aEnd, bStart, bEnd, transposed, callbacks, aIndexesF, aIndexesR, division) => {
    if (bEnd - bStart < aEnd - aStart) {
      if (transposed = !transposed, transposed && callbacks.length === 1) {
        let { foundSubsequence: foundSubsequence2, isCommon: isCommon2 } = callbacks[0];
        callbacks[1] = {
          foundSubsequence: (nCommon, bCommon, aCommon) => {
            foundSubsequence2(nCommon, aCommon, bCommon);
          },
          isCommon: (bIndex, aIndex) => isCommon2(aIndex, bIndex)
        };
      }
      let tStart = aStart, tEnd = aEnd;
      aStart = bStart, aEnd = bEnd, bStart = tStart, bEnd = tEnd;
    }
    let { foundSubsequence, isCommon } = callbacks[transposed ? 1 : 0];
    divide(
      nChange,
      aStart,
      aEnd,
      bStart,
      bEnd,
      isCommon,
      aIndexesF,
      aIndexesR,
      division
    );
    let {
      nChangePreceding,
      aEndPreceding,
      bEndPreceding,
      nCommonPreceding,
      aCommonPreceding,
      bCommonPreceding,
      nCommonFollowing,
      aCommonFollowing,
      bCommonFollowing,
      nChangeFollowing,
      aStartFollowing,
      bStartFollowing
    } = division;
    aStart < aEndPreceding && bStart < bEndPreceding && findSubsequences(
      nChangePreceding,
      aStart,
      aEndPreceding,
      bStart,
      bEndPreceding,
      transposed,
      callbacks,
      aIndexesF,
      aIndexesR,
      division
    ), nCommonPreceding !== 0 && foundSubsequence(nCommonPreceding, aCommonPreceding, bCommonPreceding), nCommonFollowing !== 0 && foundSubsequence(nCommonFollowing, aCommonFollowing, bCommonFollowing), aStartFollowing < aEnd && bStartFollowing < bEnd && findSubsequences(
      nChangeFollowing,
      aStartFollowing,
      aEnd,
      bStartFollowing,
      bEnd,
      transposed,
      callbacks,
      aIndexesF,
      aIndexesR,
      division
    );
  }, validateLength = (name, arg) => {
    if (typeof arg != "number")
      throw new TypeError(`${pkg}: ${name} typeof ${typeof arg} is not a number`);
    if (!Number.isSafeInteger(arg))
      throw new RangeError(`${pkg}: ${name} value ${arg} is not a safe integer`);
    if (arg < 0)
      throw new RangeError(`${pkg}: ${name} value ${arg} is a negative integer`);
  }, validateCallback = (name, arg) => {
    let type5 = typeof arg;
    if (type5 !== "function")
      throw new TypeError(`${pkg}: ${name} typeof ${type5} is not a function`);
  };
  function diffSequence(aLength, bLength, isCommon, foundSubsequence) {
    validateLength("aLength", aLength), validateLength("bLength", bLength), validateCallback("isCommon", isCommon), validateCallback("foundSubsequence", foundSubsequence);
    let nCommonF = countCommonItemsF(0, aLength, 0, bLength, isCommon);
    if (nCommonF !== 0 && foundSubsequence(nCommonF, 0, 0), aLength !== nCommonF || bLength !== nCommonF) {
      let aStart = nCommonF, bStart = nCommonF, nCommonR = countCommonItemsR(
        aStart,
        aLength - 1,
        bStart,
        bLength - 1,
        isCommon
      ), aEnd = aLength - nCommonR, bEnd = bLength - nCommonR, nCommonFR = nCommonF + nCommonR;
      aLength !== nCommonFR && bLength !== nCommonFR && findSubsequences(
        0,
        aStart,
        aEnd,
        bStart,
        bEnd,
        !1,
        [
          {
            foundSubsequence,
            isCommon
          }
        ],
        [NOT_YET_SET],
        [NOT_YET_SET],
        {
          aCommonFollowing: NOT_YET_SET,
          aCommonPreceding: NOT_YET_SET,
          aEndPreceding: NOT_YET_SET,
          aStartFollowing: NOT_YET_SET,
          bCommonFollowing: NOT_YET_SET,
          bCommonPreceding: NOT_YET_SET,
          bEndPreceding: NOT_YET_SET,
          bStartFollowing: NOT_YET_SET,
          nChangeFollowing: NOT_YET_SET,
          nChangePreceding: NOT_YET_SET,
          nCommonFollowing: NOT_YET_SET,
          nCommonPreceding: NOT_YET_SET
        }
      ), nCommonR !== 0 && foundSubsequence(nCommonR, aEnd, bEnd);
    }
  }
  return build;
}
var buildExports = requireBuild(), diffSequences = getDefaultExportFromCjs2(buildExports);
function formatTrailingSpaces(line, trailingSpaceFormatter) {
  return line.replace(/\s+$/, (match) => trailingSpaceFormatter(match));
}
function printDiffLine(line, isFirstOrLast, color, indicator, trailingSpaceFormatter, emptyFirstOrLastLinePlaceholder) {
  return line.length !== 0 ? color(`${indicator} ${formatTrailingSpaces(line, trailingSpaceFormatter)}`) : indicator !== " " ? color(indicator) : isFirstOrLast && emptyFirstOrLastLinePlaceholder.length !== 0 ? color(`${indicator} ${emptyFirstOrLastLinePlaceholder}`) : "";
}
function printDeleteLine(line, isFirstOrLast, { aColor, aIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder }) {
  return printDiffLine(line, isFirstOrLast, aColor, aIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);
}
function printInsertLine(line, isFirstOrLast, { bColor, bIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder }) {
  return printDiffLine(line, isFirstOrLast, bColor, bIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);
}
function printCommonLine(line, isFirstOrLast, { commonColor, commonIndicator, commonLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder }) {
  return printDiffLine(line, isFirstOrLast, commonColor, commonIndicator, commonLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);
}
function createPatchMark(aStart, aEnd, bStart, bEnd, { patchColor }) {
  return patchColor(`@@ -${aStart + 1},${aEnd - aStart} +${bStart + 1},${bEnd - bStart} @@`);
}
function joinAlignedDiffsNoExpand(diffs, options) {
  let iLength = diffs.length, nContextLines = options.contextLines, nContextLines2 = nContextLines + nContextLines, jLength = iLength, hasExcessAtStartOrEnd = !1, nExcessesBetweenChanges = 0, i2 = 0;
  for (; i2 !== iLength; ) {
    let iStart = i2;
    for (; i2 !== iLength && diffs[i2][0] === DIFF_EQUAL; )
      i2 += 1;
    if (iStart !== i2)
      if (iStart === 0)
        i2 > nContextLines && (jLength -= i2 - nContextLines, hasExcessAtStartOrEnd = !0);
      else if (i2 === iLength) {
        let n2 = i2 - iStart;
        n2 > nContextLines && (jLength -= n2 - nContextLines, hasExcessAtStartOrEnd = !0);
      } else {
        let n2 = i2 - iStart;
        n2 > nContextLines2 && (jLength -= n2 - nContextLines2, nExcessesBetweenChanges += 1);
      }
    for (; i2 !== iLength && diffs[i2][0] !== DIFF_EQUAL; )
      i2 += 1;
  }
  let hasPatch = nExcessesBetweenChanges !== 0 || hasExcessAtStartOrEnd;
  nExcessesBetweenChanges !== 0 ? jLength += nExcessesBetweenChanges + 1 : hasExcessAtStartOrEnd && (jLength += 1);
  let jLast = jLength - 1, lines = [], jPatchMark = 0;
  hasPatch && lines.push("");
  let aStart = 0, bStart = 0, aEnd = 0, bEnd = 0, pushCommonLine = (line) => {
    let j2 = lines.length;
    lines.push(printCommonLine(line, j2 === 0 || j2 === jLast, options)), aEnd += 1, bEnd += 1;
  }, pushDeleteLine = (line) => {
    let j2 = lines.length;
    lines.push(printDeleteLine(line, j2 === 0 || j2 === jLast, options)), aEnd += 1;
  }, pushInsertLine = (line) => {
    let j2 = lines.length;
    lines.push(printInsertLine(line, j2 === 0 || j2 === jLast, options)), bEnd += 1;
  };
  for (i2 = 0; i2 !== iLength; ) {
    let iStart = i2;
    for (; i2 !== iLength && diffs[i2][0] === DIFF_EQUAL; )
      i2 += 1;
    if (iStart !== i2)
      if (iStart === 0) {
        i2 > nContextLines && (iStart = i2 - nContextLines, aStart = iStart, bStart = iStart, aEnd = aStart, bEnd = bStart);
        for (let iCommon = iStart; iCommon !== i2; iCommon += 1)
          pushCommonLine(diffs[iCommon][1]);
      } else if (i2 === iLength) {
        let iEnd = i2 - iStart > nContextLines ? iStart + nContextLines : i2;
        for (let iCommon = iStart; iCommon !== iEnd; iCommon += 1)
          pushCommonLine(diffs[iCommon][1]);
      } else {
        let nCommon = i2 - iStart;
        if (nCommon > nContextLines2) {
          let iEnd = iStart + nContextLines;
          for (let iCommon = iStart; iCommon !== iEnd; iCommon += 1)
            pushCommonLine(diffs[iCommon][1]);
          lines[jPatchMark] = createPatchMark(aStart, aEnd, bStart, bEnd, options), jPatchMark = lines.length, lines.push("");
          let nOmit = nCommon - nContextLines2;
          aStart = aEnd + nOmit, bStart = bEnd + nOmit, aEnd = aStart, bEnd = bStart;
          for (let iCommon = i2 - nContextLines; iCommon !== i2; iCommon += 1)
            pushCommonLine(diffs[iCommon][1]);
        } else
          for (let iCommon = iStart; iCommon !== i2; iCommon += 1)
            pushCommonLine(diffs[iCommon][1]);
      }
    for (; i2 !== iLength && diffs[i2][0] === DIFF_DELETE; )
      pushDeleteLine(diffs[i2][1]), i2 += 1;
    for (; i2 !== iLength && diffs[i2][0] === DIFF_INSERT; )
      pushInsertLine(diffs[i2][1]), i2 += 1;
  }
  return hasPatch && (lines[jPatchMark] = createPatchMark(aStart, aEnd, bStart, bEnd, options)), lines.join(`
`);
}
function joinAlignedDiffsExpand(diffs, options) {
  return diffs.map((diff2, i2, diffs2) => {
    let line = diff2[1], isFirstOrLast = i2 === 0 || i2 === diffs2.length - 1;
    switch (diff2[0]) {
      case DIFF_DELETE:
        return printDeleteLine(line, isFirstOrLast, options);
      case DIFF_INSERT:
        return printInsertLine(line, isFirstOrLast, options);
      default:
        return printCommonLine(line, isFirstOrLast, options);
    }
  }).join(`
`);
}
var noColor = (string) => string, DIFF_CONTEXT_DEFAULT = 5, DIFF_TRUNCATE_THRESHOLD_DEFAULT = 0;
function getDefaultOptions() {
  return {
    aAnnotation: "Expected",
    aColor: s.green,
    aIndicator: "-",
    bAnnotation: "Received",
    bColor: s.red,
    bIndicator: "+",
    changeColor: s.inverse,
    changeLineTrailingSpaceColor: noColor,
    commonColor: s.dim,
    commonIndicator: " ",
    commonLineTrailingSpaceColor: noColor,
    compareKeys: void 0,
    contextLines: DIFF_CONTEXT_DEFAULT,
    emptyFirstOrLastLinePlaceholder: "",
    expand: !1,
    includeChangeCounts: !1,
    omitAnnotationLines: !1,
    patchColor: s.yellow,
    printBasicPrototype: !1,
    truncateThreshold: DIFF_TRUNCATE_THRESHOLD_DEFAULT,
    truncateAnnotation: "... Diff result is truncated",
    truncateAnnotationColor: noColor
  };
}
function getCompareKeys(compareKeys) {
  return compareKeys && typeof compareKeys == "function" ? compareKeys : void 0;
}
function getContextLines(contextLines) {
  return typeof contextLines == "number" && Number.isSafeInteger(contextLines) && contextLines >= 0 ? contextLines : DIFF_CONTEXT_DEFAULT;
}
function normalizeDiffOptions(options = {}) {
  return {
    ...getDefaultOptions(),
    ...options,
    compareKeys: getCompareKeys(options.compareKeys),
    contextLines: getContextLines(options.contextLines)
  };
}
function isEmptyString(lines) {
  return lines.length === 1 && lines[0].length === 0;
}
function countChanges(diffs) {
  let a2 = 0, b2 = 0;
  return diffs.forEach((diff2) => {
    switch (diff2[0]) {
      case DIFF_DELETE:
        a2 += 1;
        break;
      case DIFF_INSERT:
        b2 += 1;
        break;
    }
  }), {
    a: a2,
    b: b2
  };
}
function printAnnotation({ aAnnotation, aColor, aIndicator, bAnnotation, bColor, bIndicator, includeChangeCounts, omitAnnotationLines }, changeCounts) {
  if (omitAnnotationLines)
    return "";
  let aRest = "", bRest = "";
  if (includeChangeCounts) {
    let aCount = String(changeCounts.a), bCount = String(changeCounts.b), baAnnotationLengthDiff = bAnnotation.length - aAnnotation.length, aAnnotationPadding = " ".repeat(Math.max(0, baAnnotationLengthDiff)), bAnnotationPadding = " ".repeat(Math.max(0, -baAnnotationLengthDiff)), baCountLengthDiff = bCount.length - aCount.length, aCountPadding = " ".repeat(Math.max(0, baCountLengthDiff)), bCountPadding = " ".repeat(Math.max(0, -baCountLengthDiff));
    aRest = `${aAnnotationPadding}  ${aIndicator} ${aCountPadding}${aCount}`, bRest = `${bAnnotationPadding}  ${bIndicator} ${bCountPadding}${bCount}`;
  }
  let a2 = `${aIndicator} ${aAnnotation}${aRest}`, b2 = `${bIndicator} ${bAnnotation}${bRest}`;
  return `${aColor(a2)}
${bColor(b2)}

`;
}
function printDiffLines(diffs, truncated, options) {
  return printAnnotation(options, countChanges(diffs)) + (options.expand ? joinAlignedDiffsExpand(diffs, options) : joinAlignedDiffsNoExpand(diffs, options)) + (truncated ? options.truncateAnnotationColor(`
${options.truncateAnnotation}`) : "");
}
function diffLinesUnified(aLines, bLines, options) {
  let normalizedOptions = normalizeDiffOptions(options), [diffs, truncated] = diffLinesRaw(isEmptyString(aLines) ? [] : aLines, isEmptyString(bLines) ? [] : bLines, normalizedOptions);
  return printDiffLines(diffs, truncated, normalizedOptions);
}
function diffLinesUnified2(aLinesDisplay, bLinesDisplay, aLinesCompare, bLinesCompare, options) {
  if (isEmptyString(aLinesDisplay) && isEmptyString(aLinesCompare) && (aLinesDisplay = [], aLinesCompare = []), isEmptyString(bLinesDisplay) && isEmptyString(bLinesCompare) && (bLinesDisplay = [], bLinesCompare = []), aLinesDisplay.length !== aLinesCompare.length || bLinesDisplay.length !== bLinesCompare.length)
    return diffLinesUnified(aLinesDisplay, bLinesDisplay, options);
  let [diffs, truncated] = diffLinesRaw(aLinesCompare, bLinesCompare, options), aIndex = 0, bIndex = 0;
  return diffs.forEach((diff2) => {
    switch (diff2[0]) {
      case DIFF_DELETE:
        diff2[1] = aLinesDisplay[aIndex], aIndex += 1;
        break;
      case DIFF_INSERT:
        diff2[1] = bLinesDisplay[bIndex], bIndex += 1;
        break;
      default:
        diff2[1] = bLinesDisplay[bIndex], aIndex += 1, bIndex += 1;
    }
  }), printDiffLines(diffs, truncated, normalizeDiffOptions(options));
}
function diffLinesRaw(aLines, bLines, options) {
  let truncate3 = options?.truncateThreshold ?? !1, truncateThreshold = Math.max(Math.floor(options?.truncateThreshold ?? 0), 0), aLength = truncate3 ? Math.min(aLines.length, truncateThreshold) : aLines.length, bLength = truncate3 ? Math.min(bLines.length, truncateThreshold) : bLines.length, truncated = aLength !== aLines.length || bLength !== bLines.length, isCommon = (aIndex2, bIndex2) => aLines[aIndex2] === bLines[bIndex2], diffs = [], aIndex = 0, bIndex = 0;
  for (diffSequences(aLength, bLength, isCommon, (nCommon, aCommon, bCommon) => {
    for (; aIndex !== aCommon; aIndex += 1)
      diffs.push(new Diff(DIFF_DELETE, aLines[aIndex]));
    for (; bIndex !== bCommon; bIndex += 1)
      diffs.push(new Diff(DIFF_INSERT, bLines[bIndex]));
    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1)
      diffs.push(new Diff(DIFF_EQUAL, bLines[bIndex]));
  }); aIndex !== aLength; aIndex += 1)
    diffs.push(new Diff(DIFF_DELETE, aLines[aIndex]));
  for (; bIndex !== bLength; bIndex += 1)
    diffs.push(new Diff(DIFF_INSERT, bLines[bIndex]));
  return [diffs, truncated];
}
function getType3(value) {
  if (value === void 0)
    return "undefined";
  if (value === null)
    return "null";
  if (Array.isArray(value))
    return "array";
  if (typeof value == "boolean")
    return "boolean";
  if (typeof value == "function")
    return "function";
  if (typeof value == "number")
    return "number";
  if (typeof value == "string")
    return "string";
  if (typeof value == "bigint")
    return "bigint";
  if (typeof value == "object") {
    if (value != null) {
      if (value.constructor === RegExp)
        return "regexp";
      if (value.constructor === Map)
        return "map";
      if (value.constructor === Set)
        return "set";
      if (value.constructor === Date)
        return "date";
    }
    return "object";
  } else if (typeof value == "symbol")
    return "symbol";
  throw new Error(`value of unknown type: ${value}`);
}
function getNewLineSymbol(string) {
  return string.includes(`\r
`) ? `\r
` : `
`;
}
function diffStrings(a2, b2, options) {
  let truncate3 = options?.truncateThreshold ?? !1, truncateThreshold = Math.max(Math.floor(options?.truncateThreshold ?? 0), 0), aLength = a2.length, bLength = b2.length;
  if (truncate3) {
    let aMultipleLines = a2.includes(`
`), bMultipleLines = b2.includes(`
`), aNewLineSymbol = getNewLineSymbol(a2), bNewLineSymbol = getNewLineSymbol(b2), _a3 = aMultipleLines ? `${a2.split(aNewLineSymbol, truncateThreshold).join(aNewLineSymbol)}
` : a2, _b = bMultipleLines ? `${b2.split(bNewLineSymbol, truncateThreshold).join(bNewLineSymbol)}
` : b2;
    aLength = _a3.length, bLength = _b.length;
  }
  let truncated = aLength !== a2.length || bLength !== b2.length, isCommon = (aIndex2, bIndex2) => a2[aIndex2] === b2[bIndex2], aIndex = 0, bIndex = 0, diffs = [];
  return diffSequences(aLength, bLength, isCommon, (nCommon, aCommon, bCommon) => {
    aIndex !== aCommon && diffs.push(new Diff(DIFF_DELETE, a2.slice(aIndex, aCommon))), bIndex !== bCommon && diffs.push(new Diff(DIFF_INSERT, b2.slice(bIndex, bCommon))), aIndex = aCommon + nCommon, bIndex = bCommon + nCommon, diffs.push(new Diff(DIFF_EQUAL, b2.slice(bCommon, bIndex)));
  }), aIndex !== aLength && diffs.push(new Diff(DIFF_DELETE, a2.slice(aIndex))), bIndex !== bLength && diffs.push(new Diff(DIFF_INSERT, b2.slice(bIndex))), [diffs, truncated];
}
function concatenateRelevantDiffs(op, diffs, changeColor) {
  return diffs.reduce((reduced, diff2) => reduced + (diff2[0] === DIFF_EQUAL ? diff2[1] : diff2[0] === op && diff2[1].length !== 0 ? changeColor(diff2[1]) : ""), "");
}
var ChangeBuffer = class {
  op;
  line;
  lines;
  changeColor;
  constructor(op, changeColor) {
    this.op = op, this.line = [], this.lines = [], this.changeColor = changeColor;
  }
  pushSubstring(substring) {
    this.pushDiff(new Diff(this.op, substring));
  }
  pushLine() {
    this.lines.push(this.line.length !== 1 ? new Diff(this.op, concatenateRelevantDiffs(this.op, this.line, this.changeColor)) : this.line[0][0] === this.op ? this.line[0] : new Diff(this.op, this.line[0][1])), this.line.length = 0;
  }
  isLineEmpty() {
    return this.line.length === 0;
  }
  // Minor input to buffer.
  pushDiff(diff2) {
    this.line.push(diff2);
  }
  // Main input to buffer.
  align(diff2) {
    let string = diff2[1];
    if (string.includes(`
`)) {
      let substrings = string.split(`
`), iLast = substrings.length - 1;
      substrings.forEach((substring, i2) => {
        i2 < iLast ? (this.pushSubstring(substring), this.pushLine()) : substring.length !== 0 && this.pushSubstring(substring);
      });
    } else
      this.pushDiff(diff2);
  }
  // Output from buffer.
  moveLinesTo(lines) {
    this.isLineEmpty() || this.pushLine(), lines.push(...this.lines), this.lines.length = 0;
  }
}, CommonBuffer = class {
  deleteBuffer;
  insertBuffer;
  lines;
  constructor(deleteBuffer, insertBuffer) {
    this.deleteBuffer = deleteBuffer, this.insertBuffer = insertBuffer, this.lines = [];
  }
  pushDiffCommonLine(diff2) {
    this.lines.push(diff2);
  }
  pushDiffChangeLines(diff2) {
    let isDiffEmpty = diff2[1].length === 0;
    (!isDiffEmpty || this.deleteBuffer.isLineEmpty()) && this.deleteBuffer.pushDiff(diff2), (!isDiffEmpty || this.insertBuffer.isLineEmpty()) && this.insertBuffer.pushDiff(diff2);
  }
  flushChangeLines() {
    this.deleteBuffer.moveLinesTo(this.lines), this.insertBuffer.moveLinesTo(this.lines);
  }
  // Input to buffer.
  align(diff2) {
    let op = diff2[0], string = diff2[1];
    if (string.includes(`
`)) {
      let substrings = string.split(`
`), iLast = substrings.length - 1;
      substrings.forEach((substring, i2) => {
        if (i2 === 0) {
          let subdiff = new Diff(op, substring);
          this.deleteBuffer.isLineEmpty() && this.insertBuffer.isLineEmpty() ? (this.flushChangeLines(), this.pushDiffCommonLine(subdiff)) : (this.pushDiffChangeLines(subdiff), this.flushChangeLines());
        } else i2 < iLast ? this.pushDiffCommonLine(new Diff(op, substring)) : substring.length !== 0 && this.pushDiffChangeLines(new Diff(op, substring));
      });
    } else
      this.pushDiffChangeLines(diff2);
  }
  // Output from buffer.
  getLines() {
    return this.flushChangeLines(), this.lines;
  }
};
function getAlignedDiffs(diffs, changeColor) {
  let deleteBuffer = new ChangeBuffer(DIFF_DELETE, changeColor), insertBuffer = new ChangeBuffer(DIFF_INSERT, changeColor), commonBuffer = new CommonBuffer(deleteBuffer, insertBuffer);
  return diffs.forEach((diff2) => {
    switch (diff2[0]) {
      case DIFF_DELETE:
        deleteBuffer.align(diff2);
        break;
      case DIFF_INSERT:
        insertBuffer.align(diff2);
        break;
      default:
        commonBuffer.align(diff2);
    }
  }), commonBuffer.getLines();
}
function hasCommonDiff(diffs, isMultiline) {
  if (isMultiline) {
    let iLast = diffs.length - 1;
    return diffs.some((diff2, i2) => diff2[0] === DIFF_EQUAL && (i2 !== iLast || diff2[1] !== `
`));
  }
  return diffs.some((diff2) => diff2[0] === DIFF_EQUAL);
}
function diffStringsUnified(a2, b2, options) {
  if (a2 !== b2 && a2.length !== 0 && b2.length !== 0) {
    let isMultiline = a2.includes(`
`) || b2.includes(`
`), [diffs, truncated] = diffStringsRaw(isMultiline ? `${a2}
` : a2, isMultiline ? `${b2}
` : b2, !0, options);
    if (hasCommonDiff(diffs, isMultiline)) {
      let optionsNormalized = normalizeDiffOptions(options), lines = getAlignedDiffs(diffs, optionsNormalized.changeColor);
      return printDiffLines(lines, truncated, optionsNormalized);
    }
  }
  return diffLinesUnified(a2.split(`
`), b2.split(`
`), options);
}
function diffStringsRaw(a2, b2, cleanup, options) {
  let [diffs, truncated] = diffStrings(a2, b2, options);
  return cleanup && diff_cleanupSemantic(diffs), [diffs, truncated];
}
function getCommonMessage(message, options) {
  let { commonColor } = normalizeDiffOptions(options);
  return commonColor(message);
}
var { AsymmetricMatcher: AsymmetricMatcher2, DOMCollection: DOMCollection2, DOMElement: DOMElement2, Immutable: Immutable2, ReactElement: ReactElement2, ReactTestComponent: ReactTestComponent2 } = plugins, PLUGINS2 = [
  ReactTestComponent2,
  ReactElement2,
  DOMElement2,
  DOMCollection2,
  Immutable2,
  AsymmetricMatcher2,
  plugins.Error
], FORMAT_OPTIONS = {
  maxDepth: 20,
  plugins: PLUGINS2
}, FALLBACK_FORMAT_OPTIONS = {
  callToJSON: !1,
  maxDepth: 8,
  plugins: PLUGINS2
};
function diff(a2, b2, options) {
  if (Object.is(a2, b2))
    return "";
  let aType = getType3(a2), expectedType = aType, omitDifference = !1;
  if (aType === "object" && typeof a2.asymmetricMatch == "function") {
    if (a2.$$typeof !== Symbol.for("jest.asymmetricMatcher") || typeof a2.getExpectedType != "function")
      return;
    expectedType = a2.getExpectedType(), omitDifference = expectedType === "string";
  }
  if (expectedType !== getType3(b2)) {
    let truncate3 = function(s3) {
      return s3.length <= MAX_LENGTH ? s3 : `${s3.slice(0, MAX_LENGTH)}...`;
    }, { aAnnotation, aColor, aIndicator, bAnnotation, bColor, bIndicator } = normalizeDiffOptions(options), formatOptions = getFormatOptions(FALLBACK_FORMAT_OPTIONS, options), aDisplay = format(a2, formatOptions), bDisplay = format(b2, formatOptions), MAX_LENGTH = 1e5;
    aDisplay = truncate3(aDisplay), bDisplay = truncate3(bDisplay);
    let aDiff = `${aColor(`${aIndicator} ${aAnnotation}:`)} 
${aDisplay}`, bDiff = `${bColor(`${bIndicator} ${bAnnotation}:`)} 
${bDisplay}`;
    return `${aDiff}

${bDiff}`;
  }
  if (!omitDifference)
    switch (aType) {
      case "string":
        return diffLinesUnified(a2.split(`
`), b2.split(`
`), options);
      case "boolean":
      case "number":
        return comparePrimitive(a2, b2, options);
      case "map":
        return compareObjects(sortMap(a2), sortMap(b2), options);
      case "set":
        return compareObjects(sortSet(a2), sortSet(b2), options);
      default:
        return compareObjects(a2, b2, options);
    }
}
function comparePrimitive(a2, b2, options) {
  let aFormat = format(a2, FORMAT_OPTIONS), bFormat = format(b2, FORMAT_OPTIONS);
  return aFormat === bFormat ? "" : diffLinesUnified(aFormat.split(`
`), bFormat.split(`
`), options);
}
function sortMap(map2) {
  return new Map(Array.from(map2.entries()).sort());
}
function sortSet(set2) {
  return new Set(Array.from(set2.values()).sort());
}
function compareObjects(a2, b2, options) {
  let difference, hasThrown = !1;
  try {
    let formatOptions = getFormatOptions(FORMAT_OPTIONS, options);
    difference = getObjectsDifference(a2, b2, formatOptions, options);
  } catch {
    hasThrown = !0;
  }
  let noDiffMessage = getCommonMessage(NO_DIFF_MESSAGE, options);
  if (difference === void 0 || difference === noDiffMessage) {
    let formatOptions = getFormatOptions(FALLBACK_FORMAT_OPTIONS, options);
    difference = getObjectsDifference(a2, b2, formatOptions, options), difference !== noDiffMessage && !hasThrown && (difference = `${getCommonMessage(SIMILAR_MESSAGE, options)}

${difference}`);
  }
  return difference;
}
function getFormatOptions(formatOptions, options) {
  let { compareKeys, printBasicPrototype, maxDepth } = normalizeDiffOptions(options);
  return {
    ...formatOptions,
    compareKeys,
    printBasicPrototype,
    maxDepth: maxDepth ?? formatOptions.maxDepth
  };
}
function getObjectsDifference(a2, b2, formatOptions, options) {
  let formatOptionsZeroIndent = {
    ...formatOptions,
    indent: 0
  }, aCompare = format(a2, formatOptionsZeroIndent), bCompare = format(b2, formatOptionsZeroIndent);
  if (aCompare === bCompare)
    return getCommonMessage(NO_DIFF_MESSAGE, options);
  {
    let aDisplay = format(a2, formatOptions), bDisplay = format(b2, formatOptions);
    return diffLinesUnified2(aDisplay.split(`
`), bDisplay.split(`
`), aCompare.split(`
`), bCompare.split(`
`), options);
  }
}
var MAX_DIFF_STRING_LENGTH = 2e4;
function isAsymmetricMatcher(data) {
  return getType2(data) === "Object" && typeof data.asymmetricMatch == "function";
}
function isReplaceable(obj1, obj2) {
  let obj1Type = getType2(obj1), obj2Type = getType2(obj2);
  return obj1Type === obj2Type && (obj1Type === "Object" || obj1Type === "Array");
}
function printDiffOrStringify(received, expected, options) {
  let { aAnnotation, bAnnotation } = normalizeDiffOptions(options);
  if (typeof expected == "string" && typeof received == "string" && expected.length > 0 && received.length > 0 && expected.length <= MAX_DIFF_STRING_LENGTH && received.length <= MAX_DIFF_STRING_LENGTH && expected !== received) {
    if (expected.includes(`
`) || received.includes(`
`))
      return diffStringsUnified(expected, received, options);
    let [diffs] = diffStringsRaw(expected, received, !0), hasCommonDiff2 = diffs.some((diff2) => diff2[0] === DIFF_EQUAL), printLabel = getLabelPrinter(aAnnotation, bAnnotation), expectedLine = printLabel(aAnnotation) + printExpected(getCommonAndChangedSubstrings(diffs, DIFF_DELETE, hasCommonDiff2)), receivedLine = printLabel(bAnnotation) + printReceived(getCommonAndChangedSubstrings(diffs, DIFF_INSERT, hasCommonDiff2));
    return `${expectedLine}
${receivedLine}`;
  }
  let clonedExpected = deepClone(expected, { forceWritable: !0 }), clonedReceived = deepClone(received, { forceWritable: !0 }), { replacedExpected, replacedActual } = replaceAsymmetricMatcher(clonedReceived, clonedExpected);
  return diff(replacedExpected, replacedActual, options);
}
function replaceAsymmetricMatcher(actual, expected, actualReplaced = /* @__PURE__ */ new WeakSet(), expectedReplaced = /* @__PURE__ */ new WeakSet()) {
  return actual instanceof Error && expected instanceof Error && typeof actual.cause < "u" && typeof expected.cause > "u" ? (delete actual.cause, {
    replacedActual: actual,
    replacedExpected: expected
  }) : isReplaceable(actual, expected) ? actualReplaced.has(actual) || expectedReplaced.has(expected) ? {
    replacedActual: actual,
    replacedExpected: expected
  } : (actualReplaced.add(actual), expectedReplaced.add(expected), getOwnProperties(expected).forEach((key) => {
    let expectedValue = expected[key], actualValue = actual[key];
    if (isAsymmetricMatcher(expectedValue))
      expectedValue.asymmetricMatch(actualValue) && (actual[key] = expectedValue);
    else if (isAsymmetricMatcher(actualValue))
      actualValue.asymmetricMatch(expectedValue) && (expected[key] = actualValue);
    else if (isReplaceable(actualValue, expectedValue)) {
      let replaced = replaceAsymmetricMatcher(actualValue, expectedValue, actualReplaced, expectedReplaced);
      actual[key] = replaced.replacedActual, expected[key] = replaced.replacedExpected;
    }
  }), {
    replacedActual: actual,
    replacedExpected: expected
  }) : {
    replacedActual: actual,
    replacedExpected: expected
  };
}
function getLabelPrinter(...strings) {
  let maxLength = strings.reduce((max, string) => string.length > max ? string.length : max, 0);
  return (string) => `${string}: ${" ".repeat(maxLength - string.length)}`;
}
var SPACE_SYMBOL = "\xB7";
function replaceTrailingSpaces(text) {
  return text.replace(/\s+$/gm, (spaces) => SPACE_SYMBOL.repeat(spaces.length));
}
function printReceived(object) {
  return s.red(replaceTrailingSpaces(stringify2(object)));
}
function printExpected(value) {
  return s.green(replaceTrailingSpaces(stringify2(value)));
}
function getCommonAndChangedSubstrings(diffs, op, hasCommonDiff2) {
  return diffs.reduce((reduced, diff2) => reduced + (diff2[0] === DIFF_EQUAL ? diff2[1] : diff2[0] === op ? hasCommonDiff2 ? s.inverse(diff2[1]) : diff2[1] : ""), "");
}

// ../node_modules/@vitest/utils/dist/error.js
var IS_RECORD_SYMBOL = "@@__IMMUTABLE_RECORD__@@", IS_COLLECTION_SYMBOL = "@@__IMMUTABLE_ITERABLE__@@";
function isImmutable(v2) {
  return v2 && (v2[IS_COLLECTION_SYMBOL] || v2[IS_RECORD_SYMBOL]);
}
var OBJECT_PROTO = Object.getPrototypeOf({});
function getUnserializableMessage(err) {
  return err instanceof Error ? `<unserializable>: ${err.message}` : typeof err == "string" ? `<unserializable>: ${err}` : "<unserializable>";
}
function serializeValue(val, seen = /* @__PURE__ */ new WeakMap()) {
  if (!val || typeof val == "string")
    return val;
  if (val instanceof Error && "toJSON" in val && typeof val.toJSON == "function") {
    let jsonValue = val.toJSON();
    return jsonValue && jsonValue !== val && typeof jsonValue == "object" && (typeof val.message == "string" && safe(() => jsonValue.message ?? (jsonValue.message = val.message)), typeof val.stack == "string" && safe(() => jsonValue.stack ?? (jsonValue.stack = val.stack)), typeof val.name == "string" && safe(() => jsonValue.name ?? (jsonValue.name = val.name)), val.cause != null && safe(() => jsonValue.cause ?? (jsonValue.cause = serializeValue(val.cause, seen)))), serializeValue(jsonValue, seen);
  }
  if (typeof val == "function")
    return `Function<${val.name || "anonymous"}>`;
  if (typeof val == "symbol")
    return val.toString();
  if (typeof val != "object")
    return val;
  if (typeof Buffer < "u" && val instanceof Buffer)
    return `<Buffer(${val.length}) ...>`;
  if (typeof Uint8Array < "u" && val instanceof Uint8Array)
    return `<Uint8Array(${val.length}) ...>`;
  if (isImmutable(val))
    return serializeValue(val.toJSON(), seen);
  if (val instanceof Promise || val.constructor && val.constructor.prototype === "AsyncFunction")
    return "Promise";
  if (typeof Element < "u" && val instanceof Element)
    return val.tagName;
  if (typeof val.asymmetricMatch == "function")
    return `${val.toString()} ${format2(val.sample)}`;
  if (typeof val.toJSON == "function")
    return serializeValue(val.toJSON(), seen);
  if (seen.has(val))
    return seen.get(val);
  if (Array.isArray(val)) {
    let clone3 = new Array(val.length);
    return seen.set(val, clone3), val.forEach((e2, i2) => {
      try {
        clone3[i2] = serializeValue(e2, seen);
      } catch (err) {
        clone3[i2] = getUnserializableMessage(err);
      }
    }), clone3;
  } else {
    let clone3 = /* @__PURE__ */ Object.create(null);
    seen.set(val, clone3);
    let obj = val;
    for (; obj && obj !== OBJECT_PROTO; )
      Object.getOwnPropertyNames(obj).forEach((key) => {
        if (!(key in clone3))
          try {
            clone3[key] = serializeValue(val[key], seen);
          } catch (err) {
            delete clone3[key], clone3[key] = getUnserializableMessage(err);
          }
      }), obj = Object.getPrototypeOf(obj);
    return clone3;
  }
}
function safe(fn3) {
  try {
    return fn3();
  } catch {
  }
}
function normalizeErrorMessage(message) {
  return message.replace(/__(vite_ssr_import|vi_import)_\d+__\./g, "");
}
function processError(_err, diffOptions, seen = /* @__PURE__ */ new WeakSet()) {
  if (!_err || typeof _err != "object")
    return { message: String(_err) };
  let err = _err;
  (err.showDiff || err.showDiff === void 0 && err.expected !== void 0 && err.actual !== void 0) && (err.diff = printDiffOrStringify(err.actual, err.expected, {
    ...diffOptions,
    ...err.diffOptions
  })), "expected" in err && typeof err.expected != "string" && (err.expected = stringify2(err.expected, 10)), "actual" in err && typeof err.actual != "string" && (err.actual = stringify2(err.actual, 10));
  try {
    typeof err.message == "string" && (err.message = normalizeErrorMessage(err.message));
  } catch {
  }
  try {
    !seen.has(err) && typeof err.cause == "object" && (seen.add(err), err.cause = processError(err.cause, diffOptions, seen));
  } catch {
  }
  try {
    return serializeValue(err);
  } catch (e2) {
    return serializeValue(new Error(`Failed to fully serialize error: ${e2?.message}
Inner error message: ${err?.message}`));
  }
}

// src/instrumenter/EVENTS.ts
var EVENTS = {
  CALL: "storybook/instrumenter/call",
  SYNC: "storybook/instrumenter/sync",
  START: "storybook/instrumenter/start",
  BACK: "storybook/instrumenter/back",
  GOTO: "storybook/instrumenter/goto",
  NEXT: "storybook/instrumenter/next",
  END: "storybook/instrumenter/end"
};

// src/instrumenter/preview-api.ts
var addons2 = globalThis.__STORYBOOK_ADDONS_PREVIEW;

// src/instrumenter/instrumenter.ts
var alreadyCompletedException = new Error(
  "This function ran after the play function completed. Did you forget to `await` it?"
), isObject5 = (o2) => Object.prototype.toString.call(o2) === "[object Object]", isModule = (o2) => Object.prototype.toString.call(o2) === "[object Module]", isInstrumentable = (o2) => {
  if (!isObject5(o2) && !isModule(o2))
    return !1;
  if (o2.constructor === void 0)
    return !0;
  let proto = o2.constructor.prototype;
  return !!isObject5(proto);
}, construct = (obj) => {
  try {
    return new obj.constructor();
  } catch {
    return {};
  }
}, getInitialState = () => ({
  renderPhase: "preparing",
  isDebugging: !1,
  isPlaying: !1,
  isLocked: !1,
  cursor: 0,
  calls: [],
  shadowCalls: [],
  callRefsByResult: /* @__PURE__ */ new Map(),
  chainedCallIds: /* @__PURE__ */ new Set(),
  ancestors: [],
  playUntil: void 0,
  resolvers: {},
  syncTimeout: void 0
}), getRetainedState = (state3, isDebugging = !1) => {
  let calls = (isDebugging ? state3.shadowCalls : state3.calls).filter((call2) => call2.retain);
  if (!calls.length)
    return;
  let callRefsByResult = new Map(
    Array.from(state3.callRefsByResult.entries()).filter(([, ref]) => ref.retain)
  );
  return { cursor: calls.length, calls, callRefsByResult };
}, Instrumenter = class {
  constructor() {
    this.detached = !1;
    this.initialized = !1;
    // State is tracked per story to deal with multiple stories on the same canvas (i.e. docs mode)
    this.state = {};
    this.loadParentWindowState = () => {
      try {
        this.state = scope.window?.parent?.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ || {};
      } catch {
        this.detached = !0;
      }
    };
    this.updateParentWindowState = () => {
      try {
        scope.window.parent.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ = this.state;
      } catch {
        this.detached = !0;
      }
    };
    this.loadParentWindowState();
    let resetState = ({
      storyId,
      renderPhase,
      isPlaying = !0,
      isDebugging = !1
    }) => {
      let state3 = this.getState(storyId);
      this.setState(storyId, {
        ...getInitialState(),
        ...getRetainedState(state3, isDebugging),
        renderPhase: renderPhase || state3.renderPhase,
        shadowCalls: isDebugging ? state3.shadowCalls : [],
        chainedCallIds: isDebugging ? state3.chainedCallIds : /* @__PURE__ */ new Set(),
        playUntil: isDebugging ? state3.playUntil : void 0,
        isPlaying,
        isDebugging
      }), this.sync(storyId);
    }, start = (channel) => ({ storyId, playUntil }) => {
      this.getState(storyId).isDebugging || this.setState(storyId, ({ calls }) => ({
        calls: [],
        shadowCalls: calls.map((call2) => ({ ...call2, status: "waiting" /* WAITING */ })),
        isDebugging: !0
      }));
      let log = this.getLog(storyId);
      this.setState(storyId, ({ shadowCalls }) => {
        if (playUntil || !log.length)
          return { playUntil };
        let firstRowIndex = shadowCalls.findIndex((call2) => call2.id === log[0].callId);
        return {
          playUntil: shadowCalls.slice(0, firstRowIndex).filter((call2) => call2.interceptable && !call2.ancestors?.length).slice(-1)[0]?.id
        };
      }), channel.emit(FORCE_REMOUNT, { storyId, isDebugging: !0 });
    }, back = (channel) => ({ storyId }) => {
      let log = this.getLog(storyId).filter((call2) => !call2.ancestors?.length), last = log.reduceRight((res, item, index2) => res >= 0 || item.status === "waiting" /* WAITING */ ? res : index2, -1);
      start(channel)({ storyId, playUntil: log[last - 1]?.callId });
    }, goto = (channel) => ({ storyId, callId }) => {
      let { calls, shadowCalls, resolvers } = this.getState(storyId), call2 = calls.find(({ id }) => id === callId), shadowCall = shadowCalls.find(({ id }) => id === callId);
      if (!call2 && shadowCall && Object.values(resolvers).length > 0) {
        let nextId = this.getLog(storyId).find((c2) => c2.status === "waiting" /* WAITING */)?.callId;
        shadowCall.id !== nextId && this.setState(storyId, { playUntil: shadowCall.id }), Object.values(resolvers).forEach((resolve) => resolve());
      } else
        start(channel)({ storyId, playUntil: callId });
    }, next = (channel) => ({ storyId }) => {
      let { resolvers } = this.getState(storyId);
      if (Object.values(resolvers).length > 0)
        Object.values(resolvers).forEach((resolve) => resolve());
      else {
        let nextId = this.getLog(storyId).find((c2) => c2.status === "waiting" /* WAITING */)?.callId;
        nextId ? start(channel)({ storyId, playUntil: nextId }) : end({ storyId });
      }
    }, end = ({ storyId }) => {
      this.setState(storyId, { playUntil: void 0, isDebugging: !1 }), Object.values(this.getState(storyId).resolvers).forEach((resolve) => resolve());
    }, renderPhaseChanged = ({
      storyId,
      newPhase
    }) => {
      let { isDebugging } = this.getState(storyId);
      if (newPhase === "preparing" && isDebugging)
        return resetState({ storyId, renderPhase: newPhase, isDebugging });
      if (newPhase === "playing")
        return resetState({ storyId, renderPhase: newPhase, isDebugging });
      newPhase === "played" ? this.setState(storyId, {
        renderPhase: newPhase,
        isLocked: !1,
        isPlaying: !1,
        isDebugging: !1
      }) : newPhase === "errored" ? this.setState(storyId, {
        renderPhase: newPhase,
        isLocked: !1,
        isPlaying: !1
      }) : newPhase === "aborted" ? this.setState(storyId, {
        renderPhase: newPhase,
        isLocked: !0,
        isPlaying: !1
      }) : this.setState(storyId, {
        renderPhase: newPhase
      }), this.sync(storyId);
    };
    addons2 && addons2.ready().then(() => {
      this.channel = addons2.getChannel(), this.channel.on(FORCE_REMOUNT, resetState), this.channel.on(STORY_RENDER_PHASE_CHANGED, renderPhaseChanged), this.channel.on(SET_CURRENT_STORY, () => {
        this.initialized ? this.cleanup() : this.initialized = !0;
      }), this.channel.on(EVENTS.START, start(this.channel)), this.channel.on(EVENTS.BACK, back(this.channel)), this.channel.on(EVENTS.GOTO, goto(this.channel)), this.channel.on(EVENTS.NEXT, next(this.channel)), this.channel.on(EVENTS.END, end);
    });
  }
  getState(storyId) {
    return this.state[storyId] || getInitialState();
  }
  setState(storyId, update) {
    if (storyId) {
      let state3 = this.getState(storyId), patch = typeof update == "function" ? update(state3) : update;
      this.state = { ...this.state, [storyId]: { ...state3, ...patch } }, this.updateParentWindowState();
    }
  }
  cleanup() {
    this.state = Object.entries(this.state).reduce(
      (acc, [storyId, state3]) => {
        let retainedState = getRetainedState(state3);
        return retainedState && (acc[storyId] = Object.assign(getInitialState(), retainedState)), acc;
      },
      {}
    );
    let payload = { controlStates: {
      detached: this.detached,
      start: !1,
      back: !1,
      goto: !1,
      next: !1,
      end: !1
    }, logItems: [] };
    this.channel?.emit(EVENTS.SYNC, payload), this.updateParentWindowState();
  }
  getLog(storyId) {
    let { calls, shadowCalls } = this.getState(storyId), merged = [...shadowCalls];
    calls.forEach((call2, index2) => {
      merged[index2] = call2;
    });
    let seen = /* @__PURE__ */ new Set();
    return merged.reduceRight((acc, call2) => (call2.args.forEach((arg) => {
      arg?.__callId__ && seen.add(arg.__callId__);
    }), call2.path.forEach((node) => {
      node.__callId__ && seen.add(node.__callId__);
    }), (call2.interceptable || call2.exception) && !seen.has(call2.id) && (acc.unshift({ callId: call2.id, status: call2.status, ancestors: call2.ancestors }), seen.add(call2.id)), acc), []);
  }
  // Traverses the object structure to recursively patch all function properties.
  // Returns the original object, or a new object with the same constructor,
  // depending on whether it should mutate.
  instrument(obj, options, depth = 0) {
    if (!isInstrumentable(obj))
      return obj;
    let { mutate = !1, path = [] } = options, keys2 = options.getKeys ? options.getKeys(obj, depth) : Object.keys(obj);
    return depth += 1, keys2.reduce(
      (acc, key) => {
        let descriptor = getPropertyDescriptor(obj, key);
        if (typeof descriptor?.get == "function") {
          if (descriptor.configurable) {
            let getter = () => descriptor?.get?.bind(obj)?.();
            Object.defineProperty(acc, key, {
              get: () => this.instrument(getter(), { ...options, path: path.concat(key) }, depth)
            });
          }
          return acc;
        }
        let value = obj[key];
        return typeof value != "function" ? (acc[key] = this.instrument(value, { ...options, path: path.concat(key) }, depth), acc) : "__originalFn__" in value && typeof value.__originalFn__ == "function" ? (acc[key] = value, acc) : (acc[key] = (...args) => this.track(key, value, obj, args, options), acc[key].__originalFn__ = value, Object.defineProperty(acc[key], "name", { value: key, writable: !1 }), Object.keys(value).length > 0 && Object.assign(
          acc[key],
          this.instrument({ ...value }, { ...options, path: path.concat(key) }, depth)
        ), acc);
      },
      mutate ? obj : construct(obj)
    );
  }
  // Monkey patch an object method to record calls.
  // Returns a function that invokes the original function, records the invocation ("call") and
  // returns the original result.
  track(method, fn3, object, args, options) {
    let storyId = args?.[0]?.__storyId__ || scope.__STORYBOOK_PREVIEW__?.selectionStore?.selection?.storyId, { cursor, ancestors } = this.getState(storyId);
    this.setState(storyId, { cursor: cursor + 1 });
    let id = `${ancestors.slice(-1)[0] || storyId} [${cursor}] ${method}`, { path = [], intercept = !1, retain = !1 } = options, interceptable = typeof intercept == "function" ? intercept(method, path) : intercept, call2 = { id, cursor, storyId, ancestors, path, method, args, interceptable, retain }, result = (interceptable && !ancestors.length ? this.intercept : this.invoke).call(this, fn3, object, call2, options);
    return this.instrument(result, { ...options, mutate: !0, path: [{ __callId__: call2.id }] });
  }
  intercept(fn3, object, call2, options) {
    let { chainedCallIds, isDebugging, playUntil } = this.getState(call2.storyId), isChainedUpon = chainedCallIds.has(call2.id);
    return !isDebugging || isChainedUpon || playUntil ? (playUntil === call2.id && this.setState(call2.storyId, { playUntil: void 0 }), this.invoke(fn3, object, call2, options)) : new Promise((resolve) => {
      this.setState(call2.storyId, ({ resolvers }) => ({
        isLocked: !1,
        resolvers: { ...resolvers, [call2.id]: resolve }
      }));
    }).then(() => (this.setState(call2.storyId, (state3) => {
      let { [call2.id]: _, ...resolvers } = state3.resolvers;
      return { isLocked: !0, resolvers };
    }), this.invoke(fn3, object, call2, options)));
  }
  invoke(fn3, object, call2, options) {
    let { callRefsByResult, renderPhase } = this.getState(call2.storyId), maximumDepth = 25, serializeValues = (value, depth, seen) => {
      if (seen.includes(value))
        return "[Circular]";
      if (seen = [...seen, value], depth > maximumDepth)
        return "...";
      if (callRefsByResult.has(value))
        return callRefsByResult.get(value);
      if (value instanceof Array)
        return value.map((it) => serializeValues(it, ++depth, seen));
      if (value instanceof Date)
        return { __date__: { value: value.toISOString() } };
      if (value instanceof Error) {
        let { name, message, stack } = value;
        return { __error__: { name, message, stack } };
      }
      if (value instanceof RegExp) {
        let { flags, source } = value;
        return { __regexp__: { flags, source } };
      }
      if (value instanceof scope.window?.HTMLElement) {
        let { prefix: prefix2, localName, id, classList, innerText } = value, classNames = Array.from(classList);
        return { __element__: { prefix: prefix2, localName, id, classNames, innerText } };
      }
      return typeof value == "function" ? {
        __function__: { name: "getMockName" in value ? value.getMockName() : value.name }
      } : typeof value == "symbol" ? { __symbol__: { description: value.description } } : typeof value == "object" && value?.constructor?.name && value?.constructor?.name !== "Object" ? { __class__: { name: value.constructor.name } } : Object.prototype.toString.call(value) === "[object Object]" ? Object.fromEntries(
        Object.entries(value).map(([key, val]) => [key, serializeValues(val, ++depth, seen)])
      ) : value;
    }, info = {
      ...call2,
      args: call2.args.map((arg) => serializeValues(arg, 0, []))
    };
    call2.path.forEach((ref) => {
      ref?.__callId__ && this.setState(call2.storyId, ({ chainedCallIds }) => ({
        chainedCallIds: new Set(Array.from(chainedCallIds).concat(ref.__callId__))
      }));
    });
    let handleException = (e2) => {
      if (e2 instanceof Error) {
        let { name, message, stack, callId = call2.id } = e2, {
          showDiff = void 0,
          diff: diff2 = void 0,
          actual = void 0,
          expected = void 0
        } = e2.name === "AssertionError" ? processError(e2) : e2, exception = { name, message, stack, callId, showDiff, diff: diff2, actual, expected };
        if (this.update({ ...info, status: "error" /* ERROR */, exception }), this.setState(call2.storyId, (state3) => ({
          callRefsByResult: new Map([
            ...Array.from(state3.callRefsByResult.entries()),
            [e2, { __callId__: call2.id, retain: call2.retain }]
          ])
        })), call2.ancestors?.length)
          throw Object.prototype.hasOwnProperty.call(e2, "callId") || Object.defineProperty(e2, "callId", { value: call2.id }), e2;
      }
      throw e2;
    };
    try {
      if (renderPhase === "played" && !call2.retain)
        throw alreadyCompletedException;
      let finalArgs = (options.getArgs ? options.getArgs(call2, this.getState(call2.storyId)) : call2.args).map((arg) => typeof arg != "function" || isClass(arg) || Object.keys(arg).length ? arg : (...args) => {
        let { cursor, ancestors } = this.getState(call2.storyId);
        this.setState(call2.storyId, { cursor: 0, ancestors: [...ancestors, call2.id] });
        let restore = () => this.setState(call2.storyId, { cursor, ancestors }), willRestore = !1;
        try {
          let res = arg(...args);
          return res instanceof Promise ? (willRestore = !0, res.finally(restore)) : res;
        } finally {
          willRestore || restore();
        }
      }), result = fn3.apply(object, finalArgs);
      return result && ["object", "function", "symbol"].includes(typeof result) && this.setState(call2.storyId, (state3) => ({
        callRefsByResult: new Map([
          ...Array.from(state3.callRefsByResult.entries()),
          [result, { __callId__: call2.id, retain: call2.retain }]
        ])
      })), this.update({
        ...info,
        status: result instanceof Promise ? "active" /* ACTIVE */ : "done" /* DONE */
      }), result instanceof Promise ? result.then((value) => (this.update({ ...info, status: "done" /* DONE */ }), value), handleException) : result;
    } catch (e2) {
      return handleException(e2);
    }
  }
  // Sends the call info to the manager and synchronizes the log.
  update(call2) {
    this.channel?.emit(EVENTS.CALL, call2), this.setState(call2.storyId, ({ calls }) => {
      let callsById = calls.concat(call2).reduce((a2, c2) => Object.assign(a2, { [c2.id]: c2 }), {});
      return {
        // Calls are sorted to ensure parent calls always come before calls in their callback.
        calls: Object.values(callsById).sort(
          (a2, b2) => a2.id.localeCompare(b2.id, void 0, { numeric: !0 })
        )
      };
    }), this.sync(call2.storyId);
  }
  // Builds a log of interceptable calls and control states and sends it to the manager.
  // Uses a 0ms debounce because this might get called many times in one tick.
  sync(storyId) {
    let synchronize = () => {
      let { isLocked, isPlaying } = this.getState(storyId), logItems = this.getLog(storyId), pausedAt = logItems.filter(({ ancestors }) => !ancestors.length).find((item) => item.status === "waiting" /* WAITING */)?.callId, hasActive = logItems.some((item) => item.status === "active" /* ACTIVE */);
      if (this.detached || isLocked || hasActive || logItems.length === 0) {
        let payload2 = { controlStates: {
          detached: this.detached,
          start: !1,
          back: !1,
          goto: !1,
          next: !1,
          end: !1
        }, logItems };
        this.channel?.emit(EVENTS.SYNC, payload2);
        return;
      }
      let hasPrevious = logItems.some(
        (item) => item.status === "done" /* DONE */ || item.status === "error" /* ERROR */
      ), payload = { controlStates: {
        detached: this.detached,
        start: hasPrevious,
        back: hasPrevious,
        goto: !0,
        next: isPlaying,
        end: isPlaying
      }, logItems, pausedAt };
      this.channel?.emit(EVENTS.SYNC, payload);
    };
    this.setState(storyId, ({ syncTimeout }) => (clearTimeout(syncTimeout), { syncTimeout: setTimeout(synchronize, 0) }));
  }
};
function instrument(obj, options = {}) {
  try {
    let forceInstrument = !1, skipInstrument = !1;
    return scope.window?.location?.search?.includes("instrument=true") ? forceInstrument = !0 : scope.window?.location?.search?.includes("instrument=false") && (skipInstrument = !0), scope.window?.parent === scope.window && !forceInstrument || skipInstrument ? obj : (scope.window && !scope.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__ && (scope.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__ = new Instrumenter()), (scope.window?.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__).instrument(obj, options));
  } catch (e2) {
    return once.warn(e2), obj;
  }
}
function getPropertyDescriptor(obj, propName) {
  let target = obj;
  for (; target != null; ) {
    let descriptor = Object.getOwnPropertyDescriptor(target, propName);
    if (descriptor)
      return descriptor;
    target = Object.getPrototypeOf(target);
  }
}
function isClass(obj) {
  if (typeof obj != "function")
    return !1;
  let descriptor = Object.getOwnPropertyDescriptor(obj, "prototype");
  return descriptor ? !descriptor.writable : !1;
}

// ../node_modules/chai/index.js
var __defProp3 = Object.defineProperty, __name = (target, value) => __defProp3(target, "name", { value, configurable: !0 }), __export2 = (target, all) => {
  for (var name in all)
    __defProp3(target, name, { get: all[name], enumerable: !0 });
}, utils_exports = {};
__export2(utils_exports, {
  addChainableMethod: () => addChainableMethod,
  addLengthGuard: () => addLengthGuard,
  addMethod: () => addMethod,
  addProperty: () => addProperty,
  checkError: () => check_error_exports,
  compareByInspect: () => compareByInspect,
  eql: () => deep_eql_default,
  expectTypes: () => expectTypes,
  flag: () => flag,
  getActual: () => getActual,
  getMessage: () => getMessage2,
  getName: () => getName,
  getOperator: () => getOperator,
  getOwnEnumerableProperties: () => getOwnEnumerableProperties,
  getOwnEnumerablePropertySymbols: () => getOwnEnumerablePropertySymbols,
  getPathInfo: () => getPathInfo,
  hasProperty: () => hasProperty,
  inspect: () => inspect22,
  isNaN: () => isNaN22,
  isNumeric: () => isNumeric,
  isProxyEnabled: () => isProxyEnabled,
  isRegExp: () => isRegExp2,
  objDisplay: () => objDisplay,
  overwriteChainableMethod: () => overwriteChainableMethod,
  overwriteMethod: () => overwriteMethod,
  overwriteProperty: () => overwriteProperty,
  proxify: () => proxify,
  test: () => test2,
  transferFlags: () => transferFlags,
  type: () => type
});
var check_error_exports = {};
__export2(check_error_exports, {
  compatibleConstructor: () => compatibleConstructor,
  compatibleInstance: () => compatibleInstance,
  compatibleMessage: () => compatibleMessage,
  getConstructorName: () => getConstructorName2,
  getMessage: () => getMessage
});
function isErrorInstance(obj) {
  return obj instanceof Error || Object.prototype.toString.call(obj) === "[object Error]";
}
__name(isErrorInstance, "isErrorInstance");
function isRegExp(obj) {
  return Object.prototype.toString.call(obj) === "[object RegExp]";
}
__name(isRegExp, "isRegExp");
function compatibleInstance(thrown, errorLike) {
  return isErrorInstance(errorLike) && thrown === errorLike;
}
__name(compatibleInstance, "compatibleInstance");
function compatibleConstructor(thrown, errorLike) {
  return isErrorInstance(errorLike) ? thrown.constructor === errorLike.constructor || thrown instanceof errorLike.constructor : (typeof errorLike == "object" || typeof errorLike == "function") && errorLike.prototype ? thrown.constructor === errorLike || thrown instanceof errorLike : !1;
}
__name(compatibleConstructor, "compatibleConstructor");
function compatibleMessage(thrown, errMatcher) {
  let comparisonString = typeof thrown == "string" ? thrown : thrown.message;
  return isRegExp(errMatcher) ? errMatcher.test(comparisonString) : typeof errMatcher == "string" ? comparisonString.indexOf(errMatcher) !== -1 : !1;
}
__name(compatibleMessage, "compatibleMessage");
function getConstructorName2(errorLike) {
  let constructorName = errorLike;
  return isErrorInstance(errorLike) ? constructorName = errorLike.constructor.name : typeof errorLike == "function" && (constructorName = errorLike.name, constructorName === "" && (constructorName = new errorLike().name || constructorName)), constructorName;
}
__name(getConstructorName2, "getConstructorName");
function getMessage(errorLike) {
  let msg = "";
  return errorLike && errorLike.message ? msg = errorLike.message : typeof errorLike == "string" && (msg = errorLike), msg;
}
__name(getMessage, "getMessage");
function flag(obj, key, value) {
  let flags = obj.__flags || (obj.__flags = /* @__PURE__ */ Object.create(null));
  if (arguments.length === 3)
    flags[key] = value;
  else
    return flags[key];
}
__name(flag, "flag");
function test2(obj, args) {
  let negate = flag(obj, "negate"), expr = args[0];
  return negate ? !expr : expr;
}
__name(test2, "test");
function type(obj) {
  if (typeof obj > "u")
    return "undefined";
  if (obj === null)
    return "null";
  let stringTag2 = obj[Symbol.toStringTag];
  return typeof stringTag2 == "string" ? stringTag2 : Object.prototype.toString.call(obj).slice(8, -1);
}
__name(type, "type");
var canElideFrames = "captureStackTrace" in Error, _a, AssertionError = (_a = class extends Error {
  message;
  get name() {
    return "AssertionError";
  }
  get ok() {
    return !1;
  }
  constructor(message = "Unspecified AssertionError", props, ssf) {
    super(message), this.message = message, canElideFrames && Error.captureStackTrace(this, ssf || _a);
    for (let key in props)
      key in this || (this[key] = props[key]);
  }
  toJSON(stack) {
    return {
      ...this,
      name: this.name,
      message: this.message,
      ok: !1,
      stack: stack !== !1 ? this.stack : void 0
    };
  }
}, __name(_a, "AssertionError"), _a);
function expectTypes(obj, types) {
  let flagMsg = flag(obj, "message"), ssfi = flag(obj, "ssfi");
  flagMsg = flagMsg ? flagMsg + ": " : "", obj = flag(obj, "object"), types = types.map(function(t2) {
    return t2.toLowerCase();
  }), types.sort();
  let str2 = types.map(function(t2, index2) {
    let art = ~["a", "e", "i", "o", "u"].indexOf(t2.charAt(0)) ? "an" : "a";
    return (types.length > 1 && index2 === types.length - 1 ? "or " : "") + art + " " + t2;
  }).join(", "), objType = type(obj).toLowerCase();
  if (!types.some(function(expected) {
    return objType === expected;
  }))
    throw new AssertionError(
      flagMsg + "object tested must be " + str2 + ", but " + objType + " given",
      void 0,
      ssfi
    );
}
__name(expectTypes, "expectTypes");
function getActual(obj, args) {
  return args.length > 4 ? args[4] : obj._obj;
}
__name(getActual, "getActual");
var ansiColors2 = {
  bold: ["1", "22"],
  dim: ["2", "22"],
  italic: ["3", "23"],
  underline: ["4", "24"],
  // 5 & 6 are blinking
  inverse: ["7", "27"],
  hidden: ["8", "28"],
  strike: ["9", "29"],
  // 10-20 are fonts
  // 21-29 are resets for 1-9
  black: ["30", "39"],
  red: ["31", "39"],
  green: ["32", "39"],
  yellow: ["33", "39"],
  blue: ["34", "39"],
  magenta: ["35", "39"],
  cyan: ["36", "39"],
  white: ["37", "39"],
  brightblack: ["30;1", "39"],
  brightred: ["31;1", "39"],
  brightgreen: ["32;1", "39"],
  brightyellow: ["33;1", "39"],
  brightblue: ["34;1", "39"],
  brightmagenta: ["35;1", "39"],
  brightcyan: ["36;1", "39"],
  brightwhite: ["37;1", "39"],
  grey: ["90", "39"]
}, styles2 = {
  special: "cyan",
  number: "yellow",
  bigint: "yellow",
  boolean: "yellow",
  undefined: "grey",
  null: "bold",
  string: "green",
  symbol: "green",
  date: "magenta",
  regexp: "red"
}, truncator2 = "\u2026";
function colorise2(value, styleType) {
  let color = ansiColors2[styles2[styleType]] || ansiColors2[styleType] || "";
  return color ? `\x1B[${color[0]}m${String(value)}\x1B[${color[1]}m` : String(value);
}
__name(colorise2, "colorise");
function normaliseOptions2({
  showHidden = !1,
  depth = 2,
  colors: colors3 = !1,
  customInspect = !0,
  showProxy = !1,
  maxArrayLength = 1 / 0,
  breakLength = 1 / 0,
  seen = [],
  // eslint-disable-next-line no-shadow
  truncate: truncate22 = 1 / 0,
  stylize = String
} = {}, inspect32) {
  let options = {
    showHidden: !!showHidden,
    depth: Number(depth),
    colors: !!colors3,
    customInspect: !!customInspect,
    showProxy: !!showProxy,
    maxArrayLength: Number(maxArrayLength),
    breakLength: Number(breakLength),
    truncate: Number(truncate22),
    seen,
    inspect: inspect32,
    stylize
  };
  return options.colors && (options.stylize = colorise2), options;
}
__name(normaliseOptions2, "normaliseOptions");
function isHighSurrogate2(char) {
  return char >= "\uD800" && char <= "\uDBFF";
}
__name(isHighSurrogate2, "isHighSurrogate");
function truncate2(string, length, tail = truncator2) {
  string = String(string);
  let tailLength = tail.length, stringLength = string.length;
  if (tailLength > length && stringLength > tailLength)
    return tail;
  if (stringLength > length && stringLength > tailLength) {
    let end = length - tailLength;
    return end > 0 && isHighSurrogate2(string[end - 1]) && (end = end - 1), `${string.slice(0, end)}${tail}`;
  }
  return string;
}
__name(truncate2, "truncate");
function inspectList2(list, options, inspectItem, separator = ", ") {
  inspectItem = inspectItem || options.inspect;
  let size = list.length;
  if (size === 0)
    return "";
  let originalLength = options.truncate, output = "", peek = "", truncated = "";
  for (let i2 = 0; i2 < size; i2 += 1) {
    let last = i2 + 1 === list.length, secondToLast = i2 + 2 === list.length;
    truncated = `${truncator2}(${list.length - i2})`;
    let value = list[i2];
    options.truncate = originalLength - output.length - (last ? 0 : separator.length);
    let string = peek || inspectItem(value, options) + (last ? "" : separator), nextLength = output.length + string.length, truncatedLength = nextLength + truncated.length;
    if (last && nextLength > originalLength && output.length + truncated.length <= originalLength || !last && !secondToLast && truncatedLength > originalLength || (peek = last ? "" : inspectItem(list[i2 + 1], options) + (secondToLast ? "" : separator), !last && secondToLast && truncatedLength > originalLength && nextLength + peek.length > originalLength))
      break;
    if (output += string, !last && !secondToLast && nextLength + peek.length >= originalLength) {
      truncated = `${truncator2}(${list.length - i2 - 1})`;
      break;
    }
    truncated = "";
  }
  return `${output}${truncated}`;
}
__name(inspectList2, "inspectList");
function quoteComplexKey2(key) {
  return key.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/) ? key : JSON.stringify(key).replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
}
__name(quoteComplexKey2, "quoteComplexKey");
function inspectProperty2([key, value], options) {
  return options.truncate -= 2, typeof key == "string" ? key = quoteComplexKey2(key) : typeof key != "number" && (key = `[${options.inspect(key, options)}]`), options.truncate -= key.length, value = options.inspect(value, options), `${key}: ${value}`;
}
__name(inspectProperty2, "inspectProperty");
function inspectArray2(array, options) {
  let nonIndexProperties = Object.keys(array).slice(array.length);
  if (!array.length && !nonIndexProperties.length)
    return "[]";
  options.truncate -= 4;
  let listContents = inspectList2(array, options);
  options.truncate -= listContents.length;
  let propertyContents = "";
  return nonIndexProperties.length && (propertyContents = inspectList2(nonIndexProperties.map((key) => [key, array[key]]), options, inspectProperty2)), `[ ${listContents}${propertyContents ? `, ${propertyContents}` : ""} ]`;
}
__name(inspectArray2, "inspectArray");
var getArrayName2 = __name((array) => typeof Buffer == "function" && array instanceof Buffer ? "Buffer" : array[Symbol.toStringTag] ? array[Symbol.toStringTag] : array.constructor.name, "getArrayName");
function inspectTypedArray2(array, options) {
  let name = getArrayName2(array);
  options.truncate -= name.length + 4;
  let nonIndexProperties = Object.keys(array).slice(array.length);
  if (!array.length && !nonIndexProperties.length)
    return `${name}[]`;
  let output = "";
  for (let i2 = 0; i2 < array.length; i2++) {
    let string = `${options.stylize(truncate2(array[i2], options.truncate), "number")}${i2 === array.length - 1 ? "" : ", "}`;
    if (options.truncate -= string.length, array[i2] !== array.length && options.truncate <= 3) {
      output += `${truncator2}(${array.length - array[i2] + 1})`;
      break;
    }
    output += string;
  }
  let propertyContents = "";
  return nonIndexProperties.length && (propertyContents = inspectList2(nonIndexProperties.map((key) => [key, array[key]]), options, inspectProperty2)), `${name}[ ${output}${propertyContents ? `, ${propertyContents}` : ""} ]`;
}
__name(inspectTypedArray2, "inspectTypedArray");
function inspectDate2(dateObject, options) {
  let stringRepresentation = dateObject.toJSON();
  if (stringRepresentation === null)
    return "Invalid Date";
  let split = stringRepresentation.split("T"), date = split[0];
  return options.stylize(`${date}T${truncate2(split[1], options.truncate - date.length - 1)}`, "date");
}
__name(inspectDate2, "inspectDate");
function inspectFunction2(func, options) {
  let functionType = func[Symbol.toStringTag] || "Function", name = func.name;
  return name ? options.stylize(`[${functionType} ${truncate2(name, options.truncate - 11)}]`, "special") : options.stylize(`[${functionType}]`, "special");
}
__name(inspectFunction2, "inspectFunction");
function inspectMapEntry2([key, value], options) {
  return options.truncate -= 4, key = options.inspect(key, options), options.truncate -= key.length, value = options.inspect(value, options), `${key} => ${value}`;
}
__name(inspectMapEntry2, "inspectMapEntry");
function mapToEntries2(map2) {
  let entries = [];
  return map2.forEach((value, key) => {
    entries.push([key, value]);
  }), entries;
}
__name(mapToEntries2, "mapToEntries");
function inspectMap2(map2, options) {
  return map2.size === 0 ? "Map{}" : (options.truncate -= 7, `Map{ ${inspectList2(mapToEntries2(map2), options, inspectMapEntry2)} }`);
}
__name(inspectMap2, "inspectMap");
var isNaN3 = Number.isNaN || ((i2) => i2 !== i2);
function inspectNumber2(number, options) {
  return isNaN3(number) ? options.stylize("NaN", "number") : number === 1 / 0 ? options.stylize("Infinity", "number") : number === -1 / 0 ? options.stylize("-Infinity", "number") : number === 0 ? options.stylize(1 / number === 1 / 0 ? "+0" : "-0", "number") : options.stylize(truncate2(String(number), options.truncate), "number");
}
__name(inspectNumber2, "inspectNumber");
function inspectBigInt2(number, options) {
  let nums = truncate2(number.toString(), options.truncate - 1);
  return nums !== truncator2 && (nums += "n"), options.stylize(nums, "bigint");
}
__name(inspectBigInt2, "inspectBigInt");
function inspectRegExp2(value, options) {
  let flags = value.toString().split("/")[2], sourceLength = options.truncate - (2 + flags.length), source = value.source;
  return options.stylize(`/${truncate2(source, sourceLength)}/${flags}`, "regexp");
}
__name(inspectRegExp2, "inspectRegExp");
function arrayFromSet2(set2) {
  let values = [];
  return set2.forEach((value) => {
    values.push(value);
  }), values;
}
__name(arrayFromSet2, "arrayFromSet");
function inspectSet2(set2, options) {
  return set2.size === 0 ? "Set{}" : (options.truncate -= 7, `Set{ ${inspectList2(arrayFromSet2(set2), options)} }`);
}
__name(inspectSet2, "inspectSet");
var stringEscapeChars2 = new RegExp("['\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]", "g"), escapeCharacters2 = {
  "\b": "\\b",
  "	": "\\t",
  "\n": "\\n",
  "\f": "\\f",
  "\r": "\\r",
  "'": "\\'",
  "\\": "\\\\"
}, hex2 = 16, unicodeLength2 = 4;
function escape2(char) {
  return escapeCharacters2[char] || `\\u${`0000${char.charCodeAt(0).toString(hex2)}`.slice(-unicodeLength2)}`;
}
__name(escape2, "escape");
function inspectString2(string, options) {
  return stringEscapeChars2.test(string) && (string = string.replace(stringEscapeChars2, escape2)), options.stylize(`'${truncate2(string, options.truncate - 2)}'`, "string");
}
__name(inspectString2, "inspectString");
function inspectSymbol2(value) {
  return "description" in Symbol.prototype ? value.description ? `Symbol(${value.description})` : "Symbol()" : value.toString();
}
__name(inspectSymbol2, "inspectSymbol");
var getPromiseValue2 = __name(() => "Promise{\u2026}", "getPromiseValue"), promise_default2 = getPromiseValue2;
function inspectObject3(object, options) {
  let properties = Object.getOwnPropertyNames(object), symbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(object) : [];
  if (properties.length === 0 && symbols.length === 0)
    return "{}";
  if (options.truncate -= 4, options.seen = options.seen || [], options.seen.includes(object))
    return "[Circular]";
  options.seen.push(object);
  let propertyContents = inspectList2(properties.map((key) => [key, object[key]]), options, inspectProperty2), symbolContents = inspectList2(symbols.map((key) => [key, object[key]]), options, inspectProperty2);
  options.seen.pop();
  let sep = "";
  return propertyContents && symbolContents && (sep = ", "), `{ ${propertyContents}${sep}${symbolContents} }`;
}
__name(inspectObject3, "inspectObject");
var toStringTag2 = typeof Symbol < "u" && Symbol.toStringTag ? Symbol.toStringTag : !1;
function inspectClass2(value, options) {
  let name = "";
  return toStringTag2 && toStringTag2 in value && (name = value[toStringTag2]), name = name || value.constructor.name, (!name || name === "_class") && (name = "<Anonymous Class>"), options.truncate -= name.length, `${name}${inspectObject3(value, options)}`;
}
__name(inspectClass2, "inspectClass");
function inspectArguments2(args, options) {
  return args.length === 0 ? "Arguments[]" : (options.truncate -= 13, `Arguments[ ${inspectList2(args, options)} ]`);
}
__name(inspectArguments2, "inspectArguments");
var errorKeys2 = [
  "stack",
  "line",
  "column",
  "name",
  "message",
  "fileName",
  "lineNumber",
  "columnNumber",
  "number",
  "description",
  "cause"
];
function inspectObject22(error, options) {
  let properties = Object.getOwnPropertyNames(error).filter((key) => errorKeys2.indexOf(key) === -1), name = error.name;
  options.truncate -= name.length;
  let message = "";
  if (typeof error.message == "string" ? message = truncate2(error.message, options.truncate) : properties.unshift("message"), message = message ? `: ${message}` : "", options.truncate -= message.length + 5, options.seen = options.seen || [], options.seen.includes(error))
    return "[Circular]";
  options.seen.push(error);
  let propertyContents = inspectList2(properties.map((key) => [key, error[key]]), options, inspectProperty2);
  return `${name}${message}${propertyContents ? ` { ${propertyContents} }` : ""}`;
}
__name(inspectObject22, "inspectObject");
function inspectAttribute2([key, value], options) {
  return options.truncate -= 3, value ? `${options.stylize(String(key), "yellow")}=${options.stylize(`"${value}"`, "string")}` : `${options.stylize(String(key), "yellow")}`;
}
__name(inspectAttribute2, "inspectAttribute");
function inspectNodeCollection2(collection, options) {
  return inspectList2(collection, options, inspectNode2, `
`);
}
__name(inspectNodeCollection2, "inspectNodeCollection");
function inspectNode2(node, options) {
  switch (node.nodeType) {
    case 1:
      return inspectHTML2(node, options);
    case 3:
      return options.inspect(node.data, options);
    default:
      return options.inspect(node, options);
  }
}
__name(inspectNode2, "inspectNode");
function inspectHTML2(element, options) {
  let properties = element.getAttributeNames(), name = element.tagName.toLowerCase(), head = options.stylize(`<${name}`, "special"), headClose = options.stylize(">", "special"), tail = options.stylize(`</${name}>`, "special");
  options.truncate -= name.length * 2 + 5;
  let propertyContents = "";
  properties.length > 0 && (propertyContents += " ", propertyContents += inspectList2(properties.map((key) => [key, element.getAttribute(key)]), options, inspectAttribute2, " ")), options.truncate -= propertyContents.length;
  let truncate22 = options.truncate, children = inspectNodeCollection2(element.children, options);
  return children && children.length > truncate22 && (children = `${truncator2}(${element.children.length})`), `${head}${propertyContents}${headClose}${children}${tail}`;
}
__name(inspectHTML2, "inspectHTML");
var symbolsSupported2 = typeof Symbol == "function" && typeof Symbol.for == "function", chaiInspect2 = symbolsSupported2 ? Symbol.for("chai/inspect") : "@@chai/inspect", nodeInspect2 = Symbol.for("nodejs.util.inspect.custom"), constructorMap2 = /* @__PURE__ */ new WeakMap(), stringTagMap2 = {}, baseTypesMap2 = {
  undefined: __name((value, options) => options.stylize("undefined", "undefined"), "undefined"),
  null: __name((value, options) => options.stylize("null", "null"), "null"),
  boolean: __name((value, options) => options.stylize(String(value), "boolean"), "boolean"),
  Boolean: __name((value, options) => options.stylize(String(value), "boolean"), "Boolean"),
  number: inspectNumber2,
  Number: inspectNumber2,
  bigint: inspectBigInt2,
  BigInt: inspectBigInt2,
  string: inspectString2,
  String: inspectString2,
  function: inspectFunction2,
  Function: inspectFunction2,
  symbol: inspectSymbol2,
  // A Symbol polyfill will return `Symbol` not `symbol` from typedetect
  Symbol: inspectSymbol2,
  Array: inspectArray2,
  Date: inspectDate2,
  Map: inspectMap2,
  Set: inspectSet2,
  RegExp: inspectRegExp2,
  Promise: promise_default2,
  // WeakSet, WeakMap are totally opaque to us
  WeakSet: __name((value, options) => options.stylize("WeakSet{\u2026}", "special"), "WeakSet"),
  WeakMap: __name((value, options) => options.stylize("WeakMap{\u2026}", "special"), "WeakMap"),
  Arguments: inspectArguments2,
  Int8Array: inspectTypedArray2,
  Uint8Array: inspectTypedArray2,
  Uint8ClampedArray: inspectTypedArray2,
  Int16Array: inspectTypedArray2,
  Uint16Array: inspectTypedArray2,
  Int32Array: inspectTypedArray2,
  Uint32Array: inspectTypedArray2,
  Float32Array: inspectTypedArray2,
  Float64Array: inspectTypedArray2,
  Generator: __name(() => "", "Generator"),
  DataView: __name(() => "", "DataView"),
  ArrayBuffer: __name(() => "", "ArrayBuffer"),
  Error: inspectObject22,
  HTMLCollection: inspectNodeCollection2,
  NodeList: inspectNodeCollection2
}, inspectCustom2 = __name((value, options, type32) => chaiInspect2 in value && typeof value[chaiInspect2] == "function" ? value[chaiInspect2](options) : nodeInspect2 in value && typeof value[nodeInspect2] == "function" ? value[nodeInspect2](options.depth, options) : "inspect" in value && typeof value.inspect == "function" ? value.inspect(options.depth, options) : "constructor" in value && constructorMap2.has(value.constructor) ? constructorMap2.get(value.constructor)(value, options) : stringTagMap2[type32] ? stringTagMap2[type32](value, options) : "", "inspectCustom"), toString4 = Object.prototype.toString;
function inspect3(value, opts = {}) {
  let options = normaliseOptions2(opts, inspect3), { customInspect } = options, type32 = value === null ? "null" : typeof value;
  if (type32 === "object" && (type32 = toString4.call(value).slice(8, -1)), type32 in baseTypesMap2)
    return baseTypesMap2[type32](value, options);
  if (customInspect && value) {
    let output = inspectCustom2(value, options, type32);
    if (output)
      return typeof output == "string" ? output : inspect3(output, options);
  }
  let proto = value ? Object.getPrototypeOf(value) : !1;
  return proto === Object.prototype || proto === null ? inspectObject3(value, options) : value && typeof HTMLElement == "function" && value instanceof HTMLElement ? inspectHTML2(value, options) : "constructor" in value ? value.constructor !== Object ? inspectClass2(value, options) : inspectObject3(value, options) : value === Object(value) ? inspectObject3(value, options) : options.stylize(String(value), type32);
}
__name(inspect3, "inspect");
var config = {
  /**
   * ### config.includeStack
   *
   * User configurable property, influences whether stack trace
   * is included in Assertion error message. Default of false
   * suppresses stack trace in the error message.
   *
   *     chai.config.includeStack = true;  // enable stack on error
   *
   * @param {boolean}
   * @public
   */
  includeStack: !1,
  /**
   * ### config.showDiff
   *
   * User configurable property, influences whether or not
   * the `showDiff` flag should be included in the thrown
   * AssertionErrors. `false` will always be `false`; `true`
   * will be true when the assertion has requested a diff
   * be shown.
   *
   * @param {boolean}
   * @public
   */
  showDiff: !0,
  /**
   * ### config.truncateThreshold
   *
   * User configurable property, sets length threshold for actual and
   * expected values in assertion errors. If this threshold is exceeded, for
   * example for large data structures, the value is replaced with something
   * like `[ Array(3) ]` or `{ Object (prop1, prop2) }`.
   *
   * Set it to zero if you want to disable truncating altogether.
   *
   * This is especially userful when doing assertions on arrays: having this
   * set to a reasonable large value makes the failure messages readily
   * inspectable.
   *
   *     chai.config.truncateThreshold = 0;  // disable truncating
   *
   * @param {number}
   * @public
   */
  truncateThreshold: 40,
  /**
   * ### config.useProxy
   *
   * User configurable property, defines if chai will use a Proxy to throw
   * an error when a non-existent property is read, which protects users
   * from typos when using property-based assertions.
   *
   * Set it to false if you want to disable this feature.
   *
   *     chai.config.useProxy = false;  // disable use of Proxy
   *
   * This feature is automatically disabled regardless of this config value
   * in environments that don't support proxies.
   *
   * @param {boolean}
   * @public
   */
  useProxy: !0,
  /**
   * ### config.proxyExcludedKeys
   *
   * User configurable property, defines which properties should be ignored
   * instead of throwing an error if they do not exist on the assertion.
   * This is only applied if the environment Chai is running in supports proxies and
   * if the `useProxy` configuration setting is enabled.
   * By default, `then` and `inspect` will not throw an error if they do not exist on the
   * assertion object because the `.inspect` property is read by `util.inspect` (for example, when
   * using `console.log` on the assertion object) and `.then` is necessary for promise type-checking.
   *
   *     // By default these keys will not throw an error if they do not exist on the assertion object
   *     chai.config.proxyExcludedKeys = ['then', 'inspect'];
   *
   * @param {Array}
   * @public
   */
  proxyExcludedKeys: ["then", "catch", "inspect", "toJSON"],
  /**
   * ### config.deepEqual
   *
   * User configurable property, defines which a custom function to use for deepEqual
   * comparisons.
   * By default, the function used is the one from the `deep-eql` package without custom comparator.
   *
   *     // use a custom comparator
   *     chai.config.deepEqual = (expected, actual) => {
   *         return chai.util.eql(expected, actual, {
   *             comparator: (expected, actual) => {
   *                 // for non number comparison, use the default behavior
   *                 if(typeof expected !== 'number') return null;
   *                 // allow a difference of 10 between compared numbers
   *                 return typeof actual === 'number' && Math.abs(actual - expected) < 10
   *             }
   *         })
   *     };
   *
   * @param {Function}
   * @public
   */
  deepEqual: null
};
function inspect22(obj, showHidden, depth, colors3) {
  let options = {
    colors: colors3,
    depth: typeof depth > "u" ? 2 : depth,
    showHidden,
    truncate: config.truncateThreshold ? config.truncateThreshold : 1 / 0
  };
  return inspect3(obj, options);
}
__name(inspect22, "inspect");
function objDisplay(obj) {
  let str2 = inspect22(obj), type32 = Object.prototype.toString.call(obj);
  if (config.truncateThreshold && str2.length >= config.truncateThreshold) {
    if (type32 === "[object Function]")
      return !obj.name || obj.name === "" ? "[Function]" : "[Function: " + obj.name + "]";
    if (type32 === "[object Array]")
      return "[ Array(" + obj.length + ") ]";
    if (type32 === "[object Object]") {
      let keys2 = Object.keys(obj);
      return "{ Object (" + (keys2.length > 2 ? keys2.splice(0, 2).join(", ") + ", ..." : keys2.join(", ")) + ") }";
    } else
      return str2;
  } else
    return str2;
}
__name(objDisplay, "objDisplay");
function getMessage2(obj, args) {
  let negate = flag(obj, "negate"), val = flag(obj, "object"), expected = args[3], actual = getActual(obj, args), msg = negate ? args[2] : args[1], flagMsg = flag(obj, "message");
  return typeof msg == "function" && (msg = msg()), msg = msg || "", msg = msg.replace(/#\{this\}/g, function() {
    return objDisplay(val);
  }).replace(/#\{act\}/g, function() {
    return objDisplay(actual);
  }).replace(/#\{exp\}/g, function() {
    return objDisplay(expected);
  }), flagMsg ? flagMsg + ": " + msg : msg;
}
__name(getMessage2, "getMessage");
function transferFlags(assertion, object, includeAll) {
  let flags = assertion.__flags || (assertion.__flags = /* @__PURE__ */ Object.create(null));
  object.__flags || (object.__flags = /* @__PURE__ */ Object.create(null)), includeAll = arguments.length === 3 ? includeAll : !0;
  for (let flag3 in flags)
    (includeAll || flag3 !== "object" && flag3 !== "ssfi" && flag3 !== "lockSsfi" && flag3 != "message") && (object.__flags[flag3] = flags[flag3]);
}
__name(transferFlags, "transferFlags");
function type2(obj) {
  if (typeof obj > "u")
    return "undefined";
  if (obj === null)
    return "null";
  let stringTag2 = obj[Symbol.toStringTag];
  return typeof stringTag2 == "string" ? stringTag2 : Object.prototype.toString.call(obj).slice(8, -1);
}
__name(type2, "type");
function FakeMap() {
  this._key = "chai/deep-eql__" + Math.random() + Date.now();
}
__name(FakeMap, "FakeMap");
FakeMap.prototype = {
  get: __name(function(key) {
    return key[this._key];
  }, "get"),
  set: __name(function(key, value) {
    Object.isExtensible(key) && Object.defineProperty(key, this._key, {
      value,
      configurable: !0
    });
  }, "set")
};
var MemoizeMap = typeof WeakMap == "function" ? WeakMap : FakeMap;
function memoizeCompare(leftHandOperand, rightHandOperand, memoizeMap) {
  if (!memoizeMap || isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand))
    return null;
  var leftHandMap = memoizeMap.get(leftHandOperand);
  if (leftHandMap) {
    var result = leftHandMap.get(rightHandOperand);
    if (typeof result == "boolean")
      return result;
  }
  return null;
}
__name(memoizeCompare, "memoizeCompare");
function memoizeSet(leftHandOperand, rightHandOperand, memoizeMap, result) {
  if (!(!memoizeMap || isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand))) {
    var leftHandMap = memoizeMap.get(leftHandOperand);
    leftHandMap ? leftHandMap.set(rightHandOperand, result) : (leftHandMap = new MemoizeMap(), leftHandMap.set(rightHandOperand, result), memoizeMap.set(leftHandOperand, leftHandMap));
  }
}
__name(memoizeSet, "memoizeSet");
var deep_eql_default = deepEqual;
function deepEqual(leftHandOperand, rightHandOperand, options) {
  if (options && options.comparator)
    return extensiveDeepEqual(leftHandOperand, rightHandOperand, options);
  var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);
  return simpleResult !== null ? simpleResult : extensiveDeepEqual(leftHandOperand, rightHandOperand, options);
}
__name(deepEqual, "deepEqual");
function simpleEqual(leftHandOperand, rightHandOperand) {
  return leftHandOperand === rightHandOperand ? leftHandOperand !== 0 || 1 / leftHandOperand === 1 / rightHandOperand : leftHandOperand !== leftHandOperand && // eslint-disable-line no-self-compare
  rightHandOperand !== rightHandOperand ? !0 : isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand) ? !1 : null;
}
__name(simpleEqual, "simpleEqual");
function extensiveDeepEqual(leftHandOperand, rightHandOperand, options) {
  options = options || {}, options.memoize = options.memoize === !1 ? !1 : options.memoize || new MemoizeMap();
  var comparator = options && options.comparator, memoizeResultLeft = memoizeCompare(leftHandOperand, rightHandOperand, options.memoize);
  if (memoizeResultLeft !== null)
    return memoizeResultLeft;
  var memoizeResultRight = memoizeCompare(rightHandOperand, leftHandOperand, options.memoize);
  if (memoizeResultRight !== null)
    return memoizeResultRight;
  if (comparator) {
    var comparatorResult = comparator(leftHandOperand, rightHandOperand);
    if (comparatorResult === !1 || comparatorResult === !0)
      return memoizeSet(leftHandOperand, rightHandOperand, options.memoize, comparatorResult), comparatorResult;
    var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);
    if (simpleResult !== null)
      return simpleResult;
  }
  var leftHandType = type2(leftHandOperand);
  if (leftHandType !== type2(rightHandOperand))
    return memoizeSet(leftHandOperand, rightHandOperand, options.memoize, !1), !1;
  memoizeSet(leftHandOperand, rightHandOperand, options.memoize, !0);
  var result = extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options);
  return memoizeSet(leftHandOperand, rightHandOperand, options.memoize, result), result;
}
__name(extensiveDeepEqual, "extensiveDeepEqual");
function extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options) {
  switch (leftHandType) {
    case "String":
    case "Number":
    case "Boolean":
    case "Date":
      return deepEqual(leftHandOperand.valueOf(), rightHandOperand.valueOf());
    case "Promise":
    case "Symbol":
    case "function":
    case "WeakMap":
    case "WeakSet":
      return leftHandOperand === rightHandOperand;
    case "Error":
      return keysEqual(leftHandOperand, rightHandOperand, ["name", "message", "code"], options);
    case "Arguments":
    case "Int8Array":
    case "Uint8Array":
    case "Uint8ClampedArray":
    case "Int16Array":
    case "Uint16Array":
    case "Int32Array":
    case "Uint32Array":
    case "Float32Array":
    case "Float64Array":
    case "Array":
      return iterableEqual(leftHandOperand, rightHandOperand, options);
    case "RegExp":
      return regexpEqual(leftHandOperand, rightHandOperand);
    case "Generator":
      return generatorEqual(leftHandOperand, rightHandOperand, options);
    case "DataView":
      return iterableEqual(new Uint8Array(leftHandOperand.buffer), new Uint8Array(rightHandOperand.buffer), options);
    case "ArrayBuffer":
      return iterableEqual(new Uint8Array(leftHandOperand), new Uint8Array(rightHandOperand), options);
    case "Set":
      return entriesEqual(leftHandOperand, rightHandOperand, options);
    case "Map":
      return entriesEqual(leftHandOperand, rightHandOperand, options);
    case "Temporal.PlainDate":
    case "Temporal.PlainTime":
    case "Temporal.PlainDateTime":
    case "Temporal.Instant":
    case "Temporal.ZonedDateTime":
    case "Temporal.PlainYearMonth":
    case "Temporal.PlainMonthDay":
      return leftHandOperand.equals(rightHandOperand);
    case "Temporal.Duration":
      return leftHandOperand.total("nanoseconds") === rightHandOperand.total("nanoseconds");
    case "Temporal.TimeZone":
    case "Temporal.Calendar":
      return leftHandOperand.toString() === rightHandOperand.toString();
    default:
      return objectEqual(leftHandOperand, rightHandOperand, options);
  }
}
__name(extensiveDeepEqualByType, "extensiveDeepEqualByType");
function regexpEqual(leftHandOperand, rightHandOperand) {
  return leftHandOperand.toString() === rightHandOperand.toString();
}
__name(regexpEqual, "regexpEqual");
function entriesEqual(leftHandOperand, rightHandOperand, options) {
  try {
    if (leftHandOperand.size !== rightHandOperand.size)
      return !1;
    if (leftHandOperand.size === 0)
      return !0;
  } catch {
    return !1;
  }
  var leftHandItems = [], rightHandItems = [];
  return leftHandOperand.forEach(__name(function(key, value) {
    leftHandItems.push([key, value]);
  }, "gatherEntries")), rightHandOperand.forEach(__name(function(key, value) {
    rightHandItems.push([key, value]);
  }, "gatherEntries")), iterableEqual(leftHandItems.sort(), rightHandItems.sort(), options);
}
__name(entriesEqual, "entriesEqual");
function iterableEqual(leftHandOperand, rightHandOperand, options) {
  var length = leftHandOperand.length;
  if (length !== rightHandOperand.length)
    return !1;
  if (length === 0)
    return !0;
  for (var index2 = -1; ++index2 < length; )
    if (deepEqual(leftHandOperand[index2], rightHandOperand[index2], options) === !1)
      return !1;
  return !0;
}
__name(iterableEqual, "iterableEqual");
function generatorEqual(leftHandOperand, rightHandOperand, options) {
  return iterableEqual(getGeneratorEntries(leftHandOperand), getGeneratorEntries(rightHandOperand), options);
}
__name(generatorEqual, "generatorEqual");
function hasIteratorFunction(target) {
  return typeof Symbol < "u" && typeof target == "object" && typeof Symbol.iterator < "u" && typeof target[Symbol.iterator] == "function";
}
__name(hasIteratorFunction, "hasIteratorFunction");
function getIteratorEntries(target) {
  if (hasIteratorFunction(target))
    try {
      return getGeneratorEntries(target[Symbol.iterator]());
    } catch {
      return [];
    }
  return [];
}
__name(getIteratorEntries, "getIteratorEntries");
function getGeneratorEntries(generator) {
  for (var generatorResult = generator.next(), accumulator = [generatorResult.value]; generatorResult.done === !1; )
    generatorResult = generator.next(), accumulator.push(generatorResult.value);
  return accumulator;
}
__name(getGeneratorEntries, "getGeneratorEntries");
function getEnumerableKeys(target) {
  var keys2 = [];
  for (var key in target)
    keys2.push(key);
  return keys2;
}
__name(getEnumerableKeys, "getEnumerableKeys");
function getEnumerableSymbols(target) {
  for (var keys2 = [], allKeys = Object.getOwnPropertySymbols(target), i2 = 0; i2 < allKeys.length; i2 += 1) {
    var key = allKeys[i2];
    Object.getOwnPropertyDescriptor(target, key).enumerable && keys2.push(key);
  }
  return keys2;
}
__name(getEnumerableSymbols, "getEnumerableSymbols");
function keysEqual(leftHandOperand, rightHandOperand, keys2, options) {
  var length = keys2.length;
  if (length === 0)
    return !0;
  for (var i2 = 0; i2 < length; i2 += 1)
    if (deepEqual(leftHandOperand[keys2[i2]], rightHandOperand[keys2[i2]], options) === !1)
      return !1;
  return !0;
}
__name(keysEqual, "keysEqual");
function objectEqual(leftHandOperand, rightHandOperand, options) {
  var leftHandKeys = getEnumerableKeys(leftHandOperand), rightHandKeys = getEnumerableKeys(rightHandOperand), leftHandSymbols = getEnumerableSymbols(leftHandOperand), rightHandSymbols = getEnumerableSymbols(rightHandOperand);
  if (leftHandKeys = leftHandKeys.concat(leftHandSymbols), rightHandKeys = rightHandKeys.concat(rightHandSymbols), leftHandKeys.length && leftHandKeys.length === rightHandKeys.length)
    return iterableEqual(mapSymbols(leftHandKeys).sort(), mapSymbols(rightHandKeys).sort()) === !1 ? !1 : keysEqual(leftHandOperand, rightHandOperand, leftHandKeys, options);
  var leftHandEntries = getIteratorEntries(leftHandOperand), rightHandEntries = getIteratorEntries(rightHandOperand);
  return leftHandEntries.length && leftHandEntries.length === rightHandEntries.length ? (leftHandEntries.sort(), rightHandEntries.sort(), iterableEqual(leftHandEntries, rightHandEntries, options)) : leftHandKeys.length === 0 && leftHandEntries.length === 0 && rightHandKeys.length === 0 && rightHandEntries.length === 0;
}
__name(objectEqual, "objectEqual");
function isPrimitive(value) {
  return value === null || typeof value != "object";
}
__name(isPrimitive, "isPrimitive");
function mapSymbols(arr) {
  return arr.map(__name(function(entry) {
    return typeof entry == "symbol" ? entry.toString() : entry;
  }, "mapSymbol"));
}
__name(mapSymbols, "mapSymbols");
function hasProperty(obj, name) {
  return typeof obj > "u" || obj === null ? !1 : name in Object(obj);
}
__name(hasProperty, "hasProperty");
function parsePath(path) {
  return path.replace(/([^\\])\[/g, "$1.[").match(/(\\\.|[^.]+?)+/g).map((value) => {
    if (value === "constructor" || value === "__proto__" || value === "prototype")
      return {};
    let mArr = /^\[(\d+)\]$/.exec(value), parsed = null;
    return mArr ? parsed = { i: parseFloat(mArr[1]) } : parsed = { p: value.replace(/\\([.[\]])/g, "$1") }, parsed;
  });
}
__name(parsePath, "parsePath");
function internalGetPathValue(obj, parsed, pathDepth) {
  let temporaryValue = obj, res = null;
  pathDepth = typeof pathDepth > "u" ? parsed.length : pathDepth;
  for (let i2 = 0; i2 < pathDepth; i2++) {
    let part = parsed[i2];
    temporaryValue && (typeof part.p > "u" ? temporaryValue = temporaryValue[part.i] : temporaryValue = temporaryValue[part.p], i2 === pathDepth - 1 && (res = temporaryValue));
  }
  return res;
}
__name(internalGetPathValue, "internalGetPathValue");
function getPathInfo(obj, path) {
  let parsed = parsePath(path), last = parsed[parsed.length - 1], info = {
    parent: parsed.length > 1 ? internalGetPathValue(obj, parsed, parsed.length - 1) : obj,
    name: last.p || last.i,
    value: internalGetPathValue(obj, parsed)
  };
  return info.exists = hasProperty(info.parent, info.name), info;
}
__name(getPathInfo, "getPathInfo");
var _a2, Assertion = (_a2 = class {
  /** @type {{}} */
  __flags = {};
  /**
   * Creates object for chaining.
   * `Assertion` objects contain metadata in the form of flags. Three flags can
   * be assigned during instantiation by passing arguments to this constructor:
   *
   * - `object`: This flag contains the target of the assertion. For example, in
   * the assertion `expect(numKittens).to.equal(7);`, the `object` flag will
   * contain `numKittens` so that the `equal` assertion can reference it when
   * needed.
   *
   * - `message`: This flag contains an optional custom error message to be
   * prepended to the error message that's generated by the assertion when it
   * fails.
   *
   * - `ssfi`: This flag stands for "start stack function indicator". It
   * contains a function reference that serves as the starting point for
   * removing frames from the stack trace of the error that's created by the
   * assertion when it fails. The goal is to provide a cleaner stack trace to
   * end users by removing Chai's internal functions. Note that it only works
   * in environments that support `Error.captureStackTrace`, and only when
   * `Chai.config.includeStack` hasn't been set to `false`.
   *
   * - `lockSsfi`: This flag controls whether or not the given `ssfi` flag
   * should retain its current value, even as assertions are chained off of
   * this object. This is usually set to `true` when creating a new assertion
   * from within another assertion. It's also temporarily set to `true` before
   * an overwritten assertion gets called by the overwriting assertion.
   *
   * - `eql`: This flag contains the deepEqual function to be used by the assertion.
   *
   * @param {unknown} obj target of the assertion
   * @param {string} [msg] (optional) custom error message
   * @param {Function} [ssfi] (optional) starting point for removing stack frames
   * @param {boolean} [lockSsfi] (optional) whether or not the ssfi flag is locked
   */
  constructor(obj, msg, ssfi, lockSsfi) {
    return flag(this, "ssfi", ssfi || _a2), flag(this, "lockSsfi", lockSsfi), flag(this, "object", obj), flag(this, "message", msg), flag(this, "eql", config.deepEqual || deep_eql_default), proxify(this);
  }
  /** @returns {boolean} */
  static get includeStack() {
    return console.warn(
      "Assertion.includeStack is deprecated, use chai.config.includeStack instead."
    ), config.includeStack;
  }
  /** @param {boolean} value */
  static set includeStack(value) {
    console.warn(
      "Assertion.includeStack is deprecated, use chai.config.includeStack instead."
    ), config.includeStack = value;
  }
  /** @returns {boolean} */
  static get showDiff() {
    return console.warn(
      "Assertion.showDiff is deprecated, use chai.config.showDiff instead."
    ), config.showDiff;
  }
  /** @param {boolean} value */
  static set showDiff(value) {
    console.warn(
      "Assertion.showDiff is deprecated, use chai.config.showDiff instead."
    ), config.showDiff = value;
  }
  /**
   * @param {string} name
   * @param {Function} fn
   */
  static addProperty(name, fn3) {
    addProperty(this.prototype, name, fn3);
  }
  /**
   * @param {string} name
   * @param {Function} fn
   */
  static addMethod(name, fn3) {
    addMethod(this.prototype, name, fn3);
  }
  /**
   * @param {string} name
   * @param {Function} fn
   * @param {Function} chainingBehavior
   */
  static addChainableMethod(name, fn3, chainingBehavior) {
    addChainableMethod(this.prototype, name, fn3, chainingBehavior);
  }
  /**
   * @param {string} name
   * @param {Function} fn
   */
  static overwriteProperty(name, fn3) {
    overwriteProperty(this.prototype, name, fn3);
  }
  /**
   * @param {string} name
   * @param {Function} fn
   */
  static overwriteMethod(name, fn3) {
    overwriteMethod(this.prototype, name, fn3);
  }
  /**
   * @param {string} name
   * @param {Function} fn
   * @param {Function} chainingBehavior
   */
  static overwriteChainableMethod(name, fn3, chainingBehavior) {
    overwriteChainableMethod(this.prototype, name, fn3, chainingBehavior);
  }
  /**
   * ### .assert(expression, message, negateMessage, expected, actual, showDiff)
   *
   * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.
   *
   * @name assert
   * @param {unknown} _expr to be tested
   * @param {string | Function} msg or function that returns message to display if expression fails
   * @param {string | Function} _negateMsg or function that returns negatedMessage to display if negated expression fails
   * @param {unknown} expected value (remember to check for negation)
   * @param {unknown} _actual (optional) will default to `this.obj`
   * @param {boolean} showDiff (optional) when set to `true`, assert will display a diff in addition to the message if expression fails
   * @returns {void}
   */
  assert(_expr, msg, _negateMsg, expected, _actual, showDiff) {
    let ok = test2(this, arguments);
    if (showDiff !== !1 && (showDiff = !0), expected === void 0 && _actual === void 0 && (showDiff = !1), config.showDiff !== !0 && (showDiff = !1), !ok) {
      msg = getMessage2(this, arguments);
      let assertionErrorObjectProperties = {
        actual: getActual(this, arguments),
        expected,
        showDiff
      }, operator = getOperator(this, arguments);
      throw operator && (assertionErrorObjectProperties.operator = operator), new AssertionError(
        msg,
        assertionErrorObjectProperties,
        // @ts-expect-error Not sure what to do about these types yet
        config.includeStack ? this.assert : flag(this, "ssfi")
      );
    }
  }
  /**
   * Quick reference to stored `actual` value for plugin developers.
   *
   * @returns {unknown}
   */
  get _obj() {
    return flag(this, "object");
  }
  /**
   * Quick reference to stored `actual` value for plugin developers.
   *
   * @param {unknown} val
   */
  set _obj(val) {
    flag(this, "object", val);
  }
}, __name(_a2, "Assertion"), _a2);
function isProxyEnabled() {
  return config.useProxy && typeof Proxy < "u" && typeof Reflect < "u";
}
__name(isProxyEnabled, "isProxyEnabled");
function addProperty(ctx, name, getter) {
  getter = getter === void 0 ? function() {
  } : getter, Object.defineProperty(ctx, name, {
    get: __name(function propertyGetter() {
      !isProxyEnabled() && !flag(this, "lockSsfi") && flag(this, "ssfi", propertyGetter);
      let result = getter.call(this);
      if (result !== void 0) return result;
      let newAssertion = new Assertion();
      return transferFlags(this, newAssertion), newAssertion;
    }, "propertyGetter"),
    configurable: !0
  });
}
__name(addProperty, "addProperty");
var fnLengthDesc = Object.getOwnPropertyDescriptor(function() {
}, "length");
function addLengthGuard(fn3, assertionName, isChainable) {
  return fnLengthDesc.configurable && Object.defineProperty(fn3, "length", {
    get: __name(function() {
      throw Error(
        isChainable ? "Invalid Chai property: " + assertionName + '.length. Due to a compatibility issue, "length" cannot directly follow "' + assertionName + '". Use "' + assertionName + '.lengthOf" instead.' : "Invalid Chai property: " + assertionName + '.length. See docs for proper usage of "' + assertionName + '".'
      );
    }, "get")
  }), fn3;
}
__name(addLengthGuard, "addLengthGuard");
function getProperties(object) {
  let result = Object.getOwnPropertyNames(object);
  function addProperty2(property) {
    result.indexOf(property) === -1 && result.push(property);
  }
  __name(addProperty2, "addProperty");
  let proto = Object.getPrototypeOf(object);
  for (; proto !== null; )
    Object.getOwnPropertyNames(proto).forEach(addProperty2), proto = Object.getPrototypeOf(proto);
  return result;
}
__name(getProperties, "getProperties");
var builtins = ["__flags", "__methods", "_obj", "assert"];
function proxify(obj, nonChainableMethodName) {
  return isProxyEnabled() ? new Proxy(obj, {
    get: __name(function proxyGetter(target, property) {
      if (typeof property == "string" && config.proxyExcludedKeys.indexOf(property) === -1 && !Reflect.has(target, property)) {
        if (nonChainableMethodName)
          throw Error(
            "Invalid Chai property: " + nonChainableMethodName + "." + property + '. See docs for proper usage of "' + nonChainableMethodName + '".'
          );
        let suggestion = null, suggestionDistance = 4;
        throw getProperties(target).forEach(function(prop) {
          if (
            // we actually mean to check `Object.prototype` here
            // eslint-disable-next-line no-prototype-builtins
            !Object.prototype.hasOwnProperty(prop) && builtins.indexOf(prop) === -1
          ) {
            let dist = stringDistanceCapped(property, prop, suggestionDistance);
            dist < suggestionDistance && (suggestion = prop, suggestionDistance = dist);
          }
        }), Error(
          suggestion !== null ? "Invalid Chai property: " + property + '. Did you mean "' + suggestion + '"?' : "Invalid Chai property: " + property
        );
      }
      return builtins.indexOf(property) === -1 && !flag(target, "lockSsfi") && flag(target, "ssfi", proxyGetter), Reflect.get(target, property);
    }, "proxyGetter")
  }) : obj;
}
__name(proxify, "proxify");
function stringDistanceCapped(strA, strB, cap) {
  if (Math.abs(strA.length - strB.length) >= cap)
    return cap;
  let memo = [];
  for (let i2 = 0; i2 <= strA.length; i2++)
    memo[i2] = Array(strB.length + 1).fill(0), memo[i2][0] = i2;
  for (let j2 = 0; j2 < strB.length; j2++)
    memo[0][j2] = j2;
  for (let i2 = 1; i2 <= strA.length; i2++) {
    let ch = strA.charCodeAt(i2 - 1);
    for (let j2 = 1; j2 <= strB.length; j2++) {
      if (Math.abs(i2 - j2) >= cap) {
        memo[i2][j2] = cap;
        continue;
      }
      memo[i2][j2] = Math.min(
        memo[i2 - 1][j2] + 1,
        memo[i2][j2 - 1] + 1,
        memo[i2 - 1][j2 - 1] + (ch === strB.charCodeAt(j2 - 1) ? 0 : 1)
      );
    }
  }
  return memo[strA.length][strB.length];
}
__name(stringDistanceCapped, "stringDistanceCapped");
function addMethod(ctx, name, method) {
  let methodWrapper = __name(function() {
    flag(this, "lockSsfi") || flag(this, "ssfi", methodWrapper);
    let result = method.apply(this, arguments);
    if (result !== void 0) return result;
    let newAssertion = new Assertion();
    return transferFlags(this, newAssertion), newAssertion;
  }, "methodWrapper");
  addLengthGuard(methodWrapper, name, !1), ctx[name] = proxify(methodWrapper, name);
}
__name(addMethod, "addMethod");
function overwriteProperty(ctx, name, getter) {
  let _get = Object.getOwnPropertyDescriptor(ctx, name), _super = __name(function() {
  }, "_super");
  _get && typeof _get.get == "function" && (_super = _get.get), Object.defineProperty(ctx, name, {
    get: __name(function overwritingPropertyGetter() {
      !isProxyEnabled() && !flag(this, "lockSsfi") && flag(this, "ssfi", overwritingPropertyGetter);
      let origLockSsfi = flag(this, "lockSsfi");
      flag(this, "lockSsfi", !0);
      let result = getter(_super).call(this);
      if (flag(this, "lockSsfi", origLockSsfi), result !== void 0)
        return result;
      let newAssertion = new Assertion();
      return transferFlags(this, newAssertion), newAssertion;
    }, "overwritingPropertyGetter"),
    configurable: !0
  });
}
__name(overwriteProperty, "overwriteProperty");
function overwriteMethod(ctx, name, method) {
  let _method = ctx[name], _super = __name(function() {
    throw new Error(name + " is not a function");
  }, "_super");
  _method && typeof _method == "function" && (_super = _method);
  let overwritingMethodWrapper = __name(function() {
    flag(this, "lockSsfi") || flag(this, "ssfi", overwritingMethodWrapper);
    let origLockSsfi = flag(this, "lockSsfi");
    flag(this, "lockSsfi", !0);
    let result = method(_super).apply(this, arguments);
    if (flag(this, "lockSsfi", origLockSsfi), result !== void 0)
      return result;
    let newAssertion = new Assertion();
    return transferFlags(this, newAssertion), newAssertion;
  }, "overwritingMethodWrapper");
  addLengthGuard(overwritingMethodWrapper, name, !1), ctx[name] = proxify(overwritingMethodWrapper, name);
}
__name(overwriteMethod, "overwriteMethod");
var canSetPrototype = typeof Object.setPrototypeOf == "function", testFn = __name(function() {
}, "testFn"), excludeNames = Object.getOwnPropertyNames(testFn).filter(function(name) {
  let propDesc = Object.getOwnPropertyDescriptor(testFn, name);
  return typeof propDesc != "object" ? !0 : !propDesc.configurable;
}), call = Function.prototype.call, apply = Function.prototype.apply;
function addChainableMethod(ctx, name, method, chainingBehavior) {
  typeof chainingBehavior != "function" && (chainingBehavior = __name(function() {
  }, "chainingBehavior"));
  let chainableBehavior = {
    method,
    chainingBehavior
  };
  ctx.__methods || (ctx.__methods = {}), ctx.__methods[name] = chainableBehavior, Object.defineProperty(ctx, name, {
    get: __name(function() {
      chainableBehavior.chainingBehavior.call(this);
      let chainableMethodWrapper = __name(function() {
        flag(this, "lockSsfi") || flag(this, "ssfi", chainableMethodWrapper);
        let result = chainableBehavior.method.apply(this, arguments);
        if (result !== void 0)
          return result;
        let newAssertion = new Assertion();
        return transferFlags(this, newAssertion), newAssertion;
      }, "chainableMethodWrapper");
      if (addLengthGuard(chainableMethodWrapper, name, !0), canSetPrototype) {
        let prototype = Object.create(this);
        prototype.call = call, prototype.apply = apply, Object.setPrototypeOf(chainableMethodWrapper, prototype);
      } else
        Object.getOwnPropertyNames(ctx).forEach(function(asserterName) {
          if (excludeNames.indexOf(asserterName) !== -1)
            return;
          let pd = Object.getOwnPropertyDescriptor(ctx, asserterName);
          Object.defineProperty(chainableMethodWrapper, asserterName, pd);
        });
      return transferFlags(this, chainableMethodWrapper), proxify(chainableMethodWrapper);
    }, "chainableMethodGetter"),
    configurable: !0
  });
}
__name(addChainableMethod, "addChainableMethod");
function overwriteChainableMethod(ctx, name, method, chainingBehavior) {
  let chainableBehavior = ctx.__methods[name], _chainingBehavior = chainableBehavior.chainingBehavior;
  chainableBehavior.chainingBehavior = __name(function() {
    let result = chainingBehavior(_chainingBehavior).call(this);
    if (result !== void 0)
      return result;
    let newAssertion = new Assertion();
    return transferFlags(this, newAssertion), newAssertion;
  }, "overwritingChainableMethodGetter");
  let _method = chainableBehavior.method;
  chainableBehavior.method = __name(function() {
    let result = method(_method).apply(this, arguments);
    if (result !== void 0)
      return result;
    let newAssertion = new Assertion();
    return transferFlags(this, newAssertion), newAssertion;
  }, "overwritingChainableMethodWrapper");
}
__name(overwriteChainableMethod, "overwriteChainableMethod");
function compareByInspect(a2, b2) {
  return inspect22(a2) < inspect22(b2) ? -1 : 1;
}
__name(compareByInspect, "compareByInspect");
function getOwnEnumerablePropertySymbols(obj) {
  return typeof Object.getOwnPropertySymbols != "function" ? [] : Object.getOwnPropertySymbols(obj).filter(function(sym) {
    return Object.getOwnPropertyDescriptor(obj, sym).enumerable;
  });
}
__name(getOwnEnumerablePropertySymbols, "getOwnEnumerablePropertySymbols");
function getOwnEnumerableProperties(obj) {
  return Object.keys(obj).concat(getOwnEnumerablePropertySymbols(obj));
}
__name(getOwnEnumerableProperties, "getOwnEnumerableProperties");
var isNaN22 = Number.isNaN;
function isObjectType(obj) {
  let objectType = type(obj);
  return ["Array", "Object", "Function"].indexOf(objectType) !== -1;
}
__name(isObjectType, "isObjectType");
function getOperator(obj, args) {
  let operator = flag(obj, "operator"), negate = flag(obj, "negate"), expected = args[3], msg = negate ? args[2] : args[1];
  if (operator)
    return operator;
  if (typeof msg == "function" && (msg = msg()), msg = msg || "", !msg || /\shave\s/.test(msg))
    return;
  let isObject7 = isObjectType(expected);
  return /\snot\s/.test(msg) ? isObject7 ? "notDeepStrictEqual" : "notStrictEqual" : isObject7 ? "deepStrictEqual" : "strictEqual";
}
__name(getOperator, "getOperator");
function getName(fn3) {
  return fn3.name;
}
__name(getName, "getName");
function isRegExp2(obj) {
  return Object.prototype.toString.call(obj) === "[object RegExp]";
}
__name(isRegExp2, "isRegExp");
function isNumeric(obj) {
  return ["Number", "BigInt"].includes(type(obj));
}
__name(isNumeric, "isNumeric");
var { flag: flag2 } = utils_exports;
[
  "to",
  "be",
  "been",
  "is",
  "and",
  "has",
  "have",
  "with",
  "that",
  "which",
  "at",
  "of",
  "same",
  "but",
  "does",
  "still",
  "also"
].forEach(function(chain) {
  Assertion.addProperty(chain);
});
Assertion.addProperty("not", function() {
  flag2(this, "negate", !0);
});
Assertion.addProperty("deep", function() {
  flag2(this, "deep", !0);
});
Assertion.addProperty("nested", function() {
  flag2(this, "nested", !0);
});
Assertion.addProperty("own", function() {
  flag2(this, "own", !0);
});
Assertion.addProperty("ordered", function() {
  flag2(this, "ordered", !0);
});
Assertion.addProperty("any", function() {
  flag2(this, "any", !0), flag2(this, "all", !1);
});
Assertion.addProperty("all", function() {
  flag2(this, "all", !0), flag2(this, "any", !1);
});
var functionTypes = {
  function: [
    "function",
    "asyncfunction",
    "generatorfunction",
    "asyncgeneratorfunction"
  ],
  asyncfunction: ["asyncfunction", "asyncgeneratorfunction"],
  generatorfunction: ["generatorfunction", "asyncgeneratorfunction"],
  asyncgeneratorfunction: ["asyncgeneratorfunction"]
};
function an(type32, msg) {
  msg && flag2(this, "message", msg), type32 = type32.toLowerCase();
  let obj = flag2(this, "object"), article = ~["a", "e", "i", "o", "u"].indexOf(type32.charAt(0)) ? "an " : "a ", detectedType = type(obj).toLowerCase();
  functionTypes.function.includes(type32) ? this.assert(
    functionTypes[type32].includes(detectedType),
    "expected #{this} to be " + article + type32,
    "expected #{this} not to be " + article + type32
  ) : this.assert(
    type32 === detectedType,
    "expected #{this} to be " + article + type32,
    "expected #{this} not to be " + article + type32
  );
}
__name(an, "an");
Assertion.addChainableMethod("an", an);
Assertion.addChainableMethod("a", an);
function SameValueZero(a2, b2) {
  return isNaN22(a2) && isNaN22(b2) || a2 === b2;
}
__name(SameValueZero, "SameValueZero");
function includeChainingBehavior() {
  flag2(this, "contains", !0);
}
__name(includeChainingBehavior, "includeChainingBehavior");
function include(val, msg) {
  msg && flag2(this, "message", msg);
  let obj = flag2(this, "object"), objType = type(obj).toLowerCase(), flagMsg = flag2(this, "message"), negate = flag2(this, "negate"), ssfi = flag2(this, "ssfi"), isDeep = flag2(this, "deep"), descriptor = isDeep ? "deep " : "", isEql = isDeep ? flag2(this, "eql") : SameValueZero;
  flagMsg = flagMsg ? flagMsg + ": " : "";
  let included = !1;
  switch (objType) {
    case "string":
      included = obj.indexOf(val) !== -1;
      break;
    case "weakset":
      if (isDeep)
        throw new AssertionError(
          flagMsg + "unable to use .deep.include with WeakSet",
          void 0,
          ssfi
        );
      included = obj.has(val);
      break;
    case "map":
      obj.forEach(function(item) {
        included = included || isEql(item, val);
      });
      break;
    case "set":
      isDeep ? obj.forEach(function(item) {
        included = included || isEql(item, val);
      }) : included = obj.has(val);
      break;
    case "array":
      isDeep ? included = obj.some(function(item) {
        return isEql(item, val);
      }) : included = obj.indexOf(val) !== -1;
      break;
    default: {
      if (val !== Object(val))
        throw new AssertionError(
          flagMsg + "the given combination of arguments (" + objType + " and " + type(val).toLowerCase() + ") is invalid for this assertion. You can use an array, a map, an object, a set, a string, or a weakset instead of a " + type(val).toLowerCase(),
          void 0,
          ssfi
        );
      let props = Object.keys(val), firstErr = null, numErrs = 0;
      if (props.forEach(function(prop) {
        let propAssertion = new Assertion(obj);
        if (transferFlags(this, propAssertion, !0), flag2(propAssertion, "lockSsfi", !0), !negate || props.length === 1) {
          propAssertion.property(prop, val[prop]);
          return;
        }
        try {
          propAssertion.property(prop, val[prop]);
        } catch (err) {
          if (!check_error_exports.compatibleConstructor(err, AssertionError))
            throw err;
          firstErr === null && (firstErr = err), numErrs++;
        }
      }, this), negate && props.length > 1 && numErrs === props.length)
        throw firstErr;
      return;
    }
  }
  this.assert(
    included,
    "expected #{this} to " + descriptor + "include " + inspect22(val),
    "expected #{this} to not " + descriptor + "include " + inspect22(val)
  );
}
__name(include, "include");
Assertion.addChainableMethod("include", include, includeChainingBehavior);
Assertion.addChainableMethod("contain", include, includeChainingBehavior);
Assertion.addChainableMethod("contains", include, includeChainingBehavior);
Assertion.addChainableMethod("includes", include, includeChainingBehavior);
Assertion.addProperty("ok", function() {
  this.assert(
    flag2(this, "object"),
    "expected #{this} to be truthy",
    "expected #{this} to be falsy"
  );
});
Assertion.addProperty("true", function() {
  this.assert(
    flag2(this, "object") === !0,
    "expected #{this} to be true",
    "expected #{this} to be false",
    !flag2(this, "negate")
  );
});
Assertion.addProperty("numeric", function() {
  let object = flag2(this, "object");
  this.assert(
    ["Number", "BigInt"].includes(type(object)),
    "expected #{this} to be numeric",
    "expected #{this} to not be numeric",
    !flag2(this, "negate")
  );
});
Assertion.addProperty("callable", function() {
  let val = flag2(this, "object"), ssfi = flag2(this, "ssfi"), message = flag2(this, "message"), msg = message ? `${message}: ` : "", negate = flag2(this, "negate"), assertionMessage = negate ? `${msg}expected ${inspect22(val)} not to be a callable function` : `${msg}expected ${inspect22(val)} to be a callable function`, isCallable3 = [
    "Function",
    "AsyncFunction",
    "GeneratorFunction",
    "AsyncGeneratorFunction"
  ].includes(type(val));
  if (isCallable3 && negate || !isCallable3 && !negate)
    throw new AssertionError(assertionMessage, void 0, ssfi);
});
Assertion.addProperty("false", function() {
  this.assert(
    flag2(this, "object") === !1,
    "expected #{this} to be false",
    "expected #{this} to be true",
    !!flag2(this, "negate")
  );
});
Assertion.addProperty("null", function() {
  this.assert(
    flag2(this, "object") === null,
    "expected #{this} to be null",
    "expected #{this} not to be null"
  );
});
Assertion.addProperty("undefined", function() {
  this.assert(
    flag2(this, "object") === void 0,
    "expected #{this} to be undefined",
    "expected #{this} not to be undefined"
  );
});
Assertion.addProperty("NaN", function() {
  this.assert(
    isNaN22(flag2(this, "object")),
    "expected #{this} to be NaN",
    "expected #{this} not to be NaN"
  );
});
function assertExist() {
  let val = flag2(this, "object");
  this.assert(
    val != null,
    "expected #{this} to exist",
    "expected #{this} to not exist"
  );
}
__name(assertExist, "assertExist");
Assertion.addProperty("exist", assertExist);
Assertion.addProperty("exists", assertExist);
Assertion.addProperty("empty", function() {
  let val = flag2(this, "object"), ssfi = flag2(this, "ssfi"), flagMsg = flag2(this, "message"), itemsCount;
  switch (flagMsg = flagMsg ? flagMsg + ": " : "", type(val).toLowerCase()) {
    case "array":
    case "string":
      itemsCount = val.length;
      break;
    case "map":
    case "set":
      itemsCount = val.size;
      break;
    case "weakmap":
    case "weakset":
      throw new AssertionError(
        flagMsg + ".empty was passed a weak collection",
        void 0,
        ssfi
      );
    case "function": {
      let msg = flagMsg + ".empty was passed a function " + getName(val);
      throw new AssertionError(msg.trim(), void 0, ssfi);
    }
    default:
      if (val !== Object(val))
        throw new AssertionError(
          flagMsg + ".empty was passed non-string primitive " + inspect22(val),
          void 0,
          ssfi
        );
      itemsCount = Object.keys(val).length;
  }
  this.assert(
    itemsCount === 0,
    "expected #{this} to be empty",
    "expected #{this} not to be empty"
  );
});
function checkArguments() {
  let obj = flag2(this, "object"), type32 = type(obj);
  this.assert(
    type32 === "Arguments",
    "expected #{this} to be arguments but got " + type32,
    "expected #{this} to not be arguments"
  );
}
__name(checkArguments, "checkArguments");
Assertion.addProperty("arguments", checkArguments);
Assertion.addProperty("Arguments", checkArguments);
function assertEqual(val, msg) {
  msg && flag2(this, "message", msg);
  let obj = flag2(this, "object");
  if (flag2(this, "deep")) {
    let prevLockSsfi = flag2(this, "lockSsfi");
    flag2(this, "lockSsfi", !0), this.eql(val), flag2(this, "lockSsfi", prevLockSsfi);
  } else
    this.assert(
      val === obj,
      "expected #{this} to equal #{exp}",
      "expected #{this} to not equal #{exp}",
      val,
      this._obj,
      !0
    );
}
__name(assertEqual, "assertEqual");
Assertion.addMethod("equal", assertEqual);
Assertion.addMethod("equals", assertEqual);
Assertion.addMethod("eq", assertEqual);
function assertEql(obj, msg) {
  msg && flag2(this, "message", msg);
  let eql = flag2(this, "eql");
  this.assert(
    eql(obj, flag2(this, "object")),
    "expected #{this} to deeply equal #{exp}",
    "expected #{this} to not deeply equal #{exp}",
    obj,
    this._obj,
    !0
  );
}
__name(assertEql, "assertEql");
Assertion.addMethod("eql", assertEql);
Assertion.addMethod("eqls", assertEql);
function assertAbove(n2, msg) {
  msg && flag2(this, "message", msg);
  let obj = flag2(this, "object"), doLength = flag2(this, "doLength"), flagMsg = flag2(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag2(this, "ssfi"), objType = type(obj).toLowerCase(), nType = type(n2).toLowerCase();
  if (doLength && objType !== "map" && objType !== "set" && new Assertion(obj, flagMsg, ssfi, !0).to.have.property("length"), !doLength && objType === "date" && nType !== "date")
    throw new AssertionError(
      msgPrefix + "the argument to above must be a date",
      void 0,
      ssfi
    );
  if (!isNumeric(n2) && (doLength || isNumeric(obj)))
    throw new AssertionError(
      msgPrefix + "the argument to above must be a number",
      void 0,
      ssfi
    );
  if (!doLength && objType !== "date" && !isNumeric(obj)) {
    let printObj = objType === "string" ? "'" + obj + "'" : obj;
    throw new AssertionError(
      msgPrefix + "expected " + printObj + " to be a number or a date",
      void 0,
      ssfi
    );
  }
  if (doLength) {
    let descriptor = "length", itemsCount;
    objType === "map" || objType === "set" ? (descriptor = "size", itemsCount = obj.size) : itemsCount = obj.length, this.assert(
      itemsCount > n2,
      "expected #{this} to have a " + descriptor + " above #{exp} but got #{act}",
      "expected #{this} to not have a " + descriptor + " above #{exp}",
      n2,
      itemsCount
    );
  } else
    this.assert(
      obj > n2,
      "expected #{this} to be above #{exp}",
      "expected #{this} to be at most #{exp}",
      n2
    );
}
__name(assertAbove, "assertAbove");
Assertion.addMethod("above", assertAbove);
Assertion.addMethod("gt", assertAbove);
Assertion.addMethod("greaterThan", assertAbove);
function assertLeast(n2, msg) {
  msg && flag2(this, "message", msg);
  let obj = flag2(this, "object"), doLength = flag2(this, "doLength"), flagMsg = flag2(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag2(this, "ssfi"), objType = type(obj).toLowerCase(), nType = type(n2).toLowerCase(), errorMessage, shouldThrow = !0;
  if (doLength && objType !== "map" && objType !== "set" && new Assertion(obj, flagMsg, ssfi, !0).to.have.property("length"), !doLength && objType === "date" && nType !== "date")
    errorMessage = msgPrefix + "the argument to least must be a date";
  else if (!isNumeric(n2) && (doLength || isNumeric(obj)))
    errorMessage = msgPrefix + "the argument to least must be a number";
  else if (!doLength && objType !== "date" && !isNumeric(obj)) {
    let printObj = objType === "string" ? "'" + obj + "'" : obj;
    errorMessage = msgPrefix + "expected " + printObj + " to be a number or a date";
  } else
    shouldThrow = !1;
  if (shouldThrow)
    throw new AssertionError(errorMessage, void 0, ssfi);
  if (doLength) {
    let descriptor = "length", itemsCount;
    objType === "map" || objType === "set" ? (descriptor = "size", itemsCount = obj.size) : itemsCount = obj.length, this.assert(
      itemsCount >= n2,
      "expected #{this} to have a " + descriptor + " at least #{exp} but got #{act}",
      "expected #{this} to have a " + descriptor + " below #{exp}",
      n2,
      itemsCount
    );
  } else
    this.assert(
      obj >= n2,
      "expected #{this} to be at least #{exp}",
      "expected #{this} to be below #{exp}",
      n2
    );
}
__name(assertLeast, "assertLeast");
Assertion.addMethod("least", assertLeast);
Assertion.addMethod("gte", assertLeast);
Assertion.addMethod("greaterThanOrEqual", assertLeast);
function assertBelow(n2, msg) {
  msg && flag2(this, "message", msg);
  let obj = flag2(this, "object"), doLength = flag2(this, "doLength"), flagMsg = flag2(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag2(this, "ssfi"), objType = type(obj).toLowerCase(), nType = type(n2).toLowerCase(), errorMessage, shouldThrow = !0;
  if (doLength && objType !== "map" && objType !== "set" && new Assertion(obj, flagMsg, ssfi, !0).to.have.property("length"), !doLength && objType === "date" && nType !== "date")
    errorMessage = msgPrefix + "the argument to below must be a date";
  else if (!isNumeric(n2) && (doLength || isNumeric(obj)))
    errorMessage = msgPrefix + "the argument to below must be a number";
  else if (!doLength && objType !== "date" && !isNumeric(obj)) {
    let printObj = objType === "string" ? "'" + obj + "'" : obj;
    errorMessage = msgPrefix + "expected " + printObj + " to be a number or a date";
  } else
    shouldThrow = !1;
  if (shouldThrow)
    throw new AssertionError(errorMessage, void 0, ssfi);
  if (doLength) {
    let descriptor = "length", itemsCount;
    objType === "map" || objType === "set" ? (descriptor = "size", itemsCount = obj.size) : itemsCount = obj.length, this.assert(
      itemsCount < n2,
      "expected #{this} to have a " + descriptor + " below #{exp} but got #{act}",
      "expected #{this} to not have a " + descriptor + " below #{exp}",
      n2,
      itemsCount
    );
  } else
    this.assert(
      obj < n2,
      "expected #{this} to be below #{exp}",
      "expected #{this} to be at least #{exp}",
      n2
    );
}
__name(assertBelow, "assertBelow");
Assertion.addMethod("below", assertBelow);
Assertion.addMethod("lt", assertBelow);
Assertion.addMethod("lessThan", assertBelow);
function assertMost(n2, msg) {
  msg && flag2(this, "message", msg);
  let obj = flag2(this, "object"), doLength = flag2(this, "doLength"), flagMsg = flag2(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag2(this, "ssfi"), objType = type(obj).toLowerCase(), nType = type(n2).toLowerCase(), errorMessage, shouldThrow = !0;
  if (doLength && objType !== "map" && objType !== "set" && new Assertion(obj, flagMsg, ssfi, !0).to.have.property("length"), !doLength && objType === "date" && nType !== "date")
    errorMessage = msgPrefix + "the argument to most must be a date";
  else if (!isNumeric(n2) && (doLength || isNumeric(obj)))
    errorMessage = msgPrefix + "the argument to most must be a number";
  else if (!doLength && objType !== "date" && !isNumeric(obj)) {
    let printObj = objType === "string" ? "'" + obj + "'" : obj;
    errorMessage = msgPrefix + "expected " + printObj + " to be a number or a date";
  } else
    shouldThrow = !1;
  if (shouldThrow)
    throw new AssertionError(errorMessage, void 0, ssfi);
  if (doLength) {
    let descriptor = "length", itemsCount;
    objType === "map" || objType === "set" ? (descriptor = "size", itemsCount = obj.size) : itemsCount = obj.length, this.assert(
      itemsCount <= n2,
      "expected #{this} to have a " + descriptor + " at most #{exp} but got #{act}",
      "expected #{this} to have a " + descriptor + " above #{exp}",
      n2,
      itemsCount
    );
  } else
    this.assert(
      obj <= n2,
      "expected #{this} to be at most #{exp}",
      "expected #{this} to be above #{exp}",
      n2
    );
}
__name(assertMost, "assertMost");
Assertion.addMethod("most", assertMost);
Assertion.addMethod("lte", assertMost);
Assertion.addMethod("lessThanOrEqual", assertMost);
Assertion.addMethod("within", function(start, finish, msg) {
  msg && flag2(this, "message", msg);
  let obj = flag2(this, "object"), doLength = flag2(this, "doLength"), flagMsg = flag2(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag2(this, "ssfi"), objType = type(obj).toLowerCase(), startType = type(start).toLowerCase(), finishType = type(finish).toLowerCase(), errorMessage, shouldThrow = !0, range = startType === "date" && finishType === "date" ? start.toISOString() + ".." + finish.toISOString() : start + ".." + finish;
  if (doLength && objType !== "map" && objType !== "set" && new Assertion(obj, flagMsg, ssfi, !0).to.have.property("length"), !doLength && objType === "date" && (startType !== "date" || finishType !== "date"))
    errorMessage = msgPrefix + "the arguments to within must be dates";
  else if ((!isNumeric(start) || !isNumeric(finish)) && (doLength || isNumeric(obj)))
    errorMessage = msgPrefix + "the arguments to within must be numbers";
  else if (!doLength && objType !== "date" && !isNumeric(obj)) {
    let printObj = objType === "string" ? "'" + obj + "'" : obj;
    errorMessage = msgPrefix + "expected " + printObj + " to be a number or a date";
  } else
    shouldThrow = !1;
  if (shouldThrow)
    throw new AssertionError(errorMessage, void 0, ssfi);
  if (doLength) {
    let descriptor = "length", itemsCount;
    objType === "map" || objType === "set" ? (descriptor = "size", itemsCount = obj.size) : itemsCount = obj.length, this.assert(
      itemsCount >= start && itemsCount <= finish,
      "expected #{this} to have a " + descriptor + " within " + range,
      "expected #{this} to not have a " + descriptor + " within " + range
    );
  } else
    this.assert(
      obj >= start && obj <= finish,
      "expected #{this} to be within " + range,
      "expected #{this} to not be within " + range
    );
});
function assertInstanceOf(constructor, msg) {
  msg && flag2(this, "message", msg);
  let target = flag2(this, "object"), ssfi = flag2(this, "ssfi"), flagMsg = flag2(this, "message"), isInstanceOf;
  try {
    isInstanceOf = target instanceof constructor;
  } catch (err) {
    throw err instanceof TypeError ? (flagMsg = flagMsg ? flagMsg + ": " : "", new AssertionError(
      flagMsg + "The instanceof assertion needs a constructor but " + type(constructor) + " was given.",
      void 0,
      ssfi
    )) : err;
  }
  let name = getName(constructor);
  name == null && (name = "an unnamed constructor"), this.assert(
    isInstanceOf,
    "expected #{this} to be an instance of " + name,
    "expected #{this} to not be an instance of " + name
  );
}
__name(assertInstanceOf, "assertInstanceOf");
Assertion.addMethod("instanceof", assertInstanceOf);
Assertion.addMethod("instanceOf", assertInstanceOf);
function assertProperty(name, val, msg) {
  msg && flag2(this, "message", msg);
  let isNested = flag2(this, "nested"), isOwn = flag2(this, "own"), flagMsg = flag2(this, "message"), obj = flag2(this, "object"), ssfi = flag2(this, "ssfi"), nameType = typeof name;
  if (flagMsg = flagMsg ? flagMsg + ": " : "", isNested) {
    if (nameType !== "string")
      throw new AssertionError(
        flagMsg + "the argument to property must be a string when using nested syntax",
        void 0,
        ssfi
      );
  } else if (nameType !== "string" && nameType !== "number" && nameType !== "symbol")
    throw new AssertionError(
      flagMsg + "the argument to property must be a string, number, or symbol",
      void 0,
      ssfi
    );
  if (isNested && isOwn)
    throw new AssertionError(
      flagMsg + 'The "nested" and "own" flags cannot be combined.',
      void 0,
      ssfi
    );
  if (obj == null)
    throw new AssertionError(
      flagMsg + "Target cannot be null or undefined.",
      void 0,
      ssfi
    );
  let isDeep = flag2(this, "deep"), negate = flag2(this, "negate"), pathInfo = isNested ? getPathInfo(obj, name) : null, value = isNested ? pathInfo.value : obj[name], isEql = isDeep ? flag2(this, "eql") : (val1, val2) => val1 === val2, descriptor = "";
  isDeep && (descriptor += "deep "), isOwn && (descriptor += "own "), isNested && (descriptor += "nested "), descriptor += "property ";
  let hasProperty2;
  isOwn ? hasProperty2 = Object.prototype.hasOwnProperty.call(obj, name) : isNested ? hasProperty2 = pathInfo.exists : hasProperty2 = hasProperty(obj, name), (!negate || arguments.length === 1) && this.assert(
    hasProperty2,
    "expected #{this} to have " + descriptor + inspect22(name),
    "expected #{this} to not have " + descriptor + inspect22(name)
  ), arguments.length > 1 && this.assert(
    hasProperty2 && isEql(val, value),
    "expected #{this} to have " + descriptor + inspect22(name) + " of #{exp}, but got #{act}",
    "expected #{this} to not have " + descriptor + inspect22(name) + " of #{act}",
    val,
    value
  ), flag2(this, "object", value);
}
__name(assertProperty, "assertProperty");
Assertion.addMethod("property", assertProperty);
function assertOwnProperty(_name, _value, _msg) {
  flag2(this, "own", !0), assertProperty.apply(this, arguments);
}
__name(assertOwnProperty, "assertOwnProperty");
Assertion.addMethod("ownProperty", assertOwnProperty);
Assertion.addMethod("haveOwnProperty", assertOwnProperty);
function assertOwnPropertyDescriptor(name, descriptor, msg) {
  typeof descriptor == "string" && (msg = descriptor, descriptor = null), msg && flag2(this, "message", msg);
  let obj = flag2(this, "object"), actualDescriptor = Object.getOwnPropertyDescriptor(Object(obj), name), eql = flag2(this, "eql");
  actualDescriptor && descriptor ? this.assert(
    eql(descriptor, actualDescriptor),
    "expected the own property descriptor for " + inspect22(name) + " on #{this} to match " + inspect22(descriptor) + ", got " + inspect22(actualDescriptor),
    "expected the own property descriptor for " + inspect22(name) + " on #{this} to not match " + inspect22(descriptor),
    descriptor,
    actualDescriptor,
    !0
  ) : this.assert(
    actualDescriptor,
    "expected #{this} to have an own property descriptor for " + inspect22(name),
    "expected #{this} to not have an own property descriptor for " + inspect22(name)
  ), flag2(this, "object", actualDescriptor);
}
__name(assertOwnPropertyDescriptor, "assertOwnPropertyDescriptor");
Assertion.addMethod("ownPropertyDescriptor", assertOwnPropertyDescriptor);
Assertion.addMethod("haveOwnPropertyDescriptor", assertOwnPropertyDescriptor);
function assertLengthChain() {
  flag2(this, "doLength", !0);
}
__name(assertLengthChain, "assertLengthChain");
function assertLength(n2, msg) {
  msg && flag2(this, "message", msg);
  let obj = flag2(this, "object"), objType = type(obj).toLowerCase(), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi"), descriptor = "length", itemsCount;
  switch (objType) {
    case "map":
    case "set":
      descriptor = "size", itemsCount = obj.size;
      break;
    default:
      new Assertion(obj, flagMsg, ssfi, !0).to.have.property("length"), itemsCount = obj.length;
  }
  this.assert(
    itemsCount == n2,
    "expected #{this} to have a " + descriptor + " of #{exp} but got #{act}",
    "expected #{this} to not have a " + descriptor + " of #{act}",
    n2,
    itemsCount
  );
}
__name(assertLength, "assertLength");
Assertion.addChainableMethod("length", assertLength, assertLengthChain);
Assertion.addChainableMethod("lengthOf", assertLength, assertLengthChain);
function assertMatch(re, msg) {
  msg && flag2(this, "message", msg);
  let obj = flag2(this, "object");
  this.assert(
    re.exec(obj),
    "expected #{this} to match " + re,
    "expected #{this} not to match " + re
  );
}
__name(assertMatch, "assertMatch");
Assertion.addMethod("match", assertMatch);
Assertion.addMethod("matches", assertMatch);
Assertion.addMethod("string", function(str2, msg) {
  msg && flag2(this, "message", msg);
  let obj = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
  new Assertion(obj, flagMsg, ssfi, !0).is.a("string"), this.assert(
    ~obj.indexOf(str2),
    "expected #{this} to contain " + inspect22(str2),
    "expected #{this} to not contain " + inspect22(str2)
  );
});
function assertKeys(keys2) {
  let obj = flag2(this, "object"), objType = type(obj), keysType = type(keys2), ssfi = flag2(this, "ssfi"), isDeep = flag2(this, "deep"), str2, deepStr = "", actual, ok = !0, flagMsg = flag2(this, "message");
  flagMsg = flagMsg ? flagMsg + ": " : "";
  let mixedArgsMsg = flagMsg + "when testing keys against an object or an array you must give a single Array|Object|String argument or multiple String arguments";
  if (objType === "Map" || objType === "Set")
    deepStr = isDeep ? "deeply " : "", actual = [], obj.forEach(function(val, key) {
      actual.push(key);
    }), keysType !== "Array" && (keys2 = Array.prototype.slice.call(arguments));
  else {
    switch (actual = getOwnEnumerableProperties(obj), keysType) {
      case "Array":
        if (arguments.length > 1)
          throw new AssertionError(mixedArgsMsg, void 0, ssfi);
        break;
      case "Object":
        if (arguments.length > 1)
          throw new AssertionError(mixedArgsMsg, void 0, ssfi);
        keys2 = Object.keys(keys2);
        break;
      default:
        keys2 = Array.prototype.slice.call(arguments);
    }
    keys2 = keys2.map(function(val) {
      return typeof val == "symbol" ? val : String(val);
    });
  }
  if (!keys2.length)
    throw new AssertionError(flagMsg + "keys required", void 0, ssfi);
  let len = keys2.length, any = flag2(this, "any"), all = flag2(this, "all"), expected = keys2, isEql = isDeep ? flag2(this, "eql") : (val1, val2) => val1 === val2;
  if (!any && !all && (all = !0), any && (ok = expected.some(function(expectedKey) {
    return actual.some(function(actualKey) {
      return isEql(expectedKey, actualKey);
    });
  })), all && (ok = expected.every(function(expectedKey) {
    return actual.some(function(actualKey) {
      return isEql(expectedKey, actualKey);
    });
  }), flag2(this, "contains") || (ok = ok && keys2.length == actual.length)), len > 1) {
    keys2 = keys2.map(function(key) {
      return inspect22(key);
    });
    let last = keys2.pop();
    all && (str2 = keys2.join(", ") + ", and " + last), any && (str2 = keys2.join(", ") + ", or " + last);
  } else
    str2 = inspect22(keys2[0]);
  str2 = (len > 1 ? "keys " : "key ") + str2, str2 = (flag2(this, "contains") ? "contain " : "have ") + str2, this.assert(
    ok,
    "expected #{this} to " + deepStr + str2,
    "expected #{this} to not " + deepStr + str2,
    expected.slice(0).sort(compareByInspect),
    actual.sort(compareByInspect),
    !0
  );
}
__name(assertKeys, "assertKeys");
Assertion.addMethod("keys", assertKeys);
Assertion.addMethod("key", assertKeys);
function assertThrows(errorLike, errMsgMatcher, msg) {
  msg && flag2(this, "message", msg);
  let obj = flag2(this, "object"), ssfi = flag2(this, "ssfi"), flagMsg = flag2(this, "message"), negate = flag2(this, "negate") || !1;
  new Assertion(obj, flagMsg, ssfi, !0).is.a("function"), (isRegExp2(errorLike) || typeof errorLike == "string") && (errMsgMatcher = errorLike, errorLike = null);
  let caughtErr, errorWasThrown = !1;
  try {
    obj();
  } catch (err) {
    errorWasThrown = !0, caughtErr = err;
  }
  let everyArgIsUndefined = errorLike === void 0 && errMsgMatcher === void 0, everyArgIsDefined = !!(errorLike && errMsgMatcher), errorLikeFail = !1, errMsgMatcherFail = !1;
  if (everyArgIsUndefined || !everyArgIsUndefined && !negate) {
    let errorLikeString = "an error";
    errorLike instanceof Error ? errorLikeString = "#{exp}" : errorLike && (errorLikeString = check_error_exports.getConstructorName(errorLike));
    let actual = caughtErr;
    if (caughtErr instanceof Error)
      actual = caughtErr.toString();
    else if (typeof caughtErr == "string")
      actual = caughtErr;
    else if (caughtErr && (typeof caughtErr == "object" || typeof caughtErr == "function"))
      try {
        actual = check_error_exports.getConstructorName(caughtErr);
      } catch {
      }
    this.assert(
      errorWasThrown,
      "expected #{this} to throw " + errorLikeString,
      "expected #{this} to not throw an error but #{act} was thrown",
      errorLike && errorLike.toString(),
      actual
    );
  }
  if (errorLike && caughtErr && (errorLike instanceof Error && check_error_exports.compatibleInstance(
    caughtErr,
    errorLike
  ) === negate && (everyArgIsDefined && negate ? errorLikeFail = !0 : this.assert(
    negate,
    "expected #{this} to throw #{exp} but #{act} was thrown",
    "expected #{this} to not throw #{exp}" + (caughtErr && !negate ? " but #{act} was thrown" : ""),
    errorLike.toString(),
    caughtErr.toString()
  )), check_error_exports.compatibleConstructor(
    caughtErr,
    errorLike
  ) === negate && (everyArgIsDefined && negate ? errorLikeFail = !0 : this.assert(
    negate,
    "expected #{this} to throw #{exp} but #{act} was thrown",
    "expected #{this} to not throw #{exp}" + (caughtErr ? " but #{act} was thrown" : ""),
    errorLike instanceof Error ? errorLike.toString() : errorLike && check_error_exports.getConstructorName(errorLike),
    caughtErr instanceof Error ? caughtErr.toString() : caughtErr && check_error_exports.getConstructorName(caughtErr)
  ))), caughtErr && errMsgMatcher !== void 0 && errMsgMatcher !== null) {
    let placeholder = "including";
    isRegExp2(errMsgMatcher) && (placeholder = "matching"), check_error_exports.compatibleMessage(
      caughtErr,
      errMsgMatcher
    ) === negate && (everyArgIsDefined && negate ? errMsgMatcherFail = !0 : this.assert(
      negate,
      "expected #{this} to throw error " + placeholder + " #{exp} but got #{act}",
      "expected #{this} to throw error not " + placeholder + " #{exp}",
      errMsgMatcher,
      check_error_exports.getMessage(caughtErr)
    ));
  }
  errorLikeFail && errMsgMatcherFail && this.assert(
    negate,
    "expected #{this} to throw #{exp} but #{act} was thrown",
    "expected #{this} to not throw #{exp}" + (caughtErr ? " but #{act} was thrown" : ""),
    errorLike instanceof Error ? errorLike.toString() : errorLike && check_error_exports.getConstructorName(errorLike),
    caughtErr instanceof Error ? caughtErr.toString() : caughtErr && check_error_exports.getConstructorName(caughtErr)
  ), flag2(this, "object", caughtErr);
}
__name(assertThrows, "assertThrows");
Assertion.addMethod("throw", assertThrows);
Assertion.addMethod("throws", assertThrows);
Assertion.addMethod("Throw", assertThrows);
function respondTo(method, msg) {
  msg && flag2(this, "message", msg);
  let obj = flag2(this, "object"), itself = flag2(this, "itself"), context = typeof obj == "function" && !itself ? obj.prototype[method] : obj[method];
  this.assert(
    typeof context == "function",
    "expected #{this} to respond to " + inspect22(method),
    "expected #{this} to not respond to " + inspect22(method)
  );
}
__name(respondTo, "respondTo");
Assertion.addMethod("respondTo", respondTo);
Assertion.addMethod("respondsTo", respondTo);
Assertion.addProperty("itself", function() {
  flag2(this, "itself", !0);
});
function satisfy(matcher, msg) {
  msg && flag2(this, "message", msg);
  let obj = flag2(this, "object"), result = matcher(obj);
  this.assert(
    result,
    "expected #{this} to satisfy " + objDisplay(matcher),
    "expected #{this} to not satisfy" + objDisplay(matcher),
    !flag2(this, "negate"),
    result
  );
}
__name(satisfy, "satisfy");
Assertion.addMethod("satisfy", satisfy);
Assertion.addMethod("satisfies", satisfy);
function closeTo(expected, delta, msg) {
  msg && flag2(this, "message", msg);
  let obj = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
  new Assertion(obj, flagMsg, ssfi, !0).is.numeric;
  let message = "A `delta` value is required for `closeTo`";
  if (delta == null)
    throw new AssertionError(
      flagMsg ? `${flagMsg}: ${message}` : message,
      void 0,
      ssfi
    );
  if (new Assertion(delta, flagMsg, ssfi, !0).is.numeric, message = "A `expected` value is required for `closeTo`", expected == null)
    throw new AssertionError(
      flagMsg ? `${flagMsg}: ${message}` : message,
      void 0,
      ssfi
    );
  new Assertion(expected, flagMsg, ssfi, !0).is.numeric;
  let abs = __name((x2) => x2 < 0n ? -x2 : x2, "abs"), strip = __name((number) => parseFloat(parseFloat(number).toPrecision(12)), "strip");
  this.assert(
    strip(abs(obj - expected)) <= delta,
    "expected #{this} to be close to " + expected + " +/- " + delta,
    "expected #{this} not to be close to " + expected + " +/- " + delta
  );
}
__name(closeTo, "closeTo");
Assertion.addMethod("closeTo", closeTo);
Assertion.addMethod("approximately", closeTo);
function isSubsetOf(_subset, _superset, cmp, contains, ordered) {
  let superset = Array.from(_superset), subset = Array.from(_subset);
  if (!contains) {
    if (subset.length !== superset.length) return !1;
    superset = superset.slice();
  }
  return subset.every(function(elem, idx) {
    if (ordered) return cmp ? cmp(elem, superset[idx]) : elem === superset[idx];
    if (!cmp) {
      let matchIdx = superset.indexOf(elem);
      return matchIdx === -1 ? !1 : (contains || superset.splice(matchIdx, 1), !0);
    }
    return superset.some(function(elem2, matchIdx) {
      return cmp(elem, elem2) ? (contains || superset.splice(matchIdx, 1), !0) : !1;
    });
  });
}
__name(isSubsetOf, "isSubsetOf");
Assertion.addMethod("members", function(subset, msg) {
  msg && flag2(this, "message", msg);
  let obj = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
  new Assertion(obj, flagMsg, ssfi, !0).to.be.iterable, new Assertion(subset, flagMsg, ssfi, !0).to.be.iterable;
  let contains = flag2(this, "contains"), ordered = flag2(this, "ordered"), subject, failMsg, failNegateMsg;
  contains ? (subject = ordered ? "an ordered superset" : "a superset", failMsg = "expected #{this} to be " + subject + " of #{exp}", failNegateMsg = "expected #{this} to not be " + subject + " of #{exp}") : (subject = ordered ? "ordered members" : "members", failMsg = "expected #{this} to have the same " + subject + " as #{exp}", failNegateMsg = "expected #{this} to not have the same " + subject + " as #{exp}");
  let cmp = flag2(this, "deep") ? flag2(this, "eql") : void 0;
  this.assert(
    isSubsetOf(subset, obj, cmp, contains, ordered),
    failMsg,
    failNegateMsg,
    subset,
    obj,
    !0
  );
});
Assertion.addProperty("iterable", function(msg) {
  msg && flag2(this, "message", msg);
  let obj = flag2(this, "object");
  this.assert(
    obj != null && obj[Symbol.iterator],
    "expected #{this} to be an iterable",
    "expected #{this} to not be an iterable",
    obj
  );
});
function oneOf(list, msg) {
  msg && flag2(this, "message", msg);
  let expected = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi"), contains = flag2(this, "contains"), isDeep = flag2(this, "deep"), eql = flag2(this, "eql");
  new Assertion(list, flagMsg, ssfi, !0).to.be.an("array"), contains ? this.assert(
    list.some(function(possibility) {
      return expected.indexOf(possibility) > -1;
    }),
    "expected #{this} to contain one of #{exp}",
    "expected #{this} to not contain one of #{exp}",
    list,
    expected
  ) : isDeep ? this.assert(
    list.some(function(possibility) {
      return eql(expected, possibility);
    }),
    "expected #{this} to deeply equal one of #{exp}",
    "expected #{this} to deeply equal one of #{exp}",
    list,
    expected
  ) : this.assert(
    list.indexOf(expected) > -1,
    "expected #{this} to be one of #{exp}",
    "expected #{this} to not be one of #{exp}",
    list,
    expected
  );
}
__name(oneOf, "oneOf");
Assertion.addMethod("oneOf", oneOf);
function assertChanges(subject, prop, msg) {
  msg && flag2(this, "message", msg);
  let fn3 = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
  new Assertion(fn3, flagMsg, ssfi, !0).is.a("function");
  let initial;
  prop ? (new Assertion(subject, flagMsg, ssfi, !0).to.have.property(prop), initial = subject[prop]) : (new Assertion(subject, flagMsg, ssfi, !0).is.a("function"), initial = subject()), fn3();
  let final = prop == null ? subject() : subject[prop], msgObj = prop == null ? initial : "." + prop;
  flag2(this, "deltaMsgObj", msgObj), flag2(this, "initialDeltaValue", initial), flag2(this, "finalDeltaValue", final), flag2(this, "deltaBehavior", "change"), flag2(this, "realDelta", final !== initial), this.assert(
    initial !== final,
    "expected " + msgObj + " to change",
    "expected " + msgObj + " to not change"
  );
}
__name(assertChanges, "assertChanges");
Assertion.addMethod("change", assertChanges);
Assertion.addMethod("changes", assertChanges);
function assertIncreases(subject, prop, msg) {
  msg && flag2(this, "message", msg);
  let fn3 = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
  new Assertion(fn3, flagMsg, ssfi, !0).is.a("function");
  let initial;
  prop ? (new Assertion(subject, flagMsg, ssfi, !0).to.have.property(prop), initial = subject[prop]) : (new Assertion(subject, flagMsg, ssfi, !0).is.a("function"), initial = subject()), new Assertion(initial, flagMsg, ssfi, !0).is.a("number"), fn3();
  let final = prop == null ? subject() : subject[prop], msgObj = prop == null ? initial : "." + prop;
  flag2(this, "deltaMsgObj", msgObj), flag2(this, "initialDeltaValue", initial), flag2(this, "finalDeltaValue", final), flag2(this, "deltaBehavior", "increase"), flag2(this, "realDelta", final - initial), this.assert(
    final - initial > 0,
    "expected " + msgObj + " to increase",
    "expected " + msgObj + " to not increase"
  );
}
__name(assertIncreases, "assertIncreases");
Assertion.addMethod("increase", assertIncreases);
Assertion.addMethod("increases", assertIncreases);
function assertDecreases(subject, prop, msg) {
  msg && flag2(this, "message", msg);
  let fn3 = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
  new Assertion(fn3, flagMsg, ssfi, !0).is.a("function");
  let initial;
  prop ? (new Assertion(subject, flagMsg, ssfi, !0).to.have.property(prop), initial = subject[prop]) : (new Assertion(subject, flagMsg, ssfi, !0).is.a("function"), initial = subject()), new Assertion(initial, flagMsg, ssfi, !0).is.a("number"), fn3();
  let final = prop == null ? subject() : subject[prop], msgObj = prop == null ? initial : "." + prop;
  flag2(this, "deltaMsgObj", msgObj), flag2(this, "initialDeltaValue", initial), flag2(this, "finalDeltaValue", final), flag2(this, "deltaBehavior", "decrease"), flag2(this, "realDelta", initial - final), this.assert(
    final - initial < 0,
    "expected " + msgObj + " to decrease",
    "expected " + msgObj + " to not decrease"
  );
}
__name(assertDecreases, "assertDecreases");
Assertion.addMethod("decrease", assertDecreases);
Assertion.addMethod("decreases", assertDecreases);
function assertDelta(delta, msg) {
  msg && flag2(this, "message", msg);
  let msgObj = flag2(this, "deltaMsgObj"), initial = flag2(this, "initialDeltaValue"), final = flag2(this, "finalDeltaValue"), behavior2 = flag2(this, "deltaBehavior"), realDelta = flag2(this, "realDelta"), expression;
  behavior2 === "change" ? expression = Math.abs(final - initial) === Math.abs(delta) : expression = realDelta === Math.abs(delta), this.assert(
    expression,
    "expected " + msgObj + " to " + behavior2 + " by " + delta,
    "expected " + msgObj + " to not " + behavior2 + " by " + delta
  );
}
__name(assertDelta, "assertDelta");
Assertion.addMethod("by", assertDelta);
Assertion.addProperty("extensible", function() {
  let obj = flag2(this, "object"), isExtensible = obj === Object(obj) && Object.isExtensible(obj);
  this.assert(
    isExtensible,
    "expected #{this} to be extensible",
    "expected #{this} to not be extensible"
  );
});
Assertion.addProperty("sealed", function() {
  let obj = flag2(this, "object"), isSealed = obj === Object(obj) ? Object.isSealed(obj) : !0;
  this.assert(
    isSealed,
    "expected #{this} to be sealed",
    "expected #{this} to not be sealed"
  );
});
Assertion.addProperty("frozen", function() {
  let obj = flag2(this, "object"), isFrozen = obj === Object(obj) ? Object.isFrozen(obj) : !0;
  this.assert(
    isFrozen,
    "expected #{this} to be frozen",
    "expected #{this} to not be frozen"
  );
});
Assertion.addProperty("finite", function(_msg) {
  let obj = flag2(this, "object");
  this.assert(
    typeof obj == "number" && isFinite(obj),
    "expected #{this} to be a finite number",
    "expected #{this} to not be a finite number"
  );
});
function compareSubset(expected, actual) {
  return expected === actual ? !0 : typeof actual != typeof expected ? !1 : typeof expected != "object" || expected === null ? expected === actual : actual ? Array.isArray(expected) ? Array.isArray(actual) ? expected.every(function(exp) {
    return actual.some(function(act) {
      return compareSubset(exp, act);
    });
  }) : !1 : expected instanceof Date ? actual instanceof Date ? expected.getTime() === actual.getTime() : !1 : Object.keys(expected).every(function(key) {
    let expectedValue = expected[key], actualValue = actual[key];
    return typeof expectedValue == "object" && expectedValue !== null && actualValue !== null ? compareSubset(expectedValue, actualValue) : typeof expectedValue == "function" ? expectedValue(actualValue) : actualValue === expectedValue;
  }) : !1;
}
__name(compareSubset, "compareSubset");
Assertion.addMethod("containSubset", function(expected) {
  let actual = flag(this, "object"), showDiff = config.showDiff;
  this.assert(
    compareSubset(expected, actual),
    "expected #{act} to contain subset #{exp}",
    "expected #{act} to not contain subset #{exp}",
    expected,
    actual,
    showDiff
  );
});
function expect(val, message) {
  return new Assertion(val, message);
}
__name(expect, "expect");
expect.fail = function(actual, expected, message, operator) {
  throw arguments.length < 2 && (message = actual, actual = void 0), message = message || "expect.fail()", new AssertionError(
    message,
    {
      actual,
      expected,
      operator
    },
    expect.fail
  );
};
var should_exports = {};
__export2(should_exports, {
  Should: () => Should,
  should: () => should
});
function loadShould() {
  function shouldGetter() {
    return this instanceof String || this instanceof Number || this instanceof Boolean || typeof Symbol == "function" && this instanceof Symbol || typeof BigInt == "function" && this instanceof BigInt ? new Assertion(this.valueOf(), null, shouldGetter) : new Assertion(this, null, shouldGetter);
  }
  __name(shouldGetter, "shouldGetter");
  function shouldSetter(value) {
    Object.defineProperty(this, "should", {
      value,
      enumerable: !0,
      configurable: !0,
      writable: !0
    });
  }
  __name(shouldSetter, "shouldSetter"), Object.defineProperty(Object.prototype, "should", {
    set: shouldSetter,
    get: shouldGetter,
    configurable: !0
  });
  let should2 = {};
  return should2.fail = function(actual, expected, message, operator) {
    throw arguments.length < 2 && (message = actual, actual = void 0), message = message || "should.fail()", new AssertionError(
      message,
      {
        actual,
        expected,
        operator
      },
      should2.fail
    );
  }, should2.equal = function(actual, expected, message) {
    new Assertion(actual, message).to.equal(expected);
  }, should2.Throw = function(fn3, errt, errs, msg) {
    new Assertion(fn3, msg).to.Throw(errt, errs);
  }, should2.exist = function(val, msg) {
    new Assertion(val, msg).to.exist;
  }, should2.not = {}, should2.not.equal = function(actual, expected, msg) {
    new Assertion(actual, msg).to.not.equal(expected);
  }, should2.not.Throw = function(fn3, errt, errs, msg) {
    new Assertion(fn3, msg).to.not.Throw(errt, errs);
  }, should2.not.exist = function(val, msg) {
    new Assertion(val, msg).to.not.exist;
  }, should2.throw = should2.Throw, should2.not.throw = should2.not.Throw, should2;
}
__name(loadShould, "loadShould");
var should = loadShould, Should = loadShould;
function assert(express, errmsg) {
  new Assertion(null, null, assert, !0).assert(express, errmsg, "[ negation message unavailable ]");
}
__name(assert, "assert");
assert.fail = function(actual, expected, message, operator) {
  throw arguments.length < 2 && (message = actual, actual = void 0), message = message || "assert.fail()", new AssertionError(
    message,
    {
      actual,
      expected,
      operator
    },
    assert.fail
  );
};
assert.isOk = function(val, msg) {
  new Assertion(val, msg, assert.isOk, !0).is.ok;
};
assert.isNotOk = function(val, msg) {
  new Assertion(val, msg, assert.isNotOk, !0).is.not.ok;
};
assert.equal = function(act, exp, msg) {
  let test22 = new Assertion(act, msg, assert.equal, !0);
  test22.assert(
    exp == flag(test22, "object"),
    "expected #{this} to equal #{exp}",
    "expected #{this} to not equal #{act}",
    exp,
    act,
    !0
  );
};
assert.notEqual = function(act, exp, msg) {
  let test22 = new Assertion(act, msg, assert.notEqual, !0);
  test22.assert(
    exp != flag(test22, "object"),
    "expected #{this} to not equal #{exp}",
    "expected #{this} to equal #{act}",
    exp,
    act,
    !0
  );
};
assert.strictEqual = function(act, exp, msg) {
  new Assertion(act, msg, assert.strictEqual, !0).to.equal(exp);
};
assert.notStrictEqual = function(act, exp, msg) {
  new Assertion(act, msg, assert.notStrictEqual, !0).to.not.equal(exp);
};
assert.deepEqual = assert.deepStrictEqual = function(act, exp, msg) {
  new Assertion(act, msg, assert.deepEqual, !0).to.eql(exp);
};
assert.notDeepEqual = function(act, exp, msg) {
  new Assertion(act, msg, assert.notDeepEqual, !0).to.not.eql(exp);
};
assert.isAbove = function(val, abv, msg) {
  new Assertion(val, msg, assert.isAbove, !0).to.be.above(abv);
};
assert.isAtLeast = function(val, atlst, msg) {
  new Assertion(val, msg, assert.isAtLeast, !0).to.be.least(atlst);
};
assert.isBelow = function(val, blw, msg) {
  new Assertion(val, msg, assert.isBelow, !0).to.be.below(blw);
};
assert.isAtMost = function(val, atmst, msg) {
  new Assertion(val, msg, assert.isAtMost, !0).to.be.most(atmst);
};
assert.isTrue = function(val, msg) {
  new Assertion(val, msg, assert.isTrue, !0).is.true;
};
assert.isNotTrue = function(val, msg) {
  new Assertion(val, msg, assert.isNotTrue, !0).to.not.equal(!0);
};
assert.isFalse = function(val, msg) {
  new Assertion(val, msg, assert.isFalse, !0).is.false;
};
assert.isNotFalse = function(val, msg) {
  new Assertion(val, msg, assert.isNotFalse, !0).to.not.equal(!1);
};
assert.isNull = function(val, msg) {
  new Assertion(val, msg, assert.isNull, !0).to.equal(null);
};
assert.isNotNull = function(val, msg) {
  new Assertion(val, msg, assert.isNotNull, !0).to.not.equal(null);
};
assert.isNaN = function(val, msg) {
  new Assertion(val, msg, assert.isNaN, !0).to.be.NaN;
};
assert.isNotNaN = function(value, message) {
  new Assertion(value, message, assert.isNotNaN, !0).not.to.be.NaN;
};
assert.exists = function(val, msg) {
  new Assertion(val, msg, assert.exists, !0).to.exist;
};
assert.notExists = function(val, msg) {
  new Assertion(val, msg, assert.notExists, !0).to.not.exist;
};
assert.isUndefined = function(val, msg) {
  new Assertion(val, msg, assert.isUndefined, !0).to.equal(void 0);
};
assert.isDefined = function(val, msg) {
  new Assertion(val, msg, assert.isDefined, !0).to.not.equal(void 0);
};
assert.isCallable = function(value, message) {
  new Assertion(value, message, assert.isCallable, !0).is.callable;
};
assert.isNotCallable = function(value, message) {
  new Assertion(value, message, assert.isNotCallable, !0).is.not.callable;
};
assert.isObject = function(val, msg) {
  new Assertion(val, msg, assert.isObject, !0).to.be.a("object");
};
assert.isNotObject = function(val, msg) {
  new Assertion(val, msg, assert.isNotObject, !0).to.not.be.a("object");
};
assert.isArray = function(val, msg) {
  new Assertion(val, msg, assert.isArray, !0).to.be.an("array");
};
assert.isNotArray = function(val, msg) {
  new Assertion(val, msg, assert.isNotArray, !0).to.not.be.an("array");
};
assert.isString = function(val, msg) {
  new Assertion(val, msg, assert.isString, !0).to.be.a("string");
};
assert.isNotString = function(val, msg) {
  new Assertion(val, msg, assert.isNotString, !0).to.not.be.a("string");
};
assert.isNumber = function(val, msg) {
  new Assertion(val, msg, assert.isNumber, !0).to.be.a("number");
};
assert.isNotNumber = function(val, msg) {
  new Assertion(val, msg, assert.isNotNumber, !0).to.not.be.a("number");
};
assert.isNumeric = function(val, msg) {
  new Assertion(val, msg, assert.isNumeric, !0).is.numeric;
};
assert.isNotNumeric = function(val, msg) {
  new Assertion(val, msg, assert.isNotNumeric, !0).is.not.numeric;
};
assert.isFinite = function(val, msg) {
  new Assertion(val, msg, assert.isFinite, !0).to.be.finite;
};
assert.isBoolean = function(val, msg) {
  new Assertion(val, msg, assert.isBoolean, !0).to.be.a("boolean");
};
assert.isNotBoolean = function(val, msg) {
  new Assertion(val, msg, assert.isNotBoolean, !0).to.not.be.a("boolean");
};
assert.typeOf = function(val, type32, msg) {
  new Assertion(val, msg, assert.typeOf, !0).to.be.a(type32);
};
assert.notTypeOf = function(value, type32, message) {
  new Assertion(value, message, assert.notTypeOf, !0).to.not.be.a(type32);
};
assert.instanceOf = function(val, type32, msg) {
  new Assertion(val, msg, assert.instanceOf, !0).to.be.instanceOf(type32);
};
assert.notInstanceOf = function(val, type32, msg) {
  new Assertion(val, msg, assert.notInstanceOf, !0).to.not.be.instanceOf(
    type32
  );
};
assert.include = function(exp, inc, msg) {
  new Assertion(exp, msg, assert.include, !0).include(inc);
};
assert.notInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert.notInclude, !0).not.include(inc);
};
assert.deepInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert.deepInclude, !0).deep.include(inc);
};
assert.notDeepInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert.notDeepInclude, !0).not.deep.include(inc);
};
assert.nestedInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert.nestedInclude, !0).nested.include(inc);
};
assert.notNestedInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert.notNestedInclude, !0).not.nested.include(
    inc
  );
};
assert.deepNestedInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert.deepNestedInclude, !0).deep.nested.include(
    inc
  );
};
assert.notDeepNestedInclude = function(exp, inc, msg) {
  new Assertion(
    exp,
    msg,
    assert.notDeepNestedInclude,
    !0
  ).not.deep.nested.include(inc);
};
assert.ownInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert.ownInclude, !0).own.include(inc);
};
assert.notOwnInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert.notOwnInclude, !0).not.own.include(inc);
};
assert.deepOwnInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert.deepOwnInclude, !0).deep.own.include(inc);
};
assert.notDeepOwnInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert.notDeepOwnInclude, !0).not.deep.own.include(
    inc
  );
};
assert.match = function(exp, re, msg) {
  new Assertion(exp, msg, assert.match, !0).to.match(re);
};
assert.notMatch = function(exp, re, msg) {
  new Assertion(exp, msg, assert.notMatch, !0).to.not.match(re);
};
assert.property = function(obj, prop, msg) {
  new Assertion(obj, msg, assert.property, !0).to.have.property(prop);
};
assert.notProperty = function(obj, prop, msg) {
  new Assertion(obj, msg, assert.notProperty, !0).to.not.have.property(prop);
};
assert.propertyVal = function(obj, prop, val, msg) {
  new Assertion(obj, msg, assert.propertyVal, !0).to.have.property(prop, val);
};
assert.notPropertyVal = function(obj, prop, val, msg) {
  new Assertion(obj, msg, assert.notPropertyVal, !0).to.not.have.property(
    prop,
    val
  );
};
assert.deepPropertyVal = function(obj, prop, val, msg) {
  new Assertion(obj, msg, assert.deepPropertyVal, !0).to.have.deep.property(
    prop,
    val
  );
};
assert.notDeepPropertyVal = function(obj, prop, val, msg) {
  new Assertion(
    obj,
    msg,
    assert.notDeepPropertyVal,
    !0
  ).to.not.have.deep.property(prop, val);
};
assert.ownProperty = function(obj, prop, msg) {
  new Assertion(obj, msg, assert.ownProperty, !0).to.have.own.property(prop);
};
assert.notOwnProperty = function(obj, prop, msg) {
  new Assertion(obj, msg, assert.notOwnProperty, !0).to.not.have.own.property(
    prop
  );
};
assert.ownPropertyVal = function(obj, prop, value, msg) {
  new Assertion(obj, msg, assert.ownPropertyVal, !0).to.have.own.property(
    prop,
    value
  );
};
assert.notOwnPropertyVal = function(obj, prop, value, msg) {
  new Assertion(
    obj,
    msg,
    assert.notOwnPropertyVal,
    !0
  ).to.not.have.own.property(prop, value);
};
assert.deepOwnPropertyVal = function(obj, prop, value, msg) {
  new Assertion(
    obj,
    msg,
    assert.deepOwnPropertyVal,
    !0
  ).to.have.deep.own.property(prop, value);
};
assert.notDeepOwnPropertyVal = function(obj, prop, value, msg) {
  new Assertion(
    obj,
    msg,
    assert.notDeepOwnPropertyVal,
    !0
  ).to.not.have.deep.own.property(prop, value);
};
assert.nestedProperty = function(obj, prop, msg) {
  new Assertion(obj, msg, assert.nestedProperty, !0).to.have.nested.property(
    prop
  );
};
assert.notNestedProperty = function(obj, prop, msg) {
  new Assertion(
    obj,
    msg,
    assert.notNestedProperty,
    !0
  ).to.not.have.nested.property(prop);
};
assert.nestedPropertyVal = function(obj, prop, val, msg) {
  new Assertion(
    obj,
    msg,
    assert.nestedPropertyVal,
    !0
  ).to.have.nested.property(prop, val);
};
assert.notNestedPropertyVal = function(obj, prop, val, msg) {
  new Assertion(
    obj,
    msg,
    assert.notNestedPropertyVal,
    !0
  ).to.not.have.nested.property(prop, val);
};
assert.deepNestedPropertyVal = function(obj, prop, val, msg) {
  new Assertion(
    obj,
    msg,
    assert.deepNestedPropertyVal,
    !0
  ).to.have.deep.nested.property(prop, val);
};
assert.notDeepNestedPropertyVal = function(obj, prop, val, msg) {
  new Assertion(
    obj,
    msg,
    assert.notDeepNestedPropertyVal,
    !0
  ).to.not.have.deep.nested.property(prop, val);
};
assert.lengthOf = function(exp, len, msg) {
  new Assertion(exp, msg, assert.lengthOf, !0).to.have.lengthOf(len);
};
assert.hasAnyKeys = function(obj, keys2, msg) {
  new Assertion(obj, msg, assert.hasAnyKeys, !0).to.have.any.keys(keys2);
};
assert.hasAllKeys = function(obj, keys2, msg) {
  new Assertion(obj, msg, assert.hasAllKeys, !0).to.have.all.keys(keys2);
};
assert.containsAllKeys = function(obj, keys2, msg) {
  new Assertion(obj, msg, assert.containsAllKeys, !0).to.contain.all.keys(
    keys2
  );
};
assert.doesNotHaveAnyKeys = function(obj, keys2, msg) {
  new Assertion(obj, msg, assert.doesNotHaveAnyKeys, !0).to.not.have.any.keys(
    keys2
  );
};
assert.doesNotHaveAllKeys = function(obj, keys2, msg) {
  new Assertion(obj, msg, assert.doesNotHaveAllKeys, !0).to.not.have.all.keys(
    keys2
  );
};
assert.hasAnyDeepKeys = function(obj, keys2, msg) {
  new Assertion(obj, msg, assert.hasAnyDeepKeys, !0).to.have.any.deep.keys(
    keys2
  );
};
assert.hasAllDeepKeys = function(obj, keys2, msg) {
  new Assertion(obj, msg, assert.hasAllDeepKeys, !0).to.have.all.deep.keys(
    keys2
  );
};
assert.containsAllDeepKeys = function(obj, keys2, msg) {
  new Assertion(
    obj,
    msg,
    assert.containsAllDeepKeys,
    !0
  ).to.contain.all.deep.keys(keys2);
};
assert.doesNotHaveAnyDeepKeys = function(obj, keys2, msg) {
  new Assertion(
    obj,
    msg,
    assert.doesNotHaveAnyDeepKeys,
    !0
  ).to.not.have.any.deep.keys(keys2);
};
assert.doesNotHaveAllDeepKeys = function(obj, keys2, msg) {
  new Assertion(
    obj,
    msg,
    assert.doesNotHaveAllDeepKeys,
    !0
  ).to.not.have.all.deep.keys(keys2);
};
assert.throws = function(fn3, errorLike, errMsgMatcher, msg) {
  (typeof errorLike == "string" || errorLike instanceof RegExp) && (errMsgMatcher = errorLike, errorLike = null);
  let assertErr = new Assertion(fn3, msg, assert.throws, !0).to.throw(
    errorLike,
    errMsgMatcher
  );
  return flag(assertErr, "object");
};
assert.doesNotThrow = function(fn3, errorLike, errMsgMatcher, message) {
  (typeof errorLike == "string" || errorLike instanceof RegExp) && (errMsgMatcher = errorLike, errorLike = null), new Assertion(fn3, message, assert.doesNotThrow, !0).to.not.throw(
    errorLike,
    errMsgMatcher
  );
};
assert.operator = function(val, operator, val2, msg) {
  let ok;
  switch (operator) {
    case "==":
      ok = val == val2;
      break;
    case "===":
      ok = val === val2;
      break;
    case ">":
      ok = val > val2;
      break;
    case ">=":
      ok = val >= val2;
      break;
    case "<":
      ok = val < val2;
      break;
    case "<=":
      ok = val <= val2;
      break;
    case "!=":
      ok = val != val2;
      break;
    case "!==":
      ok = val !== val2;
      break;
    default:
      throw msg = msg && msg + ": ", new AssertionError(
        msg + 'Invalid operator "' + operator + '"',
        void 0,
        assert.operator
      );
  }
  let test22 = new Assertion(ok, msg, assert.operator, !0);
  test22.assert(
    flag(test22, "object") === !0,
    "expected " + inspect22(val) + " to be " + operator + " " + inspect22(val2),
    "expected " + inspect22(val) + " to not be " + operator + " " + inspect22(val2)
  );
};
assert.closeTo = function(act, exp, delta, msg) {
  new Assertion(act, msg, assert.closeTo, !0).to.be.closeTo(exp, delta);
};
assert.approximately = function(act, exp, delta, msg) {
  new Assertion(act, msg, assert.approximately, !0).to.be.approximately(
    exp,
    delta
  );
};
assert.sameMembers = function(set1, set2, msg) {
  new Assertion(set1, msg, assert.sameMembers, !0).to.have.same.members(set2);
};
assert.notSameMembers = function(set1, set2, msg) {
  new Assertion(
    set1,
    msg,
    assert.notSameMembers,
    !0
  ).to.not.have.same.members(set2);
};
assert.sameDeepMembers = function(set1, set2, msg) {
  new Assertion(
    set1,
    msg,
    assert.sameDeepMembers,
    !0
  ).to.have.same.deep.members(set2);
};
assert.notSameDeepMembers = function(set1, set2, msg) {
  new Assertion(
    set1,
    msg,
    assert.notSameDeepMembers,
    !0
  ).to.not.have.same.deep.members(set2);
};
assert.sameOrderedMembers = function(set1, set2, msg) {
  new Assertion(
    set1,
    msg,
    assert.sameOrderedMembers,
    !0
  ).to.have.same.ordered.members(set2);
};
assert.notSameOrderedMembers = function(set1, set2, msg) {
  new Assertion(
    set1,
    msg,
    assert.notSameOrderedMembers,
    !0
  ).to.not.have.same.ordered.members(set2);
};
assert.sameDeepOrderedMembers = function(set1, set2, msg) {
  new Assertion(
    set1,
    msg,
    assert.sameDeepOrderedMembers,
    !0
  ).to.have.same.deep.ordered.members(set2);
};
assert.notSameDeepOrderedMembers = function(set1, set2, msg) {
  new Assertion(
    set1,
    msg,
    assert.notSameDeepOrderedMembers,
    !0
  ).to.not.have.same.deep.ordered.members(set2);
};
assert.includeMembers = function(superset, subset, msg) {
  new Assertion(superset, msg, assert.includeMembers, !0).to.include.members(
    subset
  );
};
assert.notIncludeMembers = function(superset, subset, msg) {
  new Assertion(
    superset,
    msg,
    assert.notIncludeMembers,
    !0
  ).to.not.include.members(subset);
};
assert.includeDeepMembers = function(superset, subset, msg) {
  new Assertion(
    superset,
    msg,
    assert.includeDeepMembers,
    !0
  ).to.include.deep.members(subset);
};
assert.notIncludeDeepMembers = function(superset, subset, msg) {
  new Assertion(
    superset,
    msg,
    assert.notIncludeDeepMembers,
    !0
  ).to.not.include.deep.members(subset);
};
assert.includeOrderedMembers = function(superset, subset, msg) {
  new Assertion(
    superset,
    msg,
    assert.includeOrderedMembers,
    !0
  ).to.include.ordered.members(subset);
};
assert.notIncludeOrderedMembers = function(superset, subset, msg) {
  new Assertion(
    superset,
    msg,
    assert.notIncludeOrderedMembers,
    !0
  ).to.not.include.ordered.members(subset);
};
assert.includeDeepOrderedMembers = function(superset, subset, msg) {
  new Assertion(
    superset,
    msg,
    assert.includeDeepOrderedMembers,
    !0
  ).to.include.deep.ordered.members(subset);
};
assert.notIncludeDeepOrderedMembers = function(superset, subset, msg) {
  new Assertion(
    superset,
    msg,
    assert.notIncludeDeepOrderedMembers,
    !0
  ).to.not.include.deep.ordered.members(subset);
};
assert.oneOf = function(inList, list, msg) {
  new Assertion(inList, msg, assert.oneOf, !0).to.be.oneOf(list);
};
assert.isIterable = function(obj, msg) {
  if (obj == null || !obj[Symbol.iterator])
    throw msg = msg ? `${msg} expected ${inspect22(obj)} to be an iterable` : `expected ${inspect22(obj)} to be an iterable`, new AssertionError(msg, void 0, assert.isIterable);
};
assert.changes = function(fn3, obj, prop, msg) {
  arguments.length === 3 && typeof obj == "function" && (msg = prop, prop = null), new Assertion(fn3, msg, assert.changes, !0).to.change(obj, prop);
};
assert.changesBy = function(fn3, obj, prop, delta, msg) {
  if (arguments.length === 4 && typeof obj == "function") {
    let tmpMsg = delta;
    delta = prop, msg = tmpMsg;
  } else arguments.length === 3 && (delta = prop, prop = null);
  new Assertion(fn3, msg, assert.changesBy, !0).to.change(obj, prop).by(delta);
};
assert.doesNotChange = function(fn3, obj, prop, msg) {
  return arguments.length === 3 && typeof obj == "function" && (msg = prop, prop = null), new Assertion(fn3, msg, assert.doesNotChange, !0).to.not.change(
    obj,
    prop
  );
};
assert.changesButNotBy = function(fn3, obj, prop, delta, msg) {
  if (arguments.length === 4 && typeof obj == "function") {
    let tmpMsg = delta;
    delta = prop, msg = tmpMsg;
  } else arguments.length === 3 && (delta = prop, prop = null);
  new Assertion(fn3, msg, assert.changesButNotBy, !0).to.change(obj, prop).but.not.by(delta);
};
assert.increases = function(fn3, obj, prop, msg) {
  return arguments.length === 3 && typeof obj == "function" && (msg = prop, prop = null), new Assertion(fn3, msg, assert.increases, !0).to.increase(obj, prop);
};
assert.increasesBy = function(fn3, obj, prop, delta, msg) {
  if (arguments.length === 4 && typeof obj == "function") {
    let tmpMsg = delta;
    delta = prop, msg = tmpMsg;
  } else arguments.length === 3 && (delta = prop, prop = null);
  new Assertion(fn3, msg, assert.increasesBy, !0).to.increase(obj, prop).by(delta);
};
assert.doesNotIncrease = function(fn3, obj, prop, msg) {
  return arguments.length === 3 && typeof obj == "function" && (msg = prop, prop = null), new Assertion(fn3, msg, assert.doesNotIncrease, !0).to.not.increase(
    obj,
    prop
  );
};
assert.increasesButNotBy = function(fn3, obj, prop, delta, msg) {
  if (arguments.length === 4 && typeof obj == "function") {
    let tmpMsg = delta;
    delta = prop, msg = tmpMsg;
  } else arguments.length === 3 && (delta = prop, prop = null);
  new Assertion(fn3, msg, assert.increasesButNotBy, !0).to.increase(obj, prop).but.not.by(delta);
};
assert.decreases = function(fn3, obj, prop, msg) {
  return arguments.length === 3 && typeof obj == "function" && (msg = prop, prop = null), new Assertion(fn3, msg, assert.decreases, !0).to.decrease(obj, prop);
};
assert.decreasesBy = function(fn3, obj, prop, delta, msg) {
  if (arguments.length === 4 && typeof obj == "function") {
    let tmpMsg = delta;
    delta = prop, msg = tmpMsg;
  } else arguments.length === 3 && (delta = prop, prop = null);
  new Assertion(fn3, msg, assert.decreasesBy, !0).to.decrease(obj, prop).by(delta);
};
assert.doesNotDecrease = function(fn3, obj, prop, msg) {
  return arguments.length === 3 && typeof obj == "function" && (msg = prop, prop = null), new Assertion(fn3, msg, assert.doesNotDecrease, !0).to.not.decrease(
    obj,
    prop
  );
};
assert.doesNotDecreaseBy = function(fn3, obj, prop, delta, msg) {
  if (arguments.length === 4 && typeof obj == "function") {
    let tmpMsg = delta;
    delta = prop, msg = tmpMsg;
  } else arguments.length === 3 && (delta = prop, prop = null);
  return new Assertion(fn3, msg, assert.doesNotDecreaseBy, !0).to.not.decrease(obj, prop).by(delta);
};
assert.decreasesButNotBy = function(fn3, obj, prop, delta, msg) {
  if (arguments.length === 4 && typeof obj == "function") {
    let tmpMsg = delta;
    delta = prop, msg = tmpMsg;
  } else arguments.length === 3 && (delta = prop, prop = null);
  new Assertion(fn3, msg, assert.decreasesButNotBy, !0).to.decrease(obj, prop).but.not.by(delta);
};
assert.ifError = function(val) {
  if (val)
    throw val;
};
assert.isExtensible = function(obj, msg) {
  new Assertion(obj, msg, assert.isExtensible, !0).to.be.extensible;
};
assert.isNotExtensible = function(obj, msg) {
  new Assertion(obj, msg, assert.isNotExtensible, !0).to.not.be.extensible;
};
assert.isSealed = function(obj, msg) {
  new Assertion(obj, msg, assert.isSealed, !0).to.be.sealed;
};
assert.isNotSealed = function(obj, msg) {
  new Assertion(obj, msg, assert.isNotSealed, !0).to.not.be.sealed;
};
assert.isFrozen = function(obj, msg) {
  new Assertion(obj, msg, assert.isFrozen, !0).to.be.frozen;
};
assert.isNotFrozen = function(obj, msg) {
  new Assertion(obj, msg, assert.isNotFrozen, !0).to.not.be.frozen;
};
assert.isEmpty = function(val, msg) {
  new Assertion(val, msg, assert.isEmpty, !0).to.be.empty;
};
assert.isNotEmpty = function(val, msg) {
  new Assertion(val, msg, assert.isNotEmpty, !0).to.not.be.empty;
};
assert.containsSubset = function(val, exp, msg) {
  new Assertion(val, msg).to.containSubset(exp);
};
assert.doesNotContainSubset = function(val, exp, msg) {
  new Assertion(val, msg).to.not.containSubset(exp);
};
var aliases = [
  ["isOk", "ok"],
  ["isNotOk", "notOk"],
  ["throws", "throw"],
  ["throws", "Throw"],
  ["isExtensible", "extensible"],
  ["isNotExtensible", "notExtensible"],
  ["isSealed", "sealed"],
  ["isNotSealed", "notSealed"],
  ["isFrozen", "frozen"],
  ["isNotFrozen", "notFrozen"],
  ["isEmpty", "empty"],
  ["isNotEmpty", "notEmpty"],
  ["isCallable", "isFunction"],
  ["isNotCallable", "isNotFunction"],
  ["containsSubset", "containSubset"]
];
for (let [name, as] of aliases)
  assert[as] = assert[name];
var used = [];
function use(fn3) {
  let exports = {
    use,
    AssertionError,
    util: utils_exports,
    config,
    expect,
    assert,
    Assertion,
    ...should_exports
  };
  return ~used.indexOf(fn3) || (fn3(exports, utils_exports), used.push(fn3)), exports;
}
__name(use, "use");

// ../node_modules/@testing-library/jest-dom/dist/matchers.mjs
var matchers_exports = {};
__export(matchers_exports, {
  toAppearAfter: () => toAppearAfter,
  toAppearBefore: () => toAppearBefore,
  toBeChecked: () => toBeChecked,
  toBeDisabled: () => toBeDisabled,
  toBeEmpty: () => toBeEmpty,
  toBeEmptyDOMElement: () => toBeEmptyDOMElement,
  toBeEnabled: () => toBeEnabled,
  toBeInTheDOM: () => toBeInTheDOM,
  toBeInTheDocument: () => toBeInTheDocument,
  toBeInvalid: () => toBeInvalid,
  toBePartiallyChecked: () => toBePartiallyChecked,
  toBePartiallyPressed: () => toBePartiallyPressed,
  toBePressed: () => toBePressed,
  toBeRequired: () => toBeRequired,
  toBeValid: () => toBeValid,
  toBeVisible: () => toBeVisible,
  toContainElement: () => toContainElement,
  toContainHTML: () => toContainHTML,
  toHaveAccessibleDescription: () => toHaveAccessibleDescription,
  toHaveAccessibleErrorMessage: () => toHaveAccessibleErrorMessage,
  toHaveAccessibleName: () => toHaveAccessibleName,
  toHaveAttribute: () => toHaveAttribute,
  toHaveClass: () => toHaveClass,
  toHaveDescription: () => toHaveDescription,
  toHaveDisplayValue: () => toHaveDisplayValue,
  toHaveErrorMessage: () => toHaveErrorMessage,
  toHaveFocus: () => toHaveFocus,
  toHaveFormValues: () => toHaveFormValues,
  toHaveRole: () => toHaveRole,
  toHaveSelection: () => toHaveSelection,
  toHaveStyle: () => toHaveStyle,
  toHaveTextContent: () => toHaveTextContent,
  toHaveValue: () => toHaveValue
});

// ../node_modules/@testing-library/jest-dom/dist/matchers-35e4d3bd.mjs
var import_redent = __toESM(require_redent(), 1);

// ../node_modules/@adobe/css-tools/dist/esm/adobe-css-tools.mjs
var t = class extends Error {
  reason;
  filename;
  line;
  column;
  source;
  constructor(t2, e2, i2, s3, n2) {
    super(`${t2}:${i2}:${s3}: ${e2}`), this.reason = e2, this.filename = t2, this.line = i2, this.column = s3, this.source = n2;
  }
}, e = class {
  start;
  end;
  source;
  constructor(t2, e2, i2) {
    this.start = t2, this.end = e2, this.source = i2;
  }
}, i;
(function(t2) {
  t2.stylesheet = "stylesheet", t2.rule = "rule", t2.declaration = "declaration", t2.comment = "comment", t2.container = "container", t2.charset = "charset", t2.document = "document", t2.customMedia = "custom-media", t2.fontFace = "font-face", t2.host = "host", t2.import = "import", t2.keyframes = "keyframes", t2.keyframe = "keyframe", t2.layer = "layer", t2.media = "media", t2.namespace = "namespace", t2.page = "page", t2.startingStyle = "starting-style", t2.supports = "supports";
})(i || (i = {}));
var s2 = (t2, e2, i2) => {
  let s3 = i2, n2 = 1e4;
  do {
    let i3 = e2.map((e3) => t2.indexOf(e3, s3));
    i3.push(t2.indexOf("\\", s3));
    let r2 = i3.filter((t3) => t3 !== -1);
    if (r2.length === 0) return -1;
    let o2 = Math.min(...r2);
    if (t2[o2] !== "\\") return o2;
    s3 = o2 + 2, n2--;
  } while (n2 > 0);
  throw new Error("Too many escaping");
}, n = (t2, e2, i2) => {
  let r2 = i2, o2 = 1e4;
  do {
    let i3 = e2.map((e3) => t2.indexOf(e3, r2));
    i3.push(t2.indexOf("(", r2)), i3.push(t2.indexOf('"', r2)), i3.push(t2.indexOf("'", r2)), i3.push(t2.indexOf("\\", r2));
    let c2 = i3.filter((t3) => t3 !== -1);
    if (c2.length === 0) return -1;
    let a2 = Math.min(...c2);
    switch (t2[a2]) {
      case "\\":
        r2 = a2 + 2;
        break;
      case "(":
        {
          let e3 = n(t2, [")"], a2 + 1);
          if (e3 === -1) return -1;
          r2 = e3 + 1;
        }
        break;
      case '"':
        {
          let e3 = s2(t2, ['"'], a2 + 1);
          if (e3 === -1) return -1;
          r2 = e3 + 1;
        }
        break;
      case "'":
        {
          let e3 = s2(t2, ["'"], a2 + 1);
          if (e3 === -1) return -1;
          r2 = e3 + 1;
        }
        break;
      default:
        return a2;
    }
    o2--;
  } while (o2 > 0);
  throw new Error("Too many escaping");
}, r = /\/\*[^]*?(?:\*\/|$)/g;
function o(t2) {
  return t2 ? t2.trim() : "";
}
function c(t2, e2) {
  let i2 = t2 && typeof t2.type == "string", s3 = i2 ? t2 : e2;
  for (let e3 in t2) {
    let i3 = t2[e3];
    Array.isArray(i3) ? i3.forEach((t3) => {
      c(t3, s3);
    }) : i3 && typeof i3 == "object" && c(i3, s3);
  }
  return i2 && Object.defineProperty(t2, "parent", { configurable: !0, writable: !0, enumerable: !1, value: e2 || null }), t2;
}
var m2 = (s3, a2) => {
  a2 = a2 || {};
  let m3 = 1, h3 = 1;
  function u3() {
    let t2 = { line: m3, column: h3 };
    return (i2) => (i2.position = new e(t2, { line: m3, column: h3 }, a2?.source || ""), $(), i2);
  }
  let p2 = [];
  function l2(e2) {
    let i2 = new t(a2?.source || "", e2, m3, h3, s3);
    if (!a2?.silent) throw i2;
    p2.push(i2);
  }
  function f4() {
    let t2 = /^{\s*/.exec(s3);
    return !!t2 && (g2(t2), !0);
  }
  function d() {
    let t2 = /^}/.exec(s3);
    return !!t2 && (g2(t2), !0);
  }
  function y2() {
    let t2, e2 = [];
    for ($(), x2(e2); s3.length && s3.charAt(0) !== "}" && (t2 = A() || S2(), t2); ) e2.push(t2), x2(e2);
    return e2;
  }
  function g2(t2) {
    let e2 = t2[0];
    return (function(t3) {
      let e3 = t3.match(/\n/g);
      e3 && (m3 += e3.length);
      let i2 = t3.lastIndexOf(`
`);
      h3 = ~i2 ? t3.length - i2 : h3 + t3.length;
    })(e2), s3 = s3.slice(e2.length), t2;
  }
  function $() {
    let t2 = /^\s*/.exec(s3);
    t2 && g2(t2);
  }
  function x2(t2) {
    t2 = t2 || [];
    let e2 = V();
    for (; e2; ) t2.push(e2), e2 = V();
    return t2;
  }
  function V() {
    let t2 = u3();
    if (s3.charAt(0) !== "/" || s3.charAt(1) !== "*") return;
    let e2 = /^\/\*[^]*?\*\//.exec(s3);
    return e2 ? (g2(e2), t2({ type: i.comment, comment: e2[0].slice(2, -2) })) : l2("End of comment missing");
  }
  function k2() {
    let t2 = /^([^{]+)/.exec(s3);
    if (t2)
      return g2(t2), ((t3, e2) => {
        let i2 = [], s4 = 0;
        for (; s4 < t3.length; ) {
          let r2 = n(t3, e2, s4);
          if (r2 === -1) return i2.push(t3.substring(s4)), i2;
          i2.push(t3.substring(s4, r2)), s4 = r2 + 1;
        }
        return i2;
      })(o(t2[0]).replace(r, ""), [","]).map((t3) => o(t3));
  }
  function v2() {
    let t2 = u3(), e2 = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/.exec(s3);
    if (!e2) return;
    g2(e2);
    let c2 = o(e2[0]), a3 = /^:\s*/.exec(s3);
    if (!a3) return l2("property missing ':'");
    g2(a3);
    let m4 = "", h4 = n(s3, [";", "}"]);
    h4 !== -1 && (m4 = s3.substring(0, h4), g2([m4]), m4 = o(m4).replace(r, ""));
    let p3 = t2({ type: i.declaration, property: c2.replace(r, ""), value: m4 }), f5 = /^[;\s]*/.exec(s3);
    return f5 && g2(f5), p3;
  }
  function w2() {
    let t2 = [];
    if (!f4()) return l2("missing '{'");
    x2(t2);
    let e2 = v2();
    for (; e2; ) t2.push(e2), x2(t2), e2 = v2();
    return d() ? t2 : l2("missing '}'");
  }
  function b2() {
    let t2 = [], e2 = u3(), n2 = /^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/.exec(s3);
    for (; n2; ) {
      let e3 = g2(n2);
      t2.push(e3[1]);
      let i2 = /^,\s*/.exec(s3);
      i2 && g2(i2), n2 = /^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/.exec(s3);
    }
    if (t2.length) return e2({ type: i.keyframe, values: t2, declarations: w2() || [] });
  }
  let j2 = M2("import"), O = M2("charset"), E2 = M2("namespace");
  function M2(t2) {
    let e2 = new RegExp("^@" + t2 + `\\s*((?::?[^;'"]|"(?:\\\\"|[^"])*?"|'(?:\\\\'|[^'])*?')+)(?:;|$)`);
    return () => {
      let i2 = u3(), n2 = e2.exec(s3);
      if (!n2) return;
      let r2 = g2(n2), o2 = { type: t2 };
      return o2[t2] = r2[1].trim(), i2(o2);
    };
  }
  function A() {
    if (s3[0] === "@") return (function() {
      let t2 = u3(), e2 = /^@([-\w]+)?keyframes\s*/.exec(s3);
      if (!e2) return;
      let n2 = g2(e2)[1], r2 = /^([-\w]+)\s*/.exec(s3);
      if (!r2) return l2("@keyframes missing name");
      let o2 = g2(r2)[1];
      if (!f4()) return l2("@keyframes missing '{'");
      let c2 = x2(), a3 = b2();
      for (; a3; ) c2.push(a3), c2 = c2.concat(x2()), a3 = b2();
      return d() ? t2({ type: i.keyframes, name: o2, vendor: n2, keyframes: c2 }) : l2("@keyframes missing '}'");
    })() || (function() {
      let t2 = u3(), e2 = /^@media *([^{]+)/.exec(s3);
      if (!e2) return;
      let n2 = o(g2(e2)[1]);
      if (!f4()) return l2("@media missing '{'");
      let r2 = x2().concat(y2());
      return d() ? t2({ type: i.media, media: n2, rules: r2 }) : l2("@media missing '}'");
    })() || (function() {
      let t2 = u3(), e2 = /^@custom-media\s+(--\S+)\s+([^{;\s][^{;]*);/.exec(s3);
      if (!e2) return;
      let n2 = g2(e2);
      return t2({ type: i.customMedia, name: o(n2[1]), media: o(n2[2]) });
    })() || (function() {
      let t2 = u3(), e2 = /^@supports *([^{]+)/.exec(s3);
      if (!e2) return;
      let n2 = o(g2(e2)[1]);
      if (!f4()) return l2("@supports missing '{'");
      let r2 = x2().concat(y2());
      return d() ? t2({ type: i.supports, supports: n2, rules: r2 }) : l2("@supports missing '}'");
    })() || j2() || O() || E2() || (function() {
      let t2 = u3(), e2 = /^@([-\w]+)?document *([^{]+)/.exec(s3);
      if (!e2) return;
      let n2 = g2(e2), r2 = o(n2[1]), c2 = o(n2[2]);
      if (!f4()) return l2("@document missing '{'");
      let a3 = x2().concat(y2());
      return d() ? t2({ type: i.document, document: c2, vendor: r2, rules: a3 }) : l2("@document missing '}'");
    })() || (function() {
      let t2 = u3(), e2 = /^@page */.exec(s3);
      if (!e2) return;
      g2(e2);
      let n2 = k2() || [];
      if (!f4()) return l2("@page missing '{'");
      let r2 = x2(), o2 = v2();
      for (; o2; ) r2.push(o2), r2 = r2.concat(x2()), o2 = v2();
      return d() ? t2({ type: i.page, selectors: n2, declarations: r2 }) : l2("@page missing '}'");
    })() || (function() {
      let t2 = u3(), e2 = /^@host\s*/.exec(s3);
      if (!e2) return;
      if (g2(e2), !f4()) return l2("@host missing '{'");
      let n2 = x2().concat(y2());
      return d() ? t2({ type: i.host, rules: n2 }) : l2("@host missing '}'");
    })() || (function() {
      let t2 = u3(), e2 = /^@font-face\s*/.exec(s3);
      if (!e2) return;
      if (g2(e2), !f4()) return l2("@font-face missing '{'");
      let n2 = x2(), r2 = v2();
      for (; r2; ) n2.push(r2), n2 = n2.concat(x2()), r2 = v2();
      return d() ? t2({ type: i.fontFace, declarations: n2 }) : l2("@font-face missing '}'");
    })() || (function() {
      let t2 = u3(), e2 = /^@container *([^{]+)/.exec(s3);
      if (!e2) return;
      let n2 = o(g2(e2)[1]);
      if (!f4()) return l2("@container missing '{'");
      let r2 = x2().concat(y2());
      return d() ? t2({ type: i.container, container: n2, rules: r2 }) : l2("@container missing '}'");
    })() || (function() {
      let t2 = u3(), e2 = /^@starting-style\s*/.exec(s3);
      if (!e2) return;
      if (g2(e2), !f4()) return l2("@starting-style missing '{'");
      let n2 = x2().concat(y2());
      return d() ? t2({ type: i.startingStyle, rules: n2 }) : l2("@starting-style missing '}'");
    })() || (function() {
      let t2 = u3(), e2 = /^@layer *([^{;@]+)/.exec(s3);
      if (!e2) return;
      let n2 = o(g2(e2)[1]);
      if (!f4()) {
        let e3 = /^[;\s]*/.exec(s3);
        return e3 && g2(e3), t2({ type: i.layer, layer: n2 });
      }
      let r2 = x2().concat(y2());
      return d() ? t2({ type: i.layer, layer: n2, rules: r2 }) : l2("@layer missing '}'");
    })();
  }
  function S2() {
    let t2 = u3(), e2 = k2();
    return e2 ? (x2(), t2({ type: i.rule, selectors: e2, declarations: w2() || [] })) : l2("selector missing");
  }
  return c((function() {
    let t2 = y2();
    return { type: i.stylesheet, stylesheet: { source: a2?.source, rules: t2, parsingErrors: p2 } };
  })());
};

// ../node_modules/@testing-library/jest-dom/node_modules/dom-accessibility-api/dist/polyfills/array.from.mjs
var toStr = Object.prototype.toString;
function isCallable(fn3) {
  return typeof fn3 == "function" || toStr.call(fn3) === "[object Function]";
}
function toInteger(value) {
  var number = Number(value);
  return isNaN(number) ? 0 : number === 0 || !isFinite(number) ? number : (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));
}
var maxSafeInteger = Math.pow(2, 53) - 1;
function toLength(value) {
  var len = toInteger(value);
  return Math.min(Math.max(len, 0), maxSafeInteger);
}
function arrayFrom(arrayLike, mapFn) {
  var C2 = Array, items = Object(arrayLike);
  if (arrayLike == null)
    throw new TypeError("Array.from requires an array-like object - not null or undefined");
  if (typeof mapFn < "u" && !isCallable(mapFn))
    throw new TypeError("Array.from: when provided, the second argument must be a function");
  for (var len = toLength(items.length), A = isCallable(C2) ? Object(new C2(len)) : new Array(len), k2 = 0, kValue; k2 < len; )
    kValue = items[k2], mapFn ? A[k2] = mapFn(kValue, k2) : A[k2] = kValue, k2 += 1;
  return A.length = len, A;
}

// ../node_modules/@testing-library/jest-dom/node_modules/dom-accessibility-api/dist/polyfills/SetLike.mjs
function _typeof(o2) {
  "@babel/helpers - typeof";
  return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && typeof Symbol == "function" && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof(o2);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor))
    throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Object.defineProperty(Constructor, "prototype", { writable: !1 }), Constructor;
}
function _defineProperty(obj, key, value) {
  return key = _toPropertyKey(key), key in obj ? Object.defineProperty(obj, key, { value, enumerable: !0, configurable: !0, writable: !0 }) : obj[key] = value, obj;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
function _toPrimitive(input2, hint) {
  if (_typeof(input2) !== "object" || input2 === null) return input2;
  var prim = input2[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input2, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input2);
}
var SetLike = (function() {
  function SetLike3() {
    var items = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    _classCallCheck(this, SetLike3), _defineProperty(this, "items", void 0), this.items = items;
  }
  return _createClass(SetLike3, [{
    key: "add",
    value: function(value) {
      return this.has(value) === !1 && this.items.push(value), this;
    }
  }, {
    key: "clear",
    value: function() {
      this.items = [];
    }
  }, {
    key: "delete",
    value: function(value) {
      var previousLength = this.items.length;
      return this.items = this.items.filter(function(item) {
        return item !== value;
      }), previousLength !== this.items.length;
    }
  }, {
    key: "forEach",
    value: function(callbackfn) {
      var _this = this;
      this.items.forEach(function(item) {
        callbackfn(item, item, _this);
      });
    }
  }, {
    key: "has",
    value: function(value) {
      return this.items.indexOf(value) !== -1;
    }
  }, {
    key: "size",
    get: function() {
      return this.items.length;
    }
  }]), SetLike3;
})(), SetLike_default = typeof Set > "u" ? Set : SetLike;

// ../node_modules/@testing-library/jest-dom/node_modules/dom-accessibility-api/dist/getRole.mjs
function getLocalName(element) {
  var _element$localName;
  return (
    // eslint-disable-next-line no-restricted-properties -- actual guard for environments without localName
    (_element$localName = element.localName) !== null && _element$localName !== void 0 ? _element$localName : (
      // eslint-disable-next-line no-restricted-properties -- required for the fallback
      element.tagName.toLowerCase()
    )
  );
}
var localNameToRoleMappings = {
  article: "article",
  aside: "complementary",
  button: "button",
  datalist: "listbox",
  dd: "definition",
  details: "group",
  dialog: "dialog",
  dt: "term",
  fieldset: "group",
  figure: "figure",
  // WARNING: Only with an accessible name
  form: "form",
  footer: "contentinfo",
  h1: "heading",
  h2: "heading",
  h3: "heading",
  h4: "heading",
  h5: "heading",
  h6: "heading",
  header: "banner",
  hr: "separator",
  html: "document",
  legend: "legend",
  li: "listitem",
  math: "math",
  main: "main",
  menu: "list",
  nav: "navigation",
  ol: "list",
  optgroup: "group",
  // WARNING: Only in certain context
  option: "option",
  output: "status",
  progress: "progressbar",
  // WARNING: Only with an accessible name
  section: "region",
  summary: "button",
  table: "table",
  tbody: "rowgroup",
  textarea: "textbox",
  tfoot: "rowgroup",
  // WARNING: Only in certain context
  td: "cell",
  th: "columnheader",
  thead: "rowgroup",
  tr: "row",
  ul: "list"
}, prohibitedAttributes = {
  caption: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  code: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  deletion: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  emphasis: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  generic: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby", "aria-roledescription"]),
  insertion: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  none: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  paragraph: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  presentation: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  strong: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  subscript: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  superscript: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"])
};
function hasGlobalAriaAttributes(element, role) {
  return [
    "aria-atomic",
    "aria-busy",
    "aria-controls",
    "aria-current",
    "aria-description",
    "aria-describedby",
    "aria-details",
    // "disabled",
    "aria-dropeffect",
    // "errormessage",
    "aria-flowto",
    "aria-grabbed",
    // "haspopup",
    "aria-hidden",
    // "invalid",
    "aria-keyshortcuts",
    "aria-label",
    "aria-labelledby",
    "aria-live",
    "aria-owns",
    "aria-relevant",
    "aria-roledescription"
  ].some(function(attributeName) {
    var _prohibitedAttributes;
    return element.hasAttribute(attributeName) && !((_prohibitedAttributes = prohibitedAttributes[role]) !== null && _prohibitedAttributes !== void 0 && _prohibitedAttributes.has(attributeName));
  });
}
function ignorePresentationalRole(element, implicitRole) {
  return hasGlobalAriaAttributes(element, implicitRole);
}
function getRole(element) {
  var explicitRole = getExplicitRole(element);
  if (explicitRole === null || presentationRoles.indexOf(explicitRole) !== -1) {
    var implicitRole = getImplicitRole(element);
    if (presentationRoles.indexOf(explicitRole || "") === -1 || ignorePresentationalRole(element, implicitRole || ""))
      return implicitRole;
  }
  return explicitRole;
}
function getImplicitRole(element) {
  var mappedByTag = localNameToRoleMappings[getLocalName(element)];
  if (mappedByTag !== void 0)
    return mappedByTag;
  switch (getLocalName(element)) {
    case "a":
    case "area":
    case "link":
      if (element.hasAttribute("href"))
        return "link";
      break;
    case "img":
      return element.getAttribute("alt") === "" && !ignorePresentationalRole(element, "img") ? "presentation" : "img";
    case "input": {
      var _ref = element, type5 = _ref.type;
      switch (type5) {
        case "button":
        case "image":
        case "reset":
        case "submit":
          return "button";
        case "checkbox":
        case "radio":
          return type5;
        case "range":
          return "slider";
        case "email":
        case "tel":
        case "text":
        case "url":
          return element.hasAttribute("list") ? "combobox" : "textbox";
        case "search":
          return element.hasAttribute("list") ? "combobox" : "searchbox";
        case "number":
          return "spinbutton";
        default:
          return null;
      }
    }
    case "select":
      return element.hasAttribute("multiple") || element.size > 1 ? "listbox" : "combobox";
  }
  return null;
}
function getExplicitRole(element) {
  var role = element.getAttribute("role");
  if (role !== null) {
    var explicitRole = role.trim().split(" ")[0];
    if (explicitRole.length > 0)
      return explicitRole;
  }
  return null;
}

// ../node_modules/@testing-library/jest-dom/node_modules/dom-accessibility-api/dist/util.mjs
var presentationRoles = ["presentation", "none"];
function isElement(node) {
  return node !== null && node.nodeType === node.ELEMENT_NODE;
}
function isHTMLTableCaptionElement(node) {
  return isElement(node) && getLocalName(node) === "caption";
}
function isHTMLInputElement(node) {
  return isElement(node) && getLocalName(node) === "input";
}
function isHTMLOptGroupElement(node) {
  return isElement(node) && getLocalName(node) === "optgroup";
}
function isHTMLSelectElement(node) {
  return isElement(node) && getLocalName(node) === "select";
}
function isHTMLTableElement(node) {
  return isElement(node) && getLocalName(node) === "table";
}
function isHTMLTextAreaElement(node) {
  return isElement(node) && getLocalName(node) === "textarea";
}
function safeWindow(node) {
  var _ref = node.ownerDocument === null ? node : node.ownerDocument, defaultView = _ref.defaultView;
  if (defaultView === null)
    throw new TypeError("no window available");
  return defaultView;
}
function isHTMLFieldSetElement(node) {
  return isElement(node) && getLocalName(node) === "fieldset";
}
function isHTMLLegendElement(node) {
  return isElement(node) && getLocalName(node) === "legend";
}
function isHTMLSlotElement(node) {
  return isElement(node) && getLocalName(node) === "slot";
}
function isSVGElement(node) {
  return isElement(node) && node.ownerSVGElement !== void 0;
}
function isSVGSVGElement(node) {
  return isElement(node) && getLocalName(node) === "svg";
}
function isSVGTitleElement(node) {
  return isSVGElement(node) && getLocalName(node) === "title";
}
function queryIdRefs(node, attributeName) {
  if (isElement(node) && node.hasAttribute(attributeName)) {
    var ids = node.getAttribute(attributeName).split(" "), root2 = node.getRootNode ? node.getRootNode() : node.ownerDocument;
    return ids.map(function(id) {
      return root2.getElementById(id);
    }).filter(
      function(element) {
        return element !== null;
      }
      // TODO: why does this not narrow?
    );
  }
  return [];
}
function hasAnyConcreteRoles(node, roles3) {
  return isElement(node) ? roles3.indexOf(getRole(node)) !== -1 : !1;
}

// ../node_modules/@testing-library/jest-dom/node_modules/dom-accessibility-api/dist/accessible-name-and-description.mjs
function asFlatString(s3) {
  return s3.trim().replace(/\s\s+/g, " ");
}
function isHidden(node, getComputedStyleImplementation) {
  if (!isElement(node))
    return !1;
  if (node.hasAttribute("hidden") || node.getAttribute("aria-hidden") === "true")
    return !0;
  var style = getComputedStyleImplementation(node);
  return style.getPropertyValue("display") === "none" || style.getPropertyValue("visibility") === "hidden";
}
function isControl(node) {
  return hasAnyConcreteRoles(node, ["button", "combobox", "listbox", "textbox"]) || hasAbstractRole(node, "range");
}
function hasAbstractRole(node, role) {
  if (!isElement(node))
    return !1;
  switch (role) {
    case "range":
      return hasAnyConcreteRoles(node, ["meter", "progressbar", "scrollbar", "slider", "spinbutton"]);
    default:
      throw new TypeError("No knowledge about abstract role '".concat(role, "'. This is likely a bug :("));
  }
}
function querySelectorAllSubtree(element, selectors) {
  var elements = arrayFrom(element.querySelectorAll(selectors));
  return queryIdRefs(element, "aria-owns").forEach(function(root2) {
    elements.push.apply(elements, arrayFrom(root2.querySelectorAll(selectors)));
  }), elements;
}
function querySelectedOptions(listbox) {
  return isHTMLSelectElement(listbox) ? listbox.selectedOptions || querySelectorAllSubtree(listbox, "[selected]") : querySelectorAllSubtree(listbox, '[aria-selected="true"]');
}
function isMarkedPresentational(node) {
  return hasAnyConcreteRoles(node, presentationRoles);
}
function isNativeHostLanguageTextAlternativeElement(node) {
  return isHTMLTableCaptionElement(node);
}
function allowsNameFromContent(node) {
  return hasAnyConcreteRoles(node, ["button", "cell", "checkbox", "columnheader", "gridcell", "heading", "label", "legend", "link", "menuitem", "menuitemcheckbox", "menuitemradio", "option", "radio", "row", "rowheader", "switch", "tab", "tooltip", "treeitem"]);
}
function isDescendantOfNativeHostLanguageTextAlternativeElement(node) {
  return !1;
}
function getValueOfTextbox(element) {
  return isHTMLInputElement(element) || isHTMLTextAreaElement(element) ? element.value : element.textContent || "";
}
function getTextualContent(declaration) {
  var content = declaration.getPropertyValue("content");
  return /^["'].*["']$/.test(content) ? content.slice(1, -1) : "";
}
function isLabelableElement(element) {
  var localName = getLocalName(element);
  return localName === "button" || localName === "input" && element.getAttribute("type") !== "hidden" || localName === "meter" || localName === "output" || localName === "progress" || localName === "select" || localName === "textarea";
}
function findLabelableElement(element) {
  if (isLabelableElement(element))
    return element;
  var labelableElement = null;
  return element.childNodes.forEach(function(childNode) {
    if (labelableElement === null && isElement(childNode)) {
      var descendantLabelableElement = findLabelableElement(childNode);
      descendantLabelableElement !== null && (labelableElement = descendantLabelableElement);
    }
  }), labelableElement;
}
function getControlOfLabel(label) {
  if (label.control !== void 0)
    return label.control;
  var htmlFor = label.getAttribute("for");
  return htmlFor !== null ? label.ownerDocument.getElementById(htmlFor) : findLabelableElement(label);
}
function getLabels(element) {
  var labelsProperty = element.labels;
  if (labelsProperty === null)
    return labelsProperty;
  if (labelsProperty !== void 0)
    return arrayFrom(labelsProperty);
  if (!isLabelableElement(element))
    return null;
  var document7 = element.ownerDocument;
  return arrayFrom(document7.querySelectorAll("label")).filter(function(label) {
    return getControlOfLabel(label) === element;
  });
}
function getSlotContents(slot) {
  var assignedNodes = slot.assignedNodes();
  return assignedNodes.length === 0 ? arrayFrom(slot.childNodes) : assignedNodes;
}
function computeTextAlternative(root2) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, consultedNodes = new SetLike_default(), window2 = safeWindow(root2), _options$compute = options.compute, compute = _options$compute === void 0 ? "name" : _options$compute, _options$computedStyl = options.computedStyleSupportsPseudoElements, computedStyleSupportsPseudoElements = _options$computedStyl === void 0 ? options.getComputedStyle !== void 0 : _options$computedStyl, _options$getComputedS = options.getComputedStyle, getComputedStyle2 = _options$getComputedS === void 0 ? window2.getComputedStyle.bind(window2) : _options$getComputedS, _options$hidden = options.hidden, hidden = _options$hidden === void 0 ? !1 : _options$hidden;
  function computeMiscTextAlternative(node, context) {
    var accumulatedText = "";
    if (isElement(node) && computedStyleSupportsPseudoElements) {
      var pseudoBefore = getComputedStyle2(node, "::before"), beforeContent = getTextualContent(pseudoBefore);
      accumulatedText = "".concat(beforeContent, " ").concat(accumulatedText);
    }
    var childNodes = isHTMLSlotElement(node) ? getSlotContents(node) : arrayFrom(node.childNodes).concat(queryIdRefs(node, "aria-owns"));
    if (childNodes.forEach(function(child) {
      var result = computeTextAlternative3(child, {
        isEmbeddedInLabel: context.isEmbeddedInLabel,
        isReferenced: !1,
        recursion: !0
      }), display2 = isElement(child) ? getComputedStyle2(child).getPropertyValue("display") : "inline", separator = display2 !== "inline" ? " " : "";
      accumulatedText += "".concat(separator).concat(result).concat(separator);
    }), isElement(node) && computedStyleSupportsPseudoElements) {
      var pseudoAfter = getComputedStyle2(node, "::after"), afterContent = getTextualContent(pseudoAfter);
      accumulatedText = "".concat(accumulatedText, " ").concat(afterContent);
    }
    return accumulatedText.trim();
  }
  function useAttribute(element, attributeName) {
    var attribute = element.getAttributeNode(attributeName);
    return attribute !== null && !consultedNodes.has(attribute) && attribute.value.trim() !== "" ? (consultedNodes.add(attribute), attribute.value) : null;
  }
  function computeTooltipAttributeValue(node) {
    return isElement(node) ? useAttribute(node, "title") : null;
  }
  function computeElementTextAlternative(node) {
    if (!isElement(node))
      return null;
    if (isHTMLFieldSetElement(node)) {
      consultedNodes.add(node);
      for (var children = arrayFrom(node.childNodes), i2 = 0; i2 < children.length; i2 += 1) {
        var child = children[i2];
        if (isHTMLLegendElement(child))
          return computeTextAlternative3(child, {
            isEmbeddedInLabel: !1,
            isReferenced: !1,
            recursion: !1
          });
      }
    } else if (isHTMLTableElement(node)) {
      consultedNodes.add(node);
      for (var _children = arrayFrom(node.childNodes), _i = 0; _i < _children.length; _i += 1) {
        var _child = _children[_i];
        if (isHTMLTableCaptionElement(_child))
          return computeTextAlternative3(_child, {
            isEmbeddedInLabel: !1,
            isReferenced: !1,
            recursion: !1
          });
      }
    } else if (isSVGSVGElement(node)) {
      consultedNodes.add(node);
      for (var _children2 = arrayFrom(node.childNodes), _i2 = 0; _i2 < _children2.length; _i2 += 1) {
        var _child2 = _children2[_i2];
        if (isSVGTitleElement(_child2))
          return _child2.textContent;
      }
      return null;
    } else if (getLocalName(node) === "img" || getLocalName(node) === "area") {
      var nameFromAlt = useAttribute(node, "alt");
      if (nameFromAlt !== null)
        return nameFromAlt;
    } else if (isHTMLOptGroupElement(node)) {
      var nameFromLabel = useAttribute(node, "label");
      if (nameFromLabel !== null)
        return nameFromLabel;
    }
    if (isHTMLInputElement(node) && (node.type === "button" || node.type === "submit" || node.type === "reset")) {
      var nameFromValue = useAttribute(node, "value");
      if (nameFromValue !== null)
        return nameFromValue;
      if (node.type === "submit")
        return "Submit";
      if (node.type === "reset")
        return "Reset";
    }
    var labels = getLabels(node);
    if (labels !== null && labels.length !== 0)
      return consultedNodes.add(node), arrayFrom(labels).map(function(element) {
        return computeTextAlternative3(element, {
          isEmbeddedInLabel: !0,
          isReferenced: !1,
          recursion: !0
        });
      }).filter(function(label) {
        return label.length > 0;
      }).join(" ");
    if (isHTMLInputElement(node) && node.type === "image") {
      var _nameFromAlt = useAttribute(node, "alt");
      if (_nameFromAlt !== null)
        return _nameFromAlt;
      var nameFromTitle = useAttribute(node, "title");
      return nameFromTitle !== null ? nameFromTitle : "Submit Query";
    }
    if (hasAnyConcreteRoles(node, ["button"])) {
      var nameFromSubTree = computeMiscTextAlternative(node, {
        isEmbeddedInLabel: !1,
        isReferenced: !1
      });
      if (nameFromSubTree !== "")
        return nameFromSubTree;
    }
    return null;
  }
  function computeTextAlternative3(current, context) {
    if (consultedNodes.has(current))
      return "";
    if (!hidden && isHidden(current, getComputedStyle2) && !context.isReferenced)
      return consultedNodes.add(current), "";
    var labelAttributeNode = isElement(current) ? current.getAttributeNode("aria-labelledby") : null, labelElements = labelAttributeNode !== null && !consultedNodes.has(labelAttributeNode) ? queryIdRefs(current, "aria-labelledby") : [];
    if (compute === "name" && !context.isReferenced && labelElements.length > 0)
      return consultedNodes.add(labelAttributeNode), labelElements.map(function(element) {
        return computeTextAlternative3(element, {
          isEmbeddedInLabel: context.isEmbeddedInLabel,
          isReferenced: !0,
          // this isn't recursion as specified, otherwise we would skip
          // `aria-label` in
          // <input id="myself" aria-label="foo" aria-labelledby="myself"
          recursion: !1
        });
      }).join(" ");
    var skipToStep2E = context.recursion && isControl(current) && compute === "name";
    if (!skipToStep2E) {
      var ariaLabel = (isElement(current) && current.getAttribute("aria-label") || "").trim();
      if (ariaLabel !== "" && compute === "name")
        return consultedNodes.add(current), ariaLabel;
      if (!isMarkedPresentational(current)) {
        var elementTextAlternative = computeElementTextAlternative(current);
        if (elementTextAlternative !== null)
          return consultedNodes.add(current), elementTextAlternative;
      }
    }
    if (hasAnyConcreteRoles(current, ["menu"]))
      return consultedNodes.add(current), "";
    if (skipToStep2E || context.isEmbeddedInLabel || context.isReferenced) {
      if (hasAnyConcreteRoles(current, ["combobox", "listbox"])) {
        consultedNodes.add(current);
        var selectedOptions = querySelectedOptions(current);
        return selectedOptions.length === 0 ? isHTMLInputElement(current) ? current.value : "" : arrayFrom(selectedOptions).map(function(selectedOption) {
          return computeTextAlternative3(selectedOption, {
            isEmbeddedInLabel: context.isEmbeddedInLabel,
            isReferenced: !1,
            recursion: !0
          });
        }).join(" ");
      }
      if (hasAbstractRole(current, "range"))
        return consultedNodes.add(current), current.hasAttribute("aria-valuetext") ? current.getAttribute("aria-valuetext") : current.hasAttribute("aria-valuenow") ? current.getAttribute("aria-valuenow") : current.getAttribute("value") || "";
      if (hasAnyConcreteRoles(current, ["textbox"]))
        return consultedNodes.add(current), getValueOfTextbox(current);
    }
    if (allowsNameFromContent(current) || isElement(current) && context.isReferenced || isNativeHostLanguageTextAlternativeElement(current) || isDescendantOfNativeHostLanguageTextAlternativeElement(current)) {
      var accumulatedText2F = computeMiscTextAlternative(current, {
        isEmbeddedInLabel: context.isEmbeddedInLabel,
        isReferenced: !1
      });
      if (accumulatedText2F !== "")
        return consultedNodes.add(current), accumulatedText2F;
    }
    if (current.nodeType === current.TEXT_NODE)
      return consultedNodes.add(current), current.textContent || "";
    if (context.recursion)
      return consultedNodes.add(current), computeMiscTextAlternative(current, {
        isEmbeddedInLabel: context.isEmbeddedInLabel,
        isReferenced: !1
      });
    var tooltipAttributeValue = computeTooltipAttributeValue(current);
    return tooltipAttributeValue !== null ? (consultedNodes.add(current), tooltipAttributeValue) : (consultedNodes.add(current), "");
  }
  return asFlatString(computeTextAlternative3(root2, {
    isEmbeddedInLabel: !1,
    // by spec computeAccessibleDescription starts with the referenced elements as roots
    isReferenced: compute === "description",
    recursion: !1
  }));
}

// ../node_modules/@testing-library/jest-dom/node_modules/dom-accessibility-api/dist/accessible-description.mjs
function _typeof2(o2) {
  "@babel/helpers - typeof";
  return _typeof2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && typeof Symbol == "function" && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof2(o2);
}
function ownKeys(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e2);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = arguments[r2] != null ? arguments[r2] : {};
    r2 % 2 ? ownKeys(Object(t2), !0).forEach(function(r3) {
      _defineProperty2(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
function _defineProperty2(obj, key, value) {
  return key = _toPropertyKey2(key), key in obj ? Object.defineProperty(obj, key, { value, enumerable: !0, configurable: !0, writable: !0 }) : obj[key] = value, obj;
}
function _toPropertyKey2(arg) {
  var key = _toPrimitive2(arg, "string");
  return _typeof2(key) === "symbol" ? key : String(key);
}
function _toPrimitive2(input2, hint) {
  if (_typeof2(input2) !== "object" || input2 === null) return input2;
  var prim = input2[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input2, hint || "default");
    if (_typeof2(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input2);
}
function computeAccessibleDescription(root2) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, description = queryIdRefs(root2, "aria-describedby").map(function(element) {
    return computeTextAlternative(element, _objectSpread(_objectSpread({}, options), {}, {
      compute: "description"
    }));
  }).join(" ");
  if (description === "") {
    var ariaDescription = root2.getAttribute("aria-description");
    description = ariaDescription === null ? "" : ariaDescription;
  }
  if (description === "") {
    var title = root2.getAttribute("title");
    description = title === null ? "" : title;
  }
  return description;
}

// ../node_modules/@testing-library/jest-dom/node_modules/dom-accessibility-api/dist/accessible-name.mjs
function prohibitsNaming(node) {
  return hasAnyConcreteRoles(node, ["caption", "code", "deletion", "emphasis", "generic", "insertion", "none", "paragraph", "presentation", "strong", "subscript", "superscript"]);
}
function computeAccessibleName(root2) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return prohibitsNaming(root2) ? "" : computeTextAlternative(root2, options);
}

// ../node_modules/@testing-library/jest-dom/dist/matchers-35e4d3bd.mjs
var import_aria_query = __toESM(require_lib(), 1), import_picocolors = __toESM(require_picocolors_browser(), 1), import_css = __toESM(require_css_escape(), 1), GenericTypeError = class extends Error {
  constructor(expectedString, received, matcherFn, context) {
    super(), Error.captureStackTrace && Error.captureStackTrace(this, matcherFn);
    let withType = "";
    try {
      withType = context.utils.printWithType(
        "Received",
        received,
        context.utils.printReceived
      );
    } catch {
    }
    this.message = [
      context.utils.matcherHint(
        `${context.isNot ? ".not" : ""}.${matcherFn.name}`,
        "received",
        ""
      ),
      "",
      // eslint-disable-next-line new-cap
      `${context.utils.RECEIVED_COLOR(
        "received"
      )} value must ${expectedString}.`,
      withType
    ].join(`
`);
  }
}, HtmlElementTypeError = class extends GenericTypeError {
  constructor(...args) {
    super("be an HTMLElement or an SVGElement", ...args);
  }
}, NodeTypeError = class extends GenericTypeError {
  constructor(...args) {
    super("be a Node", ...args);
  }
};
function checkHasWindow(htmlElement, ErrorClass, ...args) {
  if (!htmlElement || !htmlElement.ownerDocument || !htmlElement.ownerDocument.defaultView)
    throw new ErrorClass(htmlElement, ...args);
}
function checkNode(node, ...args) {
  checkHasWindow(node, NodeTypeError, ...args);
  let window2 = node.ownerDocument.defaultView;
  if (!(node instanceof window2.Node))
    throw new NodeTypeError(node, ...args);
}
function checkHtmlElement(htmlElement, ...args) {
  checkHasWindow(htmlElement, HtmlElementTypeError, ...args);
  let window2 = htmlElement.ownerDocument.defaultView;
  if (!(htmlElement instanceof window2.HTMLElement) && !(htmlElement instanceof window2.SVGElement))
    throw new HtmlElementTypeError(htmlElement, ...args);
}
var InvalidCSSError = class extends Error {
  constructor(received, matcherFn, context) {
    super(), Error.captureStackTrace && Error.captureStackTrace(this, matcherFn), this.message = [
      received.message,
      "",
      // eslint-disable-next-line new-cap
      context.utils.RECEIVED_COLOR("Failing css:"),
      // eslint-disable-next-line new-cap
      context.utils.RECEIVED_COLOR(`${received.css}`)
    ].join(`
`);
  }
};
function parseCSS(css, ...args) {
  let ast = m2(`selector { ${css} }`, { silent: !0 }).stylesheet;
  if (ast.parsingErrors && ast.parsingErrors.length > 0) {
    let { reason, line } = ast.parsingErrors[0];
    throw new InvalidCSSError(
      {
        css,
        message: `Syntax error parsing expected css: ${reason} on line: ${line}`
      },
      ...args
    );
  }
  return ast.rules[0].declarations.filter((d) => d.type === "declaration").reduce(
    (obj, { property, value }) => Object.assign(obj, { [property]: value }),
    {}
  );
}
function display(context, value) {
  return typeof value == "string" ? value : context.utils.stringify(value);
}
function getMessage3(context, matcher, expectedLabel, expectedValue, receivedLabel, receivedValue) {
  return [
    `${matcher}
`,
    // eslint-disable-next-line new-cap
    `${expectedLabel}:
${context.utils.EXPECTED_COLOR(
      (0, import_redent.default)(display(context, expectedValue), 2)
    )}`,
    // eslint-disable-next-line new-cap
    `${receivedLabel}:
${context.utils.RECEIVED_COLOR(
      (0, import_redent.default)(display(context, receivedValue), 2)
    )}`
  ].join(`
`);
}
function matches(textToMatch, matcher) {
  return matcher instanceof RegExp ? matcher.test(textToMatch) : textToMatch.includes(String(matcher));
}
function deprecate2(name, replacementText) {
  console.warn(
    `Warning: ${name} has been deprecated and will be removed in future updates.`,
    replacementText
  );
}
function normalize(text) {
  return text.replace(/\s+/g, " ").trim();
}
function getTag(element) {
  return element.tagName && element.tagName.toLowerCase();
}
function getSelectValue({ multiple, options }) {
  let selectedOptions = [...options].filter((option) => option.selected);
  if (multiple)
    return [...selectedOptions].map((opt) => opt.value);
  if (selectedOptions.length !== 0)
    return selectedOptions[0].value;
}
function getInputValue(inputElement) {
  switch (inputElement.type) {
    case "number":
      return inputElement.value === "" ? null : Number(inputElement.value);
    case "checkbox":
      return inputElement.checked;
    default:
      return inputElement.value;
  }
}
var rolesSupportingValues = ["meter", "progressbar", "slider", "spinbutton"];
function getAccessibleValue(element) {
  if (rolesSupportingValues.includes(element.getAttribute("role")))
    return Number(element.getAttribute("aria-valuenow"));
}
function getSingleElementValue(element) {
  if (element)
    switch (element.tagName.toLowerCase()) {
      case "input":
        return getInputValue(element);
      case "select":
        return getSelectValue(element);
      default:
        return element.value ?? getAccessibleValue(element);
    }
}
function toSentence(array, { wordConnector = ", ", lastWordConnector = " and " } = {}) {
  return [array.slice(0, -1).join(wordConnector), array[array.length - 1]].join(
    array.length > 1 ? lastWordConnector : ""
  );
}
function compareAsSet(val1, val2) {
  return Array.isArray(val1) && Array.isArray(val2) ? [...new Set(val1)].every((v2) => new Set(val2).has(v2)) : val1 === val2;
}
function toBeInTheDOM(element, container) {
  return deprecate2(
    "toBeInTheDOM",
    "Please use toBeInTheDocument for searching the entire document and toContainElement for searching a specific container."
  ), element && checkHtmlElement(element, toBeInTheDOM, this), container && checkHtmlElement(container, toBeInTheDOM, this), {
    pass: container ? container.contains(element) : !!element,
    message: () => [
      this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toBeInTheDOM`,
        "element",
        ""
      ),
      "",
      "Received:",
      `  ${this.utils.printReceived(
        element && element.cloneNode(!1)
      )}`
    ].join(`
`)
  };
}
function toBeInTheDocument(element) {
  (element !== null || !this.isNot) && checkHtmlElement(element, toBeInTheDocument, this);
  let pass = element === null ? !1 : element.ownerDocument === element.getRootNode({ composed: !0 }), errorFound = () => `expected document not to contain element, found ${this.utils.stringify(
    element.cloneNode(!0)
  )} instead`, errorNotFound = () => "element could not be found in the document";
  return {
    pass,
    message: () => [
      this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toBeInTheDocument`,
        "element",
        ""
      ),
      "",
      // eslint-disable-next-line new-cap
      this.utils.RECEIVED_COLOR(this.isNot ? errorFound() : errorNotFound())
    ].join(`
`)
  };
}
function toBeEmpty(element) {
  return deprecate2(
    "toBeEmpty",
    "Please use instead toBeEmptyDOMElement for finding empty nodes in the DOM."
  ), checkHtmlElement(element, toBeEmpty, this), {
    pass: element.innerHTML === "",
    message: () => [
      this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toBeEmpty`,
        "element",
        ""
      ),
      "",
      "Received:",
      `  ${this.utils.printReceived(element.innerHTML)}`
    ].join(`
`)
  };
}
function toBeEmptyDOMElement(element) {
  return checkHtmlElement(element, toBeEmptyDOMElement, this), {
    pass: isEmptyElement(element),
    message: () => [
      this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toBeEmptyDOMElement`,
        "element",
        ""
      ),
      "",
      "Received:",
      `  ${this.utils.printReceived(element.innerHTML)}`
    ].join(`
`)
  };
}
function isEmptyElement(element) {
  return [...element.childNodes].filter((node) => node.nodeType !== 8).length === 0;
}
function toContainElement(container, element) {
  return checkHtmlElement(container, toContainElement, this), element !== null && checkHtmlElement(element, toContainElement, this), {
    pass: container.contains(element),
    message: () => [
      this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toContainElement`,
        "element",
        "element"
      ),
      "",
      // eslint-disable-next-line new-cap
      this.utils.RECEIVED_COLOR(`${this.utils.stringify(
        container.cloneNode(!1)
      )} ${this.isNot ? "contains:" : "does not contain:"} ${this.utils.stringify(element && element.cloneNode(!1))}
        `)
    ].join(`
`)
  };
}
function getNormalizedHtml(container, htmlText) {
  let div = container.ownerDocument.createElement("div");
  return div.innerHTML = htmlText, div.innerHTML;
}
function toContainHTML(container, htmlText) {
  if (checkHtmlElement(container, toContainHTML, this), typeof htmlText != "string")
    throw new Error(`.toContainHTML() expects a string value, got ${htmlText}`);
  return {
    pass: container.outerHTML.includes(getNormalizedHtml(container, htmlText)),
    message: () => [
      this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toContainHTML`,
        "element",
        ""
      ),
      "Expected:",
      // eslint-disable-next-line new-cap
      `  ${this.utils.EXPECTED_COLOR(htmlText)}`,
      "Received:",
      `  ${this.utils.printReceived(container.cloneNode(!0))}`
    ].join(`
`)
  };
}
function toHaveTextContent(node, checkWith, options = { normalizeWhitespace: !0 }) {
  checkNode(node, toHaveTextContent, this);
  let textContent = options.normalizeWhitespace ? normalize(node.textContent) : node.textContent.replace(/\u00a0/g, " "), checkingWithEmptyString = textContent !== "" && checkWith === "";
  return {
    pass: !checkingWithEmptyString && matches(textContent, checkWith),
    message: () => {
      let to = this.isNot ? "not to" : "to";
      return getMessage3(
        this,
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toHaveTextContent`,
          "element",
          ""
        ),
        checkingWithEmptyString ? "Checking with empty string will always match, use .toBeEmptyDOMElement() instead" : `Expected element ${to} have text content`,
        checkWith,
        "Received",
        textContent
      );
    }
  };
}
function toHaveAccessibleDescription(htmlElement, expectedAccessibleDescription) {
  checkHtmlElement(htmlElement, toHaveAccessibleDescription, this);
  let actualAccessibleDescription = computeAccessibleDescription(htmlElement), missingExpectedValue = arguments.length === 1, pass = !1;
  return missingExpectedValue ? pass = actualAccessibleDescription !== "" : pass = expectedAccessibleDescription instanceof RegExp ? expectedAccessibleDescription.test(actualAccessibleDescription) : this.equals(
    actualAccessibleDescription,
    expectedAccessibleDescription
  ), {
    pass,
    message: () => {
      let to = this.isNot ? "not to" : "to";
      return getMessage3(
        this,
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.${toHaveAccessibleDescription.name}`,
          "element",
          ""
        ),
        `Expected element ${to} have accessible description`,
        expectedAccessibleDescription,
        "Received",
        actualAccessibleDescription
      );
    }
  };
}
var ariaInvalidName = "aria-invalid", validStates = ["false"];
function toHaveAccessibleErrorMessage(htmlElement, expectedAccessibleErrorMessage) {
  checkHtmlElement(htmlElement, toHaveAccessibleErrorMessage, this);
  let to = this.isNot ? "not to" : "to", method = this.isNot ? ".not.toHaveAccessibleErrorMessage" : ".toHaveAccessibleErrorMessage", errormessageId = htmlElement.getAttribute("aria-errormessage");
  if (!!errormessageId && /\s+/.test(errormessageId))
    return {
      pass: !1,
      message: () => getMessage3(
        this,
        this.utils.matcherHint(method, "element"),
        "Expected element's `aria-errormessage` attribute to be empty or a single, valid ID",
        "",
        "Received",
        `aria-errormessage="${errormessageId}"`
      )
    };
  let ariaInvalidVal = htmlElement.getAttribute(ariaInvalidName);
  if (!htmlElement.hasAttribute(ariaInvalidName) || validStates.includes(ariaInvalidVal))
    return {
      pass: !1,
      message: () => getMessage3(
        this,
        this.utils.matcherHint(method, "element"),
        "Expected element to be marked as invalid with attribute",
        `${ariaInvalidName}="${String(!0)}"`,
        "Received",
        htmlElement.hasAttribute("aria-invalid") ? `${ariaInvalidName}="${htmlElement.getAttribute(ariaInvalidName)}` : null
      )
    };
  let error = normalize(
    htmlElement.ownerDocument.getElementById(errormessageId)?.textContent ?? ""
  );
  return {
    pass: expectedAccessibleErrorMessage === void 0 ? !!error : expectedAccessibleErrorMessage instanceof RegExp ? expectedAccessibleErrorMessage.test(error) : this.equals(error, expectedAccessibleErrorMessage),
    message: () => getMessage3(
      this,
      this.utils.matcherHint(method, "element"),
      `Expected element ${to} have accessible error message`,
      expectedAccessibleErrorMessage ?? "",
      "Received",
      error
    )
  };
}
var elementRoleList = buildElementRoleList(import_aria_query.elementRoles);
function toHaveRole(htmlElement, expectedRole) {
  checkHtmlElement(htmlElement, toHaveRole, this);
  let actualRoles = getExplicitOrImplicitRoles(htmlElement);
  return {
    pass: actualRoles.some((el) => el === expectedRole),
    message: () => {
      let to = this.isNot ? "not to" : "to";
      return getMessage3(
        this,
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.${toHaveRole.name}`,
          "element",
          ""
        ),
        `Expected element ${to} have role`,
        expectedRole,
        "Received",
        actualRoles.join(", ")
      );
    }
  };
}
function getExplicitOrImplicitRoles(htmlElement) {
  return htmlElement.hasAttribute("role") ? htmlElement.getAttribute("role").split(" ").filter(Boolean) : getImplicitAriaRoles(htmlElement);
}
function getImplicitAriaRoles(currentNode) {
  for (let { match, roles: roles3 } of elementRoleList)
    if (match(currentNode))
      return [...roles3];
  return [];
}
function buildElementRoleList(elementRolesMap) {
  function makeElementSelector({ name, attributes }) {
    return `${name}${attributes.map(({ name: attributeName, value, constraints = [] }) => constraints.indexOf("undefined") !== -1 ? `:not([${attributeName}])` : value ? `[${attributeName}="${value}"]` : `[${attributeName}]`).join("")}`;
  }
  function getSelectorSpecificity({ attributes = [] }) {
    return attributes.length;
  }
  function bySelectorSpecificity({ specificity: leftSpecificity }, { specificity: rightSpecificity }) {
    return rightSpecificity - leftSpecificity;
  }
  function match(element) {
    let { attributes = [] } = element, typeTextIndex = attributes.findIndex(
      (attribute) => attribute.value && attribute.name === "type" && attribute.value === "text"
    );
    typeTextIndex >= 0 && (attributes = [
      ...attributes.slice(0, typeTextIndex),
      ...attributes.slice(typeTextIndex + 1)
    ]);
    let selector = makeElementSelector({ ...element, attributes });
    return (node) => typeTextIndex >= 0 && node.type !== "text" ? !1 : node.matches(selector);
  }
  let result = [];
  for (let [element, roles3] of elementRolesMap.entries())
    result = [
      ...result,
      {
        match: match(element),
        roles: Array.from(roles3),
        specificity: getSelectorSpecificity(element)
      }
    ];
  return result.sort(bySelectorSpecificity);
}
function toHaveAccessibleName(htmlElement, expectedAccessibleName) {
  checkHtmlElement(htmlElement, toHaveAccessibleName, this);
  let actualAccessibleName = computeAccessibleName(htmlElement), missingExpectedValue = arguments.length === 1, pass = !1;
  return missingExpectedValue ? pass = actualAccessibleName !== "" : pass = expectedAccessibleName instanceof RegExp ? expectedAccessibleName.test(actualAccessibleName) : this.equals(actualAccessibleName, expectedAccessibleName), {
    pass,
    message: () => {
      let to = this.isNot ? "not to" : "to";
      return getMessage3(
        this,
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.${toHaveAccessibleName.name}`,
          "element",
          ""
        ),
        `Expected element ${to} have accessible name`,
        expectedAccessibleName,
        "Received",
        actualAccessibleName
      );
    }
  };
}
function printAttribute(stringify5, name, value) {
  return value === void 0 ? name : `${name}=${stringify5(value)}`;
}
function getAttributeComment(stringify5, name, value) {
  return value === void 0 ? `element.hasAttribute(${stringify5(name)})` : `element.getAttribute(${stringify5(name)}) === ${stringify5(value)}`;
}
function toHaveAttribute(htmlElement, name, expectedValue) {
  checkHtmlElement(htmlElement, toHaveAttribute, this);
  let isExpectedValuePresent = expectedValue !== void 0, hasAttribute = htmlElement.hasAttribute(name), receivedValue = htmlElement.getAttribute(name);
  return {
    pass: isExpectedValuePresent ? hasAttribute && this.equals(receivedValue, expectedValue) : hasAttribute,
    message: () => {
      let to = this.isNot ? "not to" : "to", receivedAttribute = hasAttribute ? printAttribute(this.utils.stringify, name, receivedValue) : null, matcher = this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toHaveAttribute`,
        "element",
        this.utils.printExpected(name),
        {
          secondArgument: isExpectedValuePresent ? this.utils.printExpected(expectedValue) : void 0,
          comment: getAttributeComment(
            this.utils.stringify,
            name,
            expectedValue
          )
        }
      );
      return getMessage3(
        this,
        matcher,
        `Expected the element ${to} have attribute`,
        printAttribute(this.utils.stringify, name, expectedValue),
        "Received",
        receivedAttribute
      );
    }
  };
}
function getExpectedClassNamesAndOptions(params) {
  let lastParam = params.pop(), expectedClassNames, options;
  return typeof lastParam == "object" && !(lastParam instanceof RegExp) ? (expectedClassNames = params, options = lastParam) : (expectedClassNames = params.concat(lastParam), options = { exact: !1 }), { expectedClassNames, options };
}
function splitClassNames(str2) {
  return str2 ? str2.split(/\s+/).filter((s3) => s3.length > 0) : [];
}
function isSubset$1(subset, superset) {
  return subset.every(
    (strOrRegexp) => typeof strOrRegexp == "string" ? superset.includes(strOrRegexp) : superset.some((className) => strOrRegexp.test(className))
  );
}
function toHaveClass(htmlElement, ...params) {
  checkHtmlElement(htmlElement, toHaveClass, this);
  let { expectedClassNames, options } = getExpectedClassNamesAndOptions(params), received = splitClassNames(htmlElement.getAttribute("class")), expected = expectedClassNames.reduce(
    (acc, className) => acc.concat(
      typeof className == "string" || !className ? splitClassNames(className) : className
    ),
    []
  ), hasRegExp = expected.some((className) => className instanceof RegExp);
  if (options.exact && hasRegExp)
    throw new Error("Exact option does not support RegExp expected class names");
  return options.exact ? {
    pass: isSubset$1(expected, received) && expected.length === received.length,
    message: () => {
      let to = this.isNot ? "not to" : "to";
      return getMessage3(
        this,
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toHaveClass`,
          "element",
          this.utils.printExpected(expected.join(" "))
        ),
        `Expected the element ${to} have EXACTLY defined classes`,
        expected.join(" "),
        "Received",
        received.join(" ")
      );
    }
  } : expected.length > 0 ? {
    pass: isSubset$1(expected, received),
    message: () => {
      let to = this.isNot ? "not to" : "to";
      return getMessage3(
        this,
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toHaveClass`,
          "element",
          this.utils.printExpected(expected.join(" "))
        ),
        `Expected the element ${to} have class`,
        expected.join(" "),
        "Received",
        received.join(" ")
      );
    }
  } : {
    pass: this.isNot ? received.length > 0 : !1,
    message: () => this.isNot ? getMessage3(
      this,
      this.utils.matcherHint(".not.toHaveClass", "element", ""),
      "Expected the element to have classes",
      "(none)",
      "Received",
      received.join(" ")
    ) : [
      this.utils.matcherHint(".toHaveClass", "element"),
      "At least one expected class must be provided."
    ].join(`
`)
  };
}
function getStyleDeclaration(document7, css) {
  let styles3 = {}, copy3 = document7.createElement("div");
  return Object.keys(css).forEach((property) => {
    copy3.style[property] = css[property], styles3[property] = copy3.style[property];
  }), styles3;
}
function isSubset(styles3, computedStyle) {
  return !!Object.keys(styles3).length && Object.entries(styles3).every(([prop, value]) => {
    let isCustomProperty = prop.startsWith("--"), spellingVariants = [prop];
    return isCustomProperty || spellingVariants.push(prop.toLowerCase()), spellingVariants.some(
      (name) => computedStyle[name] === value || computedStyle.getPropertyValue(name) === value
    );
  });
}
function printoutStyles(styles3) {
  return Object.keys(styles3).sort().map((prop) => `${prop}: ${styles3[prop]};`).join(`
`);
}
function expectedDiff(diffFn, expected, computedStyles) {
  let received = Array.from(computedStyles).filter((prop) => expected[prop] !== void 0).reduce(
    (obj, prop) => Object.assign(obj, { [prop]: computedStyles.getPropertyValue(prop) }),
    {}
  );
  return diffFn(printoutStyles(expected), printoutStyles(received)).replace(`${import_picocolors.default.red("+ Received")}
`, "");
}
function toHaveStyle(htmlElement, css) {
  checkHtmlElement(htmlElement, toHaveStyle, this);
  let parsedCSS = typeof css == "object" ? css : parseCSS(css, toHaveStyle, this), { getComputedStyle: getComputedStyle2 } = htmlElement.ownerDocument.defaultView, expected = getStyleDeclaration(htmlElement.ownerDocument, parsedCSS), received = getComputedStyle2(htmlElement);
  return {
    pass: isSubset(expected, received),
    message: () => {
      let matcher = `${this.isNot ? ".not" : ""}.toHaveStyle`;
      return [
        this.utils.matcherHint(matcher, "element", ""),
        expectedDiff(this.utils.diff, expected, received)
      ].join(`

`);
    }
  };
}
function toHaveFocus(element) {
  return checkHtmlElement(element, toHaveFocus, this), {
    pass: element.ownerDocument.activeElement === element,
    message: () => [
      this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toHaveFocus`,
        "element",
        ""
      ),
      "",
      ...this.isNot ? [
        "Received element is focused:",
        `  ${this.utils.printReceived(element)}`
      ] : [
        "Expected element with focus:",
        `  ${this.utils.printExpected(element)}`,
        "Received element with focus:",
        `  ${this.utils.printReceived(
          element.ownerDocument.activeElement
        )}`
      ]
    ].join(`
`)
  };
}
function getMultiElementValue(elements) {
  let types = [...new Set(elements.map((element) => element.type))];
  if (types.length !== 1)
    throw new Error(
      "Multiple form elements with the same name must be of the same type"
    );
  switch (types[0]) {
    case "radio": {
      let theChosenOne = elements.find((radio) => radio.checked);
      return theChosenOne ? theChosenOne.value : void 0;
    }
    case "checkbox":
      return elements.filter((checkbox) => checkbox.checked).map((checkbox) => checkbox.value);
    default:
      return elements.map((element) => element.value);
  }
}
function getFormValue(container, name) {
  let elements = [...container.querySelectorAll(`[name="${(0, import_css.default)(name)}"]`)];
  if (elements.length !== 0)
    switch (elements.length) {
      case 1:
        return getSingleElementValue(elements[0]);
      default:
        return getMultiElementValue(elements);
    }
}
function getPureName(name) {
  return /\[\]$/.test(name) ? name.slice(0, -2) : name;
}
function getAllFormValues(container) {
  return Array.from(container.elements).map((element) => element.name).reduce(
    (obj, name) => ({
      ...obj,
      [getPureName(name)]: getFormValue(container, name)
    }),
    {}
  );
}
function toHaveFormValues(formElement, expectedValues) {
  if (checkHtmlElement(formElement, toHaveFormValues, this), !formElement.elements)
    throw new Error("toHaveFormValues must be called on a form or a fieldset");
  let formValues = getAllFormValues(formElement);
  return {
    pass: Object.entries(expectedValues).every(
      ([name, expectedValue]) => compareAsSet(formValues[name], expectedValue)
    ),
    message: () => {
      let to = this.isNot ? "not to" : "to", matcher = `${this.isNot ? ".not" : ""}.toHaveFormValues`, commonKeyValues = Object.keys(formValues).filter((key) => expectedValues.hasOwnProperty(key)).reduce((obj, key) => ({ ...obj, [key]: formValues[key] }), {});
      return [
        this.utils.matcherHint(matcher, "element", ""),
        `Expected the element ${to} have form values`,
        this.utils.diff(expectedValues, commonKeyValues)
      ].join(`

`);
    }
  };
}
function isStyleVisible(element) {
  let { getComputedStyle: getComputedStyle2 } = element.ownerDocument.defaultView, { display: display2, visibility, opacity } = getComputedStyle2(element);
  return display2 !== "none" && visibility !== "hidden" && visibility !== "collapse" && opacity !== "0" && opacity !== 0;
}
function isAttributeVisible(element, previousElement) {
  let detailsVisibility;
  return previousElement ? detailsVisibility = element.nodeName === "DETAILS" && previousElement.nodeName !== "SUMMARY" ? element.hasAttribute("open") : !0 : detailsVisibility = element.nodeName === "DETAILS" ? element.hasAttribute("open") : !0, !element.hasAttribute("hidden") && detailsVisibility;
}
function isElementVisible(element, previousElement) {
  return isStyleVisible(element) && isAttributeVisible(element, previousElement) && (!element.parentElement || isElementVisible(element.parentElement, element));
}
function toBeVisible(element) {
  checkHtmlElement(element, toBeVisible, this);
  let isInDocument = element.ownerDocument === element.getRootNode({ composed: !0 }), isVisible2 = isInDocument && isElementVisible(element);
  return {
    pass: isVisible2,
    message: () => {
      let is = isVisible2 ? "is" : "is not";
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBeVisible`,
          "element",
          ""
        ),
        "",
        `Received element ${is} visible${isInDocument ? "" : " (element is not in the document)"}:`,
        `  ${this.utils.printReceived(element.cloneNode(!1))}`
      ].join(`
`);
    }
  };
}
var FORM_TAGS$2 = [
  "fieldset",
  "input",
  "select",
  "optgroup",
  "option",
  "button",
  "textarea"
];
function isFirstLegendChildOfFieldset(element, parent) {
  return getTag(element) === "legend" && getTag(parent) === "fieldset" && element.isSameNode(
    Array.from(parent.children).find((child) => getTag(child) === "legend")
  );
}
function isElementDisabledByParent(element, parent) {
  return isElementDisabled(parent) && !isFirstLegendChildOfFieldset(element, parent);
}
function isCustomElement(tag) {
  return tag.includes("-");
}
function canElementBeDisabled(element) {
  let tag = getTag(element);
  return FORM_TAGS$2.includes(tag) || isCustomElement(tag);
}
function isElementDisabled(element) {
  return canElementBeDisabled(element) && element.hasAttribute("disabled");
}
function isAncestorDisabled(element) {
  let parent = element.parentElement;
  return !!parent && (isElementDisabledByParent(element, parent) || isAncestorDisabled(parent));
}
function isElementOrAncestorDisabled(element) {
  return canElementBeDisabled(element) && (isElementDisabled(element) || isAncestorDisabled(element));
}
function toBeDisabled(element) {
  checkHtmlElement(element, toBeDisabled, this);
  let isDisabled3 = isElementOrAncestorDisabled(element);
  return {
    pass: isDisabled3,
    message: () => {
      let is = isDisabled3 ? "is" : "is not";
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBeDisabled`,
          "element",
          ""
        ),
        "",
        `Received element ${is} disabled:`,
        `  ${this.utils.printReceived(element.cloneNode(!1))}`
      ].join(`
`);
    }
  };
}
function toBeEnabled(element) {
  checkHtmlElement(element, toBeEnabled, this);
  let isEnabled = !isElementOrAncestorDisabled(element);
  return {
    pass: isEnabled,
    message: () => {
      let is = isEnabled ? "is" : "is not";
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBeEnabled`,
          "element",
          ""
        ),
        "",
        `Received element ${is} enabled:`,
        `  ${this.utils.printReceived(element.cloneNode(!1))}`
      ].join(`
`);
    }
  };
}
var FORM_TAGS$1 = ["select", "textarea"], ARIA_FORM_TAGS = ["input", "select", "textarea"], UNSUPPORTED_INPUT_TYPES = [
  "color",
  "hidden",
  "range",
  "submit",
  "image",
  "reset"
], SUPPORTED_ARIA_ROLES = [
  "checkbox",
  "combobox",
  "gridcell",
  "listbox",
  "radiogroup",
  "spinbutton",
  "textbox",
  "tree"
];
function isRequiredOnFormTagsExceptInput(element) {
  return FORM_TAGS$1.includes(getTag(element)) && element.hasAttribute("required");
}
function isRequiredOnSupportedInput(element) {
  return getTag(element) === "input" && element.hasAttribute("required") && (element.hasAttribute("type") && !UNSUPPORTED_INPUT_TYPES.includes(element.getAttribute("type")) || !element.hasAttribute("type"));
}
function isElementRequiredByARIA(element) {
  return element.hasAttribute("aria-required") && element.getAttribute("aria-required") === "true" && (ARIA_FORM_TAGS.includes(getTag(element)) || element.hasAttribute("role") && SUPPORTED_ARIA_ROLES.includes(element.getAttribute("role")));
}
function toBeRequired(element) {
  checkHtmlElement(element, toBeRequired, this);
  let isRequired = isRequiredOnFormTagsExceptInput(element) || isRequiredOnSupportedInput(element) || isElementRequiredByARIA(element);
  return {
    pass: isRequired,
    message: () => {
      let is = isRequired ? "is" : "is not";
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBeRequired`,
          "element",
          ""
        ),
        "",
        `Received element ${is} required:`,
        `  ${this.utils.printReceived(element.cloneNode(!1))}`
      ].join(`
`);
    }
  };
}
var FORM_TAGS = ["form", "input", "select", "textarea"];
function isElementHavingAriaInvalid(element) {
  return element.hasAttribute("aria-invalid") && element.getAttribute("aria-invalid") !== "false";
}
function isSupportsValidityMethod(element) {
  return FORM_TAGS.includes(getTag(element));
}
function isElementInvalid(element) {
  let isHaveAriaInvalid = isElementHavingAriaInvalid(element);
  return isSupportsValidityMethod(element) ? isHaveAriaInvalid || !element.checkValidity() : isHaveAriaInvalid;
}
function toBeInvalid(element) {
  checkHtmlElement(element, toBeInvalid, this);
  let isInvalid = isElementInvalid(element);
  return {
    pass: isInvalid,
    message: () => {
      let is = isInvalid ? "is" : "is not";
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBeInvalid`,
          "element",
          ""
        ),
        "",
        `Received element ${is} currently invalid:`,
        `  ${this.utils.printReceived(element.cloneNode(!1))}`
      ].join(`
`);
    }
  };
}
function toBeValid(element) {
  checkHtmlElement(element, toBeValid, this);
  let isValid = !isElementInvalid(element);
  return {
    pass: isValid,
    message: () => {
      let is = isValid ? "is" : "is not";
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBeValid`,
          "element",
          ""
        ),
        "",
        `Received element ${is} currently valid:`,
        `  ${this.utils.printReceived(element.cloneNode(!1))}`
      ].join(`
`);
    }
  };
}
function toHaveValue(htmlElement, expectedValue) {
  if (checkHtmlElement(htmlElement, toHaveValue, this), htmlElement.tagName.toLowerCase() === "input" && ["checkbox", "radio"].includes(htmlElement.type))
    throw new Error(
      "input with type=checkbox or type=radio cannot be used with .toHaveValue(). Use .toBeChecked() for type=checkbox or .toHaveFormValues() instead"
    );
  let receivedValue = getSingleElementValue(htmlElement), expectsValue = expectedValue !== void 0, expectedTypedValue = expectedValue, receivedTypedValue = receivedValue;
  return expectedValue == receivedValue && expectedValue !== receivedValue && (expectedTypedValue = `${expectedValue} (${typeof expectedValue})`, receivedTypedValue = `${receivedValue} (${typeof receivedValue})`), {
    pass: expectsValue ? compareAsSet(receivedValue, expectedValue) : !!receivedValue,
    message: () => {
      let to = this.isNot ? "not to" : "to", matcher = this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toHaveValue`,
        "element",
        expectedValue
      );
      return getMessage3(
        this,
        matcher,
        `Expected the element ${to} have value`,
        expectsValue ? expectedTypedValue : "(any)",
        "Received",
        receivedTypedValue
      );
    }
  };
}
function toHaveDisplayValue(htmlElement, expectedValue) {
  checkHtmlElement(htmlElement, toHaveDisplayValue, this);
  let tagName = htmlElement.tagName.toLowerCase();
  if (!["select", "input", "textarea"].includes(tagName))
    throw new Error(
      ".toHaveDisplayValue() currently supports only input, textarea or select elements, try with another matcher instead."
    );
  if (tagName === "input" && ["radio", "checkbox"].includes(htmlElement.type))
    throw new Error(
      `.toHaveDisplayValue() currently does not support input[type="${htmlElement.type}"], try with another matcher instead.`
    );
  let values = getValues(tagName, htmlElement), expectedValues = getExpectedValues(expectedValue), numberOfMatchesWithValues = expectedValues.filter(
    (expected) => values.some(
      (value) => expected instanceof RegExp ? expected.test(value) : this.equals(value, String(expected))
    )
  ).length, matchedWithAllValues = numberOfMatchesWithValues === values.length, matchedWithAllExpectedValues = numberOfMatchesWithValues === expectedValues.length;
  return {
    pass: matchedWithAllValues && matchedWithAllExpectedValues,
    message: () => getMessage3(
      this,
      this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toHaveDisplayValue`,
        "element",
        ""
      ),
      `Expected element ${this.isNot ? "not " : ""}to have display value`,
      expectedValue,
      "Received",
      values
    )
  };
}
function getValues(tagName, htmlElement) {
  return tagName === "select" ? Array.from(htmlElement).filter((option) => option.selected).map((option) => option.textContent) : [htmlElement.value];
}
function getExpectedValues(expectedValue) {
  return expectedValue instanceof Array ? expectedValue : [expectedValue];
}
function toBeChecked(element) {
  checkHtmlElement(element, toBeChecked, this);
  let isValidInput = () => element.tagName.toLowerCase() === "input" && ["checkbox", "radio"].includes(element.type), isValidAriaElement = () => roleSupportsChecked(element.getAttribute("role")) && ["true", "false"].includes(element.getAttribute("aria-checked"));
  if (!isValidInput() && !isValidAriaElement())
    return {
      pass: !1,
      message: () => `only inputs with type="checkbox" or type="radio" or elements with ${supportedRolesSentence()} and a valid aria-checked attribute can be used with .toBeChecked(). Use .toHaveValue() instead`
    };
  let isChecked = () => isValidInput() ? element.checked : element.getAttribute("aria-checked") === "true";
  return {
    pass: isChecked(),
    message: () => {
      let is = isChecked() ? "is" : "is not";
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBeChecked`,
          "element",
          ""
        ),
        "",
        `Received element ${is} checked:`,
        `  ${this.utils.printReceived(element.cloneNode(!1))}`
      ].join(`
`);
    }
  };
}
function supportedRolesSentence() {
  return toSentence(
    supportedRoles().map((role) => `role="${role}"`),
    { lastWordConnector: " or " }
  );
}
function supportedRoles() {
  return import_aria_query.roles.keys().filter(roleSupportsChecked);
}
function roleSupportsChecked(role) {
  return import_aria_query.roles.get(role)?.props["aria-checked"] !== void 0;
}
function toBePartiallyChecked(element) {
  checkHtmlElement(element, toBePartiallyChecked, this);
  let isValidInput = () => element.tagName.toLowerCase() === "input" && element.type === "checkbox", isValidAriaElement = () => element.getAttribute("role") === "checkbox";
  if (!isValidInput() && !isValidAriaElement())
    return {
      pass: !1,
      message: () => 'only inputs with type="checkbox" or elements with role="checkbox" and a valid aria-checked attribute can be used with .toBePartiallyChecked(). Use .toHaveValue() instead'
    };
  let isPartiallyChecked = () => {
    let isAriaMixed = element.getAttribute("aria-checked") === "mixed";
    return isValidInput() && element.indeterminate || isAriaMixed;
  };
  return {
    pass: isPartiallyChecked(),
    message: () => {
      let is = isPartiallyChecked() ? "is" : "is not";
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBePartiallyChecked`,
          "element",
          ""
        ),
        "",
        `Received element ${is} partially checked:`,
        `  ${this.utils.printReceived(element.cloneNode(!1))}`
      ].join(`
`);
    }
  };
}
function toHaveDescription(htmlElement, checkWith) {
  deprecate2(
    "toHaveDescription",
    "Please use toHaveAccessibleDescription."
  ), checkHtmlElement(htmlElement, toHaveDescription, this);
  let expectsDescription = checkWith !== void 0, descriptionIDs = (htmlElement.getAttribute("aria-describedby") || "").split(/\s+/).filter(Boolean), description = "";
  if (descriptionIDs.length > 0) {
    let document7 = htmlElement.ownerDocument, descriptionEls = descriptionIDs.map((descriptionID) => document7.getElementById(descriptionID)).filter(Boolean);
    description = normalize(descriptionEls.map((el) => el.textContent).join(" "));
  }
  return {
    pass: expectsDescription ? checkWith instanceof RegExp ? checkWith.test(description) : this.equals(description, checkWith) : !!description,
    message: () => {
      let to = this.isNot ? "not to" : "to";
      return getMessage3(
        this,
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toHaveDescription`,
          "element",
          ""
        ),
        `Expected the element ${to} have description`,
        this.utils.printExpected(checkWith),
        "Received",
        this.utils.printReceived(description)
      );
    }
  };
}
function toHaveErrorMessage(htmlElement, checkWith) {
  if (deprecate2("toHaveErrorMessage", "Please use toHaveAccessibleErrorMessage."), checkHtmlElement(htmlElement, toHaveErrorMessage, this), !htmlElement.hasAttribute("aria-invalid") || htmlElement.getAttribute("aria-invalid") === "false") {
    let not = this.isNot ? ".not" : "";
    return {
      pass: !1,
      message: () => getMessage3(
        this,
        this.utils.matcherHint(`${not}.toHaveErrorMessage`, "element", ""),
        "Expected the element to have invalid state indicated by",
        'aria-invalid="true"',
        "Received",
        htmlElement.hasAttribute("aria-invalid") ? `aria-invalid="${htmlElement.getAttribute("aria-invalid")}"` : this.utils.printReceived("")
      )
    };
  }
  let expectsErrorMessage = checkWith !== void 0, errormessageIDs = (htmlElement.getAttribute("aria-errormessage") || "").split(/\s+/).filter(Boolean), errormessage = "";
  if (errormessageIDs.length > 0) {
    let document7 = htmlElement.ownerDocument, errormessageEls = errormessageIDs.map((errormessageID) => document7.getElementById(errormessageID)).filter(Boolean);
    errormessage = normalize(
      errormessageEls.map((el) => el.textContent).join(" ")
    );
  }
  return {
    pass: expectsErrorMessage ? checkWith instanceof RegExp ? checkWith.test(errormessage) : this.equals(errormessage, checkWith) : !!errormessage,
    message: () => {
      let to = this.isNot ? "not to" : "to";
      return getMessage3(
        this,
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toHaveErrorMessage`,
          "element",
          ""
        ),
        `Expected the element ${to} have error message`,
        this.utils.printExpected(checkWith),
        "Received",
        this.utils.printReceived(errormessage)
      );
    }
  };
}
function getSelection(element) {
  let selection = element.ownerDocument.getSelection();
  if (["input", "textarea"].includes(element.tagName.toLowerCase()))
    return ["radio", "checkbox"].includes(element.type) ? "" : element.value.toString().substring(element.selectionStart, element.selectionEnd);
  if (selection.anchorNode === null || selection.focusNode === null)
    return "";
  let originalRange = selection.getRangeAt(0), temporaryRange = element.ownerDocument.createRange();
  if (selection.containsNode(element, !1))
    temporaryRange.selectNodeContents(element), selection.removeAllRanges(), selection.addRange(temporaryRange);
  else if (!(element.contains(selection.anchorNode) && element.contains(selection.focusNode))) {
    let selectionStartsWithinElement = element === originalRange.startContainer || element.contains(originalRange.startContainer), selectionEndsWithinElement = element === originalRange.endContainer || element.contains(originalRange.endContainer);
    selection.removeAllRanges(), (selectionStartsWithinElement || selectionEndsWithinElement) && (temporaryRange.selectNodeContents(element), selectionStartsWithinElement && temporaryRange.setStart(
      originalRange.startContainer,
      originalRange.startOffset
    ), selectionEndsWithinElement && temporaryRange.setEnd(
      originalRange.endContainer,
      originalRange.endOffset
    ), selection.addRange(temporaryRange));
  }
  let result = selection.toString();
  return selection.removeAllRanges(), selection.addRange(originalRange), result;
}
function toHaveSelection(htmlElement, expectedSelection) {
  checkHtmlElement(htmlElement, toHaveSelection, this);
  let expectsSelection = expectedSelection !== void 0;
  if (expectsSelection && typeof expectedSelection != "string")
    throw new Error("expected selection must be a string or undefined");
  let receivedSelection = getSelection(htmlElement);
  return {
    pass: expectsSelection ? compareAsSet(receivedSelection, expectedSelection) : !!receivedSelection,
    message: () => {
      let to = this.isNot ? "not to" : "to", matcher = this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toHaveSelection`,
        "element",
        expectedSelection
      );
      return getMessage3(
        this,
        matcher,
        `Expected the element ${to} have selection`,
        expectsSelection ? expectedSelection : "(any)",
        "Received",
        receivedSelection
      );
    }
  };
}
function toBePressed(element) {
  checkHtmlElement(element, toBePressed, this);
  let roles3 = (element.getAttribute("role") || "").split(" ").map((role) => role.trim()), isButton = element.tagName.toLowerCase() === "button" || element.tagName.toLowerCase() === "input" && element.type === "button" || roles3.includes("button"), pressedAttribute = element.getAttribute("aria-pressed");
  return !isButton || !(pressedAttribute === "true" || pressedAttribute === "false") ? {
    pass: !1,
    message: () => 'Only button or input with type="button" or element with role="button" and a valid aria-pressed attribute can be used with .toBePressed()'
  } : {
    pass: isButton && pressedAttribute === "true",
    message: () => {
      let matcher = this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toBePressed`,
        "element",
        ""
      );
      return getMessage3(
        this,
        matcher,
        "Expected element to have",
        `aria-pressed="${this.isNot ? "false" : "true"}"`,
        "Received",
        `aria-pressed="${pressedAttribute}"`
      );
    }
  };
}
function toBePartiallyPressed(element) {
  checkHtmlElement(element, toBePartiallyPressed, this);
  let roles3 = (element.getAttribute("role") || "").split(" ").map((role) => role.trim()), isButton = element.tagName.toLowerCase() === "button" || element.tagName.toLowerCase() === "input" && element.type === "button" || roles3.includes("button"), pressedAttribute = element.getAttribute("aria-pressed");
  return !isButton || !(pressedAttribute === "true" || pressedAttribute === "false" || pressedAttribute === "mixed") ? {
    pass: !1,
    message: () => 'Only button or input with type="button" or element with role="button" and a valid aria-pressed attribute can be used with .toBePartiallyPressed()'
  } : {
    pass: isButton && pressedAttribute === "mixed",
    message: () => {
      let to = this.isNot ? "not to" : "to", matcher = this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toBePartiallyPressed`,
        "element",
        ""
      );
      return getMessage3(
        this,
        matcher,
        `Expected element ${to} have`,
        'aria-pressed="mixed"',
        "Received",
        `aria-pressed="${pressedAttribute}"`
      );
    }
  };
}
var DOCUMENT_POSITION_DISCONNECTED = 1, DOCUMENT_POSITION_PRECEDING = 2, DOCUMENT_POSITION_FOLLOWING = 4, DOCUMENT_POSITION_CONTAINS = 8, DOCUMENT_POSITION_CONTAINED_BY = 16, DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32, DOCUMENT_POSITIONS_STRINGS = {
  [DOCUMENT_POSITION_DISCONNECTED]: "Node.DOCUMENT_POSITION_DISCONNECTED",
  [DOCUMENT_POSITION_PRECEDING]: "Node.DOCUMENT_POSITION_PRECEDING",
  [DOCUMENT_POSITION_FOLLOWING]: "Node.DOCUMENT_POSITION_FOLLOWING",
  [DOCUMENT_POSITION_CONTAINS]: "Node.DOCUMENT_POSITION_CONTAINS",
  [DOCUMENT_POSITION_CONTAINED_BY]: "Node.DOCUMENT_POSITION_CONTAINED_BY",
  [DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC]: "Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC"
};
function makeDocumentPositionErrorString(documentPosition) {
  return documentPosition in DOCUMENT_POSITIONS_STRINGS ? `${DOCUMENT_POSITIONS_STRINGS[documentPosition]} (${documentPosition})` : `Unknown document position (${documentPosition})`;
}
function checkToAppear(methodName, targetDocumentPosition) {
  return function(element, secondElement) {
    checkHtmlElement(element, toAppearBefore, this), checkHtmlElement(secondElement, toAppearBefore, this);
    let documentPosition = element.compareDocumentPosition(secondElement);
    return {
      pass: documentPosition === targetDocumentPosition,
      message: () => [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.${methodName}`,
          "element",
          "secondElement"
        ),
        "",
        `Received: ${makeDocumentPositionErrorString(documentPosition)}`
      ].join(`
`)
    };
  };
}
function toAppearBefore(element, secondElement) {
  return checkToAppear("toAppearBefore", DOCUMENT_POSITION_FOLLOWING).apply(
    this,
    [element, secondElement]
  );
}
function toAppearAfter(element, secondElement) {
  return checkToAppear("toAppearAfter", DOCUMENT_POSITION_PRECEDING).apply(
    this,
    [element, secondElement]
  );
}
var extensions = Object.freeze({
  __proto__: null,
  toAppearAfter,
  toAppearBefore,
  toBeChecked,
  toBeDisabled,
  toBeEmpty,
  toBeEmptyDOMElement,
  toBeEnabled,
  toBeInTheDOM,
  toBeInTheDocument,
  toBeInvalid,
  toBePartiallyChecked,
  toBePartiallyPressed,
  toBePressed,
  toBeRequired,
  toBeValid,
  toBeVisible,
  toContainElement,
  toContainHTML,
  toHaveAccessibleDescription,
  toHaveAccessibleErrorMessage,
  toHaveAccessibleName,
  toHaveAttribute,
  toHaveClass,
  toHaveDescription,
  toHaveDisplayValue,
  toHaveErrorMessage,
  toHaveFocus,
  toHaveFormValues,
  toHaveRole,
  toHaveSelection,
  toHaveStyle,
  toHaveTextContent,
  toHaveValue
});

// ../node_modules/@testing-library/jest-dom/dist/matchers.mjs
var import_redent2 = __toESM(require_redent(), 1);
var import_aria_query2 = __toESM(require_lib(), 1), import_picocolors2 = __toESM(require_picocolors_browser(), 1), import_css2 = __toESM(require_css_escape(), 1);

// ../node_modules/@vitest/utils/dist/index.js
var jsTokens_1, hasRequiredJsTokens;
function requireJsTokens() {
  if (hasRequiredJsTokens) return jsTokens_1;
  hasRequiredJsTokens = 1;
  var Identifier, JSXIdentifier, JSXPunctuator, JSXString, JSXText, KeywordsWithExpressionAfter, KeywordsWithNoLineTerminatorAfter, LineTerminatorSequence, MultiLineComment, Newline, NumericLiteral, Punctuator, RegularExpressionLiteral, SingleLineComment, StringLiteral, Template, TokensNotPrecedingObjectLiteral, TokensPrecedingExpression, WhiteSpace;
  return RegularExpressionLiteral = /\/(?![*\/])(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\\]).|\\.)*(\/[$_\u200C\u200D\p{ID_Continue}]*|\\)?/yu, Punctuator = /--|\+\+|=>|\.{3}|\??\.(?!\d)|(?:&&|\|\||\?\?|[+\-%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2}|\/(?![\/*]))=?|[?~,:;[\](){}]/y, Identifier = /(\x23?)(?=[$_\p{ID_Start}\\])(?:[$_\u200C\u200D\p{ID_Continue}]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+/yu, StringLiteral = /(['"])(?:(?!\1)[^\\\n\r]|\\(?:\r\n|[^]))*(\1)?/y, NumericLiteral = /(?:0[xX][\da-fA-F](?:_?[\da-fA-F])*|0[oO][0-7](?:_?[0-7])*|0[bB][01](?:_?[01])*)n?|0n|[1-9](?:_?\d)*n|(?:(?:0(?!\d)|0\d*[89]\d*|[1-9](?:_?\d)*)(?:\.(?:\d(?:_?\d)*)?)?|\.\d(?:_?\d)*)(?:[eE][+-]?\d(?:_?\d)*)?|0[0-7]+/y, Template = /[`}](?:[^`\\$]|\\[^]|\$(?!\{))*(`|\$\{)?/y, WhiteSpace = /[\t\v\f\ufeff\p{Zs}]+/yu, LineTerminatorSequence = /\r?\n|[\r\u2028\u2029]/y, MultiLineComment = /\/\*(?:[^*]|\*(?!\/))*(\*\/)?/y, SingleLineComment = /\/\/.*/y, JSXPunctuator = /[<>.:={}]|\/(?![\/*])/y, JSXIdentifier = /[$_\p{ID_Start}][$_\u200C\u200D\p{ID_Continue}-]*/yu, JSXString = /(['"])(?:(?!\1)[^])*(\1)?/y, JSXText = /[^<>{}]+/y, TokensPrecedingExpression = /^(?:[\/+-]|\.{3}|\?(?:InterpolationIn(?:JSX|Template)|NoLineTerminatorHere|NonExpressionParenEnd|UnaryIncDec))?$|[{}([,;<>=*%&|^!~?:]$/, TokensNotPrecedingObjectLiteral = /^(?:=>|[;\]){}]|else|\?(?:NoLineTerminatorHere|NonExpressionParenEnd))?$/, KeywordsWithExpressionAfter = /^(?:await|case|default|delete|do|else|instanceof|new|return|throw|typeof|void|yield)$/, KeywordsWithNoLineTerminatorAfter = /^(?:return|throw|yield)$/, Newline = RegExp(LineTerminatorSequence.source), jsTokens_1 = function* (input2, { jsx = !1 } = {}) {
    var braces, firstCodePoint, isExpression, lastIndex, lastSignificantToken, length, match, mode, nextLastIndex, nextLastSignificantToken, parenNesting, postfixIncDec, punctuator, stack;
    for ({ length } = input2, lastIndex = 0, lastSignificantToken = "", stack = [
      { tag: "JS" }
    ], braces = [], parenNesting = 0, postfixIncDec = !1; lastIndex < length; ) {
      switch (mode = stack[stack.length - 1], mode.tag) {
        case "JS":
        case "JSNonExpressionParen":
        case "InterpolationInTemplate":
        case "InterpolationInJSX":
          if (input2[lastIndex] === "/" && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken)) && (RegularExpressionLiteral.lastIndex = lastIndex, match = RegularExpressionLiteral.exec(input2))) {
            lastIndex = RegularExpressionLiteral.lastIndex, lastSignificantToken = match[0], postfixIncDec = !0, yield {
              type: "RegularExpressionLiteral",
              value: match[0],
              closed: match[1] !== void 0 && match[1] !== "\\"
            };
            continue;
          }
          if (Punctuator.lastIndex = lastIndex, match = Punctuator.exec(input2)) {
            switch (punctuator = match[0], nextLastIndex = Punctuator.lastIndex, nextLastSignificantToken = punctuator, punctuator) {
              case "(":
                lastSignificantToken === "?NonExpressionParenKeyword" && stack.push({
                  tag: "JSNonExpressionParen",
                  nesting: parenNesting
                }), parenNesting++, postfixIncDec = !1;
                break;
              case ")":
                parenNesting--, postfixIncDec = !0, mode.tag === "JSNonExpressionParen" && parenNesting === mode.nesting && (stack.pop(), nextLastSignificantToken = "?NonExpressionParenEnd", postfixIncDec = !1);
                break;
              case "{":
                Punctuator.lastIndex = 0, isExpression = !TokensNotPrecedingObjectLiteral.test(lastSignificantToken) && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken)), braces.push(isExpression), postfixIncDec = !1;
                break;
              case "}":
                switch (mode.tag) {
                  case "InterpolationInTemplate":
                    if (braces.length === mode.nesting) {
                      Template.lastIndex = lastIndex, match = Template.exec(input2), lastIndex = Template.lastIndex, lastSignificantToken = match[0], match[1] === "${" ? (lastSignificantToken = "?InterpolationInTemplate", postfixIncDec = !1, yield {
                        type: "TemplateMiddle",
                        value: match[0]
                      }) : (stack.pop(), postfixIncDec = !0, yield {
                        type: "TemplateTail",
                        value: match[0],
                        closed: match[1] === "`"
                      });
                      continue;
                    }
                    break;
                  case "InterpolationInJSX":
                    if (braces.length === mode.nesting) {
                      stack.pop(), lastIndex += 1, lastSignificantToken = "}", yield {
                        type: "JSXPunctuator",
                        value: "}"
                      };
                      continue;
                    }
                }
                postfixIncDec = braces.pop(), nextLastSignificantToken = postfixIncDec ? "?ExpressionBraceEnd" : "}";
                break;
              case "]":
                postfixIncDec = !0;
                break;
              case "++":
              case "--":
                nextLastSignificantToken = postfixIncDec ? "?PostfixIncDec" : "?UnaryIncDec";
                break;
              case "<":
                if (jsx && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken))) {
                  stack.push({ tag: "JSXTag" }), lastIndex += 1, lastSignificantToken = "<", yield {
                    type: "JSXPunctuator",
                    value: punctuator
                  };
                  continue;
                }
                postfixIncDec = !1;
                break;
              default:
                postfixIncDec = !1;
            }
            lastIndex = nextLastIndex, lastSignificantToken = nextLastSignificantToken, yield {
              type: "Punctuator",
              value: punctuator
            };
            continue;
          }
          if (Identifier.lastIndex = lastIndex, match = Identifier.exec(input2)) {
            switch (lastIndex = Identifier.lastIndex, nextLastSignificantToken = match[0], match[0]) {
              case "for":
              case "if":
              case "while":
              case "with":
                lastSignificantToken !== "." && lastSignificantToken !== "?." && (nextLastSignificantToken = "?NonExpressionParenKeyword");
            }
            lastSignificantToken = nextLastSignificantToken, postfixIncDec = !KeywordsWithExpressionAfter.test(match[0]), yield {
              type: match[1] === "#" ? "PrivateIdentifier" : "IdentifierName",
              value: match[0]
            };
            continue;
          }
          if (StringLiteral.lastIndex = lastIndex, match = StringLiteral.exec(input2)) {
            lastIndex = StringLiteral.lastIndex, lastSignificantToken = match[0], postfixIncDec = !0, yield {
              type: "StringLiteral",
              value: match[0],
              closed: match[2] !== void 0
            };
            continue;
          }
          if (NumericLiteral.lastIndex = lastIndex, match = NumericLiteral.exec(input2)) {
            lastIndex = NumericLiteral.lastIndex, lastSignificantToken = match[0], postfixIncDec = !0, yield {
              type: "NumericLiteral",
              value: match[0]
            };
            continue;
          }
          if (Template.lastIndex = lastIndex, match = Template.exec(input2)) {
            lastIndex = Template.lastIndex, lastSignificantToken = match[0], match[1] === "${" ? (lastSignificantToken = "?InterpolationInTemplate", stack.push({
              tag: "InterpolationInTemplate",
              nesting: braces.length
            }), postfixIncDec = !1, yield {
              type: "TemplateHead",
              value: match[0]
            }) : (postfixIncDec = !0, yield {
              type: "NoSubstitutionTemplate",
              value: match[0],
              closed: match[1] === "`"
            });
            continue;
          }
          break;
        case "JSXTag":
        case "JSXTagEnd":
          if (JSXPunctuator.lastIndex = lastIndex, match = JSXPunctuator.exec(input2)) {
            switch (lastIndex = JSXPunctuator.lastIndex, nextLastSignificantToken = match[0], match[0]) {
              case "<":
                stack.push({ tag: "JSXTag" });
                break;
              case ">":
                stack.pop(), lastSignificantToken === "/" || mode.tag === "JSXTagEnd" ? (nextLastSignificantToken = "?JSX", postfixIncDec = !0) : stack.push({ tag: "JSXChildren" });
                break;
              case "{":
                stack.push({
                  tag: "InterpolationInJSX",
                  nesting: braces.length
                }), nextLastSignificantToken = "?InterpolationInJSX", postfixIncDec = !1;
                break;
              case "/":
                lastSignificantToken === "<" && (stack.pop(), stack[stack.length - 1].tag === "JSXChildren" && stack.pop(), stack.push({ tag: "JSXTagEnd" }));
            }
            lastSignificantToken = nextLastSignificantToken, yield {
              type: "JSXPunctuator",
              value: match[0]
            };
            continue;
          }
          if (JSXIdentifier.lastIndex = lastIndex, match = JSXIdentifier.exec(input2)) {
            lastIndex = JSXIdentifier.lastIndex, lastSignificantToken = match[0], yield {
              type: "JSXIdentifier",
              value: match[0]
            };
            continue;
          }
          if (JSXString.lastIndex = lastIndex, match = JSXString.exec(input2)) {
            lastIndex = JSXString.lastIndex, lastSignificantToken = match[0], yield {
              type: "JSXString",
              value: match[0],
              closed: match[2] !== void 0
            };
            continue;
          }
          break;
        case "JSXChildren":
          if (JSXText.lastIndex = lastIndex, match = JSXText.exec(input2)) {
            lastIndex = JSXText.lastIndex, lastSignificantToken = match[0], yield {
              type: "JSXText",
              value: match[0]
            };
            continue;
          }
          switch (input2[lastIndex]) {
            case "<":
              stack.push({ tag: "JSXTag" }), lastIndex++, lastSignificantToken = "<", yield {
                type: "JSXPunctuator",
                value: "<"
              };
              continue;
            case "{":
              stack.push({
                tag: "InterpolationInJSX",
                nesting: braces.length
              }), lastIndex++, lastSignificantToken = "?InterpolationInJSX", postfixIncDec = !1, yield {
                type: "JSXPunctuator",
                value: "{"
              };
              continue;
          }
      }
      if (WhiteSpace.lastIndex = lastIndex, match = WhiteSpace.exec(input2)) {
        lastIndex = WhiteSpace.lastIndex, yield {
          type: "WhiteSpace",
          value: match[0]
        };
        continue;
      }
      if (LineTerminatorSequence.lastIndex = lastIndex, match = LineTerminatorSequence.exec(input2)) {
        lastIndex = LineTerminatorSequence.lastIndex, postfixIncDec = !1, KeywordsWithNoLineTerminatorAfter.test(lastSignificantToken) && (lastSignificantToken = "?NoLineTerminatorHere"), yield {
          type: "LineTerminatorSequence",
          value: match[0]
        };
        continue;
      }
      if (MultiLineComment.lastIndex = lastIndex, match = MultiLineComment.exec(input2)) {
        lastIndex = MultiLineComment.lastIndex, Newline.test(match[0]) && (postfixIncDec = !1, KeywordsWithNoLineTerminatorAfter.test(lastSignificantToken) && (lastSignificantToken = "?NoLineTerminatorHere")), yield {
          type: "MultiLineComment",
          value: match[0],
          closed: match[1] !== void 0
        };
        continue;
      }
      if (SingleLineComment.lastIndex = lastIndex, match = SingleLineComment.exec(input2)) {
        lastIndex = SingleLineComment.lastIndex, postfixIncDec = !1, yield {
          type: "SingleLineComment",
          value: match[0]
        };
        continue;
      }
      firstCodePoint = String.fromCodePoint(input2.codePointAt(lastIndex)), lastIndex += firstCodePoint.length, lastSignificantToken = firstCodePoint, postfixIncDec = !1, yield {
        type: mode.tag.startsWith("JSX") ? "JSXInvalid" : "Invalid",
        value: firstCodePoint
      };
    }
  }, jsTokens_1;
}
var jsTokensExports = requireJsTokens(), jsTokens = getDefaultExportFromCjs2(jsTokensExports), reservedWords = {
  keyword: [
    "break",
    "case",
    "catch",
    "continue",
    "debugger",
    "default",
    "do",
    "else",
    "finally",
    "for",
    "function",
    "if",
    "return",
    "switch",
    "throw",
    "try",
    "var",
    "const",
    "while",
    "with",
    "new",
    "this",
    "super",
    "class",
    "extends",
    "export",
    "import",
    "null",
    "true",
    "false",
    "in",
    "instanceof",
    "typeof",
    "void",
    "delete"
  ],
  strict: [
    "implements",
    "interface",
    "let",
    "package",
    "private",
    "protected",
    "public",
    "static",
    "yield"
  ]
}, keywords = new Set(reservedWords.keyword), reservedWordsStrictSet = new Set(reservedWords.strict);
var SAFE_TIMERS_SYMBOL = Symbol("vitest:SAFE_TIMERS");

// ../node_modules/@vitest/spy/node_modules/tinyspy/dist/index.js
function S(e2, t2) {
  if (!e2)
    throw new Error(t2);
}
function f2(e2, t2) {
  return typeof t2 === e2;
}
function w(e2) {
  return e2 instanceof Promise;
}
function u(e2, t2, r2) {
  Object.defineProperty(e2, t2, r2);
}
function l(e2, t2, r2) {
  u(e2, t2, { value: r2, configurable: !0, writable: !0 });
}
var y = Symbol.for("tinyspy:spy"), x = /* @__PURE__ */ new Set(), h2 = (e2) => {
  e2.called = !1, e2.callCount = 0, e2.calls = [], e2.results = [], e2.resolves = [], e2.next = [];
}, k = (e2) => (u(e2, y, {
  value: { reset: () => h2(e2[y]) }
}), e2[y]), T = (e2) => e2[y] || k(e2);
function R(e2) {
  S(
    f2("function", e2) || f2("undefined", e2),
    "cannot spy on a non-function value"
  );
  let t2 = function(...s3) {
    let n2 = T(t2);
    n2.called = !0, n2.callCount++, n2.calls.push(s3);
    let d = n2.next.shift();
    if (d) {
      n2.results.push(d);
      let [a2, i2] = d;
      if (a2 === "ok")
        return i2;
      throw i2;
    }
    let o2, c2 = "ok", p2 = n2.results.length;
    if (n2.impl)
      try {
        new.target ? o2 = Reflect.construct(n2.impl, s3, new.target) : o2 = n2.impl.apply(this, s3), c2 = "ok";
      } catch (a2) {
        throw o2 = a2, c2 = "error", n2.results.push([c2, a2]), a2;
      }
    let g2 = [c2, o2];
    return w(o2) && o2.then(
      (a2) => n2.resolves[p2] = ["ok", a2],
      (a2) => n2.resolves[p2] = ["error", a2]
    ), n2.results.push(g2), o2;
  };
  l(t2, "_isMockFunction", !0), l(t2, "length", e2 ? e2.length : 0), l(t2, "name", e2 && e2.name || "spy");
  let r2 = T(t2);
  return r2.reset(), r2.impl = e2, t2;
}
function v(e2) {
  return !!e2 && e2._isMockFunction === !0;
}
var b = (e2, t2) => {
  let r2 = Object.getOwnPropertyDescriptor(e2, t2);
  if (r2)
    return [e2, r2];
  let s3 = Object.getPrototypeOf(e2);
  for (; s3 !== null; ) {
    let n2 = Object.getOwnPropertyDescriptor(s3, t2);
    if (n2)
      return [s3, n2];
    s3 = Object.getPrototypeOf(s3);
  }
}, P = (e2, t2) => {
  t2 != null && typeof t2 == "function" && t2.prototype != null && Object.setPrototypeOf(e2.prototype, t2.prototype);
};
function M(e2, t2, r2) {
  S(
    !f2("undefined", e2),
    "spyOn could not find an object to spy upon"
  ), S(
    f2("object", e2) || f2("function", e2),
    "cannot spyOn on a primitive value"
  );
  let [s3, n2] = (() => {
    if (!f2("object", t2))
      return [t2, "value"];
    if ("getter" in t2 && "setter" in t2)
      throw new Error("cannot spy on both getter and setter");
    if ("getter" in t2)
      return [t2.getter, "get"];
    if ("setter" in t2)
      return [t2.setter, "set"];
    throw new Error("specify getter or setter to spy on");
  })(), [d, o2] = b(e2, s3) || [];
  S(
    o2 || s3 in e2,
    `${String(s3)} does not exist`
  );
  let c2 = !1;
  n2 === "value" && o2 && !o2.value && o2.get && (n2 = "get", c2 = !0, r2 = o2.get());
  let p2;
  o2 ? p2 = o2[n2] : n2 !== "value" ? p2 = () => e2[s3] : p2 = e2[s3], p2 && j(p2) && (p2 = p2[y].getOriginal());
  let g2 = (I) => {
    let { value: F, ...O } = o2 || {
      configurable: !0,
      writable: !0
    };
    n2 !== "value" && delete O.writable, O[n2] = I, u(e2, s3, O);
  }, a2 = () => {
    d !== e2 ? Reflect.deleteProperty(e2, s3) : o2 && !p2 ? u(e2, s3, o2) : g2(p2);
  };
  r2 || (r2 = p2);
  let i2 = E(R(r2), r2);
  n2 === "value" && P(i2, p2);
  let m3 = i2[y];
  return l(m3, "restore", a2), l(m3, "getOriginal", () => c2 ? p2() : p2), l(m3, "willCall", (I) => (m3.impl = I, i2)), g2(
    c2 ? () => (P(i2, r2), i2) : i2
  ), x.add(i2), i2;
}
var K = /* @__PURE__ */ new Set([
  "length",
  "name",
  "prototype"
]);
function D(e2) {
  let t2 = /* @__PURE__ */ new Set(), r2 = {};
  for (; e2 && e2 !== Object.prototype && e2 !== Function.prototype; ) {
    let s3 = [
      ...Object.getOwnPropertyNames(e2),
      ...Object.getOwnPropertySymbols(e2)
    ];
    for (let n2 of s3)
      r2[n2] || K.has(n2) || (t2.add(n2), r2[n2] = Object.getOwnPropertyDescriptor(e2, n2));
    e2 = Object.getPrototypeOf(e2);
  }
  return {
    properties: t2,
    descriptors: r2
  };
}
function E(e2, t2) {
  if (!t2 || // the original is already a spy, so it has all the properties
  y in t2)
    return e2;
  let { properties: r2, descriptors: s3 } = D(t2);
  for (let n2 of r2) {
    let d = s3[n2];
    b(e2, n2) || u(e2, n2, d);
  }
  return e2;
}
function j(e2) {
  return v(e2) && "getOriginal" in e2[y];
}

// ../node_modules/@vitest/spy/dist/index.js
var mocks = /* @__PURE__ */ new Set();
function isMockFunction(fn3) {
  return typeof fn3 == "function" && "_isMockFunction" in fn3 && fn3._isMockFunction;
}
function spyOn(obj, method, accessType) {
  let objMethod = accessType ? { [{
    get: "getter",
    set: "setter"
  }[accessType]]: method } : method, state3, descriptor = getDescriptor(obj, method), fn3 = descriptor && descriptor[accessType || "value"];
  isMockFunction(fn3) && (state3 = fn3.mock._state());
  try {
    let stub = M(obj, objMethod), spy = enhanceSpy(stub);
    return state3 && spy.mock._state(state3), spy;
  } catch (error) {
    throw error instanceof TypeError && Symbol.toStringTag && obj[Symbol.toStringTag] === "Module" && (error.message.includes("Cannot redefine property") || error.message.includes("Cannot replace module namespace") || error.message.includes("can't redefine non-configurable property")) ? new TypeError(`Cannot spy on export "${String(objMethod)}". Module namespace is not configurable in ESM. See: https://vitest.dev/guide/browser/#limitations`, { cause: error }) : error;
  }
}
var callOrder = 0;
function enhanceSpy(spy) {
  let stub = spy, implementation, onceImplementations = [], implementationChangedTemporarily = !1, instances2 = [], contexts = [], invocations = [], state3 = T(spy), mockContext = {
    get calls() {
      return state3.calls;
    },
    get contexts() {
      return contexts;
    },
    get instances() {
      return instances2;
    },
    get invocationCallOrder() {
      return invocations;
    },
    get results() {
      return state3.results.map(([callType, value]) => ({
        type: callType === "error" ? "throw" : "return",
        value
      }));
    },
    get settledResults() {
      return state3.resolves.map(([callType, value]) => ({
        type: callType === "error" ? "rejected" : "fulfilled",
        value
      }));
    },
    get lastCall() {
      return state3.calls[state3.calls.length - 1];
    },
    _state(state4) {
      return state4 && (implementation = state4.implementation, onceImplementations = state4.onceImplementations, implementationChangedTemporarily = state4.implementationChangedTemporarily), {
        implementation,
        onceImplementations,
        implementationChangedTemporarily
      };
    }
  };
  function mockCall(...args) {
    return instances2.push(this), contexts.push(this), invocations.push(++callOrder), (implementationChangedTemporarily ? implementation : onceImplementations.shift() || implementation || state3.getOriginal() || (() => {
    })).apply(this, args);
  }
  let name = stub.name;
  stub.getMockName = () => name || "vi.fn()", stub.mockName = (n2) => (name = n2, stub), stub.mockClear = () => (state3.reset(), instances2 = [], contexts = [], invocations = [], stub), stub.mockReset = () => (stub.mockClear(), implementation = void 0, onceImplementations = [], stub), stub.mockRestore = () => (stub.mockReset(), state3.restore(), stub), Symbol.dispose && (stub[Symbol.dispose] = () => stub.mockRestore()), stub.getMockImplementation = () => implementationChangedTemporarily ? implementation : onceImplementations.at(0) || implementation, stub.mockImplementation = (fn3) => (implementation = fn3, state3.willCall(mockCall), stub), stub.mockImplementationOnce = (fn3) => (onceImplementations.push(fn3), stub);
  function withImplementation(fn3, cb) {
    let originalImplementation = implementation;
    implementation = fn3, state3.willCall(mockCall), implementationChangedTemporarily = !0;
    let reset = () => {
      implementation = originalImplementation, implementationChangedTemporarily = !1;
    }, result = cb();
    return typeof result == "object" && result && typeof result.then == "function" ? result.then(() => (reset(), stub)) : (reset(), stub);
  }
  return stub.withImplementation = withImplementation, stub.mockReturnThis = () => stub.mockImplementation(function() {
    return this;
  }), stub.mockReturnValue = (val) => stub.mockImplementation(() => val), stub.mockReturnValueOnce = (val) => stub.mockImplementationOnce(() => val), stub.mockResolvedValue = (val) => stub.mockImplementation(() => Promise.resolve(val)), stub.mockResolvedValueOnce = (val) => stub.mockImplementationOnce(() => Promise.resolve(val)), stub.mockRejectedValue = (val) => stub.mockImplementation(() => Promise.reject(val)), stub.mockRejectedValueOnce = (val) => stub.mockImplementationOnce(() => Promise.reject(val)), Object.defineProperty(stub, "mock", { get: () => mockContext }), state3.willCall(mockCall), mocks.add(stub), stub;
}
function fn(implementation) {
  let enhancedSpy = enhanceSpy(M({ spy: implementation || function() {
  } }, "spy"));
  return implementation && enhancedSpy.mockImplementation(implementation), enhancedSpy;
}
function getDescriptor(obj, method) {
  let objDescriptor = Object.getOwnPropertyDescriptor(obj, method);
  if (objDescriptor)
    return objDescriptor;
  let currentProto = Object.getPrototypeOf(obj);
  for (; currentProto !== null; ) {
    let descriptor = Object.getOwnPropertyDescriptor(currentProto, method);
    if (descriptor)
      return descriptor;
    currentProto = Object.getPrototypeOf(currentProto);
  }
}

// ../node_modules/@vitest/expect/dist/index.js
var MATCHERS_OBJECT = Symbol.for("matchers-object"), JEST_MATCHERS_OBJECT = Symbol.for("$$jest-matchers-object-storybook"), GLOBAL_EXPECT = Symbol.for("expect-global"), ASYMMETRIC_MATCHERS_OBJECT = Symbol.for("asymmetric-matchers-object"), customMatchers = {
  toSatisfy(actual, expected, message) {
    let { printReceived: printReceived3, printExpected: printExpected3, matcherHint: matcherHint2 } = this.utils, pass = expected(actual);
    return {
      pass,
      message: () => pass ? `${matcherHint2(".not.toSatisfy", "received", "")}

Expected value to not satisfy:
${message || printExpected3(expected)}
Received:
${printReceived3(actual)}` : `${matcherHint2(".toSatisfy", "received", "")}

Expected value to satisfy:
${message || printExpected3(expected)}

Received:
${printReceived3(actual)}`
    };
  },
  toBeOneOf(actual, expected) {
    let { equals: equals2, customTesters } = this, { printReceived: printReceived3, printExpected: printExpected3, matcherHint: matcherHint2 } = this.utils;
    if (!Array.isArray(expected))
      throw new TypeError(`You must provide an array to ${matcherHint2(".toBeOneOf")}, not '${typeof expected}'.`);
    let pass = expected.length === 0 || expected.some((item) => equals2(item, actual, customTesters));
    return {
      pass,
      message: () => pass ? `${matcherHint2(".not.toBeOneOf", "received", "")}

Expected value to not be one of:
${printExpected3(expected)}
Received:
${printReceived3(actual)}` : `${matcherHint2(".toBeOneOf", "received", "")}

Expected value to be one of:
${printExpected3(expected)}

Received:
${printReceived3(actual)}`
    };
  }
}, EXPECTED_COLOR = s.green, RECEIVED_COLOR = s.red, INVERTED_COLOR = s.inverse, BOLD_WEIGHT = s.bold, DIM_COLOR = s.dim;
function matcherHint(matcherName, received = "received", expected = "expected", options = {}) {
  let { comment = "", isDirectExpectCall = !1, isNot = !1, promise = "", secondArgument = "", expectedColor = EXPECTED_COLOR, receivedColor = RECEIVED_COLOR, secondArgumentColor = EXPECTED_COLOR } = options, hint = "", dimString = "expect";
  return !isDirectExpectCall && received !== "" && (hint += DIM_COLOR(`${dimString}(`) + receivedColor(received), dimString = ")"), promise !== "" && (hint += DIM_COLOR(`${dimString}.`) + promise, dimString = ""), isNot && (hint += `${DIM_COLOR(`${dimString}.`)}not`, dimString = ""), matcherName.includes(".") ? dimString += matcherName : (hint += DIM_COLOR(`${dimString}.`) + matcherName, dimString = ""), expected === "" ? dimString += "()" : (hint += DIM_COLOR(`${dimString}(`) + expectedColor(expected), secondArgument && (hint += DIM_COLOR(", ") + secondArgumentColor(secondArgument)), dimString = ")"), comment !== "" && (dimString += ` // ${comment}`), dimString !== "" && (hint += DIM_COLOR(dimString)), hint;
}
var SPACE_SYMBOL2 = "\xB7";
function replaceTrailingSpaces2(text) {
  return text.replace(/\s+$/gm, (spaces) => SPACE_SYMBOL2.repeat(spaces.length));
}
function printReceived2(object) {
  return RECEIVED_COLOR(replaceTrailingSpaces2(stringify2(object)));
}
function printExpected2(value) {
  return EXPECTED_COLOR(replaceTrailingSpaces2(stringify2(value)));
}
function getMatcherUtils() {
  return {
    EXPECTED_COLOR,
    RECEIVED_COLOR,
    INVERTED_COLOR,
    BOLD_WEIGHT,
    DIM_COLOR,
    diff,
    matcherHint,
    printReceived: printReceived2,
    printExpected: printExpected2,
    printDiffOrStringify,
    printWithType
  };
}
function printWithType(name, value, print) {
  let type5 = getType2(value), hasType = type5 !== "null" && type5 !== "undefined" ? `${name} has type:  ${type5}
` : "", hasValue = `${name} has value: ${print(value)}`;
  return hasType + hasValue;
}
function getCustomEqualityTesters() {
  return globalThis[JEST_MATCHERS_OBJECT].customEqualityTesters;
}
function equals(a2, b2, customTesters, strictCheck) {
  return customTesters = customTesters || [], eq2(a2, b2, [], [], customTesters, strictCheck ? hasKey : hasDefinedKey);
}
var functionToString = Function.prototype.toString;
function isAsymmetric(obj) {
  return !!obj && typeof obj == "object" && "asymmetricMatch" in obj && isA("Function", obj.asymmetricMatch);
}
function asymmetricMatch(a2, b2) {
  let asymmetricA = isAsymmetric(a2), asymmetricB = isAsymmetric(b2);
  if (!(asymmetricA && asymmetricB)) {
    if (asymmetricA)
      return a2.asymmetricMatch(b2);
    if (asymmetricB)
      return b2.asymmetricMatch(a2);
  }
}
function eq2(a2, b2, aStack, bStack, customTesters, hasKey2) {
  let result = !0, asymmetricResult = asymmetricMatch(a2, b2);
  if (asymmetricResult !== void 0)
    return asymmetricResult;
  let testerContext = { equals };
  for (let i2 = 0; i2 < customTesters.length; i2++) {
    let customTesterResult = customTesters[i2].call(testerContext, a2, b2, customTesters);
    if (customTesterResult !== void 0)
      return customTesterResult;
  }
  if (typeof URL == "function" && a2 instanceof URL && b2 instanceof URL)
    return a2.href === b2.href;
  if (Object.is(a2, b2))
    return !0;
  if (a2 === null || b2 === null)
    return a2 === b2;
  let className = Object.prototype.toString.call(a2);
  if (className !== Object.prototype.toString.call(b2))
    return !1;
  switch (className) {
    case "[object Boolean]":
    case "[object String]":
    case "[object Number]":
      return typeof a2 != typeof b2 ? !1 : typeof a2 != "object" && typeof b2 != "object" ? Object.is(a2, b2) : Object.is(a2.valueOf(), b2.valueOf());
    case "[object Date]": {
      let numA = +a2, numB = +b2;
      return numA === numB || Number.isNaN(numA) && Number.isNaN(numB);
    }
    case "[object RegExp]":
      return a2.source === b2.source && a2.flags === b2.flags;
    case "[object Temporal.Instant]":
    case "[object Temporal.ZonedDateTime]":
    case "[object Temporal.PlainDateTime]":
    case "[object Temporal.PlainDate]":
    case "[object Temporal.PlainTime]":
    case "[object Temporal.PlainYearMonth]":
    case "[object Temporal.PlainMonthDay]":
      return a2.equals(b2);
    case "[object Temporal.Duration]":
      return a2.toString() === b2.toString();
  }
  if (typeof a2 != "object" || typeof b2 != "object")
    return !1;
  if (isDomNode(a2) && isDomNode(b2))
    return a2.isEqualNode(b2);
  let length = aStack.length;
  for (; length--; ) {
    if (aStack[length] === a2)
      return bStack[length] === b2;
    if (bStack[length] === b2)
      return !1;
  }
  if (aStack.push(a2), bStack.push(b2), className === "[object Array]" && a2.length !== b2.length)
    return !1;
  if (a2 instanceof Error && b2 instanceof Error)
    try {
      return isErrorEqual(a2, b2, aStack, bStack, customTesters, hasKey2);
    } finally {
      aStack.pop(), bStack.pop();
    }
  let aKeys = keys(a2, hasKey2), key, size = aKeys.length;
  if (keys(b2, hasKey2).length !== size)
    return !1;
  for (; size--; )
    if (key = aKeys[size], result = hasKey2(b2, key) && eq2(a2[key], b2[key], aStack, bStack, customTesters, hasKey2), !result)
      return !1;
  return aStack.pop(), bStack.pop(), result;
}
function isErrorEqual(a2, b2, aStack, bStack, customTesters, hasKey2) {
  let result = Object.getPrototypeOf(a2) === Object.getPrototypeOf(b2) && a2.name === b2.name && a2.message === b2.message;
  return typeof b2.cause < "u" && result && (result = eq2(a2.cause, b2.cause, aStack, bStack, customTesters, hasKey2)), a2 instanceof AggregateError && b2 instanceof AggregateError && result && (result = eq2(a2.errors, b2.errors, aStack, bStack, customTesters, hasKey2)), result && (result = eq2({ ...a2 }, { ...b2 }, aStack, bStack, customTesters, hasKey2)), result;
}
function keys(obj, hasKey2) {
  let keys2 = [];
  for (let key in obj)
    hasKey2(obj, key) && keys2.push(key);
  return keys2.concat(Object.getOwnPropertySymbols(obj).filter((symbol) => Object.getOwnPropertyDescriptor(obj, symbol).enumerable));
}
function hasDefinedKey(obj, key) {
  return hasKey(obj, key) && obj[key] !== void 0;
}
function hasKey(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function isA(typeName, value) {
  return Object.prototype.toString.apply(value) === `[object ${typeName}]`;
}
function isDomNode(obj) {
  return obj !== null && typeof obj == "object" && "nodeType" in obj && typeof obj.nodeType == "number" && "nodeName" in obj && typeof obj.nodeName == "string" && "isEqualNode" in obj && typeof obj.isEqualNode == "function";
}
var IS_KEYED_SENTINEL2 = "@@__IMMUTABLE_KEYED__@@", IS_SET_SENTINEL2 = "@@__IMMUTABLE_SET__@@", IS_LIST_SENTINEL2 = "@@__IMMUTABLE_LIST__@@", IS_ORDERED_SENTINEL2 = "@@__IMMUTABLE_ORDERED__@@", IS_RECORD_SYMBOL2 = "@@__IMMUTABLE_RECORD__@@";
function isImmutableUnorderedKeyed(maybeKeyed) {
  return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL2] && !maybeKeyed[IS_ORDERED_SENTINEL2]);
}
function isImmutableUnorderedSet(maybeSet) {
  return !!(maybeSet && maybeSet[IS_SET_SENTINEL2] && !maybeSet[IS_ORDERED_SENTINEL2]);
}
function isObjectLiteral(source) {
  return source != null && typeof source == "object" && !Array.isArray(source);
}
function isImmutableList(source) {
  return !!(source && isObjectLiteral(source) && source[IS_LIST_SENTINEL2]);
}
function isImmutableOrderedKeyed(source) {
  return !!(source && isObjectLiteral(source) && source[IS_KEYED_SENTINEL2] && source[IS_ORDERED_SENTINEL2]);
}
function isImmutableOrderedSet(source) {
  return !!(source && isObjectLiteral(source) && source[IS_SET_SENTINEL2] && source[IS_ORDERED_SENTINEL2]);
}
function isImmutableRecord(source) {
  return !!(source && isObjectLiteral(source) && source[IS_RECORD_SYMBOL2]);
}
var IteratorSymbol = Symbol.iterator;
function hasIterator(object) {
  return !!(object != null && object[IteratorSymbol]);
}
function iterableEquality(a2, b2, customTesters = [], aStack = [], bStack = []) {
  if (typeof a2 != "object" || typeof b2 != "object" || Array.isArray(a2) || Array.isArray(b2) || !hasIterator(a2) || !hasIterator(b2))
    return;
  if (a2.constructor !== b2.constructor)
    return !1;
  let length = aStack.length;
  for (; length--; )
    if (aStack[length] === a2)
      return bStack[length] === b2;
  aStack.push(a2), bStack.push(b2);
  let filteredCustomTesters = [...customTesters.filter((t2) => t2 !== iterableEquality), iterableEqualityWithStack];
  function iterableEqualityWithStack(a3, b3) {
    return iterableEquality(a3, b3, [...customTesters], [...aStack], [...bStack]);
  }
  if (a2.size !== void 0) {
    if (a2.size !== b2.size)
      return !1;
    if (isA("Set", a2) || isImmutableUnorderedSet(a2)) {
      let allFound = !0;
      for (let aValue of a2)
        if (!b2.has(aValue)) {
          let has = !1;
          for (let bValue of b2)
            equals(aValue, bValue, filteredCustomTesters) === !0 && (has = !0);
          if (has === !1) {
            allFound = !1;
            break;
          }
        }
      return aStack.pop(), bStack.pop(), allFound;
    } else if (isA("Map", a2) || isImmutableUnorderedKeyed(a2)) {
      let allFound = !0;
      for (let aEntry of a2)
        if (!b2.has(aEntry[0]) || !equals(aEntry[1], b2.get(aEntry[0]), filteredCustomTesters)) {
          let has = !1;
          for (let bEntry of b2) {
            let matchedKey = equals(aEntry[0], bEntry[0], filteredCustomTesters), matchedValue = !1;
            matchedKey === !0 && (matchedValue = equals(aEntry[1], bEntry[1], filteredCustomTesters)), matchedValue === !0 && (has = !0);
          }
          if (has === !1) {
            allFound = !1;
            break;
          }
        }
      return aStack.pop(), bStack.pop(), allFound;
    }
  }
  let bIterator = b2[IteratorSymbol]();
  for (let aValue of a2) {
    let nextB = bIterator.next();
    if (nextB.done || !equals(aValue, nextB.value, filteredCustomTesters))
      return !1;
  }
  if (!bIterator.next().done)
    return !1;
  if (!isImmutableList(a2) && !isImmutableOrderedKeyed(a2) && !isImmutableOrderedSet(a2) && !isImmutableRecord(a2)) {
    let aEntries = Object.entries(a2), bEntries = Object.entries(b2);
    if (!equals(aEntries, bEntries, filteredCustomTesters))
      return !1;
  }
  return aStack.pop(), bStack.pop(), !0;
}
function hasPropertyInObject(object, key) {
  return !object || typeof object != "object" || object === Object.prototype ? !1 : Object.prototype.hasOwnProperty.call(object, key) || hasPropertyInObject(Object.getPrototypeOf(object), key);
}
function isObjectWithKeys(a2) {
  return isObject4(a2) && !(a2 instanceof Error) && !Array.isArray(a2) && !(a2 instanceof Date);
}
function subsetEquality(object, subset, customTesters = []) {
  let filteredCustomTesters = customTesters.filter((t2) => t2 !== subsetEquality), subsetEqualityWithContext = (seenReferences = /* @__PURE__ */ new WeakMap()) => (object2, subset2) => {
    if (isObjectWithKeys(subset2))
      return Object.keys(subset2).every((key) => {
        if (subset2[key] != null && typeof subset2[key] == "object") {
          if (seenReferences.has(subset2[key]))
            return equals(object2[key], subset2[key], filteredCustomTesters);
          seenReferences.set(subset2[key], !0);
        }
        let result = object2 != null && hasPropertyInObject(object2, key) && equals(object2[key], subset2[key], [...filteredCustomTesters, subsetEqualityWithContext(seenReferences)]);
        return seenReferences.delete(subset2[key]), result;
      });
  };
  return subsetEqualityWithContext()(object, subset);
}
function typeEquality(a2, b2) {
  if (!(a2 == null || b2 == null || a2.constructor === b2.constructor))
    return !1;
}
function arrayBufferEquality(a2, b2) {
  let dataViewA = a2, dataViewB = b2;
  if (!(a2 instanceof DataView && b2 instanceof DataView)) {
    if (!(a2 instanceof ArrayBuffer) || !(b2 instanceof ArrayBuffer))
      return;
    try {
      dataViewA = new DataView(a2), dataViewB = new DataView(b2);
    } catch {
      return;
    }
  }
  if (dataViewA.byteLength !== dataViewB.byteLength)
    return !1;
  for (let i2 = 0; i2 < dataViewA.byteLength; i2++)
    if (dataViewA.getUint8(i2) !== dataViewB.getUint8(i2))
      return !1;
  return !0;
}
function sparseArrayEquality(a2, b2, customTesters = []) {
  if (!Array.isArray(a2) || !Array.isArray(b2))
    return;
  let aKeys = Object.keys(a2), bKeys = Object.keys(b2), filteredCustomTesters = customTesters.filter((t2) => t2 !== sparseArrayEquality);
  return equals(a2, b2, filteredCustomTesters, !0) && equals(aKeys, bKeys);
}
function generateToBeMessage(deepEqualityName, expected = "#{this}", actual = "#{exp}") {
  let toBeMessage = `expected ${expected} to be ${actual} // Object.is equality`;
  return ["toStrictEqual", "toEqual"].includes(deepEqualityName) ? `${toBeMessage}

If it should pass with deep equality, replace "toBe" with "${deepEqualityName}"

Expected: ${expected}
Received: serializes to the same string
` : toBeMessage;
}
function pluralize(word, count2) {
  return `${count2} ${word}${count2 === 1 ? "" : "s"}`;
}
function getObjectKeys(object) {
  return [...Object.keys(object), ...Object.getOwnPropertySymbols(object).filter((s3) => {
    var _Object$getOwnPropert;
    return (_Object$getOwnPropert = Object.getOwnPropertyDescriptor(object, s3)) === null || _Object$getOwnPropert === void 0 ? void 0 : _Object$getOwnPropert.enumerable;
  })];
}
function getObjectSubset(object, subset, customTesters) {
  let stripped = 0, getObjectSubsetWithContext = (seenReferences = /* @__PURE__ */ new WeakMap()) => (object2, subset2) => {
    if (Array.isArray(object2)) {
      if (Array.isArray(subset2) && subset2.length === object2.length)
        return subset2.map((sub, i2) => getObjectSubsetWithContext(seenReferences)(object2[i2], sub));
    } else {
      if (object2 instanceof Date)
        return object2;
      if (isObject4(object2) && isObject4(subset2)) {
        if (equals(object2, subset2, [
          ...customTesters,
          iterableEquality,
          subsetEquality
        ]))
          return subset2;
        let trimmed = {};
        seenReferences.set(object2, trimmed), typeof object2.constructor == "function" && typeof object2.constructor.name == "string" && Object.defineProperty(trimmed, "constructor", {
          enumerable: !1,
          value: object2.constructor
        });
        for (let key of getObjectKeys(object2))
          hasPropertyInObject(subset2, key) ? trimmed[key] = seenReferences.has(object2[key]) ? seenReferences.get(object2[key]) : getObjectSubsetWithContext(seenReferences)(object2[key], subset2[key]) : seenReferences.has(object2[key]) || (stripped += 1, isObject4(object2[key]) && (stripped += getObjectKeys(object2[key]).length), getObjectSubsetWithContext(seenReferences)(object2[key], subset2[key]));
        if (getObjectKeys(trimmed).length > 0)
          return trimmed;
      }
    }
    return object2;
  };
  return {
    subset: getObjectSubsetWithContext()(object, subset),
    stripped
  };
}
if (!Object.prototype.hasOwnProperty.call(globalThis, MATCHERS_OBJECT)) {
  let globalState = /* @__PURE__ */ new WeakMap();
  Object.defineProperty(globalThis, MATCHERS_OBJECT, { get: () => globalState });
}
if (!Object.prototype.hasOwnProperty.call(globalThis, JEST_MATCHERS_OBJECT)) {
  let matchers = /* @__PURE__ */ Object.create(null), customEqualityTesters = [];
  Object.defineProperty(globalThis, JEST_MATCHERS_OBJECT, {
    configurable: !0,
    get: () => ({
      state: globalThis[MATCHERS_OBJECT].get(globalThis[GLOBAL_EXPECT]),
      matchers,
      customEqualityTesters
    })
  });
}
if (!Object.prototype.hasOwnProperty.call(globalThis, ASYMMETRIC_MATCHERS_OBJECT)) {
  let asymmetricMatchers = /* @__PURE__ */ Object.create(null);
  Object.defineProperty(globalThis, ASYMMETRIC_MATCHERS_OBJECT, { get: () => asymmetricMatchers });
}
function getState(expect4) {
  return globalThis[MATCHERS_OBJECT].get(expect4);
}
function setState(state3, expect4) {
  let map2 = globalThis[MATCHERS_OBJECT], current = map2.get(expect4) || {}, results = Object.defineProperties(current, {
    ...Object.getOwnPropertyDescriptors(current),
    ...Object.getOwnPropertyDescriptors(state3)
  });
  map2.set(expect4, results);
}
var AsymmetricMatcher3 = class {
  // should have "jest" to be compatible with its ecosystem
  $$typeof = Symbol.for("jest.asymmetricMatcher");
  constructor(sample, inverse = !1) {
    this.sample = sample, this.inverse = inverse;
  }
  getMatcherContext(expect4) {
    return {
      ...getState(expect4 || globalThis[GLOBAL_EXPECT]),
      equals,
      isNot: this.inverse,
      customTesters: getCustomEqualityTesters(),
      utils: {
        ...getMatcherUtils(),
        diff,
        stringify: stringify2,
        iterableEquality,
        subsetEquality
      }
    };
  }
};
AsymmetricMatcher3.prototype[Symbol.for("chai/inspect")] = function(options) {
  let result = stringify2(this, options.depth, { min: !0 });
  return result.length <= options.truncate ? result : `${this.toString()}{\u2026}`;
};
var StringContaining = class extends AsymmetricMatcher3 {
  constructor(sample, inverse = !1) {
    if (!isA("String", sample))
      throw new Error("Expected is not a string");
    super(sample, inverse);
  }
  asymmetricMatch(other) {
    let result = isA("String", other) && other.includes(this.sample);
    return this.inverse ? !result : result;
  }
  toString() {
    return `String${this.inverse ? "Not" : ""}Containing`;
  }
  getExpectedType() {
    return "string";
  }
}, Anything = class extends AsymmetricMatcher3 {
  asymmetricMatch(other) {
    return other != null;
  }
  toString() {
    return "Anything";
  }
  toAsymmetricMatcher() {
    return "Anything";
  }
}, ObjectContaining = class extends AsymmetricMatcher3 {
  constructor(sample, inverse = !1) {
    super(sample, inverse);
  }
  getPrototype(obj) {
    return Object.getPrototypeOf ? Object.getPrototypeOf(obj) : obj.constructor.prototype === obj ? null : obj.constructor.prototype;
  }
  hasProperty(obj, property) {
    return obj ? Object.prototype.hasOwnProperty.call(obj, property) ? !0 : this.hasProperty(this.getPrototype(obj), property) : !1;
  }
  asymmetricMatch(other) {
    if (typeof this.sample != "object")
      throw new TypeError(`You must provide an object to ${this.toString()}, not '${typeof this.sample}'.`);
    let result = !0, matcherContext = this.getMatcherContext();
    for (let property in this.sample)
      if (!this.hasProperty(other, property) || !equals(this.sample[property], other[property], matcherContext.customTesters)) {
        result = !1;
        break;
      }
    return this.inverse ? !result : result;
  }
  toString() {
    return `Object${this.inverse ? "Not" : ""}Containing`;
  }
  getExpectedType() {
    return "object";
  }
}, ArrayContaining = class extends AsymmetricMatcher3 {
  constructor(sample, inverse = !1) {
    super(sample, inverse);
  }
  asymmetricMatch(other) {
    if (!Array.isArray(this.sample))
      throw new TypeError(`You must provide an array to ${this.toString()}, not '${typeof this.sample}'.`);
    let matcherContext = this.getMatcherContext(), result = this.sample.length === 0 || Array.isArray(other) && this.sample.every((item) => other.some((another) => equals(item, another, matcherContext.customTesters)));
    return this.inverse ? !result : result;
  }
  toString() {
    return `Array${this.inverse ? "Not" : ""}Containing`;
  }
  getExpectedType() {
    return "array";
  }
}, Any = class extends AsymmetricMatcher3 {
  constructor(sample) {
    if (typeof sample > "u")
      throw new TypeError("any() expects to be passed a constructor function. Please pass one or use anything() to match any object.");
    super(sample);
  }
  fnNameFor(func) {
    if (func.name)
      return func.name;
    let matches5 = Function.prototype.toString.call(func).match(/^(?:async)?\s*function\s*(?:\*\s*)?([\w$]+)\s*\(/);
    return matches5 ? matches5[1] : "<anonymous>";
  }
  asymmetricMatch(other) {
    return this.sample === String ? typeof other == "string" || other instanceof String : this.sample === Number ? typeof other == "number" || other instanceof Number : this.sample === Function ? typeof other == "function" || typeof other == "function" : this.sample === Boolean ? typeof other == "boolean" || other instanceof Boolean : this.sample === BigInt ? typeof other == "bigint" || other instanceof BigInt : this.sample === Symbol ? typeof other == "symbol" || other instanceof Symbol : this.sample === Object ? typeof other == "object" : other instanceof this.sample;
  }
  toString() {
    return "Any";
  }
  getExpectedType() {
    return this.sample === String ? "string" : this.sample === Number ? "number" : this.sample === Function ? "function" : this.sample === Object ? "object" : this.sample === Boolean ? "boolean" : this.fnNameFor(this.sample);
  }
  toAsymmetricMatcher() {
    return `Any<${this.fnNameFor(this.sample)}>`;
  }
}, StringMatching = class extends AsymmetricMatcher3 {
  constructor(sample, inverse = !1) {
    if (!isA("String", sample) && !isA("RegExp", sample))
      throw new Error("Expected is not a String or a RegExp");
    super(new RegExp(sample), inverse);
  }
  asymmetricMatch(other) {
    let result = isA("String", other) && this.sample.test(other);
    return this.inverse ? !result : result;
  }
  toString() {
    return `String${this.inverse ? "Not" : ""}Matching`;
  }
  getExpectedType() {
    return "string";
  }
}, CloseTo = class extends AsymmetricMatcher3 {
  precision;
  constructor(sample, precision = 2, inverse = !1) {
    if (!isA("Number", sample))
      throw new Error("Expected is not a Number");
    if (!isA("Number", precision))
      throw new Error("Precision is not a Number");
    super(sample), this.inverse = inverse, this.precision = precision;
  }
  asymmetricMatch(other) {
    if (!isA("Number", other))
      return !1;
    let result = !1;
    return other === Number.POSITIVE_INFINITY && this.sample === Number.POSITIVE_INFINITY || other === Number.NEGATIVE_INFINITY && this.sample === Number.NEGATIVE_INFINITY ? result = !0 : result = Math.abs(this.sample - other) < 10 ** -this.precision / 2, this.inverse ? !result : result;
  }
  toString() {
    return `Number${this.inverse ? "Not" : ""}CloseTo`;
  }
  getExpectedType() {
    return "number";
  }
  toAsymmetricMatcher() {
    return [
      this.toString(),
      this.sample,
      `(${pluralize("digit", this.precision)})`
    ].join(" ");
  }
}, JestAsymmetricMatchers = (chai, utils) => {
  utils.addMethod(chai.expect, "anything", () => new Anything()), utils.addMethod(chai.expect, "any", (expected) => new Any(expected)), utils.addMethod(chai.expect, "stringContaining", (expected) => new StringContaining(expected)), utils.addMethod(chai.expect, "objectContaining", (expected) => new ObjectContaining(expected)), utils.addMethod(chai.expect, "arrayContaining", (expected) => new ArrayContaining(expected)), utils.addMethod(chai.expect, "stringMatching", (expected) => new StringMatching(expected)), utils.addMethod(chai.expect, "closeTo", (expected, precision) => new CloseTo(expected, precision)), chai.expect.not = {
    stringContaining: (expected) => new StringContaining(expected, !0),
    objectContaining: (expected) => new ObjectContaining(expected, !0),
    arrayContaining: (expected) => new ArrayContaining(expected, !0),
    stringMatching: (expected) => new StringMatching(expected, !0),
    closeTo: (expected, precision) => new CloseTo(expected, precision, !0)
  };
};
function createAssertionMessage(util, assertion, hasArgs) {
  let not = util.flag(assertion, "negate") ? "not." : "", name = `${util.flag(assertion, "_name")}(${hasArgs ? "expected" : ""})`, promiseName = util.flag(assertion, "promise");
  return `expect(actual)${promiseName ? `.${promiseName}` : ""}.${not}${name}`;
}
function recordAsyncExpect(_test, promise, assertion, error) {
  let test3 = _test;
  if (test3 && promise instanceof Promise) {
    promise = promise.finally(() => {
      if (!test3.promises)
        return;
      let index2 = test3.promises.indexOf(promise);
      index2 !== -1 && test3.promises.splice(index2, 1);
    }), test3.promises || (test3.promises = []), test3.promises.push(promise);
    let resolved = !1;
    return test3.onFinished ?? (test3.onFinished = []), test3.onFinished.push(() => {
      if (!resolved) {
        var _vitest_worker__;
        let stack = (((_vitest_worker__ = globalThis.__vitest_worker__) === null || _vitest_worker__ === void 0 ? void 0 : _vitest_worker__.onFilterStackTrace) || ((s3) => s3 || ""))(error.stack);
        console.warn([
          `Promise returned by \`${assertion}\` was not awaited. `,
          "Vitest currently auto-awaits hanging assertions at the end of the test, but this will cause the test to fail in Vitest 3. ",
          `Please remember to await the assertion.
`,
          stack
        ].join(""));
      }
    }), {
      then(onFulfilled, onRejected) {
        return resolved = !0, promise.then(onFulfilled, onRejected);
      },
      catch(onRejected) {
        return promise.catch(onRejected);
      },
      finally(onFinally) {
        return promise.finally(onFinally);
      },
      [Symbol.toStringTag]: "Promise"
    };
  }
  return promise;
}
function handleTestError(test3, err) {
  var _test$result;
  test3.result || (test3.result = { state: "fail" }), test3.result.state = "fail", (_test$result = test3.result).errors || (_test$result.errors = []), test3.result.errors.push(processError(err));
}
function wrapAssertion(utils, name, fn3) {
  return function(...args) {
    if (name !== "withTest" && utils.flag(this, "_name", name), !utils.flag(this, "soft"))
      return fn3.apply(this, args);
    let test3 = utils.flag(this, "vitest-test");
    if (!test3)
      throw new Error("expect.soft() can only be used inside a test");
    try {
      let result = fn3.apply(this, args);
      return result && typeof result == "object" && typeof result.then == "function" ? result.then(noop, (err) => {
        handleTestError(test3, err);
      }) : result;
    } catch (err) {
      handleTestError(test3, err);
    }
  };
}
var JestChaiExpect = (chai, utils) => {
  let { AssertionError: AssertionError2 } = chai, customTesters = getCustomEqualityTesters();
  function def(name, fn3) {
    let addMethod2 = (n2) => {
      let softWrapper = wrapAssertion(utils, n2, fn3);
      utils.addMethod(chai.Assertion.prototype, n2, softWrapper), utils.addMethod(globalThis[JEST_MATCHERS_OBJECT].matchers, n2, softWrapper);
    };
    Array.isArray(name) ? name.forEach((n2) => addMethod2(n2)) : addMethod2(name);
  }
  [
    "throw",
    "throws",
    "Throw"
  ].forEach((m3) => {
    utils.overwriteMethod(chai.Assertion.prototype, m3, (_super) => function(...args) {
      let promise = utils.flag(this, "promise"), object = utils.flag(this, "object"), isNot = utils.flag(this, "negate");
      if (promise === "rejects")
        utils.flag(this, "object", () => {
          throw object;
        });
      else if (promise === "resolves" && typeof object != "function") {
        if (isNot)
          return;
        {
          let message = utils.flag(this, "message") || "expected promise to throw an error, but it didn't", error = { showDiff: !1 };
          throw new AssertionError2(message, error, utils.flag(this, "ssfi"));
        }
      }
      _super.apply(this, args);
    });
  }), def("withTest", function(test3) {
    return utils.flag(this, "vitest-test", test3), this;
  }), def("toEqual", function(expected) {
    let actual = utils.flag(this, "object"), equal = equals(actual, expected, [...customTesters, iterableEquality]);
    return this.assert(equal, "expected #{this} to deeply equal #{exp}", "expected #{this} to not deeply equal #{exp}", expected, actual);
  }), def("toStrictEqual", function(expected) {
    let obj = utils.flag(this, "object"), equal = equals(obj, expected, [
      ...customTesters,
      iterableEquality,
      typeEquality,
      sparseArrayEquality,
      arrayBufferEquality
    ], !0);
    return this.assert(equal, "expected #{this} to strictly equal #{exp}", "expected #{this} to not strictly equal #{exp}", expected, obj);
  }), def("toBe", function(expected) {
    let actual = this._obj, pass = Object.is(actual, expected), deepEqualityName = "";
    return pass || (equals(actual, expected, [
      ...customTesters,
      iterableEquality,
      typeEquality,
      sparseArrayEquality,
      arrayBufferEquality
    ], !0) ? deepEqualityName = "toStrictEqual" : equals(actual, expected, [...customTesters, iterableEquality]) && (deepEqualityName = "toEqual")), this.assert(pass, generateToBeMessage(deepEqualityName), "expected #{this} not to be #{exp} // Object.is equality", expected, actual);
  }), def("toMatchObject", function(expected) {
    let actual = this._obj, pass = equals(actual, expected, [
      ...customTesters,
      iterableEquality,
      subsetEquality
    ]), isNot = utils.flag(this, "negate"), { subset: actualSubset, stripped } = getObjectSubset(actual, expected, customTesters);
    if (pass && isNot || !pass && !isNot) {
      let msg = utils.getMessage(this, [
        pass,
        "expected #{this} to match object #{exp}",
        "expected #{this} to not match object #{exp}",
        expected,
        actualSubset,
        !1
      ]), message = stripped === 0 ? msg : `${msg}
(${stripped} matching ${stripped === 1 ? "property" : "properties"} omitted from actual)`;
      throw new AssertionError2(message, {
        showDiff: !0,
        expected,
        actual: actualSubset
      });
    }
  }), def("toMatch", function(expected) {
    let actual = this._obj;
    if (typeof actual != "string")
      throw new TypeError(`.toMatch() expects to receive a string, but got ${typeof actual}`);
    return this.assert(typeof expected == "string" ? actual.includes(expected) : actual.match(expected), "expected #{this} to match #{exp}", "expected #{this} not to match #{exp}", expected, actual);
  }), def("toContain", function(item) {
    let actual = this._obj;
    if (typeof Node < "u" && actual instanceof Node) {
      if (!(item instanceof Node))
        throw new TypeError(`toContain() expected a DOM node as the argument, but got ${typeof item}`);
      return this.assert(actual.contains(item), "expected #{this} to contain element #{exp}", "expected #{this} not to contain element #{exp}", item, actual);
    }
    if (typeof DOMTokenList < "u" && actual instanceof DOMTokenList) {
      assertTypes(item, "class name", ["string"]);
      let expectedClassList = utils.flag(this, "negate") ? actual.value.replace(item, "").trim() : `${actual.value} ${item}`;
      return this.assert(actual.contains(item), `expected "${actual.value}" to contain "${item}"`, `expected "${actual.value}" not to contain "${item}"`, expectedClassList, actual.value);
    }
    return typeof actual == "string" && typeof item == "string" ? this.assert(actual.includes(item), "expected #{this} to contain #{exp}", "expected #{this} not to contain #{exp}", item, actual) : (actual != null && typeof actual != "string" && utils.flag(this, "object", Array.from(actual)), this.contain(item));
  }), def("toContainEqual", function(expected) {
    let obj = utils.flag(this, "object"), index2 = Array.from(obj).findIndex((item) => equals(item, expected, customTesters));
    this.assert(index2 !== -1, "expected #{this} to deep equally contain #{exp}", "expected #{this} to not deep equally contain #{exp}", expected);
  }), def("toBeTruthy", function() {
    let obj = utils.flag(this, "object");
    this.assert(!!obj, "expected #{this} to be truthy", "expected #{this} to not be truthy", !0, obj);
  }), def("toBeFalsy", function() {
    let obj = utils.flag(this, "object");
    this.assert(!obj, "expected #{this} to be falsy", "expected #{this} to not be falsy", !1, obj);
  }), def("toBeGreaterThan", function(expected) {
    let actual = this._obj;
    return assertTypes(actual, "actual", ["number", "bigint"]), assertTypes(expected, "expected", ["number", "bigint"]), this.assert(actual > expected, `expected ${actual} to be greater than ${expected}`, `expected ${actual} to be not greater than ${expected}`, expected, actual, !1);
  }), def("toBeGreaterThanOrEqual", function(expected) {
    let actual = this._obj;
    return assertTypes(actual, "actual", ["number", "bigint"]), assertTypes(expected, "expected", ["number", "bigint"]), this.assert(actual >= expected, `expected ${actual} to be greater than or equal to ${expected}`, `expected ${actual} to be not greater than or equal to ${expected}`, expected, actual, !1);
  }), def("toBeLessThan", function(expected) {
    let actual = this._obj;
    return assertTypes(actual, "actual", ["number", "bigint"]), assertTypes(expected, "expected", ["number", "bigint"]), this.assert(actual < expected, `expected ${actual} to be less than ${expected}`, `expected ${actual} to be not less than ${expected}`, expected, actual, !1);
  }), def("toBeLessThanOrEqual", function(expected) {
    let actual = this._obj;
    return assertTypes(actual, "actual", ["number", "bigint"]), assertTypes(expected, "expected", ["number", "bigint"]), this.assert(actual <= expected, `expected ${actual} to be less than or equal to ${expected}`, `expected ${actual} to be not less than or equal to ${expected}`, expected, actual, !1);
  }), def("toBeNaN", function() {
    let obj = utils.flag(this, "object");
    this.assert(Number.isNaN(obj), "expected #{this} to be NaN", "expected #{this} not to be NaN", Number.NaN, obj);
  }), def("toBeUndefined", function() {
    let obj = utils.flag(this, "object");
    this.assert(obj === void 0, "expected #{this} to be undefined", "expected #{this} not to be undefined", void 0, obj);
  }), def("toBeNull", function() {
    let obj = utils.flag(this, "object");
    this.assert(obj === null, "expected #{this} to be null", "expected #{this} not to be null", null, obj);
  }), def("toBeDefined", function() {
    let obj = utils.flag(this, "object");
    this.assert(typeof obj < "u", "expected #{this} to be defined", "expected #{this} to be undefined", obj);
  }), def("toBeTypeOf", function(expected) {
    let actual = typeof this._obj, equal = expected === actual;
    return this.assert(equal, "expected #{this} to be type of #{exp}", "expected #{this} not to be type of #{exp}", expected, actual);
  }), def("toBeInstanceOf", function(obj) {
    return this.instanceOf(obj);
  }), def("toHaveLength", function(length) {
    return this.have.length(length);
  }), def("toHaveProperty", function(...args) {
    Array.isArray(args[0]) && (args[0] = args[0].map((key) => String(key).replace(/([.[\]])/g, "\\$1")).join("."));
    let actual = this._obj, [propertyName, expected] = args, getValue2 = () => Object.prototype.hasOwnProperty.call(actual, propertyName) ? {
      value: actual[propertyName],
      exists: !0
    } : utils.getPathInfo(actual, propertyName), { value, exists } = getValue2(), pass = exists && (args.length === 1 || equals(expected, value, customTesters)), valueString = args.length === 1 ? "" : ` with value ${utils.objDisplay(expected)}`;
    return this.assert(pass, `expected #{this} to have property "${propertyName}"${valueString}`, `expected #{this} to not have property "${propertyName}"${valueString}`, expected, exists ? value : void 0);
  }), def("toBeCloseTo", function(received, precision = 2) {
    let expected = this._obj, pass = !1, expectedDiff2 = 0, receivedDiff = 0;
    return received === Number.POSITIVE_INFINITY && expected === Number.POSITIVE_INFINITY || received === Number.NEGATIVE_INFINITY && expected === Number.NEGATIVE_INFINITY ? pass = !0 : (expectedDiff2 = 10 ** -precision / 2, receivedDiff = Math.abs(expected - received), pass = receivedDiff < expectedDiff2), this.assert(pass, `expected #{this} to be close to #{exp}, received difference is ${receivedDiff}, but expected ${expectedDiff2}`, `expected #{this} to not be close to #{exp}, received difference is ${receivedDiff}, but expected ${expectedDiff2}`, received, expected, !1);
  });
  function assertIsMock(assertion) {
    if (!isMockFunction(assertion._obj))
      throw new TypeError(`${utils.inspect(assertion._obj)} is not a spy or a call to a spy!`);
  }
  function getSpy(assertion) {
    return assertIsMock(assertion), assertion._obj;
  }
  def(["toHaveBeenCalledTimes", "toBeCalledTimes"], function(number) {
    let spy = getSpy(this), spyName = spy.getMockName(), callCount = spy.mock.calls.length;
    return this.assert(callCount === number, `expected "${spyName}" to be called #{exp} times, but got ${callCount} times`, `expected "${spyName}" to not be called #{exp} times`, number, callCount, !1);
  }), def("toHaveBeenCalledOnce", function() {
    let spy = getSpy(this), spyName = spy.getMockName(), callCount = spy.mock.calls.length;
    return this.assert(callCount === 1, `expected "${spyName}" to be called once, but got ${callCount} times`, `expected "${spyName}" to not be called once`, 1, callCount, !1);
  }), def(["toHaveBeenCalled", "toBeCalled"], function() {
    let spy = getSpy(this), spyName = spy.getMockName(), callCount = spy.mock.calls.length, called = callCount > 0, isNot = utils.flag(this, "negate"), msg = utils.getMessage(this, [
      called,
      `expected "${spyName}" to be called at least once`,
      `expected "${spyName}" to not be called at all, but actually been called ${callCount} times`,
      !0,
      called
    ]);
    if (called && isNot && (msg = formatCalls(spy, msg)), called && isNot || !called && !isNot)
      throw new AssertionError2(msg);
  });
  function equalsArgumentArray(a2, b2) {
    return a2.length === b2.length && a2.every((aItem, i2) => equals(aItem, b2[i2], [...customTesters, iterableEquality]));
  }
  def(["toHaveBeenCalledWith", "toBeCalledWith"], function(...args) {
    let spy = getSpy(this), spyName = spy.getMockName(), pass = spy.mock.calls.some((callArg) => equalsArgumentArray(callArg, args)), isNot = utils.flag(this, "negate"), msg = utils.getMessage(this, [
      pass,
      `expected "${spyName}" to be called with arguments: #{exp}`,
      `expected "${spyName}" to not be called with arguments: #{exp}`,
      args
    ]);
    if (pass && isNot || !pass && !isNot)
      throw new AssertionError2(formatCalls(spy, msg, args));
  }), def("toHaveBeenCalledExactlyOnceWith", function(...args) {
    let spy = getSpy(this), spyName = spy.getMockName(), callCount = spy.mock.calls.length, pass = spy.mock.calls.some((callArg) => equalsArgumentArray(callArg, args)) && callCount === 1, isNot = utils.flag(this, "negate"), msg = utils.getMessage(this, [
      pass,
      `expected "${spyName}" to be called once with arguments: #{exp}`,
      `expected "${spyName}" to not be called once with arguments: #{exp}`,
      args
    ]);
    if (pass && isNot || !pass && !isNot)
      throw new AssertionError2(formatCalls(spy, msg, args));
  }), def(["toHaveBeenNthCalledWith", "nthCalledWith"], function(times, ...args) {
    let spy = getSpy(this), spyName = spy.getMockName(), nthCall = spy.mock.calls[times - 1], callCount = spy.mock.calls.length, isCalled = times <= callCount;
    this.assert(nthCall && equalsArgumentArray(nthCall, args), `expected ${ordinalOf(times)} "${spyName}" call to have been called with #{exp}${isCalled ? "" : `, but called only ${callCount} times`}`, `expected ${ordinalOf(times)} "${spyName}" call to not have been called with #{exp}`, args, nthCall, isCalled);
  }), def(["toHaveBeenLastCalledWith", "lastCalledWith"], function(...args) {
    let spy = getSpy(this), spyName = spy.getMockName(), lastCall = spy.mock.calls[spy.mock.calls.length - 1];
    this.assert(lastCall && equalsArgumentArray(lastCall, args), `expected last "${spyName}" call to have been called with #{exp}`, `expected last "${spyName}" call to not have been called with #{exp}`, args, lastCall);
  });
  function isSpyCalledBeforeAnotherSpy(beforeSpy, afterSpy, failIfNoFirstInvocation) {
    let beforeInvocationCallOrder = beforeSpy.mock.invocationCallOrder, afterInvocationCallOrder = afterSpy.mock.invocationCallOrder;
    return beforeInvocationCallOrder.length === 0 ? !failIfNoFirstInvocation : afterInvocationCallOrder.length === 0 ? !1 : beforeInvocationCallOrder[0] < afterInvocationCallOrder[0];
  }
  def(["toHaveBeenCalledBefore"], function(resultSpy, failIfNoFirstInvocation = !0) {
    let expectSpy = getSpy(this);
    if (!isMockFunction(resultSpy))
      throw new TypeError(`${utils.inspect(resultSpy)} is not a spy or a call to a spy`);
    this.assert(isSpyCalledBeforeAnotherSpy(expectSpy, resultSpy, failIfNoFirstInvocation), `expected "${expectSpy.getMockName()}" to have been called before "${resultSpy.getMockName()}"`, `expected "${expectSpy.getMockName()}" to not have been called before "${resultSpy.getMockName()}"`, resultSpy, expectSpy);
  }), def(["toHaveBeenCalledAfter"], function(resultSpy, failIfNoFirstInvocation = !0) {
    let expectSpy = getSpy(this);
    if (!isMockFunction(resultSpy))
      throw new TypeError(`${utils.inspect(resultSpy)} is not a spy or a call to a spy`);
    this.assert(isSpyCalledBeforeAnotherSpy(resultSpy, expectSpy, failIfNoFirstInvocation), `expected "${expectSpy.getMockName()}" to have been called after "${resultSpy.getMockName()}"`, `expected "${expectSpy.getMockName()}" to not have been called after "${resultSpy.getMockName()}"`, resultSpy, expectSpy);
  }), def(["toThrow", "toThrowError"], function(expected) {
    if (typeof expected == "string" || typeof expected > "u" || expected instanceof RegExp)
      return this.throws(expected === "" ? /^$/ : expected);
    let obj = this._obj, promise = utils.flag(this, "promise"), isNot = utils.flag(this, "negate"), thrown = null;
    if (promise === "rejects")
      thrown = obj;
    else if (promise === "resolves" && typeof obj != "function") {
      if (isNot)
        return;
      {
        let message = utils.flag(this, "message") || "expected promise to throw an error, but it didn't", error = { showDiff: !1 };
        throw new AssertionError2(message, error, utils.flag(this, "ssfi"));
      }
    } else {
      let isThrow = !1;
      try {
        obj();
      } catch (err) {
        isThrow = !0, thrown = err;
      }
      if (!isThrow && !isNot) {
        let message = utils.flag(this, "message") || "expected function to throw an error, but it didn't", error = { showDiff: !1 };
        throw new AssertionError2(message, error, utils.flag(this, "ssfi"));
      }
    }
    if (typeof expected == "function") {
      let name = expected.name || expected.prototype.constructor.name;
      return this.assert(thrown && thrown instanceof expected, `expected error to be instance of ${name}`, `expected error not to be instance of ${name}`, expected, thrown);
    }
    if (expected instanceof Error) {
      let equal = equals(thrown, expected, [...customTesters, iterableEquality]);
      return this.assert(equal, "expected a thrown error to be #{exp}", "expected a thrown error not to be #{exp}", expected, thrown);
    }
    if (typeof expected == "object" && "asymmetricMatch" in expected && typeof expected.asymmetricMatch == "function") {
      let matcher = expected;
      return this.assert(thrown && matcher.asymmetricMatch(thrown), "expected error to match asymmetric matcher", "expected error not to match asymmetric matcher", matcher, thrown);
    }
    throw new Error(`"toThrow" expects string, RegExp, function, Error instance or asymmetric matcher, got "${typeof expected}"`);
  }), [{
    name: "toHaveResolved",
    condition: (spy) => spy.mock.settledResults.length > 0 && spy.mock.settledResults.some(({ type: type5 }) => type5 === "fulfilled"),
    action: "resolved"
  }, {
    name: ["toHaveReturned", "toReturn"],
    condition: (spy) => spy.mock.calls.length > 0 && spy.mock.results.some(({ type: type5 }) => type5 !== "throw"),
    action: "called"
  }].forEach(({ name, condition, action: action2 }) => {
    def(name, function() {
      let spy = getSpy(this), spyName = spy.getMockName(), pass = condition(spy);
      this.assert(pass, `expected "${spyName}" to be successfully ${action2} at least once`, `expected "${spyName}" to not be successfully ${action2}`, pass, !pass, !1);
    });
  }), [{
    name: "toHaveResolvedTimes",
    condition: (spy, times) => spy.mock.settledResults.reduce((s3, { type: type5 }) => type5 === "fulfilled" ? ++s3 : s3, 0) === times,
    action: "resolved"
  }, {
    name: ["toHaveReturnedTimes", "toReturnTimes"],
    condition: (spy, times) => spy.mock.results.reduce((s3, { type: type5 }) => type5 === "throw" ? s3 : ++s3, 0) === times,
    action: "called"
  }].forEach(({ name, condition, action: action2 }) => {
    def(name, function(times) {
      let spy = getSpy(this), spyName = spy.getMockName(), pass = condition(spy, times);
      this.assert(pass, `expected "${spyName}" to be successfully ${action2} ${times} times`, `expected "${spyName}" to not be successfully ${action2} ${times} times`, `expected resolved times: ${times}`, `received resolved times: ${pass}`, !1);
    });
  }), [{
    name: "toHaveResolvedWith",
    condition: (spy, value) => spy.mock.settledResults.some(({ type: type5, value: result }) => type5 === "fulfilled" && equals(value, result)),
    action: "resolve"
  }, {
    name: ["toHaveReturnedWith", "toReturnWith"],
    condition: (spy, value) => spy.mock.results.some(({ type: type5, value: result }) => type5 === "return" && equals(value, result)),
    action: "return"
  }].forEach(({ name, condition, action: action2 }) => {
    def(name, function(value) {
      let spy = getSpy(this), pass = condition(spy, value), isNot = utils.flag(this, "negate");
      if (pass && isNot || !pass && !isNot) {
        let spyName = spy.getMockName(), msg = utils.getMessage(this, [
          pass,
          `expected "${spyName}" to ${action2} with: #{exp} at least once`,
          `expected "${spyName}" to not ${action2} with: #{exp}`,
          value
        ]), results = action2 === "return" ? spy.mock.results : spy.mock.settledResults;
        throw new AssertionError2(formatReturns(spy, results, msg, value));
      }
    });
  }), [{
    name: "toHaveLastResolvedWith",
    condition: (spy, value) => {
      let result = spy.mock.settledResults[spy.mock.settledResults.length - 1];
      return result && result.type === "fulfilled" && equals(result.value, value);
    },
    action: "resolve"
  }, {
    name: ["toHaveLastReturnedWith", "lastReturnedWith"],
    condition: (spy, value) => {
      let result = spy.mock.results[spy.mock.results.length - 1];
      return result && result.type === "return" && equals(result.value, value);
    },
    action: "return"
  }].forEach(({ name, condition, action: action2 }) => {
    def(name, function(value) {
      let spy = getSpy(this), results = action2 === "return" ? spy.mock.results : spy.mock.settledResults, result = results[results.length - 1], spyName = spy.getMockName();
      this.assert(condition(spy, value), `expected last "${spyName}" call to ${action2} #{exp}`, `expected last "${spyName}" call to not ${action2} #{exp}`, value, result?.value);
    });
  }), [{
    name: "toHaveNthResolvedWith",
    condition: (spy, index2, value) => {
      let result = spy.mock.settledResults[index2 - 1];
      return result && result.type === "fulfilled" && equals(result.value, value);
    },
    action: "resolve"
  }, {
    name: ["toHaveNthReturnedWith", "nthReturnedWith"],
    condition: (spy, index2, value) => {
      let result = spy.mock.results[index2 - 1];
      return result && result.type === "return" && equals(result.value, value);
    },
    action: "return"
  }].forEach(({ name, condition, action: action2 }) => {
    def(name, function(nthCall, value) {
      let spy = getSpy(this), spyName = spy.getMockName(), result = (action2 === "return" ? spy.mock.results : spy.mock.settledResults)[nthCall - 1], ordinalCall = `${ordinalOf(nthCall)} call`;
      this.assert(condition(spy, nthCall, value), `expected ${ordinalCall} "${spyName}" call to ${action2} #{exp}`, `expected ${ordinalCall} "${spyName}" call to not ${action2} #{exp}`, value, result?.value);
    });
  }), def("withContext", function(context) {
    for (let key in context)
      utils.flag(this, key, context[key]);
    return this;
  }), utils.addProperty(chai.Assertion.prototype, "resolves", function() {
    let error = new Error("resolves");
    utils.flag(this, "promise", "resolves"), utils.flag(this, "error", error);
    let test3 = utils.flag(this, "vitest-test"), obj = utils.flag(this, "object");
    if (utils.flag(this, "poll"))
      throw new SyntaxError("expect.poll() is not supported in combination with .resolves");
    if (typeof obj?.then != "function")
      throw new TypeError(`You must provide a Promise to expect() when using .resolves, not '${typeof obj}'.`);
    let proxy = new Proxy(this, { get: (target, key, receiver) => {
      let result = Reflect.get(target, key, receiver);
      return typeof result != "function" ? result instanceof chai.Assertion ? proxy : result : (...args) => {
        utils.flag(this, "_name", key);
        let promise = obj.then((value) => (utils.flag(this, "object", value), result.call(this, ...args)), (err) => {
          let _error = new AssertionError2(`promise rejected "${utils.inspect(err)}" instead of resolving`, { showDiff: !1 });
          throw _error.cause = err, _error.stack = error.stack.replace(error.message, _error.message), _error;
        });
        return recordAsyncExpect(test3, promise, createAssertionMessage(utils, this, !!args.length), error);
      };
    } });
    return proxy;
  }), utils.addProperty(chai.Assertion.prototype, "rejects", function() {
    let error = new Error("rejects");
    utils.flag(this, "promise", "rejects"), utils.flag(this, "error", error);
    let test3 = utils.flag(this, "vitest-test"), obj = utils.flag(this, "object"), wrapper = typeof obj == "function" ? obj() : obj;
    if (utils.flag(this, "poll"))
      throw new SyntaxError("expect.poll() is not supported in combination with .rejects");
    if (typeof wrapper?.then != "function")
      throw new TypeError(`You must provide a Promise to expect() when using .rejects, not '${typeof wrapper}'.`);
    let proxy = new Proxy(this, { get: (target, key, receiver) => {
      let result = Reflect.get(target, key, receiver);
      return typeof result != "function" ? result instanceof chai.Assertion ? proxy : result : (...args) => {
        utils.flag(this, "_name", key);
        let promise = wrapper.then((value) => {
          let _error = new AssertionError2(`promise resolved "${utils.inspect(value)}" instead of rejecting`, {
            showDiff: !0,
            expected: new Error("rejected promise"),
            actual: value
          });
          throw _error.stack = error.stack.replace(error.message, _error.message), _error;
        }, (err) => (utils.flag(this, "object", err), result.call(this, ...args)));
        return recordAsyncExpect(test3, promise, createAssertionMessage(utils, this, !!args.length), error);
      };
    } });
    return proxy;
  });
};
function ordinalOf(i2) {
  let j2 = i2 % 10, k2 = i2 % 100;
  return j2 === 1 && k2 !== 11 ? `${i2}st` : j2 === 2 && k2 !== 12 ? `${i2}nd` : j2 === 3 && k2 !== 13 ? `${i2}rd` : `${i2}th`;
}
function formatCalls(spy, msg, showActualCall) {
  return spy.mock.calls.length && (msg += s.gray(`

Received: 

${spy.mock.calls.map((callArg, i2) => {
    let methodCall = s.bold(`  ${ordinalOf(i2 + 1)} ${spy.getMockName()} call:

`);
    return showActualCall ? methodCall += diff(showActualCall, callArg, { omitAnnotationLines: !0 }) : methodCall += stringify2(callArg).split(`
`).map((line) => `    ${line}`).join(`
`), methodCall += `
`, methodCall;
  }).join(`
`)}`)), msg += s.gray(`

Number of calls: ${s.bold(spy.mock.calls.length)}
`), msg;
}
function formatReturns(spy, results, msg, showActualReturn) {
  return results.length && (msg += s.gray(`

Received: 

${results.map((callReturn, i2) => {
    let methodCall = s.bold(`  ${ordinalOf(i2 + 1)} ${spy.getMockName()} call return:

`);
    return showActualReturn ? methodCall += diff(showActualReturn, callReturn.value, { omitAnnotationLines: !0 }) : methodCall += stringify2(callReturn).split(`
`).map((line) => `    ${line}`).join(`
`), methodCall += `
`, methodCall;
  }).join(`
`)}`)), msg += s.gray(`

Number of calls: ${s.bold(spy.mock.calls.length)}
`), msg;
}
function getMatcherState(assertion, expect4) {
  let obj = assertion._obj, isNot = utils_exports.flag(assertion, "negate"), promise = utils_exports.flag(assertion, "promise") || "", jestUtils = {
    ...getMatcherUtils(),
    diff,
    stringify: stringify2,
    iterableEquality,
    subsetEquality
  };
  return {
    state: {
      ...getState(expect4),
      customTesters: getCustomEqualityTesters(),
      isNot,
      utils: jestUtils,
      promise,
      equals,
      suppressedErrors: [],
      soft: utils_exports.flag(assertion, "soft"),
      poll: utils_exports.flag(assertion, "poll")
    },
    isNot,
    obj
  };
}
var JestExtendError = class extends Error {
  constructor(message, actual, expected) {
    super(message), this.actual = actual, this.expected = expected;
  }
};
function JestExtendPlugin(c2, expect4, matchers) {
  return (_, utils) => {
    Object.entries(matchers).forEach(([expectAssertionName, expectAssertion]) => {
      function expectWrapper(...args) {
        let { state: state3, isNot, obj } = getMatcherState(this, expect4), result = expectAssertion.call(state3, obj, ...args);
        if (result && typeof result == "object" && typeof result.then == "function")
          return result.then(({ pass: pass2, message: message2, actual: actual2, expected: expected2 }) => {
            if (pass2 && isNot || !pass2 && !isNot)
              throw new JestExtendError(message2(), actual2, expected2);
          });
        let { pass, message, actual, expected } = result;
        if (pass && isNot || !pass && !isNot)
          throw new JestExtendError(message(), actual, expected);
      }
      let softWrapper = wrapAssertion(utils, expectAssertionName, expectWrapper);
      utils.addMethod(globalThis[JEST_MATCHERS_OBJECT].matchers, expectAssertionName, softWrapper), utils.addMethod(c2.Assertion.prototype, expectAssertionName, softWrapper);
      class CustomMatcher extends AsymmetricMatcher3 {
        constructor(inverse = !1, ...sample) {
          super(sample, inverse);
        }
        asymmetricMatch(other) {
          let { pass } = expectAssertion.call(this.getMatcherContext(expect4), other, ...this.sample);
          return this.inverse ? !pass : pass;
        }
        toString() {
          return `${this.inverse ? "not." : ""}${expectAssertionName}`;
        }
        getExpectedType() {
          return "any";
        }
        toAsymmetricMatcher() {
          return `${this.toString()}<${this.sample.map((item) => stringify2(item)).join(", ")}>`;
        }
      }
      let customMatcher = (...sample) => new CustomMatcher(!1, ...sample);
      Object.defineProperty(expect4, expectAssertionName, {
        configurable: !0,
        enumerable: !0,
        value: customMatcher,
        writable: !0
      }), Object.defineProperty(expect4.not, expectAssertionName, {
        configurable: !0,
        enumerable: !0,
        value: (...sample) => new CustomMatcher(!0, ...sample),
        writable: !0
      }), Object.defineProperty(globalThis[ASYMMETRIC_MATCHERS_OBJECT], expectAssertionName, {
        configurable: !0,
        enumerable: !0,
        value: customMatcher,
        writable: !0
      });
    });
  };
}
var JestExtend = (chai, utils) => {
  utils.addMethod(chai.expect, "extend", (expect4, expects) => {
    use(JestExtendPlugin(chai, expect4, expects));
  });
};

// src/test/expect.ts
function createExpect() {
  use(JestExtend), use(JestChaiExpect), use(JestAsymmetricMatchers);
  let expect4 = ((value, message) => {
    let { assertionCalls } = getState(expect4);
    return setState({ assertionCalls: assertionCalls + 1, soft: !1 }, expect4), expect(value, message);
  });
  Object.assign(expect4, expect), expect4.getState = () => getState(expect4), expect4.setState = (state3) => setState(state3, expect4), expect4.extend = (expects) => expect.extend(expect4, expects), expect4.soft = (...args) => {
    let assert2 = expect4(...args);
    return expect4.setState({
      soft: !0
    }), assert2;
  }, expect4.extend(customMatchers), expect4.unreachable = (message) => {
    assert.fail(`expected${message ? ` "${message}" ` : " "}not to be reached`);
  };
  function assertions(expected) {
    let errorGen = () => new Error(
      `expected number of assertions to be ${expected}, but got ${expect4.getState().assertionCalls}`
    );
    "captureStackTrace" in Error && typeof Error.captureStackTrace == "function" && Error.captureStackTrace(errorGen(), assertions), expect4.setState({
      expectedAssertionsNumber: expected,
      expectedAssertionsNumberErrorGen: errorGen
    });
  }
  function hasAssertions() {
    let error = new Error("expected any number of assertion, but got none");
    "captureStackTrace" in Error && typeof Error.captureStackTrace == "function" && Error.captureStackTrace(error, hasAssertions), expect4.setState({
      isExpectingAssertions: !0,
      isExpectingAssertionsError: error
    });
  }
  return setState(
    {
      // this should also add "snapshotState" that is added conditionally
      assertionCalls: 0,
      isExpectingAssertions: !1,
      isExpectingAssertionsError: null,
      expectedAssertionsNumber: null,
      expectedAssertionsNumberErrorGen: null
    },
    expect4
  ), utils_exports.addMethod(expect4, "assertions", assertions), utils_exports.addMethod(expect4, "hasAssertions", hasAssertions), expect4.extend(matchers_exports), expect4;
}
var expect2 = createExpect();
Object.defineProperty(globalThis, GLOBAL_EXPECT, {
  value: expect2,
  writable: !0,
  configurable: !0
});

// ../node_modules/tinyspy/dist/index.js
function f3(e2, t2, n2) {
  Object.defineProperty(e2, t2, n2);
}
var u2 = Symbol.for("tinyspy:spy");
var P2 = (e2) => {
  e2.called = !1, e2.callCount = 0, e2.calls = [], e2.results = [], e2.resolves = [], e2.next = [];
}, K2 = (e2) => (f3(e2, u2, { value: { reset: () => P2(e2[u2]) } }), e2[u2]), T2 = (e2) => e2[u2] || K2(e2);

// src/test/spy.ts
var listeners = /* @__PURE__ */ new Set();
function onMockCall(callback) {
  return listeners.add(callback), () => void listeners.delete(callback);
}
var spyOn2 = (...args) => {
  let mock = spyOn(...args);
  return reactiveMock(mock);
};
function fn2(implementation) {
  let mock = implementation ? fn(implementation) : fn();
  return reactiveMock(mock);
}
function reactiveMock(mock) {
  let reactive = listenWhenCalled(mock), originalMockImplementation = reactive.mockImplementation.bind(null);
  return reactive.mockImplementation = (fn3) => listenWhenCalled(originalMockImplementation(fn3)), reactive;
}
function listenWhenCalled(mock) {
  let state3 = T2(mock), impl = state3.impl;
  return state3.willCall(function(...args) {
    return listeners.forEach((listener) => listener(mock, args)), impl?.apply(this, args);
  }), mock;
}
function clearAllMocks() {
  mocks.forEach((spy) => spy.mockClear());
}
function resetAllMocks() {
  mocks.forEach((spy) => spy.mockReset());
}
function restoreAllMocks() {
  mocks.forEach((spy) => spy.mockRestore());
}
function mocked(item, _options = {}) {
  return item;
}

// ../node_modules/@testing-library/dom/dist/@testing-library/dom.esm.js
var dom_esm_exports = {};
__export(dom_esm_exports, {
  buildQueries: () => buildQueries,
  configure: () => configure,
  createEvent: () => createEvent,
  findAllByAltText: () => findAllByAltText,
  findAllByDisplayValue: () => findAllByDisplayValue,
  findAllByLabelText: () => findAllByLabelText,
  findAllByPlaceholderText: () => findAllByPlaceholderText,
  findAllByRole: () => findAllByRole,
  findAllByTestId: () => findAllByTestId,
  findAllByText: () => findAllByText,
  findAllByTitle: () => findAllByTitle,
  findByAltText: () => findByAltText,
  findByDisplayValue: () => findByDisplayValue,
  findByLabelText: () => findByLabelText,
  findByPlaceholderText: () => findByPlaceholderText,
  findByRole: () => findByRole,
  findByTestId: () => findByTestId,
  findByText: () => findByText,
  findByTitle: () => findByTitle,
  fireEvent: () => fireEvent,
  getAllByAltText: () => getAllByAltText,
  getAllByDisplayValue: () => getAllByDisplayValue,
  getAllByLabelText: () => getAllByLabelTextWithSuggestions,
  getAllByPlaceholderText: () => getAllByPlaceholderText,
  getAllByRole: () => getAllByRole,
  getAllByTestId: () => getAllByTestId,
  getAllByText: () => getAllByText,
  getAllByTitle: () => getAllByTitle,
  getByAltText: () => getByAltText,
  getByDisplayValue: () => getByDisplayValue,
  getByLabelText: () => getByLabelTextWithSuggestions,
  getByPlaceholderText: () => getByPlaceholderText,
  getByRole: () => getByRole,
  getByTestId: () => getByTestId,
  getByText: () => getByText,
  getByTitle: () => getByTitle,
  getConfig: () => getConfig2,
  getDefaultNormalizer: () => getDefaultNormalizer,
  getElementError: () => getElementError,
  getMultipleElementsFoundError: () => getMultipleElementsFoundError,
  getNodeText: () => getNodeText,
  getQueriesForElement: () => getQueriesForElement,
  getRoles: () => getRoles,
  getSuggestedQuery: () => getSuggestedQuery,
  isInaccessible: () => isInaccessible,
  logDOM: () => logDOM,
  logRoles: () => logRoles,
  makeFindQuery: () => makeFindQuery,
  makeGetAllQuery: () => makeGetAllQuery,
  makeSingleQuery: () => makeSingleQuery,
  prettyDOM: () => prettyDOM,
  prettyFormat: () => prettyFormat,
  queries: () => queries,
  queryAllByAltText: () => queryAllByAltTextWithSuggestions,
  queryAllByAttribute: () => queryAllByAttribute,
  queryAllByDisplayValue: () => queryAllByDisplayValueWithSuggestions,
  queryAllByLabelText: () => queryAllByLabelTextWithSuggestions,
  queryAllByPlaceholderText: () => queryAllByPlaceholderTextWithSuggestions,
  queryAllByRole: () => queryAllByRoleWithSuggestions,
  queryAllByTestId: () => queryAllByTestIdWithSuggestions,
  queryAllByText: () => queryAllByTextWithSuggestions,
  queryAllByTitle: () => queryAllByTitleWithSuggestions,
  queryByAltText: () => queryByAltText,
  queryByAttribute: () => queryByAttribute,
  queryByDisplayValue: () => queryByDisplayValue,
  queryByLabelText: () => queryByLabelText,
  queryByPlaceholderText: () => queryByPlaceholderText,
  queryByRole: () => queryByRole,
  queryByTestId: () => queryByTestId,
  queryByText: () => queryByText,
  queryByTitle: () => queryByTitle,
  queryHelpers: () => queryHelpers,
  screen: () => screen,
  waitFor: () => waitForWrapper,
  waitForElementToBeRemoved: () => waitForElementToBeRemoved,
  within: () => getQueriesForElement,
  wrapAllByQueryWithSuggestion: () => wrapAllByQueryWithSuggestion,
  wrapSingleQueryWithSuggestion: () => wrapSingleQueryWithSuggestion
});
var prettyFormat = __toESM(require_build());

// ../node_modules/dom-accessibility-api/dist/polyfills/array.from.mjs
var toStr2 = Object.prototype.toString;
function isCallable2(fn3) {
  return typeof fn3 == "function" || toStr2.call(fn3) === "[object Function]";
}
function toInteger2(value) {
  var number = Number(value);
  return isNaN(number) ? 0 : number === 0 || !isFinite(number) ? number : (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));
}
var maxSafeInteger2 = Math.pow(2, 53) - 1;
function toLength2(value) {
  var len = toInteger2(value);
  return Math.min(Math.max(len, 0), maxSafeInteger2);
}
function arrayFrom2(arrayLike, mapFn) {
  var C2 = Array, items = Object(arrayLike);
  if (arrayLike == null)
    throw new TypeError("Array.from requires an array-like object - not null or undefined");
  if (typeof mapFn < "u" && !isCallable2(mapFn))
    throw new TypeError("Array.from: when provided, the second argument must be a function");
  for (var len = toLength2(items.length), A = isCallable2(C2) ? Object(new C2(len)) : new Array(len), k2 = 0, kValue; k2 < len; )
    kValue = items[k2], mapFn ? A[k2] = mapFn(kValue, k2) : A[k2] = kValue, k2 += 1;
  return A.length = len, A;
}

// ../node_modules/dom-accessibility-api/dist/polyfills/SetLike.mjs
function _typeof3(obj) {
  "@babel/helpers - typeof";
  return _typeof3 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof3(obj);
}
function _classCallCheck2(instance, Constructor) {
  if (!(instance instanceof Constructor))
    throw new TypeError("Cannot call a class as a function");
}
function _defineProperties2(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, _toPropertyKey3(descriptor.key), descriptor);
  }
}
function _createClass2(Constructor, protoProps, staticProps) {
  return protoProps && _defineProperties2(Constructor.prototype, protoProps), staticProps && _defineProperties2(Constructor, staticProps), Object.defineProperty(Constructor, "prototype", { writable: !1 }), Constructor;
}
function _defineProperty3(obj, key, value) {
  return key = _toPropertyKey3(key), key in obj ? Object.defineProperty(obj, key, { value, enumerable: !0, configurable: !0, writable: !0 }) : obj[key] = value, obj;
}
function _toPropertyKey3(arg) {
  var key = _toPrimitive3(arg, "string");
  return _typeof3(key) === "symbol" ? key : String(key);
}
function _toPrimitive3(input2, hint) {
  if (_typeof3(input2) !== "object" || input2 === null) return input2;
  var prim = input2[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input2, hint || "default");
    if (_typeof3(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input2);
}
var SetLike2 = (function() {
  function SetLike3() {
    var items = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    _classCallCheck2(this, SetLike3), _defineProperty3(this, "items", void 0), this.items = items;
  }
  return _createClass2(SetLike3, [{
    key: "add",
    value: function(value) {
      return this.has(value) === !1 && this.items.push(value), this;
    }
  }, {
    key: "clear",
    value: function() {
      this.items = [];
    }
  }, {
    key: "delete",
    value: function(value) {
      var previousLength = this.items.length;
      return this.items = this.items.filter(function(item) {
        return item !== value;
      }), previousLength !== this.items.length;
    }
  }, {
    key: "forEach",
    value: function(callbackfn) {
      var _this = this;
      this.items.forEach(function(item) {
        callbackfn(item, item, _this);
      });
    }
  }, {
    key: "has",
    value: function(value) {
      return this.items.indexOf(value) !== -1;
    }
  }, {
    key: "size",
    get: function() {
      return this.items.length;
    }
  }]), SetLike3;
})(), SetLike_default2 = typeof Set > "u" ? Set : SetLike2;

// ../node_modules/dom-accessibility-api/dist/getRole.mjs
function getLocalName2(element) {
  var _element$localName;
  return (
    // eslint-disable-next-line no-restricted-properties -- actual guard for environments without localName
    (_element$localName = element.localName) !== null && _element$localName !== void 0 ? _element$localName : (
      // eslint-disable-next-line no-restricted-properties -- required for the fallback
      element.tagName.toLowerCase()
    )
  );
}
var localNameToRoleMappings2 = {
  article: "article",
  aside: "complementary",
  button: "button",
  datalist: "listbox",
  dd: "definition",
  details: "group",
  dialog: "dialog",
  dt: "term",
  fieldset: "group",
  figure: "figure",
  // WARNING: Only with an accessible name
  form: "form",
  footer: "contentinfo",
  h1: "heading",
  h2: "heading",
  h3: "heading",
  h4: "heading",
  h5: "heading",
  h6: "heading",
  header: "banner",
  hr: "separator",
  html: "document",
  legend: "legend",
  li: "listitem",
  math: "math",
  main: "main",
  menu: "list",
  nav: "navigation",
  ol: "list",
  optgroup: "group",
  // WARNING: Only in certain context
  option: "option",
  output: "status",
  progress: "progressbar",
  // WARNING: Only with an accessible name
  section: "region",
  summary: "button",
  table: "table",
  tbody: "rowgroup",
  textarea: "textbox",
  tfoot: "rowgroup",
  // WARNING: Only in certain context
  td: "cell",
  th: "columnheader",
  thead: "rowgroup",
  tr: "row",
  ul: "list"
}, prohibitedAttributes2 = {
  caption: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  code: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  deletion: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  emphasis: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  generic: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby", "aria-roledescription"]),
  insertion: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  paragraph: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  presentation: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  strong: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  subscript: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  superscript: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"])
};
function hasGlobalAriaAttributes2(element, role) {
  return [
    "aria-atomic",
    "aria-busy",
    "aria-controls",
    "aria-current",
    "aria-describedby",
    "aria-details",
    // "disabled",
    "aria-dropeffect",
    // "errormessage",
    "aria-flowto",
    "aria-grabbed",
    // "haspopup",
    "aria-hidden",
    // "invalid",
    "aria-keyshortcuts",
    "aria-label",
    "aria-labelledby",
    "aria-live",
    "aria-owns",
    "aria-relevant",
    "aria-roledescription"
  ].some(function(attributeName) {
    var _prohibitedAttributes;
    return element.hasAttribute(attributeName) && !((_prohibitedAttributes = prohibitedAttributes2[role]) !== null && _prohibitedAttributes !== void 0 && _prohibitedAttributes.has(attributeName));
  });
}
function ignorePresentationalRole2(element, implicitRole) {
  return hasGlobalAriaAttributes2(element, implicitRole);
}
function getRole2(element) {
  var explicitRole = getExplicitRole2(element);
  if (explicitRole === null || explicitRole === "presentation") {
    var implicitRole = getImplicitRole2(element);
    if (explicitRole !== "presentation" || ignorePresentationalRole2(element, implicitRole || ""))
      return implicitRole;
  }
  return explicitRole;
}
function getImplicitRole2(element) {
  var mappedByTag = localNameToRoleMappings2[getLocalName2(element)];
  if (mappedByTag !== void 0)
    return mappedByTag;
  switch (getLocalName2(element)) {
    case "a":
    case "area":
    case "link":
      if (element.hasAttribute("href"))
        return "link";
      break;
    case "img":
      return element.getAttribute("alt") === "" && !ignorePresentationalRole2(element, "img") ? "presentation" : "img";
    case "input": {
      var _ref = element, type5 = _ref.type;
      switch (type5) {
        case "button":
        case "image":
        case "reset":
        case "submit":
          return "button";
        case "checkbox":
        case "radio":
          return type5;
        case "range":
          return "slider";
        case "email":
        case "tel":
        case "text":
        case "url":
          return element.hasAttribute("list") ? "combobox" : "textbox";
        case "search":
          return element.hasAttribute("list") ? "combobox" : "searchbox";
        case "number":
          return "spinbutton";
        default:
          return null;
      }
    }
    case "select":
      return element.hasAttribute("multiple") || element.size > 1 ? "listbox" : "combobox";
  }
  return null;
}
function getExplicitRole2(element) {
  var role = element.getAttribute("role");
  if (role !== null) {
    var explicitRole = role.trim().split(" ")[0];
    if (explicitRole.length > 0)
      return explicitRole;
  }
  return null;
}

// ../node_modules/dom-accessibility-api/dist/util.mjs
function isElement2(node) {
  return node !== null && node.nodeType === node.ELEMENT_NODE;
}
function isHTMLTableCaptionElement2(node) {
  return isElement2(node) && getLocalName2(node) === "caption";
}
function isHTMLInputElement2(node) {
  return isElement2(node) && getLocalName2(node) === "input";
}
function isHTMLOptGroupElement2(node) {
  return isElement2(node) && getLocalName2(node) === "optgroup";
}
function isHTMLSelectElement2(node) {
  return isElement2(node) && getLocalName2(node) === "select";
}
function isHTMLTableElement2(node) {
  return isElement2(node) && getLocalName2(node) === "table";
}
function isHTMLTextAreaElement2(node) {
  return isElement2(node) && getLocalName2(node) === "textarea";
}
function safeWindow2(node) {
  var _ref = node.ownerDocument === null ? node : node.ownerDocument, defaultView = _ref.defaultView;
  if (defaultView === null)
    throw new TypeError("no window available");
  return defaultView;
}
function isHTMLFieldSetElement2(node) {
  return isElement2(node) && getLocalName2(node) === "fieldset";
}
function isHTMLLegendElement2(node) {
  return isElement2(node) && getLocalName2(node) === "legend";
}
function isHTMLSlotElement2(node) {
  return isElement2(node) && getLocalName2(node) === "slot";
}
function isSVGElement2(node) {
  return isElement2(node) && node.ownerSVGElement !== void 0;
}
function isSVGSVGElement2(node) {
  return isElement2(node) && getLocalName2(node) === "svg";
}
function isSVGTitleElement2(node) {
  return isSVGElement2(node) && getLocalName2(node) === "title";
}
function queryIdRefs2(node, attributeName) {
  if (isElement2(node) && node.hasAttribute(attributeName)) {
    var ids = node.getAttribute(attributeName).split(" "), root2 = node.getRootNode ? node.getRootNode() : node.ownerDocument;
    return ids.map(function(id) {
      return root2.getElementById(id);
    }).filter(
      function(element) {
        return element !== null;
      }
      // TODO: why does this not narrow?
    );
  }
  return [];
}
function hasAnyConcreteRoles2(node, roles3) {
  return isElement2(node) ? roles3.indexOf(getRole2(node)) !== -1 : !1;
}

// ../node_modules/dom-accessibility-api/dist/accessible-name-and-description.mjs
function asFlatString2(s3) {
  return s3.trim().replace(/\s\s+/g, " ");
}
function isHidden2(node, getComputedStyleImplementation) {
  if (!isElement2(node))
    return !1;
  if (node.hasAttribute("hidden") || node.getAttribute("aria-hidden") === "true")
    return !0;
  var style = getComputedStyleImplementation(node);
  return style.getPropertyValue("display") === "none" || style.getPropertyValue("visibility") === "hidden";
}
function isControl2(node) {
  return hasAnyConcreteRoles2(node, ["button", "combobox", "listbox", "textbox"]) || hasAbstractRole2(node, "range");
}
function hasAbstractRole2(node, role) {
  if (!isElement2(node))
    return !1;
  switch (role) {
    case "range":
      return hasAnyConcreteRoles2(node, ["meter", "progressbar", "scrollbar", "slider", "spinbutton"]);
    default:
      throw new TypeError("No knowledge about abstract role '".concat(role, "'. This is likely a bug :("));
  }
}
function querySelectorAllSubtree2(element, selectors) {
  var elements = arrayFrom2(element.querySelectorAll(selectors));
  return queryIdRefs2(element, "aria-owns").forEach(function(root2) {
    elements.push.apply(elements, arrayFrom2(root2.querySelectorAll(selectors)));
  }), elements;
}
function querySelectedOptions2(listbox) {
  return isHTMLSelectElement2(listbox) ? listbox.selectedOptions || querySelectorAllSubtree2(listbox, "[selected]") : querySelectorAllSubtree2(listbox, '[aria-selected="true"]');
}
function isMarkedPresentational2(node) {
  return hasAnyConcreteRoles2(node, ["none", "presentation"]);
}
function isNativeHostLanguageTextAlternativeElement2(node) {
  return isHTMLTableCaptionElement2(node);
}
function allowsNameFromContent2(node) {
  return hasAnyConcreteRoles2(node, ["button", "cell", "checkbox", "columnheader", "gridcell", "heading", "label", "legend", "link", "menuitem", "menuitemcheckbox", "menuitemradio", "option", "radio", "row", "rowheader", "switch", "tab", "tooltip", "treeitem"]);
}
function isDescendantOfNativeHostLanguageTextAlternativeElement2(node) {
  return !1;
}
function getValueOfTextbox2(element) {
  return isHTMLInputElement2(element) || isHTMLTextAreaElement2(element) ? element.value : element.textContent || "";
}
function getTextualContent2(declaration) {
  var content = declaration.getPropertyValue("content");
  return /^["'].*["']$/.test(content) ? content.slice(1, -1) : "";
}
function isLabelableElement2(element) {
  var localName = getLocalName2(element);
  return localName === "button" || localName === "input" && element.getAttribute("type") !== "hidden" || localName === "meter" || localName === "output" || localName === "progress" || localName === "select" || localName === "textarea";
}
function findLabelableElement2(element) {
  if (isLabelableElement2(element))
    return element;
  var labelableElement = null;
  return element.childNodes.forEach(function(childNode) {
    if (labelableElement === null && isElement2(childNode)) {
      var descendantLabelableElement = findLabelableElement2(childNode);
      descendantLabelableElement !== null && (labelableElement = descendantLabelableElement);
    }
  }), labelableElement;
}
function getControlOfLabel2(label) {
  if (label.control !== void 0)
    return label.control;
  var htmlFor = label.getAttribute("for");
  return htmlFor !== null ? label.ownerDocument.getElementById(htmlFor) : findLabelableElement2(label);
}
function getLabels2(element) {
  var labelsProperty = element.labels;
  if (labelsProperty === null)
    return labelsProperty;
  if (labelsProperty !== void 0)
    return arrayFrom2(labelsProperty);
  if (!isLabelableElement2(element))
    return null;
  var document7 = element.ownerDocument;
  return arrayFrom2(document7.querySelectorAll("label")).filter(function(label) {
    return getControlOfLabel2(label) === element;
  });
}
function getSlotContents2(slot) {
  var assignedNodes = slot.assignedNodes();
  return assignedNodes.length === 0 ? arrayFrom2(slot.childNodes) : assignedNodes;
}
function computeTextAlternative2(root2) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, consultedNodes = new SetLike_default2(), window2 = safeWindow2(root2), _options$compute = options.compute, compute = _options$compute === void 0 ? "name" : _options$compute, _options$computedStyl = options.computedStyleSupportsPseudoElements, computedStyleSupportsPseudoElements = _options$computedStyl === void 0 ? options.getComputedStyle !== void 0 : _options$computedStyl, _options$getComputedS = options.getComputedStyle, getComputedStyle2 = _options$getComputedS === void 0 ? window2.getComputedStyle.bind(window2) : _options$getComputedS, _options$hidden = options.hidden, hidden = _options$hidden === void 0 ? !1 : _options$hidden;
  function computeMiscTextAlternative(node, context) {
    var accumulatedText = "";
    if (isElement2(node) && computedStyleSupportsPseudoElements) {
      var pseudoBefore = getComputedStyle2(node, "::before"), beforeContent = getTextualContent2(pseudoBefore);
      accumulatedText = "".concat(beforeContent, " ").concat(accumulatedText);
    }
    var childNodes = isHTMLSlotElement2(node) ? getSlotContents2(node) : arrayFrom2(node.childNodes).concat(queryIdRefs2(node, "aria-owns"));
    if (childNodes.forEach(function(child) {
      var result = computeTextAlternative3(child, {
        isEmbeddedInLabel: context.isEmbeddedInLabel,
        isReferenced: !1,
        recursion: !0
      }), display2 = isElement2(child) ? getComputedStyle2(child).getPropertyValue("display") : "inline", separator = display2 !== "inline" ? " " : "";
      accumulatedText += "".concat(separator).concat(result).concat(separator);
    }), isElement2(node) && computedStyleSupportsPseudoElements) {
      var pseudoAfter = getComputedStyle2(node, "::after"), afterContent = getTextualContent2(pseudoAfter);
      accumulatedText = "".concat(accumulatedText, " ").concat(afterContent);
    }
    return accumulatedText.trim();
  }
  function useAttribute(element, attributeName) {
    var attribute = element.getAttributeNode(attributeName);
    return attribute !== null && !consultedNodes.has(attribute) && attribute.value.trim() !== "" ? (consultedNodes.add(attribute), attribute.value) : null;
  }
  function computeTooltipAttributeValue(node) {
    return isElement2(node) ? useAttribute(node, "title") : null;
  }
  function computeElementTextAlternative(node) {
    if (!isElement2(node))
      return null;
    if (isHTMLFieldSetElement2(node)) {
      consultedNodes.add(node);
      for (var children = arrayFrom2(node.childNodes), i2 = 0; i2 < children.length; i2 += 1) {
        var child = children[i2];
        if (isHTMLLegendElement2(child))
          return computeTextAlternative3(child, {
            isEmbeddedInLabel: !1,
            isReferenced: !1,
            recursion: !1
          });
      }
    } else if (isHTMLTableElement2(node)) {
      consultedNodes.add(node);
      for (var _children = arrayFrom2(node.childNodes), _i = 0; _i < _children.length; _i += 1) {
        var _child = _children[_i];
        if (isHTMLTableCaptionElement2(_child))
          return computeTextAlternative3(_child, {
            isEmbeddedInLabel: !1,
            isReferenced: !1,
            recursion: !1
          });
      }
    } else if (isSVGSVGElement2(node)) {
      consultedNodes.add(node);
      for (var _children2 = arrayFrom2(node.childNodes), _i2 = 0; _i2 < _children2.length; _i2 += 1) {
        var _child2 = _children2[_i2];
        if (isSVGTitleElement2(_child2))
          return _child2.textContent;
      }
      return null;
    } else if (getLocalName2(node) === "img" || getLocalName2(node) === "area") {
      var nameFromAlt = useAttribute(node, "alt");
      if (nameFromAlt !== null)
        return nameFromAlt;
    } else if (isHTMLOptGroupElement2(node)) {
      var nameFromLabel = useAttribute(node, "label");
      if (nameFromLabel !== null)
        return nameFromLabel;
    }
    if (isHTMLInputElement2(node) && (node.type === "button" || node.type === "submit" || node.type === "reset")) {
      var nameFromValue = useAttribute(node, "value");
      if (nameFromValue !== null)
        return nameFromValue;
      if (node.type === "submit")
        return "Submit";
      if (node.type === "reset")
        return "Reset";
    }
    var labels = getLabels2(node);
    if (labels !== null && labels.length !== 0)
      return consultedNodes.add(node), arrayFrom2(labels).map(function(element) {
        return computeTextAlternative3(element, {
          isEmbeddedInLabel: !0,
          isReferenced: !1,
          recursion: !0
        });
      }).filter(function(label) {
        return label.length > 0;
      }).join(" ");
    if (isHTMLInputElement2(node) && node.type === "image") {
      var _nameFromAlt = useAttribute(node, "alt");
      if (_nameFromAlt !== null)
        return _nameFromAlt;
      var nameFromTitle = useAttribute(node, "title");
      return nameFromTitle !== null ? nameFromTitle : "Submit Query";
    }
    if (hasAnyConcreteRoles2(node, ["button"])) {
      var nameFromSubTree = computeMiscTextAlternative(node, {
        isEmbeddedInLabel: !1,
        isReferenced: !1
      });
      if (nameFromSubTree !== "")
        return nameFromSubTree;
    }
    return null;
  }
  function computeTextAlternative3(current, context) {
    if (consultedNodes.has(current))
      return "";
    if (!hidden && isHidden2(current, getComputedStyle2) && !context.isReferenced)
      return consultedNodes.add(current), "";
    var labelAttributeNode = isElement2(current) ? current.getAttributeNode("aria-labelledby") : null, labelElements = labelAttributeNode !== null && !consultedNodes.has(labelAttributeNode) ? queryIdRefs2(current, "aria-labelledby") : [];
    if (compute === "name" && !context.isReferenced && labelElements.length > 0)
      return consultedNodes.add(labelAttributeNode), labelElements.map(function(element) {
        return computeTextAlternative3(element, {
          isEmbeddedInLabel: context.isEmbeddedInLabel,
          isReferenced: !0,
          // this isn't recursion as specified, otherwise we would skip
          // `aria-label` in
          // <input id="myself" aria-label="foo" aria-labelledby="myself"
          recursion: !1
        });
      }).join(" ");
    var skipToStep2E = context.recursion && isControl2(current) && compute === "name";
    if (!skipToStep2E) {
      var ariaLabel = (isElement2(current) && current.getAttribute("aria-label") || "").trim();
      if (ariaLabel !== "" && compute === "name")
        return consultedNodes.add(current), ariaLabel;
      if (!isMarkedPresentational2(current)) {
        var elementTextAlternative = computeElementTextAlternative(current);
        if (elementTextAlternative !== null)
          return consultedNodes.add(current), elementTextAlternative;
      }
    }
    if (hasAnyConcreteRoles2(current, ["menu"]))
      return consultedNodes.add(current), "";
    if (skipToStep2E || context.isEmbeddedInLabel || context.isReferenced) {
      if (hasAnyConcreteRoles2(current, ["combobox", "listbox"])) {
        consultedNodes.add(current);
        var selectedOptions = querySelectedOptions2(current);
        return selectedOptions.length === 0 ? isHTMLInputElement2(current) ? current.value : "" : arrayFrom2(selectedOptions).map(function(selectedOption) {
          return computeTextAlternative3(selectedOption, {
            isEmbeddedInLabel: context.isEmbeddedInLabel,
            isReferenced: !1,
            recursion: !0
          });
        }).join(" ");
      }
      if (hasAbstractRole2(current, "range"))
        return consultedNodes.add(current), current.hasAttribute("aria-valuetext") ? current.getAttribute("aria-valuetext") : current.hasAttribute("aria-valuenow") ? current.getAttribute("aria-valuenow") : current.getAttribute("value") || "";
      if (hasAnyConcreteRoles2(current, ["textbox"]))
        return consultedNodes.add(current), getValueOfTextbox2(current);
    }
    if (allowsNameFromContent2(current) || isElement2(current) && context.isReferenced || isNativeHostLanguageTextAlternativeElement2(current) || isDescendantOfNativeHostLanguageTextAlternativeElement2(current)) {
      var accumulatedText2F = computeMiscTextAlternative(current, {
        isEmbeddedInLabel: context.isEmbeddedInLabel,
        isReferenced: !1
      });
      if (accumulatedText2F !== "")
        return consultedNodes.add(current), accumulatedText2F;
    }
    if (current.nodeType === current.TEXT_NODE)
      return consultedNodes.add(current), current.textContent || "";
    if (context.recursion)
      return consultedNodes.add(current), computeMiscTextAlternative(current, {
        isEmbeddedInLabel: context.isEmbeddedInLabel,
        isReferenced: !1
      });
    var tooltipAttributeValue = computeTooltipAttributeValue(current);
    return tooltipAttributeValue !== null ? (consultedNodes.add(current), tooltipAttributeValue) : (consultedNodes.add(current), "");
  }
  return asFlatString2(computeTextAlternative3(root2, {
    isEmbeddedInLabel: !1,
    // by spec computeAccessibleDescription starts with the referenced elements as roots
    isReferenced: compute === "description",
    recursion: !1
  }));
}

// ../node_modules/dom-accessibility-api/dist/accessible-description.mjs
function _typeof4(obj) {
  "@babel/helpers - typeof";
  return _typeof4 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof4(obj);
}
function ownKeys2(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    i2 % 2 ? ownKeys2(Object(source), !0).forEach(function(key) {
      _defineProperty4(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty4(obj, key, value) {
  return key = _toPropertyKey4(key), key in obj ? Object.defineProperty(obj, key, { value, enumerable: !0, configurable: !0, writable: !0 }) : obj[key] = value, obj;
}
function _toPropertyKey4(arg) {
  var key = _toPrimitive4(arg, "string");
  return _typeof4(key) === "symbol" ? key : String(key);
}
function _toPrimitive4(input2, hint) {
  if (_typeof4(input2) !== "object" || input2 === null) return input2;
  var prim = input2[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input2, hint || "default");
    if (_typeof4(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input2);
}
function computeAccessibleDescription2(root2) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, description = queryIdRefs2(root2, "aria-describedby").map(function(element) {
    return computeTextAlternative2(element, _objectSpread2(_objectSpread2({}, options), {}, {
      compute: "description"
    }));
  }).join(" ");
  if (description === "") {
    var title = root2.getAttribute("title");
    description = title === null ? "" : title;
  }
  return description;
}

// ../node_modules/dom-accessibility-api/dist/accessible-name.mjs
function prohibitsNaming2(node) {
  return hasAnyConcreteRoles2(node, ["caption", "code", "deletion", "emphasis", "generic", "insertion", "paragraph", "presentation", "strong", "subscript", "superscript"]);
}
function computeAccessibleName2(root2) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return prohibitsNaming2(root2) ? "" : computeTextAlternative2(root2, options);
}

// ../node_modules/@testing-library/dom/dist/@testing-library/dom.esm.js
var import_aria_query3 = __toESM(require_lib()), import_lz_string = __toESM(require_lz_string());
function escapeHTML2(str2) {
  return str2.replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
var printProps2 = (keys2, props, config4, indentation, depth, refs, printer2) => {
  let indentationNext = indentation + config4.indent, colors3 = config4.colors;
  return keys2.map((key) => {
    let value = props[key], printed = printer2(value, config4, indentationNext, depth, refs);
    return typeof value != "string" && (printed.indexOf(`
`) !== -1 && (printed = config4.spacingOuter + indentationNext + printed + config4.spacingOuter + indentation), printed = "{" + printed + "}"), config4.spacingInner + indentation + colors3.prop.open + key + colors3.prop.close + "=" + colors3.value.open + printed + colors3.value.close;
  }).join("");
}, NodeTypeTextNode = 3, printChildren2 = (children, config4, indentation, depth, refs, printer2) => children.map((child) => {
  let printedChild = typeof child == "string" ? printText2(child, config4) : printer2(child, config4, indentation, depth, refs);
  return printedChild === "" && typeof child == "object" && child !== null && child.nodeType !== NodeTypeTextNode ? "" : config4.spacingOuter + indentation + printedChild;
}).join(""), printText2 = (text, config4) => {
  let contentColor = config4.colors.content;
  return contentColor.open + escapeHTML2(text) + contentColor.close;
}, printComment2 = (comment, config4) => {
  let commentColor = config4.colors.comment;
  return commentColor.open + "<!--" + escapeHTML2(comment) + "-->" + commentColor.close;
}, printElement2 = (type5, printedProps, printedChildren, config4, indentation) => {
  let tagColor = config4.colors.tag;
  return tagColor.open + "<" + type5 + (printedProps && tagColor.close + printedProps + config4.spacingOuter + indentation + tagColor.open) + (printedChildren ? ">" + tagColor.close + printedChildren + config4.spacingOuter + indentation + tagColor.open + "</" + type5 : (printedProps && !config4.min ? "" : " ") + "/") + ">" + tagColor.close;
}, printElementAsLeaf2 = (type5, config4) => {
  let tagColor = config4.colors.tag;
  return tagColor.open + "<" + type5 + tagColor.close + " \u2026" + tagColor.open + " />" + tagColor.close;
}, ELEMENT_NODE$1 = 1, TEXT_NODE$1 = 3, COMMENT_NODE$1 = 8, FRAGMENT_NODE2 = 11, ELEMENT_REGEXP2 = /^((HTML|SVG)\w*)?Element$/, isCustomElement2 = (val) => {
  let {
    tagName
  } = val;
  return !!(typeof tagName == "string" && tagName.includes("-") || typeof val.hasAttribute == "function" && val.hasAttribute("is"));
}, testNode2 = (val) => {
  let constructorName = val.constructor.name, {
    nodeType
  } = val;
  return nodeType === ELEMENT_NODE$1 && (ELEMENT_REGEXP2.test(constructorName) || isCustomElement2(val)) || nodeType === TEXT_NODE$1 && constructorName === "Text" || nodeType === COMMENT_NODE$1 && constructorName === "Comment" || nodeType === FRAGMENT_NODE2 && constructorName === "DocumentFragment";
};
function nodeIsText2(node) {
  return node.nodeType === TEXT_NODE$1;
}
function nodeIsComment2(node) {
  return node.nodeType === COMMENT_NODE$1;
}
function nodeIsFragment2(node) {
  return node.nodeType === FRAGMENT_NODE2;
}
function createDOMElementFilter(filterNode) {
  return {
    test: (val) => {
      var _val$constructor2;
      return ((val == null || (_val$constructor2 = val.constructor) == null ? void 0 : _val$constructor2.name) || isCustomElement2(val)) && testNode2(val);
    },
    serialize: (node, config4, indentation, depth, refs, printer2) => {
      if (nodeIsText2(node))
        return printText2(node.data, config4);
      if (nodeIsComment2(node))
        return printComment2(node.data, config4);
      let type5 = nodeIsFragment2(node) ? "DocumentFragment" : node.tagName.toLowerCase();
      return ++depth > config4.maxDepth ? printElementAsLeaf2(type5, config4) : printElement2(type5, printProps2(nodeIsFragment2(node) ? [] : Array.from(node.attributes).map((attr) => attr.name).sort(), nodeIsFragment2(node) ? {} : Array.from(node.attributes).reduce((props, attribute) => (props[attribute.name] = attribute.value, props), {}), config4, indentation + config4.indent, depth, refs, printer2), printChildren2(Array.prototype.slice.call(node.childNodes || node.children).filter(filterNode), config4, indentation + config4.indent, depth, refs, printer2), config4, indentation);
    }
  };
}
var picocolors = null, readFileSync = null, codeFrameColumns = null;
try {
  let nodeRequire = module && module.require;
  readFileSync = nodeRequire.call(module, "fs").readFileSync, codeFrameColumns = nodeRequire.call(module, "@babel/code-frame").codeFrameColumns, picocolors = nodeRequire.call(module, "picocolors");
} catch {
}
function getCodeFrame(frame) {
  let locationStart = frame.indexOf("(") + 1, locationEnd = frame.indexOf(")"), frameLocation = frame.slice(locationStart, locationEnd), frameLocationElements = frameLocation.split(":"), [filename, line, column] = [frameLocationElements[0], parseInt(frameLocationElements[1], 10), parseInt(frameLocationElements[2], 10)], rawFileContents = "";
  try {
    rawFileContents = readFileSync(filename, "utf-8");
  } catch {
    return "";
  }
  let codeFrame = codeFrameColumns(rawFileContents, {
    start: {
      line,
      column
    }
  }, {
    highlightCode: !0,
    linesBelow: 0
  });
  return picocolors.dim(frameLocation) + `
` + codeFrame + `
`;
}
function getUserCodeFrame() {
  if (!readFileSync || !codeFrameColumns)
    return "";
  let firstClientCodeFrame = new Error().stack.split(`
`).slice(1).find((frame) => !frame.includes("node_modules/"));
  return getCodeFrame(firstClientCodeFrame);
}
var TEXT_NODE2 = 3;
function jestFakeTimersAreEnabled() {
  return typeof jest < "u" && jest !== null ? (
    // legacy timers
    setTimeout._isMockFunction === !0 || // modern timers
    // eslint-disable-next-line prefer-object-has-own -- not supported by our support matrix
    Object.prototype.hasOwnProperty.call(setTimeout, "clock")
  ) : !1;
}
function getDocument() {
  if (typeof window > "u")
    throw new Error("Could not find default container");
  return window.document;
}
function getWindowFromNode(node) {
  if (node.defaultView)
    return node.defaultView;
  if (node.ownerDocument && node.ownerDocument.defaultView)
    return node.ownerDocument.defaultView;
  if (node.window)
    return node.window;
  throw node.ownerDocument && node.ownerDocument.defaultView === null ? new Error("It looks like the window object is not available for the provided node.") : node.then instanceof Function ? new Error("It looks like you passed a Promise object instead of a DOM node. Did you do something like `fireEvent.click(screen.findBy...` when you meant to use a `getBy` query `fireEvent.click(screen.getBy...`, or await the findBy query `fireEvent.click(await screen.findBy...`?") : Array.isArray(node) ? new Error("It looks like you passed an Array instead of a DOM node. Did you do something like `fireEvent.click(screen.getAllBy...` when you meant to use a `getBy` query `fireEvent.click(screen.getBy...`?") : typeof node.debug == "function" && typeof node.logTestingPlaygroundURL == "function" ? new Error("It looks like you passed a `screen` object. Did you do something like `fireEvent.click(screen, ...` when you meant to use a query, e.g. `fireEvent.click(screen.getBy..., `?") : new Error("The given node is not an Element, the node type is: " + typeof node + ".");
}
function checkContainerType(container) {
  if (!container || typeof container.querySelector != "function" || typeof container.querySelectorAll != "function")
    throw new TypeError("Expected container to be an Element, a Document or a DocumentFragment but got " + getTypeName(container) + ".");
  function getTypeName(object) {
    return typeof object == "object" ? object === null ? "null" : object.constructor.name : typeof object;
  }
}
var shouldHighlight = () => {
  if (typeof process > "u")
    return !1;
  let colors3;
  try {
    var _process$env;
    let colorsJSON = (_process$env = process.env) == null ? void 0 : _process$env.COLORS;
    colorsJSON && (colors3 = JSON.parse(colorsJSON));
  } catch {
  }
  return typeof colors3 == "boolean" ? colors3 : process.versions !== void 0 && process.versions.node !== void 0;
}, {
  DOMCollection: DOMCollection3
} = prettyFormat.plugins, ELEMENT_NODE2 = 1, COMMENT_NODE2 = 8;
function filterCommentsAndDefaultIgnoreTagsTags(value) {
  return value.nodeType !== COMMENT_NODE2 && (value.nodeType !== ELEMENT_NODE2 || !value.matches(getConfig2().defaultIgnore));
}
function prettyDOM(dom, maxLength, options) {
  if (options === void 0 && (options = {}), dom || (dom = getDocument().body), typeof maxLength != "number" && (maxLength = typeof process < "u" && typeof process.env < "u" && process.env.DEBUG_PRINT_LIMIT || 7e3), maxLength === 0)
    return "";
  dom.documentElement && (dom = dom.documentElement);
  let domTypeName = typeof dom;
  if (domTypeName === "object" ? domTypeName = dom.constructor.name : dom = {}, !("outerHTML" in dom))
    throw new TypeError("Expected an element or document but got " + domTypeName);
  let {
    filterNode = filterCommentsAndDefaultIgnoreTagsTags,
    ...prettyFormatOptions
  } = options, debugContent = prettyFormat.format(dom, {
    plugins: [createDOMElementFilter(filterNode), DOMCollection3],
    printFunctionName: !1,
    highlight: shouldHighlight(),
    ...prettyFormatOptions
  });
  return maxLength !== void 0 && dom.outerHTML.length > maxLength ? debugContent.slice(0, maxLength) + "..." : debugContent;
}
var logDOM = function() {
  let userCodeFrame = getUserCodeFrame();
  console.log(userCodeFrame ? prettyDOM(...arguments) + `

` + userCodeFrame : prettyDOM(...arguments));
}, config2 = {
  testIdAttribute: "data-testid",
  asyncUtilTimeout: 1e3,
  // asyncWrapper and advanceTimersWrapper is to support React's async `act` function.
  // forcing react-testing-library to wrap all async functions would've been
  // a total nightmare (consider wrapping every findBy* query and then also
  // updating `within` so those would be wrapped too. Total nightmare).
  // so we have this config option that's really only intended for
  // react-testing-library to use. For that reason, this feature will remain
  // undocumented.
  asyncWrapper: (cb) => cb(),
  unstable_advanceTimersWrapper: (cb) => cb(),
  eventWrapper: (cb) => cb(),
  // default value for the `hidden` option in `ByRole` queries
  defaultHidden: !1,
  // default value for the `ignore` option in `ByText` queries
  defaultIgnore: "script, style",
  // showOriginalStackTrace flag to show the full error stack traces for async errors
  showOriginalStackTrace: !1,
  // throw errors w/ suggestions for better queries. Opt in so off by default.
  throwSuggestions: !1,
  // called when getBy* queries fail. (message, container) => Error
  getElementError(message, container) {
    let prettifiedDOM = prettyDOM(container), error = new Error([message, "Ignored nodes: comments, " + config2.defaultIgnore + `
` + prettifiedDOM].filter(Boolean).join(`

`));
    return error.name = "TestingLibraryElementError", error;
  },
  _disableExpensiveErrorDiagnostics: !1,
  computedStyleSupportsPseudoElements: !1
};
function runWithExpensiveErrorDiagnosticsDisabled(callback) {
  try {
    return config2._disableExpensiveErrorDiagnostics = !0, callback();
  } finally {
    config2._disableExpensiveErrorDiagnostics = !1;
  }
}
function configure(newConfig) {
  typeof newConfig == "function" && (newConfig = newConfig(config2)), config2 = {
    ...config2,
    ...newConfig
  };
}
function getConfig2() {
  return config2;
}
var labelledNodeNames = ["button", "meter", "output", "progress", "select", "textarea", "input"];
function getTextContent(node) {
  return labelledNodeNames.includes(node.nodeName.toLowerCase()) ? "" : node.nodeType === TEXT_NODE2 ? node.textContent : Array.from(node.childNodes).map((childNode) => getTextContent(childNode)).join("");
}
function getLabelContent(element) {
  let textContent;
  return element.tagName.toLowerCase() === "label" ? textContent = getTextContent(element) : textContent = element.value || element.textContent, textContent;
}
function getRealLabels(element) {
  if (element.labels !== void 0) {
    var _labels;
    return (_labels = element.labels) != null ? _labels : [];
  }
  if (!isLabelable(element)) return [];
  let labels = element.ownerDocument.querySelectorAll("label");
  return Array.from(labels).filter((label) => label.control === element);
}
function isLabelable(element) {
  return /BUTTON|METER|OUTPUT|PROGRESS|SELECT|TEXTAREA/.test(element.tagName) || element.tagName === "INPUT" && element.getAttribute("type") !== "hidden";
}
function getLabels3(container, element, _temp) {
  let {
    selector = "*"
  } = _temp === void 0 ? {} : _temp, ariaLabelledBy = element.getAttribute("aria-labelledby"), labelsId = ariaLabelledBy ? ariaLabelledBy.split(" ") : [];
  return labelsId.length ? labelsId.map((labelId) => {
    let labellingElement = container.querySelector('[id="' + labelId + '"]');
    return labellingElement ? {
      content: getLabelContent(labellingElement),
      formControl: null
    } : {
      content: "",
      formControl: null
    };
  }) : Array.from(getRealLabels(element)).map((label) => {
    let textToMatch = getLabelContent(label), labelledFormControl = Array.from(label.querySelectorAll("button, input, meter, output, progress, select, textarea")).filter((formControlElement) => formControlElement.matches(selector))[0];
    return {
      content: textToMatch,
      formControl: labelledFormControl
    };
  });
}
function assertNotNullOrUndefined(matcher) {
  if (matcher == null)
    throw new Error(
      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions -- implicitly converting `T` to `string`
      "It looks like " + matcher + " was passed instead of a matcher. Did you do something like getByText(" + matcher + ")?"
    );
}
function fuzzyMatches(textToMatch, node, matcher, normalizer) {
  if (typeof textToMatch != "string")
    return !1;
  assertNotNullOrUndefined(matcher);
  let normalizedText = normalizer(textToMatch);
  return typeof matcher == "string" || typeof matcher == "number" ? normalizedText.toLowerCase().includes(matcher.toString().toLowerCase()) : typeof matcher == "function" ? matcher(normalizedText, node) : matchRegExp(matcher, normalizedText);
}
function matches2(textToMatch, node, matcher, normalizer) {
  if (typeof textToMatch != "string")
    return !1;
  assertNotNullOrUndefined(matcher);
  let normalizedText = normalizer(textToMatch);
  return matcher instanceof Function ? matcher(normalizedText, node) : matcher instanceof RegExp ? matchRegExp(matcher, normalizedText) : normalizedText === String(matcher);
}
function getDefaultNormalizer(_temp) {
  let {
    trim = !0,
    collapseWhitespace = !0
  } = _temp === void 0 ? {} : _temp;
  return (text) => {
    let normalizedText = text;
    return normalizedText = trim ? normalizedText.trim() : normalizedText, normalizedText = collapseWhitespace ? normalizedText.replace(/\s+/g, " ") : normalizedText, normalizedText;
  };
}
function makeNormalizer(_ref) {
  let {
    trim,
    collapseWhitespace,
    normalizer
  } = _ref;
  if (!normalizer)
    return getDefaultNormalizer({
      trim,
      collapseWhitespace
    });
  if (typeof trim < "u" || typeof collapseWhitespace < "u")
    throw new Error('trim and collapseWhitespace are not supported with a normalizer. If you want to use the default trim and collapseWhitespace logic in your normalizer, use "getDefaultNormalizer({trim, collapseWhitespace})" and compose that into your normalizer');
  return normalizer;
}
function matchRegExp(matcher, text) {
  let match = matcher.test(text);
  return matcher.global && matcher.lastIndex !== 0 && (console.warn("To match all elements we had to reset the lastIndex of the RegExp because the global flag is enabled. We encourage to remove the global flag from the RegExp."), matcher.lastIndex = 0), match;
}
function getNodeText(node) {
  return node.matches("input[type=submit], input[type=button], input[type=reset]") ? node.value : Array.from(node.childNodes).filter((child) => child.nodeType === TEXT_NODE2 && !!child.textContent).map((c2) => c2.textContent).join("");
}
var elementRoleList2 = buildElementRoleList2(import_aria_query3.elementRoles);
function isSubtreeInaccessible(element) {
  return element.hidden === !0 || element.getAttribute("aria-hidden") === "true" || element.ownerDocument.defaultView.getComputedStyle(element).display === "none";
}
function isInaccessible(element, options) {
  options === void 0 && (options = {});
  let {
    isSubtreeInaccessible: isSubtreeInaccessibleImpl = isSubtreeInaccessible
  } = options;
  if (element.ownerDocument.defaultView.getComputedStyle(element).visibility === "hidden")
    return !0;
  let currentElement = element;
  for (; currentElement; ) {
    if (isSubtreeInaccessibleImpl(currentElement))
      return !0;
    currentElement = currentElement.parentElement;
  }
  return !1;
}
function getImplicitAriaRoles2(currentNode) {
  for (let {
    match,
    roles: roles3
  } of elementRoleList2)
    if (match(currentNode))
      return [...roles3];
  return [];
}
function buildElementRoleList2(elementRolesMap) {
  function makeElementSelector(_ref) {
    let {
      name,
      attributes
    } = _ref;
    return "" + name + attributes.map((_ref2) => {
      let {
        name: attributeName,
        value,
        constraints = []
      } = _ref2, shouldNotExist = constraints.indexOf("undefined") !== -1, shouldBeNonEmpty = constraints.indexOf("set") !== -1;
      return typeof value < "u" ? "[" + attributeName + '="' + value + '"]' : shouldNotExist ? ":not([" + attributeName + "])" : shouldBeNonEmpty ? "[" + attributeName + "]:not([" + attributeName + '=""])' : "[" + attributeName + "]";
    }).join("");
  }
  function getSelectorSpecificity(_ref3) {
    let {
      attributes = []
    } = _ref3;
    return attributes.length;
  }
  function bySelectorSpecificity(_ref4, _ref5) {
    let {
      specificity: leftSpecificity
    } = _ref4, {
      specificity: rightSpecificity
    } = _ref5;
    return rightSpecificity - leftSpecificity;
  }
  function match(element) {
    let {
      attributes = []
    } = element, typeTextIndex = attributes.findIndex((attribute) => attribute.value && attribute.name === "type" && attribute.value === "text");
    typeTextIndex >= 0 && (attributes = [...attributes.slice(0, typeTextIndex), ...attributes.slice(typeTextIndex + 1)]);
    let selector = makeElementSelector({
      ...element,
      attributes
    });
    return (node) => typeTextIndex >= 0 && node.type !== "text" ? !1 : node.matches(selector);
  }
  let result = [];
  for (let [element, roles3] of elementRolesMap.entries())
    result = [...result, {
      match: match(element),
      roles: Array.from(roles3),
      specificity: getSelectorSpecificity(element)
    }];
  return result.sort(bySelectorSpecificity);
}
function getRoles(container, _temp) {
  let {
    hidden = !1
  } = _temp === void 0 ? {} : _temp;
  function flattenDOM(node) {
    return [node, ...Array.from(node.children).reduce((acc, child) => [...acc, ...flattenDOM(child)], [])];
  }
  return flattenDOM(container).filter((element) => hidden === !1 ? isInaccessible(element) === !1 : !0).reduce((acc, node) => {
    let roles3 = [];
    return node.hasAttribute("role") ? roles3 = node.getAttribute("role").split(" ").slice(0, 1) : roles3 = getImplicitAriaRoles2(node), roles3.reduce((rolesAcc, role) => Array.isArray(rolesAcc[role]) ? {
      ...rolesAcc,
      [role]: [...rolesAcc[role], node]
    } : {
      ...rolesAcc,
      [role]: [node]
    }, acc);
  }, {});
}
function prettyRoles(dom, _ref6) {
  let {
    hidden,
    includeDescription
  } = _ref6, roles3 = getRoles(dom, {
    hidden
  });
  return Object.entries(roles3).filter((_ref7) => {
    let [role] = _ref7;
    return role !== "generic";
  }).map((_ref8) => {
    let [role, elements] = _ref8, delimiterBar = "-".repeat(50), elementsString = elements.map((el) => {
      let nameString = 'Name "' + computeAccessibleName2(el, {
        computedStyleSupportsPseudoElements: getConfig2().computedStyleSupportsPseudoElements
      }) + `":
`, domString = prettyDOM(el.cloneNode(!1));
      if (includeDescription) {
        let descriptionString = 'Description "' + computeAccessibleDescription2(el, {
          computedStyleSupportsPseudoElements: getConfig2().computedStyleSupportsPseudoElements
        }) + `":
`;
        return "" + nameString + descriptionString + domString;
      }
      return "" + nameString + domString;
    }).join(`

`);
    return role + `:

` + elementsString + `

` + delimiterBar;
  }).join(`
`);
}
var logRoles = function(dom, _temp2) {
  let {
    hidden = !1
  } = _temp2 === void 0 ? {} : _temp2;
  return console.log(prettyRoles(dom, {
    hidden
  }));
};
function computeAriaSelected(element) {
  return element.tagName === "OPTION" ? element.selected : checkBooleanAttribute(element, "aria-selected");
}
function computeAriaBusy(element) {
  return element.getAttribute("aria-busy") === "true";
}
function computeAriaChecked(element) {
  if (!("indeterminate" in element && element.indeterminate))
    return "checked" in element ? element.checked : checkBooleanAttribute(element, "aria-checked");
}
function computeAriaPressed(element) {
  return checkBooleanAttribute(element, "aria-pressed");
}
function computeAriaCurrent(element) {
  var _ref9, _checkBooleanAttribut;
  return (_ref9 = (_checkBooleanAttribut = checkBooleanAttribute(element, "aria-current")) != null ? _checkBooleanAttribut : element.getAttribute("aria-current")) != null ? _ref9 : !1;
}
function computeAriaExpanded(element) {
  return checkBooleanAttribute(element, "aria-expanded");
}
function checkBooleanAttribute(element, attribute) {
  let attributeValue = element.getAttribute(attribute);
  if (attributeValue === "true")
    return !0;
  if (attributeValue === "false")
    return !1;
}
function computeHeadingLevel(element) {
  let implicitHeadingLevels = {
    H1: 1,
    H2: 2,
    H3: 3,
    H4: 4,
    H5: 5,
    H6: 6
  };
  return element.getAttribute("aria-level") && Number(element.getAttribute("aria-level")) || implicitHeadingLevels[element.tagName];
}
function computeAriaValueNow(element) {
  let valueNow = element.getAttribute("aria-valuenow");
  return valueNow === null ? void 0 : +valueNow;
}
function computeAriaValueMax(element) {
  let valueMax = element.getAttribute("aria-valuemax");
  return valueMax === null ? void 0 : +valueMax;
}
function computeAriaValueMin(element) {
  let valueMin = element.getAttribute("aria-valuemin");
  return valueMin === null ? void 0 : +valueMin;
}
function computeAriaValueText(element) {
  let valueText = element.getAttribute("aria-valuetext");
  return valueText === null ? void 0 : valueText;
}
var normalize2 = getDefaultNormalizer();
function escapeRegExp(string) {
  return string.replace(/[.*+\-?^${}()|[\]\\]/g, "\\$&");
}
function getRegExpMatcher(string) {
  return new RegExp(escapeRegExp(string.toLowerCase()), "i");
}
function makeSuggestion(queryName, element, content, _ref) {
  let {
    variant,
    name
  } = _ref, warning = "", queryOptions = {}, queryArgs = [["Role", "TestId"].includes(queryName) ? content : getRegExpMatcher(content)];
  name && (queryOptions.name = getRegExpMatcher(name)), queryName === "Role" && isInaccessible(element) && (queryOptions.hidden = !0, warning = `Element is inaccessible. This means that the element and all its children are invisible to screen readers.
    If you are using the aria-hidden prop, make sure this is the right choice for your case.
    `), Object.keys(queryOptions).length > 0 && queryArgs.push(queryOptions);
  let queryMethod = variant + "By" + queryName;
  return {
    queryName,
    queryMethod,
    queryArgs,
    variant,
    warning,
    toString() {
      warning && console.warn(warning);
      let [text, options] = queryArgs;
      return text = typeof text == "string" ? "'" + text + "'" : text, options = options ? ", { " + Object.entries(options).map((_ref2) => {
        let [k2, v2] = _ref2;
        return k2 + ": " + v2;
      }).join(", ") + " }" : "", queryMethod + "(" + text + options + ")";
    }
  };
}
function canSuggest(currentMethod, requestedMethod, data) {
  return data && (!requestedMethod || requestedMethod.toLowerCase() === currentMethod.toLowerCase());
}
function getSuggestedQuery(element, variant, method) {
  var _element$getAttribute, _getImplicitAriaRoles;
  if (variant === void 0 && (variant = "get"), element.matches(getConfig2().defaultIgnore))
    return;
  let role = (_element$getAttribute = element.getAttribute("role")) != null ? _element$getAttribute : (_getImplicitAriaRoles = getImplicitAriaRoles2(element)) == null ? void 0 : _getImplicitAriaRoles[0];
  if (role !== "generic" && canSuggest("Role", method, role))
    return makeSuggestion("Role", element, role, {
      variant,
      name: computeAccessibleName2(element, {
        computedStyleSupportsPseudoElements: getConfig2().computedStyleSupportsPseudoElements
      })
    });
  let labelText = getLabels3(document, element).map((label) => label.content).join(" ");
  if (canSuggest("LabelText", method, labelText))
    return makeSuggestion("LabelText", element, labelText, {
      variant
    });
  let placeholderText = element.getAttribute("placeholder");
  if (canSuggest("PlaceholderText", method, placeholderText))
    return makeSuggestion("PlaceholderText", element, placeholderText, {
      variant
    });
  let textContent = normalize2(getNodeText(element));
  if (canSuggest("Text", method, textContent))
    return makeSuggestion("Text", element, textContent, {
      variant
    });
  if (canSuggest("DisplayValue", method, element.value))
    return makeSuggestion("DisplayValue", element, normalize2(element.value), {
      variant
    });
  let alt = element.getAttribute("alt");
  if (canSuggest("AltText", method, alt))
    return makeSuggestion("AltText", element, alt, {
      variant
    });
  let title = element.getAttribute("title");
  if (canSuggest("Title", method, title))
    return makeSuggestion("Title", element, title, {
      variant
    });
  let testId = element.getAttribute(getConfig2().testIdAttribute);
  if (canSuggest("TestId", method, testId))
    return makeSuggestion("TestId", element, testId, {
      variant
    });
}
function copyStackTrace(target, source) {
  target.stack = source.stack.replace(source.message, target.message);
}
function waitFor(callback, _ref) {
  let {
    container = getDocument(),
    timeout = getConfig2().asyncUtilTimeout,
    showOriginalStackTrace = getConfig2().showOriginalStackTrace,
    stackTraceError,
    interval = 50,
    onTimeout = (error) => (Object.defineProperty(error, "message", {
      value: getConfig2().getElementError(error.message, container).message
    }), error),
    mutationObserverOptions = {
      subtree: !0,
      childList: !0,
      attributes: !0,
      characterData: !0
    }
  } = _ref;
  if (typeof callback != "function")
    throw new TypeError("Received `callback` arg must be a function");
  return new Promise(async (resolve, reject) => {
    let lastError, intervalId, observer, finished = !1, promiseStatus = "idle", overallTimeoutTimer = setTimeout(handleTimeout, timeout), usingJestFakeTimers = jestFakeTimersAreEnabled();
    if (usingJestFakeTimers) {
      let {
        unstable_advanceTimersWrapper: advanceTimersWrapper
      } = getConfig2();
      for (checkCallback(); !finished; ) {
        if (!jestFakeTimersAreEnabled()) {
          let error = new Error("Changed from using fake timers to real timers while using waitFor. This is not allowed and will result in very strange behavior. Please ensure you're awaiting all async things your test is doing before changing to real timers. For more info, please go to https://github.com/testing-library/dom-testing-library/issues/830");
          showOriginalStackTrace || copyStackTrace(error, stackTraceError), reject(error);
          return;
        }
        if (await advanceTimersWrapper(async () => {
          jest.advanceTimersByTime(interval);
        }), finished)
          break;
        checkCallback();
      }
    } else {
      try {
        checkContainerType(container);
      } catch (e2) {
        reject(e2);
        return;
      }
      intervalId = setInterval(checkRealTimersCallback, interval);
      let {
        MutationObserver: MutationObserver2
      } = getWindowFromNode(container);
      observer = new MutationObserver2(checkRealTimersCallback), observer.observe(container, mutationObserverOptions), checkCallback();
    }
    function onDone(error, result) {
      finished = !0, clearTimeout(overallTimeoutTimer), usingJestFakeTimers || (clearInterval(intervalId), observer.disconnect()), error ? reject(error) : resolve(result);
    }
    function checkRealTimersCallback() {
      if (jestFakeTimersAreEnabled()) {
        let error = new Error("Changed from using real timers to fake timers while using waitFor. This is not allowed and will result in very strange behavior. Please ensure you're awaiting all async things your test is doing before changing to fake timers. For more info, please go to https://github.com/testing-library/dom-testing-library/issues/830");
        return showOriginalStackTrace || copyStackTrace(error, stackTraceError), reject(error);
      } else
        return checkCallback();
    }
    function checkCallback() {
      if (promiseStatus !== "pending")
        try {
          let result = runWithExpensiveErrorDiagnosticsDisabled(callback);
          typeof result?.then == "function" ? (promiseStatus = "pending", result.then((resolvedValue) => {
            promiseStatus = "resolved", onDone(null, resolvedValue);
          }, (rejectedValue) => {
            promiseStatus = "rejected", lastError = rejectedValue;
          })) : onDone(null, result);
        } catch (error) {
          lastError = error;
        }
    }
    function handleTimeout() {
      let error;
      lastError ? (error = lastError, !showOriginalStackTrace && error.name === "TestingLibraryElementError" && copyStackTrace(error, stackTraceError)) : (error = new Error("Timed out in waitFor."), showOriginalStackTrace || copyStackTrace(error, stackTraceError)), onDone(onTimeout(error), null);
    }
  });
}
function waitForWrapper(callback, options) {
  let stackTraceError = new Error("STACK_TRACE_MESSAGE");
  return getConfig2().asyncWrapper(() => waitFor(callback, {
    stackTraceError,
    ...options
  }));
}
function getElementError(message, container) {
  return getConfig2().getElementError(message, container);
}
function getMultipleElementsFoundError(message, container) {
  return getElementError(message + "\n\n(If this is intentional, then use the `*AllBy*` variant of the query (like `queryAllByText`, `getAllByText`, or `findAllByText`)).", container);
}
function queryAllByAttribute(attribute, container, text, _temp) {
  let {
    exact = !0,
    collapseWhitespace,
    trim,
    normalizer
  } = _temp === void 0 ? {} : _temp, matcher = exact ? matches2 : fuzzyMatches, matchNormalizer = makeNormalizer({
    collapseWhitespace,
    trim,
    normalizer
  });
  return Array.from(container.querySelectorAll("[" + attribute + "]")).filter((node) => matcher(node.getAttribute(attribute), node, text, matchNormalizer));
}
function queryByAttribute(attribute, container, text, options) {
  let els = queryAllByAttribute(attribute, container, text, options);
  if (els.length > 1)
    throw getMultipleElementsFoundError("Found multiple elements by [" + attribute + "=" + text + "]", container);
  return els[0] || null;
}
function makeSingleQuery(allQuery, getMultipleError2) {
  return function(container) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)
      args[_key - 1] = arguments[_key];
    let els = allQuery(container, ...args);
    if (els.length > 1) {
      let elementStrings = els.map((element) => getElementError(null, element).message).join(`

`);
      throw getMultipleElementsFoundError(getMultipleError2(container, ...args) + `

Here are the matching elements:

` + elementStrings, container);
    }
    return els[0] || null;
  };
}
function getSuggestionError(suggestion, container) {
  return getConfig2().getElementError(`A better query is available, try this:
` + suggestion.toString() + `
`, container);
}
function makeGetAllQuery(allQuery, getMissingError2) {
  return function(container) {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++)
      args[_key2 - 1] = arguments[_key2];
    let els = allQuery(container, ...args);
    if (!els.length)
      throw getConfig2().getElementError(getMissingError2(container, ...args), container);
    return els;
  };
}
function makeFindQuery(getter) {
  return (container, text, options, waitForOptions) => waitForWrapper(() => getter(container, text, options), {
    container,
    ...waitForOptions
  });
}
var wrapSingleQueryWithSuggestion = (query, queryAllByName, variant) => function(container) {
  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++)
    args[_key3 - 1] = arguments[_key3];
  let element = query(container, ...args), [{
    suggest = getConfig2().throwSuggestions
  } = {}] = args.slice(-1);
  if (element && suggest) {
    let suggestion = getSuggestedQuery(element, variant);
    if (suggestion && !queryAllByName.endsWith(suggestion.queryName))
      throw getSuggestionError(suggestion.toString(), container);
  }
  return element;
}, wrapAllByQueryWithSuggestion = (query, queryAllByName, variant) => function(container) {
  for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++)
    args[_key4 - 1] = arguments[_key4];
  let els = query(container, ...args), [{
    suggest = getConfig2().throwSuggestions
  } = {}] = args.slice(-1);
  if (els.length && suggest) {
    let uniqueSuggestionMessages = [...new Set(els.map((element) => {
      var _getSuggestedQuery;
      return (_getSuggestedQuery = getSuggestedQuery(element, variant)) == null ? void 0 : _getSuggestedQuery.toString();
    }))];
    if (
      // only want to suggest if all the els have the same suggestion.
      uniqueSuggestionMessages.length === 1 && !queryAllByName.endsWith(
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- TODO: Can this be null at runtime?
        getSuggestedQuery(els[0], variant).queryName
      )
    )
      throw getSuggestionError(uniqueSuggestionMessages[0], container);
  }
  return els;
};
function buildQueries(queryAllBy, getMultipleError2, getMissingError2) {
  let queryBy = wrapSingleQueryWithSuggestion(makeSingleQuery(queryAllBy, getMultipleError2), queryAllBy.name, "query"), getAllBy = makeGetAllQuery(queryAllBy, getMissingError2), getBy = makeSingleQuery(getAllBy, getMultipleError2), getByWithSuggestions = wrapSingleQueryWithSuggestion(getBy, queryAllBy.name, "get"), getAllWithSuggestions = wrapAllByQueryWithSuggestion(getAllBy, queryAllBy.name.replace("query", "get"), "getAll"), findAllBy = makeFindQuery(wrapAllByQueryWithSuggestion(getAllBy, queryAllBy.name, "findAll")), findBy = makeFindQuery(wrapSingleQueryWithSuggestion(getBy, queryAllBy.name, "find"));
  return [queryBy, getAllWithSuggestions, getByWithSuggestions, findAllBy, findBy];
}
var queryHelpers = Object.freeze({
  __proto__: null,
  getElementError,
  wrapAllByQueryWithSuggestion,
  wrapSingleQueryWithSuggestion,
  getMultipleElementsFoundError,
  queryAllByAttribute,
  queryByAttribute,
  makeSingleQuery,
  makeGetAllQuery,
  makeFindQuery,
  buildQueries
});
function queryAllLabels(container) {
  return Array.from(container.querySelectorAll("label,input")).map((node) => ({
    node,
    textToMatch: getLabelContent(node)
  })).filter((_ref) => {
    let {
      textToMatch
    } = _ref;
    return textToMatch !== null;
  });
}
var queryAllLabelsByText = function(container, text, _temp) {
  let {
    exact = !0,
    trim,
    collapseWhitespace,
    normalizer
  } = _temp === void 0 ? {} : _temp, matcher = exact ? matches2 : fuzzyMatches, matchNormalizer = makeNormalizer({
    collapseWhitespace,
    trim,
    normalizer
  });
  return queryAllLabels(container).filter((_ref2) => {
    let {
      node,
      textToMatch
    } = _ref2;
    return matcher(textToMatch, node, text, matchNormalizer);
  }).map((_ref3) => {
    let {
      node
    } = _ref3;
    return node;
  });
}, queryAllByLabelText = function(container, text, _temp2) {
  let {
    selector = "*",
    exact = !0,
    collapseWhitespace,
    trim,
    normalizer
  } = _temp2 === void 0 ? {} : _temp2;
  checkContainerType(container);
  let matcher = exact ? matches2 : fuzzyMatches, matchNormalizer = makeNormalizer({
    collapseWhitespace,
    trim,
    normalizer
  }), matchingLabelledElements = Array.from(container.querySelectorAll("*")).filter((element) => getRealLabels(element).length || element.hasAttribute("aria-labelledby")).reduce((labelledElements, labelledElement) => {
    let labelList = getLabels3(container, labelledElement, {
      selector
    });
    labelList.filter((label) => !!label.formControl).forEach((label) => {
      matcher(label.content, label.formControl, text, matchNormalizer) && label.formControl && labelledElements.push(label.formControl);
    });
    let labelsValue = labelList.filter((label) => !!label.content).map((label) => label.content);
    return matcher(labelsValue.join(" "), labelledElement, text, matchNormalizer) && labelledElements.push(labelledElement), labelsValue.length > 1 && labelsValue.forEach((labelValue, index2) => {
      matcher(labelValue, labelledElement, text, matchNormalizer) && labelledElements.push(labelledElement);
      let labelsFiltered = [...labelsValue];
      labelsFiltered.splice(index2, 1), labelsFiltered.length > 1 && matcher(labelsFiltered.join(" "), labelledElement, text, matchNormalizer) && labelledElements.push(labelledElement);
    }), labelledElements;
  }, []).concat(queryAllByAttribute("aria-label", container, text, {
    exact,
    normalizer: matchNormalizer
  }));
  return Array.from(new Set(matchingLabelledElements)).filter((element) => element.matches(selector));
}, getAllByLabelText = function(container, text) {
  for (var _len = arguments.length, rest = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++)
    rest[_key - 2] = arguments[_key];
  let els = queryAllByLabelText(container, text, ...rest);
  if (!els.length) {
    let labels = queryAllLabelsByText(container, text, ...rest);
    if (labels.length) {
      let tagNames = labels.map((label) => getTagNameOfElementAssociatedWithLabelViaFor(container, label)).filter((tagName) => !!tagName);
      throw tagNames.length ? getConfig2().getElementError(tagNames.map((tagName) => "Found a label with the text of: " + text + ", however the element associated with this label (<" + tagName + " />) is non-labellable [https://html.spec.whatwg.org/multipage/forms.html#category-label]. If you really need to label a <" + tagName + " />, you can use aria-label or aria-labelledby instead.").join(`

`), container) : getConfig2().getElementError("Found a label with the text of: " + text + `, however no form control was found associated to that label. Make sure you're using the "for" attribute or "aria-labelledby" attribute correctly.`, container);
    } else
      throw getConfig2().getElementError("Unable to find a label with the text of: " + text, container);
  }
  return els;
};
function getTagNameOfElementAssociatedWithLabelViaFor(container, label) {
  let htmlFor = label.getAttribute("for");
  if (!htmlFor)
    return null;
  let element = container.querySelector('[id="' + htmlFor + '"]');
  return element ? element.tagName.toLowerCase() : null;
}
var getMultipleError$7 = (c2, text) => "Found multiple elements with the text of: " + text, queryByLabelText = wrapSingleQueryWithSuggestion(makeSingleQuery(queryAllByLabelText, getMultipleError$7), queryAllByLabelText.name, "query"), getByLabelText = makeSingleQuery(getAllByLabelText, getMultipleError$7), findAllByLabelText = makeFindQuery(wrapAllByQueryWithSuggestion(getAllByLabelText, getAllByLabelText.name, "findAll")), findByLabelText = makeFindQuery(wrapSingleQueryWithSuggestion(getByLabelText, getAllByLabelText.name, "find")), getAllByLabelTextWithSuggestions = wrapAllByQueryWithSuggestion(getAllByLabelText, getAllByLabelText.name, "getAll"), getByLabelTextWithSuggestions = wrapSingleQueryWithSuggestion(getByLabelText, getAllByLabelText.name, "get"), queryAllByLabelTextWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByLabelText, queryAllByLabelText.name, "queryAll"), queryAllByPlaceholderText = function() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
    args[_key] = arguments[_key];
  return checkContainerType(args[0]), queryAllByAttribute("placeholder", ...args);
}, getMultipleError$6 = (c2, text) => "Found multiple elements with the placeholder text of: " + text, getMissingError$6 = (c2, text) => "Unable to find an element with the placeholder text of: " + text, queryAllByPlaceholderTextWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByPlaceholderText, queryAllByPlaceholderText.name, "queryAll"), [queryByPlaceholderText, getAllByPlaceholderText, getByPlaceholderText, findAllByPlaceholderText, findByPlaceholderText] = buildQueries(queryAllByPlaceholderText, getMultipleError$6, getMissingError$6), queryAllByText = function(container, text, _temp) {
  let {
    selector = "*",
    exact = !0,
    collapseWhitespace,
    trim,
    ignore = getConfig2().defaultIgnore,
    normalizer
  } = _temp === void 0 ? {} : _temp;
  checkContainerType(container);
  let matcher = exact ? matches2 : fuzzyMatches, matchNormalizer = makeNormalizer({
    collapseWhitespace,
    trim,
    normalizer
  }), baseArray = [];
  return typeof container.matches == "function" && container.matches(selector) && (baseArray = [container]), [...baseArray, ...Array.from(container.querySelectorAll(selector))].filter((node) => !ignore || !node.matches(ignore)).filter((node) => matcher(getNodeText(node), node, text, matchNormalizer));
}, getMultipleError$5 = (c2, text) => "Found multiple elements with the text: " + text, getMissingError$5 = function(c2, text, options) {
  options === void 0 && (options = {});
  let {
    collapseWhitespace,
    trim,
    normalizer,
    selector
  } = options, normalizedText = makeNormalizer({
    collapseWhitespace,
    trim,
    normalizer
  })(text.toString()), isNormalizedDifferent = normalizedText !== text.toString(), isCustomSelector = (selector ?? "*") !== "*";
  return "Unable to find an element with the text: " + (isNormalizedDifferent ? normalizedText + " (normalized from '" + text + "')" : text) + (isCustomSelector ? ", which matches selector '" + selector + "'" : "") + ". This could be because the text is broken up by multiple elements. In this case, you can provide a function for your text matcher to make your matcher more flexible.";
}, queryAllByTextWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByText, queryAllByText.name, "queryAll"), [queryByText, getAllByText, getByText, findAllByText, findByText] = buildQueries(queryAllByText, getMultipleError$5, getMissingError$5), queryAllByDisplayValue = function(container, value, _temp) {
  let {
    exact = !0,
    collapseWhitespace,
    trim,
    normalizer
  } = _temp === void 0 ? {} : _temp;
  checkContainerType(container);
  let matcher = exact ? matches2 : fuzzyMatches, matchNormalizer = makeNormalizer({
    collapseWhitespace,
    trim,
    normalizer
  });
  return Array.from(container.querySelectorAll("input,textarea,select")).filter((node) => node.tagName === "SELECT" ? Array.from(node.options).filter((option) => option.selected).some((optionNode) => matcher(getNodeText(optionNode), optionNode, value, matchNormalizer)) : matcher(node.value, node, value, matchNormalizer));
}, getMultipleError$4 = (c2, value) => "Found multiple elements with the display value: " + value + ".", getMissingError$4 = (c2, value) => "Unable to find an element with the display value: " + value + ".", queryAllByDisplayValueWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByDisplayValue, queryAllByDisplayValue.name, "queryAll"), [queryByDisplayValue, getAllByDisplayValue, getByDisplayValue, findAllByDisplayValue, findByDisplayValue] = buildQueries(queryAllByDisplayValue, getMultipleError$4, getMissingError$4), VALID_TAG_REGEXP = /^(img|input|area|.+-.+)$/i, queryAllByAltText = function(container, alt, options) {
  return options === void 0 && (options = {}), checkContainerType(container), queryAllByAttribute("alt", container, alt, options).filter((node) => VALID_TAG_REGEXP.test(node.tagName));
}, getMultipleError$3 = (c2, alt) => "Found multiple elements with the alt text: " + alt, getMissingError$3 = (c2, alt) => "Unable to find an element with the alt text: " + alt, queryAllByAltTextWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByAltText, queryAllByAltText.name, "queryAll"), [queryByAltText, getAllByAltText, getByAltText, findAllByAltText, findByAltText] = buildQueries(queryAllByAltText, getMultipleError$3, getMissingError$3), isSvgTitle = (node) => {
  var _node$parentElement;
  return node.tagName.toLowerCase() === "title" && ((_node$parentElement = node.parentElement) == null ? void 0 : _node$parentElement.tagName.toLowerCase()) === "svg";
}, queryAllByTitle = function(container, text, _temp) {
  let {
    exact = !0,
    collapseWhitespace,
    trim,
    normalizer
  } = _temp === void 0 ? {} : _temp;
  checkContainerType(container);
  let matcher = exact ? matches2 : fuzzyMatches, matchNormalizer = makeNormalizer({
    collapseWhitespace,
    trim,
    normalizer
  });
  return Array.from(container.querySelectorAll("[title], svg > title")).filter((node) => matcher(node.getAttribute("title"), node, text, matchNormalizer) || isSvgTitle(node) && matcher(getNodeText(node), node, text, matchNormalizer));
}, getMultipleError$2 = (c2, title) => "Found multiple elements with the title: " + title + ".", getMissingError$2 = (c2, title) => "Unable to find an element with the title: " + title + ".", queryAllByTitleWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByTitle, queryAllByTitle.name, "queryAll"), [queryByTitle, getAllByTitle, getByTitle, findAllByTitle, findByTitle] = buildQueries(queryAllByTitle, getMultipleError$2, getMissingError$2), queryAllByRole = function(container, role, _temp) {
  let {
    hidden = getConfig2().defaultHidden,
    name,
    description,
    queryFallbacks = !1,
    selected,
    busy,
    checked,
    pressed,
    current,
    level,
    expanded,
    value: {
      now: valueNow,
      min: valueMin,
      max: valueMax,
      text: valueText
    } = {}
  } = _temp === void 0 ? {} : _temp;
  if (checkContainerType(container), selected !== void 0) {
    var _allRoles$get;
    if (((_allRoles$get = import_aria_query3.roles.get(role)) == null ? void 0 : _allRoles$get.props["aria-selected"]) === void 0)
      throw new Error('"aria-selected" is not supported on role "' + role + '".');
  }
  if (busy !== void 0) {
    var _allRoles$get2;
    if (((_allRoles$get2 = import_aria_query3.roles.get(role)) == null ? void 0 : _allRoles$get2.props["aria-busy"]) === void 0)
      throw new Error('"aria-busy" is not supported on role "' + role + '".');
  }
  if (checked !== void 0) {
    var _allRoles$get3;
    if (((_allRoles$get3 = import_aria_query3.roles.get(role)) == null ? void 0 : _allRoles$get3.props["aria-checked"]) === void 0)
      throw new Error('"aria-checked" is not supported on role "' + role + '".');
  }
  if (pressed !== void 0) {
    var _allRoles$get4;
    if (((_allRoles$get4 = import_aria_query3.roles.get(role)) == null ? void 0 : _allRoles$get4.props["aria-pressed"]) === void 0)
      throw new Error('"aria-pressed" is not supported on role "' + role + '".');
  }
  if (current !== void 0) {
    var _allRoles$get5;
    if (((_allRoles$get5 = import_aria_query3.roles.get(role)) == null ? void 0 : _allRoles$get5.props["aria-current"]) === void 0)
      throw new Error('"aria-current" is not supported on role "' + role + '".');
  }
  if (level !== void 0 && role !== "heading")
    throw new Error('Role "' + role + '" cannot have "level" property.');
  if (valueNow !== void 0) {
    var _allRoles$get6;
    if (((_allRoles$get6 = import_aria_query3.roles.get(role)) == null ? void 0 : _allRoles$get6.props["aria-valuenow"]) === void 0)
      throw new Error('"aria-valuenow" is not supported on role "' + role + '".');
  }
  if (valueMax !== void 0) {
    var _allRoles$get7;
    if (((_allRoles$get7 = import_aria_query3.roles.get(role)) == null ? void 0 : _allRoles$get7.props["aria-valuemax"]) === void 0)
      throw new Error('"aria-valuemax" is not supported on role "' + role + '".');
  }
  if (valueMin !== void 0) {
    var _allRoles$get8;
    if (((_allRoles$get8 = import_aria_query3.roles.get(role)) == null ? void 0 : _allRoles$get8.props["aria-valuemin"]) === void 0)
      throw new Error('"aria-valuemin" is not supported on role "' + role + '".');
  }
  if (valueText !== void 0) {
    var _allRoles$get9;
    if (((_allRoles$get9 = import_aria_query3.roles.get(role)) == null ? void 0 : _allRoles$get9.props["aria-valuetext"]) === void 0)
      throw new Error('"aria-valuetext" is not supported on role "' + role + '".');
  }
  if (expanded !== void 0) {
    var _allRoles$get0;
    if (((_allRoles$get0 = import_aria_query3.roles.get(role)) == null ? void 0 : _allRoles$get0.props["aria-expanded"]) === void 0)
      throw new Error('"aria-expanded" is not supported on role "' + role + '".');
  }
  let subtreeIsInaccessibleCache = /* @__PURE__ */ new WeakMap();
  function cachedIsSubtreeInaccessible(element) {
    return subtreeIsInaccessibleCache.has(element) || subtreeIsInaccessibleCache.set(element, isSubtreeInaccessible(element)), subtreeIsInaccessibleCache.get(element);
  }
  return Array.from(container.querySelectorAll(
    // Only query elements that can be matched by the following filters
    makeRoleSelector(role)
  )).filter((node) => {
    if (node.hasAttribute("role")) {
      let roleValue = node.getAttribute("role");
      if (queryFallbacks)
        return roleValue.split(" ").filter(Boolean).some((roleAttributeToken) => roleAttributeToken === role);
      let [firstRoleAttributeToken] = roleValue.split(" ");
      return firstRoleAttributeToken === role;
    }
    return getImplicitAriaRoles2(node).some((implicitRole) => implicitRole === role);
  }).filter((element) => {
    if (selected !== void 0)
      return selected === computeAriaSelected(element);
    if (busy !== void 0)
      return busy === computeAriaBusy(element);
    if (checked !== void 0)
      return checked === computeAriaChecked(element);
    if (pressed !== void 0)
      return pressed === computeAriaPressed(element);
    if (current !== void 0)
      return current === computeAriaCurrent(element);
    if (expanded !== void 0)
      return expanded === computeAriaExpanded(element);
    if (level !== void 0)
      return level === computeHeadingLevel(element);
    if (valueNow !== void 0 || valueMax !== void 0 || valueMin !== void 0 || valueText !== void 0) {
      let valueMatches = !0;
      if (valueNow !== void 0 && valueMatches && (valueMatches = valueNow === computeAriaValueNow(element)), valueMax !== void 0 && valueMatches && (valueMatches = valueMax === computeAriaValueMax(element)), valueMin !== void 0 && valueMatches && (valueMatches = valueMin === computeAriaValueMin(element)), valueText !== void 0) {
        var _computeAriaValueText;
        valueMatches && (valueMatches = matches2((_computeAriaValueText = computeAriaValueText(element)) != null ? _computeAriaValueText : null, element, valueText, (text) => text));
      }
      return valueMatches;
    }
    return !0;
  }).filter((element) => name === void 0 ? !0 : matches2(computeAccessibleName2(element, {
    computedStyleSupportsPseudoElements: getConfig2().computedStyleSupportsPseudoElements
  }), element, name, (text) => text)).filter((element) => description === void 0 ? !0 : matches2(computeAccessibleDescription2(element, {
    computedStyleSupportsPseudoElements: getConfig2().computedStyleSupportsPseudoElements
  }), element, description, (text) => text)).filter((element) => hidden === !1 ? isInaccessible(element, {
    isSubtreeInaccessible: cachedIsSubtreeInaccessible
  }) === !1 : !0);
};
function makeRoleSelector(role) {
  var _roleElements$get;
  let explicitRoleSelector = '*[role~="' + role + '"]', roleRelations = (_roleElements$get = import_aria_query3.roleElements.get(role)) != null ? _roleElements$get : /* @__PURE__ */ new Set(), implicitRoleSelectors = new Set(Array.from(roleRelations).map((_ref) => {
    let {
      name
    } = _ref;
    return name;
  }));
  return [explicitRoleSelector].concat(Array.from(implicitRoleSelectors)).join(",");
}
var getNameHint = (name) => {
  let nameHint = "";
  return name === void 0 ? nameHint = "" : typeof name == "string" ? nameHint = ' and name "' + name + '"' : nameHint = " and name `" + name + "`", nameHint;
}, getMultipleError$1 = function(c2, role, _temp2) {
  let {
    name
  } = _temp2 === void 0 ? {} : _temp2;
  return 'Found multiple elements with the role "' + role + '"' + getNameHint(name);
}, getMissingError$1 = function(container, role, _temp3) {
  let {
    hidden = getConfig2().defaultHidden,
    name,
    description
  } = _temp3 === void 0 ? {} : _temp3;
  if (getConfig2()._disableExpensiveErrorDiagnostics)
    return 'Unable to find role="' + role + '"' + getNameHint(name);
  let roles3 = "";
  Array.from(container.children).forEach((childElement) => {
    roles3 += prettyRoles(childElement, {
      hidden,
      includeDescription: description !== void 0
    });
  });
  let roleMessage;
  roles3.length === 0 ? hidden === !1 ? roleMessage = "There are no accessible roles. But there might be some inaccessible roles. If you wish to access them, then set the `hidden` option to `true`. Learn more about this here: https://testing-library.com/docs/dom-testing-library/api-queries#byrole" : roleMessage = "There are no available roles." : roleMessage = (`
Here are the ` + (hidden === !1 ? "accessible" : "available") + ` roles:

  ` + roles3.replace(/\n/g, `
  `).replace(/\n\s\s\n/g, `

`) + `
`).trim();
  let nameHint = "";
  name === void 0 ? nameHint = "" : typeof name == "string" ? nameHint = ' and name "' + name + '"' : nameHint = " and name `" + name + "`";
  let descriptionHint = "";
  return description === void 0 ? descriptionHint = "" : typeof description == "string" ? descriptionHint = ' and description "' + description + '"' : descriptionHint = " and description `" + description + "`", (`
Unable to find an ` + (hidden === !1 ? "accessible " : "") + 'element with the role "' + role + '"' + nameHint + descriptionHint + `

` + roleMessage).trim();
}, queryAllByRoleWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByRole, queryAllByRole.name, "queryAll"), [queryByRole, getAllByRole, getByRole, findAllByRole, findByRole] = buildQueries(queryAllByRole, getMultipleError$1, getMissingError$1), getTestIdAttribute = () => getConfig2().testIdAttribute, queryAllByTestId = function() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
    args[_key] = arguments[_key];
  return checkContainerType(args[0]), queryAllByAttribute(getTestIdAttribute(), ...args);
}, getMultipleError = (c2, id) => "Found multiple elements by: [" + getTestIdAttribute() + '="' + id + '"]', getMissingError = (c2, id) => "Unable to find an element by: [" + getTestIdAttribute() + '="' + id + '"]', queryAllByTestIdWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByTestId, queryAllByTestId.name, "queryAll"), [queryByTestId, getAllByTestId, getByTestId, findAllByTestId, findByTestId] = buildQueries(queryAllByTestId, getMultipleError, getMissingError), queries = Object.freeze({
  __proto__: null,
  queryAllByLabelText: queryAllByLabelTextWithSuggestions,
  queryByLabelText,
  getAllByLabelText: getAllByLabelTextWithSuggestions,
  getByLabelText: getByLabelTextWithSuggestions,
  findAllByLabelText,
  findByLabelText,
  queryByPlaceholderText,
  queryAllByPlaceholderText: queryAllByPlaceholderTextWithSuggestions,
  getByPlaceholderText,
  getAllByPlaceholderText,
  findAllByPlaceholderText,
  findByPlaceholderText,
  queryByText,
  queryAllByText: queryAllByTextWithSuggestions,
  getByText,
  getAllByText,
  findAllByText,
  findByText,
  queryByDisplayValue,
  queryAllByDisplayValue: queryAllByDisplayValueWithSuggestions,
  getByDisplayValue,
  getAllByDisplayValue,
  findAllByDisplayValue,
  findByDisplayValue,
  queryByAltText,
  queryAllByAltText: queryAllByAltTextWithSuggestions,
  getByAltText,
  getAllByAltText,
  findAllByAltText,
  findByAltText,
  queryByTitle,
  queryAllByTitle: queryAllByTitleWithSuggestions,
  getByTitle,
  getAllByTitle,
  findAllByTitle,
  findByTitle,
  queryByRole,
  queryAllByRole: queryAllByRoleWithSuggestions,
  getAllByRole,
  getByRole,
  findAllByRole,
  findByRole,
  queryByTestId,
  queryAllByTestId: queryAllByTestIdWithSuggestions,
  getByTestId,
  getAllByTestId,
  findAllByTestId,
  findByTestId
});
function getQueriesForElement(element, queries$1, initialValue2) {
  return queries$1 === void 0 && (queries$1 = queries), initialValue2 === void 0 && (initialValue2 = {}), Object.keys(queries$1).reduce((helpers, key) => {
    let fn3 = queries$1[key];
    return helpers[key] = fn3.bind(null, element), helpers;
  }, initialValue2);
}
var isRemoved = (result) => !result || Array.isArray(result) && !result.length;
function initialCheck(elements) {
  if (isRemoved(elements))
    throw new Error("The element(s) given to waitForElementToBeRemoved are already removed. waitForElementToBeRemoved requires that the element(s) exist(s) before waiting for removal.");
}
async function waitForElementToBeRemoved(callback, options) {
  let timeoutError = new Error("Timed out in waitForElementToBeRemoved.");
  if (typeof callback != "function") {
    initialCheck(callback);
    let getRemainingElements = (Array.isArray(callback) ? callback : [callback]).map((element) => {
      let parent = element.parentElement;
      if (parent === null) return () => null;
      for (; parent.parentElement; ) parent = parent.parentElement;
      return () => parent.contains(element) ? element : null;
    });
    callback = () => getRemainingElements.map((c2) => c2()).filter(Boolean);
  }
  return initialCheck(callback()), waitForWrapper(() => {
    let result;
    try {
      result = callback();
    } catch (error) {
      if (error.name === "TestingLibraryElementError")
        return;
      throw error;
    }
    if (!isRemoved(result))
      throw timeoutError;
  }, options);
}
var eventMap = {
  // Clipboard Events
  copy: {
    EventType: "ClipboardEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  cut: {
    EventType: "ClipboardEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  paste: {
    EventType: "ClipboardEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  // Composition Events
  compositionEnd: {
    EventType: "CompositionEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  compositionStart: {
    EventType: "CompositionEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  compositionUpdate: {
    EventType: "CompositionEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  // Keyboard Events
  keyDown: {
    EventType: "KeyboardEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      charCode: 0,
      composed: !0
    }
  },
  keyPress: {
    EventType: "KeyboardEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      charCode: 0,
      composed: !0
    }
  },
  keyUp: {
    EventType: "KeyboardEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      charCode: 0,
      composed: !0
    }
  },
  // Focus Events
  focus: {
    EventType: "FocusEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1,
      composed: !0
    }
  },
  blur: {
    EventType: "FocusEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1,
      composed: !0
    }
  },
  focusIn: {
    EventType: "FocusEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }
  },
  focusOut: {
    EventType: "FocusEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }
  },
  // Form Events
  change: {
    EventType: "Event",
    defaultInit: {
      bubbles: !0,
      cancelable: !1
    }
  },
  input: {
    EventType: "InputEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }
  },
  invalid: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !0
    }
  },
  submit: {
    EventType: "Event",
    defaultInit: {
      bubbles: !0,
      cancelable: !0
    }
  },
  reset: {
    EventType: "Event",
    defaultInit: {
      bubbles: !0,
      cancelable: !0
    }
  },
  // Mouse Events
  click: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      button: 0,
      composed: !0
    }
  },
  contextMenu: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  dblClick: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  drag: {
    EventType: "DragEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  dragEnd: {
    EventType: "DragEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }
  },
  dragEnter: {
    EventType: "DragEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  dragExit: {
    EventType: "DragEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }
  },
  dragLeave: {
    EventType: "DragEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }
  },
  dragOver: {
    EventType: "DragEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  dragStart: {
    EventType: "DragEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  drop: {
    EventType: "DragEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  mouseDown: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  mouseEnter: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1,
      composed: !0
    }
  },
  mouseLeave: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1,
      composed: !0
    }
  },
  mouseMove: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  mouseOut: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  mouseOver: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  mouseUp: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  // Selection Events
  select: {
    EventType: "Event",
    defaultInit: {
      bubbles: !0,
      cancelable: !1
    }
  },
  // Touch Events
  touchCancel: {
    EventType: "TouchEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }
  },
  touchEnd: {
    EventType: "TouchEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  touchMove: {
    EventType: "TouchEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  touchStart: {
    EventType: "TouchEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  // UI Events
  resize: {
    EventType: "UIEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  scroll: {
    EventType: "UIEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  // Wheel Events
  wheel: {
    EventType: "WheelEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  // Media Events
  abort: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  canPlay: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  canPlayThrough: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  durationChange: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  emptied: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  encrypted: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  ended: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  loadedData: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  loadedMetadata: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  loadStart: {
    EventType: "ProgressEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  pause: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  play: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  playing: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  progress: {
    EventType: "ProgressEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  rateChange: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  seeked: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  seeking: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  stalled: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  suspend: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  timeUpdate: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  volumeChange: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  waiting: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  // Events
  load: {
    // TODO: load events can be UIEvent or Event depending on what generated them
    // This is where this abstraction breaks down.
    // But the common targets are <img />, <script /> and window.
    // Neither of these targets receive a UIEvent
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  error: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  // Animation Events
  animationStart: {
    EventType: "AnimationEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1
    }
  },
  animationEnd: {
    EventType: "AnimationEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1
    }
  },
  animationIteration: {
    EventType: "AnimationEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1
    }
  },
  // Transition Events
  transitionCancel: {
    EventType: "TransitionEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1
    }
  },
  transitionEnd: {
    EventType: "TransitionEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0
    }
  },
  transitionRun: {
    EventType: "TransitionEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1
    }
  },
  transitionStart: {
    EventType: "TransitionEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1
    }
  },
  // pointer events
  pointerOver: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  pointerEnter: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  pointerDown: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  pointerMove: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  pointerUp: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  pointerCancel: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }
  },
  pointerOut: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  pointerLeave: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  gotPointerCapture: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }
  },
  lostPointerCapture: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }
  },
  // history events
  popState: {
    EventType: "PopStateEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1
    }
  },
  // window events
  offline: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  online: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  pageHide: {
    EventType: "PageTransitionEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0
    }
  },
  pageShow: {
    EventType: "PageTransitionEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0
    }
  }
}, eventAliasMap = {
  doubleClick: "dblClick"
};
function fireEvent(element, event) {
  return getConfig2().eventWrapper(() => {
    if (!event)
      throw new Error("Unable to fire an event - please provide an event object.");
    if (!element)
      throw new Error('Unable to fire a "' + event.type + '" event - please provide a DOM element.');
    return element.dispatchEvent(event);
  });
}
function createEvent(eventName, node, init2, _temp) {
  let {
    EventType = "Event",
    defaultInit = {}
  } = _temp === void 0 ? {} : _temp;
  if (!node)
    throw new Error('Unable to fire a "' + eventName + '" event - please provide a DOM element.');
  let eventInit = {
    ...defaultInit,
    ...init2
  }, {
    target: {
      value,
      files,
      ...targetProperties
    } = {}
  } = eventInit;
  value !== void 0 && setNativeValue(node, value), files !== void 0 && Object.defineProperty(node, "files", {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    value: files
  }), Object.assign(node, targetProperties);
  let window2 = getWindowFromNode(node), EventConstructor = window2[EventType] || window2.Event, event;
  if (typeof EventConstructor == "function")
    event = new EventConstructor(eventName, eventInit);
  else {
    event = window2.document.createEvent(EventType);
    let {
      bubbles,
      cancelable,
      detail,
      ...otherInit
    } = eventInit;
    event.initEvent(eventName, bubbles, cancelable, detail), Object.keys(otherInit).forEach((eventKey) => {
      event[eventKey] = otherInit[eventKey];
    });
  }
  return ["dataTransfer", "clipboardData"].forEach((dataTransferKey) => {
    let dataTransferValue = eventInit[dataTransferKey];
    typeof dataTransferValue == "object" && (typeof window2.DataTransfer == "function" ? Object.defineProperty(event, dataTransferKey, {
      value: Object.getOwnPropertyNames(dataTransferValue).reduce((acc, propName) => (Object.defineProperty(acc, propName, {
        value: dataTransferValue[propName]
      }), acc), new window2.DataTransfer())
    }) : Object.defineProperty(event, dataTransferKey, {
      value: dataTransferValue
    }));
  }), event;
}
Object.keys(eventMap).forEach((key) => {
  let {
    EventType,
    defaultInit
  } = eventMap[key], eventName = key.toLowerCase();
  createEvent[key] = (node, init2) => createEvent(eventName, node, init2, {
    EventType,
    defaultInit
  }), fireEvent[key] = (node, init2) => fireEvent(node, createEvent[key](node, init2));
});
function setNativeValue(element, value) {
  let {
    set: valueSetter
  } = Object.getOwnPropertyDescriptor(element, "value") || {}, prototype = Object.getPrototypeOf(element), {
    set: prototypeValueSetter
  } = Object.getOwnPropertyDescriptor(prototype, "value") || {};
  if (prototypeValueSetter && valueSetter !== prototypeValueSetter)
    prototypeValueSetter.call(element, value);
  else if (valueSetter)
    valueSetter.call(element, value);
  else
    throw new Error("The given element does not have a value setter");
}
Object.keys(eventAliasMap).forEach((aliasKey) => {
  let key = eventAliasMap[aliasKey];
  fireEvent[aliasKey] = function() {
    return fireEvent[key](...arguments);
  };
});
function unindent(string) {
  return string.replace(/[ \t]*[\n][ \t]*/g, `
`);
}
function encode(value) {
  return import_lz_string.default.compressToEncodedURIComponent(unindent(value));
}
function getPlaygroundUrl(markup) {
  return "https://testing-playground.com/#markup=" + encode(markup);
}
var debug = (element, maxLength, options) => Array.isArray(element) ? element.forEach((el) => logDOM(el, maxLength, options)) : logDOM(element, maxLength, options), logTestingPlaygroundURL = function(element) {
  if (element === void 0 && (element = getDocument().body), !element || !("innerHTML" in element)) {
    console.log("The element you're providing isn't a valid DOM element.");
    return;
  }
  if (!element.innerHTML) {
    console.log("The provided element doesn't have any children.");
    return;
  }
  let playgroundUrl = getPlaygroundUrl(element.innerHTML);
  return console.log(`Open this URL in your browser

` + playgroundUrl), playgroundUrl;
}, initialValue = {
  debug,
  logTestingPlaygroundURL
}, screen = typeof document < "u" && document.body ? getQueriesForElement(document.body, queries, initialValue) : Object.keys(queries).reduce((helpers, key) => (helpers[key] = () => {
  throw new TypeError("For queries bound to document.body a global document has to be available... Learn more: https://testing-library.com/s/screen-global-error");
}, helpers), initialValue);

// ../node_modules/@testing-library/user-event/dist/esm/utils/misc/isElementType.js
function isElementType(element, tag, props) {
  return element.namespaceURI && element.namespaceURI !== "http://www.w3.org/1999/xhtml" || (tag = Array.isArray(tag) ? tag : [
    tag
  ], !tag.includes(element.tagName.toLowerCase())) ? !1 : props ? Object.entries(props).every(([k2, v2]) => element[k2] === v2) : !0;
}

// ../node_modules/@testing-library/user-event/dist/esm/utils/misc/getWindow.js
function getWindow(node) {
  var _node_ownerDocument;
  if (isDocument(node) && node.defaultView)
    return node.defaultView;
  if (!((_node_ownerDocument = node.ownerDocument) === null || _node_ownerDocument === void 0) && _node_ownerDocument.defaultView)
    return node.ownerDocument.defaultView;
  throw new Error(`Could not determine window of node. Node was ${describe(node)}`);
}
function isDocument(node) {
  return node.nodeType === 9;
}
function describe(val) {
  return typeof val == "function" ? `function ${val.name}` : val === null ? "null" : String(val);
}

// ../node_modules/@testing-library/user-event/dist/esm/utils/dataTransfer/Blob.js
function readBlobText(blob, FileReader) {
  return new Promise((res, rej) => {
    let fr = new FileReader();
    fr.onerror = rej, fr.onabort = rej, fr.onload = () => {
      res(String(fr.result));
    }, fr.readAsText(blob);
  });
}

// ../node_modules/@testing-library/user-event/dist/esm/utils/dataTransfer/FileList.js
function createFileList(window2, files) {
  let list = {
    ...files,
    length: files.length,
    item: (index2) => list[index2],
    [Symbol.iterator]: function* () {
      for (let i2 = 0; i2 < list.length; i2++)
        yield list[i2];
    }
  };
  return list.constructor = window2.FileList, window2.FileList && Object.setPrototypeOf(list, window2.FileList.prototype), Object.freeze(list), list;
}

// ../node_modules/@testing-library/user-event/dist/esm/utils/dataTransfer/DataTransfer.js
function _define_property(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}
var DataTransferItemStub = class {
  getAsFile() {
    return this.file;
  }
  getAsString(callback) {
    typeof this.data == "string" && callback(this.data);
  }
  /* istanbul ignore next */
  webkitGetAsEntry() {
    throw new Error("not implemented");
  }
  constructor(dataOrFile, type5) {
    _define_property(this, "kind", void 0), _define_property(this, "type", void 0), _define_property(this, "file", null), _define_property(this, "data", void 0), typeof dataOrFile == "string" ? (this.kind = "string", this.type = String(type5), this.data = dataOrFile) : (this.kind = "file", this.type = dataOrFile.type, this.file = dataOrFile);
  }
}, DataTransferItemListStub = class extends Array {
  add(...args) {
    let item = new DataTransferItemStub(args[0], args[1]);
    return this.push(item), item;
  }
  clear() {
    this.splice(0, this.length);
  }
  remove(index2) {
    this.splice(index2, 1);
  }
};
function getTypeMatcher(type5, exact) {
  let [group, sub] = type5.split("/"), isGroup = !sub || sub === "*";
  return (item) => exact ? item.type === (isGroup ? group : type5) : isGroup ? item.type.startsWith(`${group}/`) : item.type === group;
}
function createDataTransferStub(window2) {
  return new class {
    getData(format4) {
      var _this_items_find;
      let match = (_this_items_find = this.items.find(getTypeMatcher(format4, !0))) !== null && _this_items_find !== void 0 ? _this_items_find : this.items.find(getTypeMatcher(format4, !1)), text = "";
      return match?.getAsString((t2) => {
        text = t2;
      }), text;
    }
    setData(format4, data) {
      let matchIndex = this.items.findIndex(getTypeMatcher(format4, !0)), item = new DataTransferItemStub(data, format4);
      matchIndex >= 0 ? this.items.splice(matchIndex, 1, item) : this.items.push(item);
    }
    clearData(format4) {
      if (format4) {
        let matchIndex = this.items.findIndex(getTypeMatcher(format4, !0));
        matchIndex >= 0 && this.items.remove(matchIndex);
      } else
        this.items.clear();
    }
    get types() {
      let t2 = [];
      return this.files.length && t2.push("Files"), this.items.forEach((i2) => t2.push(i2.type)), Object.freeze(t2), t2;
    }
    /* istanbul ignore next */
    setDragImage() {
    }
    constructor() {
      _define_property(this, "dropEffect", "none"), _define_property(this, "effectAllowed", "uninitialized"), _define_property(this, "items", new DataTransferItemListStub()), _define_property(this, "files", createFileList(window2, []));
    }
  }();
}
function createDataTransfer(window2, files = []) {
  let dt = typeof window2.DataTransfer > "u" ? createDataTransferStub(window2) : (
    /* istanbul ignore next */
    new window2.DataTransfer()
  );
  return Object.defineProperty(dt, "files", {
    get: () => createFileList(window2, files)
  }), dt;
}
async function getBlobFromDataTransferItem(window2, item) {
  return item.kind === "file" ? item.getAsFile() : new window2.Blob([
    await new Promise((r2) => item.getAsString(r2))
  ], {
    type: item.type
  });
}

// ../node_modules/@testing-library/user-event/dist/esm/utils/dataTransfer/Clipboard.js
function _define_property2(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}
function createClipboardItem(window2, ...blobs) {
  let dataMap = Object.fromEntries(blobs.map((b2) => [
    typeof b2 == "string" ? "text/plain" : b2.type,
    Promise.resolve(b2)
  ]));
  return typeof window2.ClipboardItem < "u" ? new window2.ClipboardItem(dataMap) : new class {
    get types() {
      return Array.from(Object.keys(this.data));
    }
    async getType(type5) {
      let value = await this.data[type5];
      if (!value)
        throw new Error(`${type5} is not one of the available MIME types on this item.`);
      return value instanceof window2.Blob ? value : new window2.Blob([
        value
      ], {
        type: type5
      });
    }
    constructor(d) {
      _define_property2(this, "data", void 0), this.data = d;
    }
  }(dataMap);
}
var ClipboardStubControl = Symbol("Manage ClipboardSub");
function createClipboardStub(window2, control) {
  return Object.assign(new class extends window2.EventTarget {
    async read() {
      return Array.from(this.items);
    }
    async readText() {
      let text = "";
      for (let item of this.items) {
        let type5 = item.types.includes("text/plain") ? "text/plain" : item.types.find((t2) => t2.startsWith("text/"));
        type5 && (text += await item.getType(type5).then((b2) => readBlobText(b2, window2.FileReader)));
      }
      return text;
    }
    async write(data) {
      this.items = data;
    }
    async writeText(text) {
      this.items = [
        createClipboardItem(window2, text)
      ];
    }
    constructor(...args) {
      super(...args), _define_property2(this, "items", []);
    }
  }(), {
    [ClipboardStubControl]: control
  });
}
function isClipboardStub(clipboard) {
  return !!clipboard?.[ClipboardStubControl];
}
function attachClipboardStubToView(window2) {
  if (isClipboardStub(window2.navigator.clipboard))
    return window2.navigator.clipboard[ClipboardStubControl];
  let realClipboard = Object.getOwnPropertyDescriptor(window2.navigator, "clipboard"), stub, control = {
    resetClipboardStub: () => {
      stub = createClipboardStub(window2, control);
    },
    detachClipboardStub: () => {
      realClipboard ? Object.defineProperty(window2.navigator, "clipboard", realClipboard) : Object.defineProperty(window2.navigator, "clipboard", {
        value: void 0,
        configurable: !0
      });
    }
  };
  return stub = createClipboardStub(window2, control), Object.defineProperty(window2.navigator, "clipboard", {
    get: () => stub,
    configurable: !0
  }), stub[ClipboardStubControl];
}
function resetClipboardStubOnView(window2) {
  isClipboardStub(window2.navigator.clipboard) && window2.navigator.clipboard[ClipboardStubControl].resetClipboardStub();
}
function detachClipboardStubFromView(window2) {
  isClipboardStub(window2.navigator.clipboard) && window2.navigator.clipboard[ClipboardStubControl].detachClipboardStub();
}
async function readDataTransferFromClipboard(document7) {
  let window2 = document7.defaultView, clipboard = window2?.navigator.clipboard, items = clipboard && await clipboard.read();
  if (!items)
    throw new Error("The Clipboard API is unavailable.");
  let dt = createDataTransfer(window2);
  for (let item of items)
    for (let type5 of item.types)
      dt.setData(type5, await item.getType(type5).then((b2) => readBlobText(b2, window2.FileReader)));
  return dt;
}
async function writeDataTransferToClipboard(document7, clipboardData) {
  let window2 = getWindow(document7), clipboard = window2.navigator.clipboard, items = [];
  for (let i2 = 0; i2 < clipboardData.items.length; i2++) {
    let dtItem = clipboardData.items[i2], blob = await getBlobFromDataTransferItem(window2, dtItem);
    items.push(createClipboardItem(window2, blob));
  }
  if (!(clipboard && await clipboard.write(items).then(
    () => !0,
    // Can happen with other implementations that e.g. require permissions
    /* istanbul ignore next */
    () => !1
  )))
    throw new Error("The Clipboard API is unavailable.");
}
var g = globalThis;
typeof g.afterEach == "function" && g.afterEach(() => {
  typeof globalThis.window < "u" && resetClipboardStubOnView(globalThis.window);
});
typeof g.afterAll == "function" && g.afterAll(() => {
  typeof globalThis.window < "u" && detachClipboardStubFromView(globalThis.window);
});

// ../node_modules/@testing-library/user-event/dist/esm/utils/focus/selector.js
var FOCUSABLE_SELECTOR = [
  "input:not([type=hidden]):not([disabled])",
  "button:not([disabled])",
  "select:not([disabled])",
  "textarea:not([disabled])",
  '[contenteditable=""]',
  '[contenteditable="true"]',
  "a[href]",
  "[tabindex]:not([disabled])"
].join(", ");

// ../node_modules/@testing-library/user-event/dist/esm/utils/focus/isFocusable.js
function isFocusable(element) {
  return element.matches(FOCUSABLE_SELECTOR);
}

// ../node_modules/@testing-library/user-event/dist/esm/utils/misc/cloneEvent.js
function cloneEvent(event) {
  return new event.constructor(event.type, event);
}

// ../node_modules/@testing-library/user-event/dist/esm/utils/misc/isDisabled.js
function isDisabled2(element) {
  for (let el = element; el; el = el.parentElement)
    if (isElementType(el, [
      "button",
      "input",
      "select",
      "textarea",
      "optgroup",
      "option"
    ])) {
      if (el.hasAttribute("disabled"))
        return !0;
    } else if (isElementType(el, "fieldset")) {
      var _el_querySelector;
      if (el.hasAttribute("disabled") && !(!((_el_querySelector = el.querySelector(":scope > legend")) === null || _el_querySelector === void 0) && _el_querySelector.contains(element)))
        return !0;
    } else if (el.tagName.includes("-") && el.constructor.formAssociated && el.hasAttribute("disabled"))
      return !0;
  return !1;
}

// ../node_modules/@testing-library/user-event/dist/esm/utils/focus/getActiveElement.js
function getActiveElement(document7) {
  let activeElement = document7.activeElement;
  return activeElement?.shadowRoot ? getActiveElement(activeElement.shadowRoot) : isDisabled2(activeElement) ? document7.ownerDocument ? (
    /* istanbul ignore next */
    document7.ownerDocument.body
  ) : document7.body : activeElement;
}
function getActiveElementOrBody(document7) {
  var _getActiveElement;
  return (_getActiveElement = getActiveElement(document7)) !== null && _getActiveElement !== void 0 ? _getActiveElement : (
    /* istanbul ignore next */
    document7.body
  );
}

// ../node_modules/@testing-library/user-event/dist/esm/utils/misc/findClosest.js
function findClosest(element, callback) {
  let el = element;
  do {
    if (callback(el))
      return el;
    el = el.parentElement;
  } while (el && el !== element.ownerDocument.body);
}

// ../node_modules/@testing-library/user-event/dist/esm/utils/edit/isContentEditable.js
function isContentEditable(element) {
  return element.hasAttribute("contenteditable") && (element.getAttribute("contenteditable") == "true" || element.getAttribute("contenteditable") == "");
}
function getContentEditable(node) {
  let element = getElement(node);
  return element && (element.closest('[contenteditable=""]') || element.closest('[contenteditable="true"]'));
}
function getElement(node) {
  return node.nodeType === 1 ? node : node.parentElement;
}

// ../node_modules/@testing-library/user-event/dist/esm/utils/click/isClickableInput.js
var clickableInputTypes = (function(clickableInputTypes2) {
  return clickableInputTypes2.button = "button", clickableInputTypes2.color = "color", clickableInputTypes2.file = "file", clickableInputTypes2.image = "image", clickableInputTypes2.reset = "reset", clickableInputTypes2.submit = "submit", clickableInputTypes2.checkbox = "checkbox", clickableInputTypes2.radio = "radio", clickableInputTypes2;
})(clickableInputTypes || {});
function isClickableInput(element) {
  return isElementType(element, "button") || isElementType(element, "input") && element.type in clickableInputTypes;
}

// ../node_modules/@testing-library/user-event/dist/esm/utils/edit/isEditable.js
function isEditable(element) {
  return isEditableInputOrTextArea(element) && !element.readOnly || isContentEditable(element);
}
var editableInputTypes = (function(editableInputTypes2) {
  return editableInputTypes2.text = "text", editableInputTypes2.date = "date", editableInputTypes2["datetime-local"] = "datetime-local", editableInputTypes2.email = "email", editableInputTypes2.month = "month", editableInputTypes2.number = "number", editableInputTypes2.password = "password", editableInputTypes2.search = "search", editableInputTypes2.tel = "tel", editableInputTypes2.time = "time", editableInputTypes2.url = "url", editableInputTypes2.week = "week", editableInputTypes2;
})(editableInputTypes || {});
function isEditableInputOrTextArea(element) {
  return isElementType(element, "textarea") || isElementType(element, "input") && element.type in editableInputTypes;
}

// ../node_modules/@testing-library/user-event/dist/esm/utils/focus/selection.js
function hasOwnSelection(node) {
  return isElement3(node) && isEditableInputOrTextArea(node);
}
function hasNoSelection(node) {
  return isElement3(node) && isClickableInput(node);
}
function isElement3(node) {
  return node.nodeType === 1;
}

// ../node_modules/@testing-library/user-event/dist/esm/event/selection/updateSelectionOnFocus.js
function updateSelectionOnFocus(element) {
  let selection = element.ownerDocument.getSelection();
  if (selection?.focusNode && hasOwnSelection(element)) {
    let contenteditable = getContentEditable(selection.focusNode);
    if (contenteditable) {
      if (!selection.isCollapsed) {
        var _contenteditable_firstChild;
        let focusNode = ((_contenteditable_firstChild = contenteditable.firstChild) === null || _contenteditable_firstChild === void 0 ? void 0 : _contenteditable_firstChild.nodeType) === 3 ? contenteditable.firstChild : contenteditable;
        selection.setBaseAndExtent(focusNode, 0, focusNode, 0);
      }
    } else
      selection.setBaseAndExtent(element, 0, element, 0);
  }
}

// ../node_modules/@testing-library/user-event/dist/esm/event/wrapEvent.js
function wrapEvent(cb, _element) {
  return getConfig2().eventWrapper(cb);
}

// ../node_modules/@testing-library/user-event/dist/esm/event/focus.js
function focusElement(element) {
  let target = findClosest(element, isFocusable), activeElement = getActiveElement(element.ownerDocument);
  (target ?? element.ownerDocument.body) !== activeElement && (target ? wrapEvent(() => target.focus()) : wrapEvent(() => activeElement?.blur()), updateSelectionOnFocus(target ?? element.ownerDocument.body));
}
function blurElement(element) {
  !isFocusable(element) || !(getActiveElement(element.ownerDocument) === element) || wrapEvent(() => element.blur());
}

// ../node_modules/@testing-library/user-event/dist/esm/event/behavior/registry.js
var behavior = {};

// ../node_modules/@testing-library/user-event/dist/esm/event/behavior/click.js
behavior.click = (event, target, instance) => {
  let context = target.closest("button,input,label,select,textarea"), control = context && isElementType(context, "label") && context.control;
  if (control && control !== target)
    return () => {
      isFocusable(control) && (focusElement(control), instance.dispatchEvent(control, cloneEvent(event)));
    };
  if (isElementType(target, "input", {
    type: "file"
  }))
    return () => {
      blurElement(target), target.dispatchEvent(new (getWindow(target)).Event("fileDialog")), focusElement(target);
    };
};

// ../node_modules/@testing-library/user-event/dist/esm/document/UI.js
var UIValue = Symbol("Displayed value in UI"), UISelection = Symbol("Displayed selection in UI"), InitialValue = Symbol("Initial value to compare on blur");
function isUIValue(value) {
  return typeof value == "object" && UIValue in value;
}
function isUISelectionStart(start) {
  return !!start && typeof start == "object" && UISelection in start;
}
function setUIValue(element, value) {
  element[InitialValue] === void 0 && (element[InitialValue] = element.value), element[UIValue] = value, element.value = Object.assign(new String(value), {
    [UIValue]: !0
  });
}
function getUIValue(element) {
  return element[UIValue] === void 0 ? element.value : String(element[UIValue]);
}
function setUIValueClean(element) {
  element[UIValue] = void 0;
}
function clearInitialValue(element) {
  element[InitialValue] = void 0;
}
function getInitialValue(element) {
  return element[InitialValue];
}
function setUISelectionRaw(element, selection) {
  element[UISelection] = selection;
}
function setUISelection(element, { focusOffset: focusOffsetParam, anchorOffset: anchorOffsetParam = focusOffsetParam }, mode = "replace") {
  let valueLength = getUIValue(element).length, sanitizeOffset = (o2) => Math.max(0, Math.min(valueLength, o2)), anchorOffset = mode === "replace" || element[UISelection] === void 0 ? sanitizeOffset(anchorOffsetParam) : element[UISelection].anchorOffset, focusOffset = sanitizeOffset(focusOffsetParam), startOffset = Math.min(anchorOffset, focusOffset), endOffset = Math.max(anchorOffset, focusOffset);
  if (element[UISelection] = {
    anchorOffset,
    focusOffset
  }, element.selectionStart === startOffset && element.selectionEnd === endOffset)
    return;
  let startObj = Object.assign(new Number(startOffset), {
    [UISelection]: !0
  });
  try {
    element.setSelectionRange(startObj, endOffset);
  } catch {
  }
}
function getUISelection(element) {
  var _element_selectionStart, _element_selectionEnd, _element_UISelection;
  let sel = (_element_UISelection = element[UISelection]) !== null && _element_UISelection !== void 0 ? _element_UISelection : {
    anchorOffset: (_element_selectionStart = element.selectionStart) !== null && _element_selectionStart !== void 0 ? _element_selectionStart : 0,
    focusOffset: (_element_selectionEnd = element.selectionEnd) !== null && _element_selectionEnd !== void 0 ? _element_selectionEnd : 0
  };
  return {
    ...sel,
    startOffset: Math.min(sel.anchorOffset, sel.focusOffset),
    endOffset: Math.max(sel.anchorOffset, sel.focusOffset)
  };
}
function hasUISelection(element) {
  return !!element[UISelection];
}
function setUISelectionClean(element) {
  element[UISelection] = void 0;
}

// ../node_modules/@testing-library/user-event/dist/esm/utils/edit/timeValue.js
var parseInt2 = globalThis.parseInt;
function buildTimeValue(value) {
  let onlyDigitsValue = value.replace(/\D/g, "");
  if (onlyDigitsValue.length < 2)
    return value;
  let firstDigit = parseInt2(onlyDigitsValue[0], 10), secondDigit = parseInt2(onlyDigitsValue[1], 10);
  if (firstDigit >= 3 || firstDigit === 2 && secondDigit >= 4) {
    let index2;
    return firstDigit >= 3 ? index2 = 1 : index2 = 2, build2(onlyDigitsValue, index2);
  }
  return value.length === 2 ? value : build2(onlyDigitsValue, 2);
}
function build2(onlyDigitsValue, index2) {
  let hours = onlyDigitsValue.slice(0, index2), validHours = Math.min(parseInt2(hours, 10), 23), minuteCharacters = onlyDigitsValue.slice(index2), parsedMinutes = parseInt2(minuteCharacters, 10), validMinutes = Math.min(parsedMinutes, 59);
  return `${validHours.toString().padStart(2, "0")}:${validMinutes.toString().padStart(2, "0")}`;
}
function isValidDateOrTimeValue(element, value) {
  let clone3 = element.cloneNode();
  return clone3.value = value, clone3.value === value;
}

// ../node_modules/@testing-library/user-event/dist/esm/utils/edit/maxLength.js
var maxLengthSupportedTypes = (function(maxLengthSupportedTypes2) {
  return maxLengthSupportedTypes2.email = "email", maxLengthSupportedTypes2.password = "password", maxLengthSupportedTypes2.search = "search", maxLengthSupportedTypes2.telephone = "telephone", maxLengthSupportedTypes2.text = "text", maxLengthSupportedTypes2.url = "url", maxLengthSupportedTypes2;
})(maxLengthSupportedTypes || {});
function getMaxLength(element) {
  var _element_getAttribute;
  let attr = (_element_getAttribute = element.getAttribute("maxlength")) !== null && _element_getAttribute !== void 0 ? _element_getAttribute : "";
  return /^\d+$/.test(attr) && Number(attr) >= 0 ? Number(attr) : void 0;
}
function supportsMaxLength(element) {
  return isElementType(element, "textarea") || isElementType(element, "input") && element.type in maxLengthSupportedTypes;
}

// ../node_modules/@testing-library/user-event/dist/esm/utils/focus/cursor.js
function getNextCursorPosition(node, offset2, direction, inputType) {
  if (isTextNode(node) && offset2 + direction >= 0 && offset2 + direction <= node.nodeValue.length)
    return {
      node,
      offset: offset2 + direction
    };
  let nextNode = getNextCharacterContentNode(node, offset2, direction);
  if (nextNode) {
    if (isTextNode(nextNode))
      return {
        node: nextNode,
        offset: direction > 0 ? Math.min(1, nextNode.nodeValue.length) : Math.max(nextNode.nodeValue.length - 1, 0)
      };
    if (isElementType(nextNode, "br")) {
      let nextPlusOne = getNextCharacterContentNode(nextNode, void 0, direction);
      return nextPlusOne ? isTextNode(nextPlusOne) ? {
        node: nextPlusOne,
        offset: direction > 0 ? 0 : nextPlusOne.nodeValue.length
      } : direction < 0 && isElementType(nextPlusOne, "br") ? {
        node: nextNode.parentNode,
        offset: getOffset(nextNode)
      } : {
        node: nextPlusOne.parentNode,
        offset: getOffset(nextPlusOne) + (direction > 0 ? 0 : 1)
      } : direction < 0 && inputType === "deleteContentBackward" ? {
        node: nextNode.parentNode,
        offset: getOffset(nextNode)
      } : void 0;
    } else
      return {
        node: nextNode.parentNode,
        offset: getOffset(nextNode) + (direction > 0 ? 1 : 0)
      };
  }
}
function getNextCharacterContentNode(node, offset2, direction) {
  let nextOffset = Number(offset2) + (direction < 0 ? -1 : 0);
  return offset2 !== void 0 && isElement4(node) && nextOffset >= 0 && nextOffset < node.children.length && (node = node.children[nextOffset]), walkNodes(node, direction === 1 ? "next" : "previous", isTreatedAsCharacterContent);
}
function isTreatedAsCharacterContent(node) {
  if (isTextNode(node))
    return !0;
  if (isElement4(node)) {
    if (isElementType(node, [
      "input",
      "textarea"
    ]))
      return node.type !== "hidden";
    if (isElementType(node, "br"))
      return !0;
  }
  return !1;
}
function getOffset(node) {
  let i2 = 0;
  for (; node.previousSibling; )
    i2++, node = node.previousSibling;
  return i2;
}
function isElement4(node) {
  return node.nodeType === 1;
}
function isTextNode(node) {
  return node.nodeType === 3;
}
function walkNodes(node, direction, callback) {
  for (; ; ) {
    var _node_ownerDocument;
    let sibling = node[`${direction}Sibling`];
    if (sibling) {
      if (node = getDescendant(sibling, direction === "next" ? "first" : "last"), callback(node))
        return node;
    } else if (node.parentNode && (!isElement4(node.parentNode) || !isContentEditable(node.parentNode) && node.parentNode !== ((_node_ownerDocument = node.ownerDocument) === null || _node_ownerDocument === void 0 ? void 0 : _node_ownerDocument.body)))
      node = node.parentNode;
    else
      break;
  }
}
function getDescendant(node, direction) {
  for (; node.hasChildNodes(); )
    node = node[`${direction}Child`];
  return node;
}

// ../node_modules/@testing-library/user-event/dist/esm/document/trackValue.js
var TrackChanges = Symbol("Track programmatic changes for React workaround");
function isReact17Element(element) {
  return Object.getOwnPropertyNames(element).some((k2) => k2.startsWith("__react")) && getWindow(element).REACT_VERSION === 17;
}
function startTrackValue(element) {
  isReact17Element(element) && (element[TrackChanges] = {
    previousValue: String(element.value),
    tracked: []
  });
}
function trackOrSetValue(element, v2) {
  var _element_TrackChanges_tracked, _element_TrackChanges;
  (_element_TrackChanges = element[TrackChanges]) === null || _element_TrackChanges === void 0 || (_element_TrackChanges_tracked = _element_TrackChanges.tracked) === null || _element_TrackChanges_tracked === void 0 || _element_TrackChanges_tracked.push(v2), element[TrackChanges] || (setUIValueClean(element), setUISelection(element, {
    focusOffset: v2.length
  }));
}
function commitValueAfterInput(element, cursorOffset) {
  var _changes_tracked;
  let changes = element[TrackChanges];
  if (element[TrackChanges] = void 0, !(!(changes == null || (_changes_tracked = changes.tracked) === null || _changes_tracked === void 0) && _changes_tracked.length))
    return;
  let isJustReactStateUpdate = changes.tracked.length === 2 && changes.tracked[0] === changes.previousValue && changes.tracked[1] === element.value;
  isJustReactStateUpdate || setUIValueClean(element), hasUISelection(element) && setUISelection(element, {
    focusOffset: isJustReactStateUpdate ? cursorOffset : element.value.length
  });
}

// ../node_modules/@testing-library/user-event/dist/esm/event/selection/getTargetTypeAndSelection.js
function getTargetTypeAndSelection(node) {
  let element = getElement2(node);
  if (element && hasOwnSelection(element))
    return {
      type: "input",
      selection: getUISelection(element)
    };
  let selection = element?.ownerDocument.getSelection();
  return {
    type: getContentEditable(node) && selection?.anchorNode && getContentEditable(selection.anchorNode) ? "contenteditable" : "default",
    selection
  };
}
function getElement2(node) {
  return node.nodeType === 1 ? node : node.parentElement;
}

// ../node_modules/@testing-library/user-event/dist/esm/event/selection/getInputRange.js
function getInputRange(focusNode) {
  let typeAndSelection = getTargetTypeAndSelection(focusNode);
  if (typeAndSelection.type === "input")
    return typeAndSelection.selection;
  if (typeAndSelection.type === "contenteditable") {
    var _typeAndSelection_selection;
    return (_typeAndSelection_selection = typeAndSelection.selection) === null || _typeAndSelection_selection === void 0 ? void 0 : _typeAndSelection_selection.getRangeAt(0);
  }
}

// ../node_modules/@testing-library/user-event/dist/esm/event/selection/setSelection.js
function setSelection({ focusNode, focusOffset, anchorNode = focusNode, anchorOffset = focusOffset }) {
  var _anchorNode_ownerDocument_getSelection, _anchorNode_ownerDocument;
  if (getTargetTypeAndSelection(focusNode).type === "input")
    return setUISelection(focusNode, {
      anchorOffset,
      focusOffset
    });
  (_anchorNode_ownerDocument = anchorNode.ownerDocument) === null || _anchorNode_ownerDocument === void 0 || (_anchorNode_ownerDocument_getSelection = _anchorNode_ownerDocument.getSelection()) === null || _anchorNode_ownerDocument_getSelection === void 0 || _anchorNode_ownerDocument_getSelection.setBaseAndExtent(anchorNode, anchorOffset, focusNode, focusOffset);
}

// ../node_modules/@testing-library/user-event/dist/esm/event/input.js
function isDateOrTime(element) {
  return isElementType(element, "input") && [
    "date",
    "time"
  ].includes(element.type);
}
function input(instance, element, data, inputType = "insertText") {
  let inputRange = getInputRange(element);
  inputRange && (!isDateOrTime(element) && !instance.dispatchUIEvent(element, "beforeinput", {
    inputType,
    data
  }) || ("startContainer" in inputRange ? editContenteditable(instance, element, inputRange, data, inputType) : editInputElement(instance, element, inputRange, data, inputType)));
}
function editContenteditable(instance, element, inputRange, data, inputType) {
  let del = !1;
  if (!inputRange.collapsed)
    del = !0, inputRange.deleteContents();
  else if ([
    "deleteContentBackward",
    "deleteContentForward"
  ].includes(inputType)) {
    let nextPosition = getNextCursorPosition(inputRange.startContainer, inputRange.startOffset, inputType === "deleteContentBackward" ? -1 : 1, inputType);
    if (nextPosition) {
      del = !0;
      let delRange = inputRange.cloneRange();
      delRange.comparePoint(nextPosition.node, nextPosition.offset) < 0 ? delRange.setStart(nextPosition.node, nextPosition.offset) : delRange.setEnd(nextPosition.node, nextPosition.offset), delRange.deleteContents();
    }
  }
  if (data)
    if (inputRange.endContainer.nodeType === 3) {
      let offset2 = inputRange.endOffset;
      inputRange.endContainer.insertData(offset2, data), inputRange.setStart(inputRange.endContainer, offset2 + data.length), inputRange.setEnd(inputRange.endContainer, offset2 + data.length);
    } else {
      let text = element.ownerDocument.createTextNode(data);
      inputRange.insertNode(text), inputRange.setStart(text, data.length), inputRange.setEnd(text, data.length);
    }
  (del || data) && instance.dispatchUIEvent(element, "input", {
    inputType
  });
}
function editInputElement(instance, element, inputRange, data, inputType) {
  let dataToInsert = data;
  if (supportsMaxLength(element)) {
    let maxLength = getMaxLength(element);
    if (maxLength !== void 0 && data.length > 0) {
      let spaceUntilMaxLength = maxLength - element.value.length;
      if (spaceUntilMaxLength > 0)
        dataToInsert = data.substring(0, spaceUntilMaxLength);
      else
        return;
    }
  }
  let { newValue, newOffset, oldValue } = calculateNewValue(dataToInsert, element, inputRange, inputType);
  newValue === oldValue && newOffset === inputRange.startOffset && newOffset === inputRange.endOffset || isElementType(element, "input", {
    type: "number"
  }) && !isValidNumberInput(newValue) || (setUIValue(element, newValue), setSelection({
    focusNode: element,
    anchorOffset: newOffset,
    focusOffset: newOffset
  }), isDateOrTime(element) ? isValidDateOrTimeValue(element, newValue) && (commitInput(instance, element, newOffset, {}), instance.dispatchUIEvent(element, "change"), clearInitialValue(element)) : commitInput(instance, element, newOffset, {
    data,
    inputType
  }));
}
function calculateNewValue(inputData, node, { startOffset, endOffset }, inputType) {
  let value = getUIValue(node), prologEnd = Math.max(0, startOffset === endOffset && inputType === "deleteContentBackward" ? startOffset - 1 : startOffset), prolog = value.substring(0, prologEnd), epilogStart = Math.min(value.length, startOffset === endOffset && inputType === "deleteContentForward" ? startOffset + 1 : endOffset), epilog = value.substring(epilogStart, value.length), newValue = `${prolog}${inputData}${epilog}`, newOffset = prologEnd + inputData.length;
  if (isElementType(node, "input", {
    type: "time"
  })) {
    let builtValue = buildTimeValue(newValue);
    builtValue !== "" && isValidDateOrTimeValue(node, builtValue) && (newValue = builtValue, newOffset = builtValue.length);
  }
  return {
    oldValue: value,
    newValue,
    newOffset
  };
}
function commitInput(instance, element, newOffset, inputInit) {
  instance.dispatchUIEvent(element, "input", inputInit), commitValueAfterInput(element, newOffset);
}
function isValidNumberInput(value) {
  var _value_match, _value_match1;
  let valueParts = value.split("e", 2);
  return !(/[^\d.\-e]/.test(value) || Number((_value_match = value.match(/-/g)) === null || _value_match === void 0 ? void 0 : _value_match.length) > 2 || Number((_value_match1 = value.match(/\./g)) === null || _value_match1 === void 0 ? void 0 : _value_match1.length) > 1 || valueParts[1] && !/^-?\d*$/.test(valueParts[1]));
}

// ../node_modules/@testing-library/user-event/dist/esm/event/behavior/cut.js
behavior.cut = (event, target, instance) => () => {
  isEditable(target) && input(instance, target, "", "deleteByCut");
};

// ../node_modules/@testing-library/user-event/dist/esm/document/getValueOrTextContent.js
function getValueOrTextContent(element) {
  return element ? isContentEditable(element) ? element.textContent : getUIValue(element) : null;
}

// ../node_modules/@testing-library/user-event/dist/esm/utils/misc/isVisible.js
function isVisible(element) {
  let window2 = getWindow(element);
  for (let el = element; el?.ownerDocument; el = el.parentElement) {
    let { display: display2, visibility } = window2.getComputedStyle(el);
    if (display2 === "none" || visibility === "hidden")
      return !1;
  }
  return !0;
}

// ../node_modules/@testing-library/user-event/dist/esm/utils/focus/getTabDestination.js
function getTabDestination(activeElement, shift) {
  let document7 = activeElement.ownerDocument, focusableElements = document7.querySelectorAll(FOCUSABLE_SELECTOR), enabledElements = Array.from(focusableElements).filter((el) => el === activeElement || !(Number(el.getAttribute("tabindex")) < 0 || isDisabled2(el)));
  Number(activeElement.getAttribute("tabindex")) >= 0 && enabledElements.sort((a2, b2) => {
    let i2 = Number(a2.getAttribute("tabindex")), j2 = Number(b2.getAttribute("tabindex"));
    return i2 === j2 ? 0 : i2 === 0 ? 1 : j2 === 0 ? -1 : i2 - j2;
  });
  let checkedRadio = {}, prunedElements = [
    document7.body
  ], activeRadioGroup = isElementType(activeElement, "input", {
    type: "radio"
  }) ? activeElement.name : void 0;
  enabledElements.forEach((currentElement) => {
    let el = currentElement;
    if (isElementType(el, "input", {
      type: "radio"
    }) && el.name) {
      if (el === activeElement) {
        prunedElements.push(el);
        return;
      } else if (el.name === activeRadioGroup)
        return;
      if (el.checked) {
        prunedElements = prunedElements.filter((e2) => !isElementType(e2, "input", {
          type: "radio",
          name: el.name
        })), prunedElements.push(el), checkedRadio[el.name] = el;
        return;
      }
      if (typeof checkedRadio[el.name] < "u")
        return;
    }
    prunedElements.push(el);
  });
  for (let index2 = prunedElements.findIndex((el) => el === activeElement); ; )
    if (index2 += shift ? -1 : 1, index2 === prunedElements.length ? index2 = 0 : index2 === -1 && (index2 = prunedElements.length - 1), prunedElements[index2] === activeElement || prunedElements[index2] === document7.body || isVisible(prunedElements[index2]))
      return prunedElements[index2];
}

// ../node_modules/@testing-library/user-event/dist/esm/event/selection/moveSelection.js
function moveSelection(node, direction) {
  if (hasOwnSelection(node)) {
    let selection = getUISelection(node);
    setSelection({
      focusNode: node,
      focusOffset: selection.startOffset === selection.endOffset ? selection.focusOffset + direction : direction < 0 ? selection.startOffset : selection.endOffset
    });
  } else {
    let selection = node.ownerDocument.getSelection();
    if (!selection?.focusNode)
      return;
    if (selection.isCollapsed) {
      let nextPosition = getNextCursorPosition(selection.focusNode, selection.focusOffset, direction);
      nextPosition && setSelection({
        focusNode: nextPosition.node,
        focusOffset: nextPosition.offset
      });
    } else
      selection[direction < 0 ? "collapseToStart" : "collapseToEnd"]();
  }
}

// ../node_modules/@testing-library/user-event/dist/esm/event/selection/selectAll.js
function selectAll(target) {
  if (hasOwnSelection(target))
    return setSelection({
      focusNode: target,
      anchorOffset: 0,
      focusOffset: getUIValue(target).length
    });
  var _getContentEditable;
  let focusNode = (_getContentEditable = getContentEditable(target)) !== null && _getContentEditable !== void 0 ? _getContentEditable : target.ownerDocument.body;
  setSelection({
    focusNode,
    anchorOffset: 0,
    focusOffset: focusNode.childNodes.length
  });
}
function isAllSelected(target) {
  if (hasOwnSelection(target))
    return getUISelection(target).startOffset === 0 && getUISelection(target).endOffset === getUIValue(target).length;
  var _getContentEditable;
  let focusNode = (_getContentEditable = getContentEditable(target)) !== null && _getContentEditable !== void 0 ? _getContentEditable : target.ownerDocument.body, selection = target.ownerDocument.getSelection();
  return selection?.anchorNode === focusNode && selection.focusNode === focusNode && selection.anchorOffset === 0 && selection.focusOffset === focusNode.childNodes.length;
}

// ../node_modules/@testing-library/user-event/dist/esm/event/selection/setSelectionRange.js
function setSelectionRange(element, anchorOffset, focusOffset) {
  var _element_firstChild;
  if (hasOwnSelection(element))
    return setSelection({
      focusNode: element,
      anchorOffset,
      focusOffset
    });
  if (isContentEditable(element) && ((_element_firstChild = element.firstChild) === null || _element_firstChild === void 0 ? void 0 : _element_firstChild.nodeType) === 3)
    return setSelection({
      focusNode: element.firstChild,
      anchorOffset,
      focusOffset
    });
  throw new Error("Not implemented. The result of this interaction is unreliable.");
}

// ../node_modules/@testing-library/user-event/dist/esm/event/radio.js
function walkRadio(instance, el, direction) {
  let window2 = getWindow(el), group = Array.from(el.ownerDocument.querySelectorAll(el.name ? `input[type="radio"][name="${window2.CSS.escape(el.name)}"]` : 'input[type="radio"][name=""], input[type="radio"]:not([name])'));
  for (let i2 = group.findIndex((e2) => e2 === el) + direction; ; i2 += direction) {
    if (group[i2] || (i2 = direction > 0 ? 0 : group.length - 1), group[i2] === el)
      return;
    if (!isDisabled2(group[i2])) {
      focusElement(group[i2]), instance.dispatchUIEvent(group[i2], "click");
      return;
    }
  }
}

// ../node_modules/@testing-library/user-event/dist/esm/event/behavior/keydown.js
behavior.keydown = (event, target, instance) => {
  var _keydownBehavior_event_key, _keydownBehavior_event_key1;
  return (_keydownBehavior_event_key1 = (_keydownBehavior_event_key = keydownBehavior[event.key]) === null || _keydownBehavior_event_key === void 0 ? void 0 : _keydownBehavior_event_key.call(keydownBehavior, event, target, instance)) !== null && _keydownBehavior_event_key1 !== void 0 ? _keydownBehavior_event_key1 : combinationBehavior(event, target, instance);
};
var keydownBehavior = {
  ArrowDown: (event, target, instance) => {
    if (isElementType(target, "input", {
      type: "radio"
    }))
      return () => walkRadio(instance, target, 1);
  },
  ArrowLeft: (event, target, instance) => isElementType(target, "input", {
    type: "radio"
  }) ? () => walkRadio(instance, target, -1) : () => moveSelection(target, -1),
  ArrowRight: (event, target, instance) => isElementType(target, "input", {
    type: "radio"
  }) ? () => walkRadio(instance, target, 1) : () => moveSelection(target, 1),
  ArrowUp: (event, target, instance) => {
    if (isElementType(target, "input", {
      type: "radio"
    }))
      return () => walkRadio(instance, target, -1);
  },
  Backspace: (event, target, instance) => {
    if (isEditable(target))
      return () => {
        input(instance, target, "", "deleteContentBackward");
      };
  },
  Delete: (event, target, instance) => {
    if (isEditable(target))
      return () => {
        input(instance, target, "", "deleteContentForward");
      };
  },
  End: (event, target) => {
    if (isElementType(target, [
      "input",
      "textarea"
    ]) || isContentEditable(target))
      return () => {
        var _getValueOrTextContent, _getValueOrTextContent_length;
        let newPos = (_getValueOrTextContent_length = (_getValueOrTextContent = getValueOrTextContent(target)) === null || _getValueOrTextContent === void 0 ? void 0 : _getValueOrTextContent.length) !== null && _getValueOrTextContent_length !== void 0 ? _getValueOrTextContent_length : (
          /* istanbul ignore next */
          0
        );
        setSelectionRange(target, newPos, newPos);
      };
  },
  Home: (event, target) => {
    if (isElementType(target, [
      "input",
      "textarea"
    ]) || isContentEditable(target))
      return () => {
        setSelectionRange(target, 0, 0);
      };
  },
  PageDown: (event, target) => {
    if (isElementType(target, [
      "input"
    ]))
      return () => {
        let newPos = getUIValue(target).length;
        setSelectionRange(target, newPos, newPos);
      };
  },
  PageUp: (event, target) => {
    if (isElementType(target, [
      "input"
    ]))
      return () => {
        setSelectionRange(target, 0, 0);
      };
  },
  Tab: (event, target, instance) => () => {
    let dest = getTabDestination(target, instance.system.keyboard.modifiers.Shift);
    focusElement(dest), hasOwnSelection(dest) && setUISelection(dest, {
      anchorOffset: 0,
      focusOffset: dest.value.length
    });
  }
}, combinationBehavior = (event, target, instance) => {
  if (event.code === "KeyA" && instance.system.keyboard.modifiers.Control)
    return () => selectAll(target);
};

// ../node_modules/@testing-library/user-event/dist/esm/event/behavior/keypress.js
behavior.keypress = (event, target, instance) => {
  if (event.key === "Enter") {
    if (isElementType(target, "button") || isElementType(target, "input") && ClickInputOnEnter.includes(target.type) || isElementType(target, "a") && target.href)
      return () => {
        instance.dispatchUIEvent(target, "click");
      };
    if (isElementType(target, "input")) {
      let form = target.form, submit = form?.querySelector('input[type="submit"], button:not([type]), button[type="submit"]');
      return submit ? () => instance.dispatchUIEvent(submit, "click") : form && SubmitSingleInputOnEnter.includes(target.type) && form.querySelectorAll("input").length === 1 ? () => instance.dispatchUIEvent(form, "submit") : void 0;
    }
  }
  if (isEditable(target)) {
    let inputType = event.key === "Enter" ? isContentEditable(target) && !instance.system.keyboard.modifiers.Shift ? "insertParagraph" : "insertLineBreak" : "insertText", inputData = event.key === "Enter" ? `
` : event.key;
    return () => input(instance, target, inputData, inputType);
  }
};
var ClickInputOnEnter = [
  "button",
  "color",
  "file",
  "image",
  "reset",
  "submit"
], SubmitSingleInputOnEnter = [
  "email",
  "month",
  "password",
  "search",
  "tel",
  "text",
  "url",
  "week"
];

// ../node_modules/@testing-library/user-event/dist/esm/event/behavior/keyup.js
behavior.keyup = (event, target, instance) => {
  var _keyupBehavior_event_key;
  return (_keyupBehavior_event_key = keyupBehavior[event.key]) === null || _keyupBehavior_event_key === void 0 ? void 0 : _keyupBehavior_event_key.call(keyupBehavior, event, target, instance);
};
var keyupBehavior = {
  " ": (event, target, instance) => {
    if (isClickableInput(target))
      return () => instance.dispatchUIEvent(target, "click");
  }
};

// ../node_modules/@testing-library/user-event/dist/esm/event/behavior/paste.js
behavior.paste = (event, target, instance) => {
  if (isEditable(target))
    return () => {
      var _event_clipboardData;
      let insertData = (_event_clipboardData = event.clipboardData) === null || _event_clipboardData === void 0 ? void 0 : _event_clipboardData.getData("text");
      insertData && input(instance, target, insertData, "insertFromPaste");
    };
};

// ../node_modules/@testing-library/user-event/dist/esm/event/eventMap.js
var eventMap2 = {
  auxclick: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  beforeinput: {
    EventType: "InputEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  blur: {
    EventType: "FocusEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1,
      composed: !0
    }
  },
  click: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  contextmenu: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  copy: {
    EventType: "ClipboardEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  change: {
    EventType: "Event",
    defaultInit: {
      bubbles: !0,
      cancelable: !1
    }
  },
  cut: {
    EventType: "ClipboardEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  dblclick: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  focus: {
    EventType: "FocusEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1,
      composed: !0
    }
  },
  focusin: {
    EventType: "FocusEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }
  },
  focusout: {
    EventType: "FocusEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }
  },
  keydown: {
    EventType: "KeyboardEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  keypress: {
    EventType: "KeyboardEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  keyup: {
    EventType: "KeyboardEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  paste: {
    EventType: "ClipboardEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  input: {
    EventType: "InputEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }
  },
  mousedown: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  mouseenter: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1,
      composed: !0
    }
  },
  mouseleave: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1,
      composed: !0
    }
  },
  mousemove: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  mouseout: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  mouseover: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  mouseup: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  pointerover: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  pointerenter: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  pointerdown: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  pointermove: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  pointerup: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  pointercancel: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }
  },
  pointerout: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  pointerleave: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  submit: {
    EventType: "Event",
    defaultInit: {
      bubbles: !0,
      cancelable: !0
    }
  }
};
function getEventClass(type5) {
  return eventMap2[type5].EventType;
}
var mouseEvents = [
  "MouseEvent",
  "PointerEvent"
];
function isMouseEvent(type5) {
  return mouseEvents.includes(getEventClass(type5));
}
function isKeyboardEvent(type5) {
  return getEventClass(type5) === "KeyboardEvent";
}

// ../node_modules/@testing-library/user-event/dist/esm/event/createEvent.js
var eventInitializer = {
  ClipboardEvent: [
    initClipboardEvent
  ],
  Event: [],
  FocusEvent: [
    initUIEvent,
    initFocusEvent
  ],
  InputEvent: [
    initUIEvent,
    initInputEvent
  ],
  MouseEvent: [
    initUIEvent,
    initUIEventModifiers,
    initMouseEvent
  ],
  PointerEvent: [
    initUIEvent,
    initUIEventModifiers,
    initMouseEvent,
    initPointerEvent
  ],
  KeyboardEvent: [
    initUIEvent,
    initUIEventModifiers,
    initKeyboardEvent
  ]
};
function createEvent2(type5, target, init2) {
  let window2 = getWindow(target), { EventType, defaultInit } = eventMap2[type5], event = new (getEventConstructors(window2))[EventType](type5, defaultInit);
  return eventInitializer[EventType].forEach((f4) => f4(event, init2 ?? {})), event;
}
function getEventConstructors(window2) {
  var _window_Event;
  let Event2 = (_window_Event = window2.Event) !== null && _window_Event !== void 0 ? _window_Event : class {
  };
  var _window_AnimationEvent;
  let AnimationEvent = (_window_AnimationEvent = window2.AnimationEvent) !== null && _window_AnimationEvent !== void 0 ? _window_AnimationEvent : class extends Event2 {
  };
  var _window_ClipboardEvent;
  let ClipboardEvent = (_window_ClipboardEvent = window2.ClipboardEvent) !== null && _window_ClipboardEvent !== void 0 ? _window_ClipboardEvent : class extends Event2 {
  };
  var _window_PopStateEvent;
  let PopStateEvent = (_window_PopStateEvent = window2.PopStateEvent) !== null && _window_PopStateEvent !== void 0 ? _window_PopStateEvent : class extends Event2 {
  };
  var _window_ProgressEvent;
  let ProgressEvent = (_window_ProgressEvent = window2.ProgressEvent) !== null && _window_ProgressEvent !== void 0 ? _window_ProgressEvent : class extends Event2 {
  };
  var _window_TransitionEvent;
  let TransitionEvent = (_window_TransitionEvent = window2.TransitionEvent) !== null && _window_TransitionEvent !== void 0 ? _window_TransitionEvent : class extends Event2 {
  };
  var _window_UIEvent;
  let UIEvent = (_window_UIEvent = window2.UIEvent) !== null && _window_UIEvent !== void 0 ? _window_UIEvent : class extends Event2 {
  };
  var _window_CompositionEvent;
  let CompositionEvent = (_window_CompositionEvent = window2.CompositionEvent) !== null && _window_CompositionEvent !== void 0 ? _window_CompositionEvent : class extends UIEvent {
  };
  var _window_FocusEvent;
  let FocusEvent = (_window_FocusEvent = window2.FocusEvent) !== null && _window_FocusEvent !== void 0 ? _window_FocusEvent : class extends UIEvent {
  };
  var _window_InputEvent;
  let InputEvent = (_window_InputEvent = window2.InputEvent) !== null && _window_InputEvent !== void 0 ? _window_InputEvent : class extends UIEvent {
  };
  var _window_KeyboardEvent;
  let KeyboardEvent = (_window_KeyboardEvent = window2.KeyboardEvent) !== null && _window_KeyboardEvent !== void 0 ? _window_KeyboardEvent : class extends UIEvent {
  };
  var _window_MouseEvent;
  let MouseEvent = (_window_MouseEvent = window2.MouseEvent) !== null && _window_MouseEvent !== void 0 ? _window_MouseEvent : class extends UIEvent {
  };
  var _window_DragEvent;
  let DragEvent = (_window_DragEvent = window2.DragEvent) !== null && _window_DragEvent !== void 0 ? _window_DragEvent : class extends MouseEvent {
  };
  var _window_PointerEvent;
  let PointerEvent = (_window_PointerEvent = window2.PointerEvent) !== null && _window_PointerEvent !== void 0 ? _window_PointerEvent : class extends MouseEvent {
  };
  var _window_TouchEvent;
  let TouchEvent = (_window_TouchEvent = window2.TouchEvent) !== null && _window_TouchEvent !== void 0 ? _window_TouchEvent : class extends UIEvent {
  };
  return {
    Event: Event2,
    AnimationEvent,
    ClipboardEvent,
    PopStateEvent,
    ProgressEvent,
    TransitionEvent,
    UIEvent,
    CompositionEvent,
    FocusEvent,
    InputEvent,
    KeyboardEvent,
    MouseEvent,
    DragEvent,
    PointerEvent,
    TouchEvent
  };
}
function assignProps(obj, props) {
  for (let [key, value] of Object.entries(props))
    Object.defineProperty(obj, key, {
      get: () => value ?? null
    });
}
function sanitizeNumber(n2) {
  return Number(n2 ?? 0);
}
function initClipboardEvent(event, { clipboardData }) {
  assignProps(event, {
    clipboardData
  });
}
function initFocusEvent(event, { relatedTarget }) {
  assignProps(event, {
    relatedTarget
  });
}
function initInputEvent(event, { data, inputType, isComposing }) {
  assignProps(event, {
    data,
    isComposing: !!isComposing,
    inputType: String(inputType)
  });
}
function initUIEvent(event, { view, detail }) {
  assignProps(event, {
    view,
    detail: sanitizeNumber(detail ?? 0)
  });
}
function initUIEventModifiers(event, { altKey, ctrlKey, metaKey, shiftKey, modifierAltGraph, modifierCapsLock, modifierFn, modifierFnLock, modifierNumLock, modifierScrollLock, modifierSymbol, modifierSymbolLock }) {
  assignProps(event, {
    altKey: !!altKey,
    ctrlKey: !!ctrlKey,
    metaKey: !!metaKey,
    shiftKey: !!shiftKey,
    getModifierState(k2) {
      return !!{
        Alt: altKey,
        AltGraph: modifierAltGraph,
        CapsLock: modifierCapsLock,
        Control: ctrlKey,
        Fn: modifierFn,
        FnLock: modifierFnLock,
        Meta: metaKey,
        NumLock: modifierNumLock,
        ScrollLock: modifierScrollLock,
        Shift: shiftKey,
        Symbol: modifierSymbol,
        SymbolLock: modifierSymbolLock
      }[k2];
    }
  });
}
function initKeyboardEvent(event, { key, code, location: location2, repeat, isComposing, charCode }) {
  assignProps(event, {
    key: String(key),
    code: String(code),
    location: sanitizeNumber(location2),
    repeat: !!repeat,
    isComposing: !!isComposing,
    charCode
  });
}
function initMouseEvent(event, { x: x2, y: y2, screenX, screenY, clientX = x2, clientY = y2, button, buttons, relatedTarget, offsetX, offsetY, pageX, pageY }) {
  assignProps(event, {
    screenX: sanitizeNumber(screenX),
    screenY: sanitizeNumber(screenY),
    clientX: sanitizeNumber(clientX),
    x: sanitizeNumber(clientX),
    clientY: sanitizeNumber(clientY),
    y: sanitizeNumber(clientY),
    button: sanitizeNumber(button),
    buttons: sanitizeNumber(buttons),
    relatedTarget,
    offsetX: sanitizeNumber(offsetX),
    offsetY: sanitizeNumber(offsetY),
    pageX: sanitizeNumber(pageX),
    pageY: sanitizeNumber(pageY)
  });
}
function initPointerEvent(event, { pointerId, width, height, pressure, tangentialPressure, tiltX, tiltY, twist, pointerType, isPrimary }) {
  assignProps(event, {
    pointerId: sanitizeNumber(pointerId),
    width: sanitizeNumber(width ?? 1),
    height: sanitizeNumber(height ?? 1),
    pressure: sanitizeNumber(pressure),
    tangentialPressure: sanitizeNumber(tangentialPressure),
    tiltX: sanitizeNumber(tiltX),
    tiltY: sanitizeNumber(tiltY),
    twist: sanitizeNumber(twist),
    pointerType: String(pointerType),
    isPrimary: !!isPrimary
  });
}

// ../node_modules/@testing-library/user-event/dist/esm/event/dispatchEvent.js
function dispatchUIEvent(target, type5, init2, preventDefault = !1) {
  (isMouseEvent(type5) || isKeyboardEvent(type5)) && (init2 = {
    ...init2,
    ...this.system.getUIEventModifiers()
  });
  let event = createEvent2(type5, target, init2);
  return dispatchEvent.call(this, target, event, preventDefault);
}
function dispatchEvent(target, event, preventDefault = !1) {
  var _behavior_type;
  let type5 = event.type, behaviorImplementation = preventDefault ? () => {
  } : (_behavior_type = behavior[type5]) === null || _behavior_type === void 0 ? void 0 : _behavior_type.call(behavior, event, target, this);
  if (behaviorImplementation) {
    event.preventDefault();
    let defaultPrevented = !1;
    return Object.defineProperty(event, "defaultPrevented", {
      get: () => defaultPrevented
    }), Object.defineProperty(event, "preventDefault", {
      value: () => {
        defaultPrevented = event.cancelable;
      }
    }), wrapEvent(() => target.dispatchEvent(event)), defaultPrevented || behaviorImplementation(), !defaultPrevented;
  }
  return wrapEvent(() => target.dispatchEvent(event));
}
function dispatchDOMEvent(target, type5, init2) {
  let event = createEvent2(type5, target, init2);
  wrapEvent(() => target.dispatchEvent(event));
}

// ../node_modules/@testing-library/user-event/dist/esm/document/patchFocus.js
var patched = Symbol("patched focus/blur methods");
function patchFocus(HTMLElement2) {
  if (HTMLElement2.prototype[patched])
    return;
  let { focus, blur } = HTMLElement2.prototype;
  Object.defineProperties(HTMLElement2.prototype, {
    focus: {
      configurable: !0,
      get: () => patchedFocus2
    },
    blur: {
      configurable: !0,
      get: () => patchedBlur
    },
    [patched]: {
      configurable: !0,
      get: () => ({
        focus,
        blur
      })
    }
  });
  let activeCall;
  function patchedFocus2(options) {
    if (this.ownerDocument.visibilityState !== "hidden")
      return focus.call(this, options);
    let blurred = getActiveTarget(this.ownerDocument);
    if (blurred === this)
      return;
    let thisCall = Symbol("focus call");
    activeCall = thisCall, blurred && (blur.call(blurred), dispatchDOMEvent(blurred, "blur", {
      relatedTarget: this
    }), dispatchDOMEvent(blurred, "focusout", {
      relatedTarget: activeCall === thisCall ? this : null
    })), activeCall === thisCall && (focus.call(this, options), dispatchDOMEvent(this, "focus", {
      relatedTarget: blurred
    })), activeCall === thisCall && dispatchDOMEvent(this, "focusin", {
      relatedTarget: blurred
    });
  }
  function patchedBlur() {
    if (this.ownerDocument.visibilityState !== "hidden")
      return blur.call(this);
    let blurred = getActiveTarget(this.ownerDocument);
    if (blurred !== this)
      return;
    activeCall = Symbol("blur call"), blur.call(this), dispatchDOMEvent(blurred, "blur", {
      relatedTarget: null
    }), dispatchDOMEvent(blurred, "focusout", {
      relatedTarget: null
    });
  }
}
function getActiveTarget(document7) {
  let active = getActiveElement(document7);
  return active?.tagName === "BODY" ? null : active;
}

// ../node_modules/@testing-library/user-event/dist/esm/document/interceptor.js
var Interceptor = Symbol("Interceptor for programmatical calls");
function prepareInterceptor(element, propName, interceptorImpl) {
  let prototypeDescriptor = Object.getOwnPropertyDescriptor(element.constructor.prototype, propName), objectDescriptor = Object.getOwnPropertyDescriptor(element, propName), target = prototypeDescriptor?.set ? "set" : "value";
  if (typeof prototypeDescriptor?.[target] != "function" || prototypeDescriptor[target][Interceptor])
    throw new Error(`Element ${element.tagName} does not implement "${String(propName)}".`);
  function intercept(...args) {
    let { applyNative = !1, realArgs, then } = interceptorImpl.call(this, ...args), realFunc = (!applyNative && objectDescriptor || prototypeDescriptor)[target];
    target === "set" ? realFunc.call(this, realArgs) : realFunc.call(this, ...realArgs), then?.();
  }
  intercept[Interceptor] = Interceptor, Object.defineProperty(element, propName, {
    ...objectDescriptor ?? prototypeDescriptor,
    [target]: intercept
  });
}
function prepareValueInterceptor(element) {
  prepareInterceptor(element, "value", function(v2) {
    let isUI = isUIValue(v2);
    return isUI && startTrackValue(this), {
      applyNative: !!isUI,
      realArgs: sanitizeValue(this, v2),
      then: isUI ? void 0 : () => trackOrSetValue(this, String(v2))
    };
  });
}
function sanitizeValue(element, v2) {
  return isElementType(element, "input", {
    type: "number"
  }) && String(v2) !== "" && !Number.isNaN(Number(v2)) ? String(Number(v2)) : String(v2);
}
function prepareSelectionInterceptor(element) {
  prepareInterceptor(element, "setSelectionRange", function(start, ...others) {
    let isUI = isUISelectionStart(start);
    return {
      applyNative: !!isUI,
      realArgs: [
        Number(start),
        ...others
      ],
      then: () => isUI ? void 0 : setUISelectionClean(element)
    };
  }), prepareInterceptor(element, "selectionStart", function(v2) {
    return {
      realArgs: v2,
      then: () => setUISelectionClean(element)
    };
  }), prepareInterceptor(element, "selectionEnd", function(v2) {
    return {
      realArgs: v2,
      then: () => setUISelectionClean(element)
    };
  }), prepareInterceptor(element, "select", function() {
    return {
      realArgs: [],
      then: () => setUISelectionRaw(element, {
        anchorOffset: 0,
        focusOffset: getUIValue(element).length
      })
    };
  });
}
function prepareRangeTextInterceptor(element) {
  prepareInterceptor(element, "setRangeText", function(...realArgs) {
    return {
      realArgs,
      then: () => {
        setUIValueClean(element), setUISelectionClean(element);
      }
    };
  });
}

// ../node_modules/@testing-library/user-event/dist/esm/document/prepareDocument.js
var isPrepared = Symbol("Node prepared with document state workarounds");
function prepareDocument(document7) {
  document7[isPrepared] || (document7.addEventListener("focus", (e2) => {
    let el = e2.target;
    prepareElement(el);
  }, {
    capture: !0,
    passive: !0
  }), document7.activeElement && prepareElement(document7.activeElement), document7.addEventListener("blur", (e2) => {
    let el = e2.target, initialValue2 = getInitialValue(el);
    initialValue2 !== void 0 && (el.value !== initialValue2 && dispatchDOMEvent(el, "change"), clearInitialValue(el));
  }, {
    capture: !0,
    passive: !0
  }), document7[isPrepared] = isPrepared);
}
function prepareElement(el) {
  el[isPrepared] || (isElementType(el, [
    "input",
    "textarea"
  ]) && (prepareValueInterceptor(el), prepareSelectionInterceptor(el), prepareRangeTextInterceptor(el)), el[isPrepared] = isPrepared);
}

// ../node_modules/@testing-library/user-event/dist/esm/utils/misc/getDocumentFromNode.js
function getDocumentFromNode(el) {
  return isDocument2(el) ? el : el.ownerDocument;
}
function isDocument2(node) {
  return node.nodeType === 9;
}

// ../node_modules/@testing-library/user-event/dist/esm/utils/misc/level.js
var ApiLevel = (function(ApiLevel2) {
  return ApiLevel2[ApiLevel2.Trigger = 2] = "Trigger", ApiLevel2[ApiLevel2.Call = 1] = "Call", ApiLevel2;
})({});
function setLevelRef(instance, level) {
  instance.levelRefs[level] = {};
}
function getLevelRef(instance, level) {
  return instance.levelRefs[level];
}

// ../node_modules/@testing-library/user-event/dist/esm/utils/misc/wait.js
function wait(config4) {
  let delay = config4.delay;
  if (typeof delay == "number")
    return Promise.all([
      new Promise((resolve) => globalThis.setTimeout(() => resolve(), delay)),
      config4.advanceTimers(delay)
    ]);
}

// ../node_modules/@testing-library/user-event/dist/esm/options.js
var PointerEventsCheckLevel = (function(PointerEventsCheckLevel2) {
  return PointerEventsCheckLevel2[PointerEventsCheckLevel2.EachTrigger = 4] = "EachTrigger", PointerEventsCheckLevel2[PointerEventsCheckLevel2.EachApiCall = 2] = "EachApiCall", PointerEventsCheckLevel2[PointerEventsCheckLevel2.EachTarget = 1] = "EachTarget", PointerEventsCheckLevel2[PointerEventsCheckLevel2.Never = 0] = "Never", PointerEventsCheckLevel2;
})({});

// ../node_modules/@testing-library/user-event/dist/esm/system/keyboard.js
function _define_property3(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}
var DOM_KEY_LOCATION = (function(DOM_KEY_LOCATION2) {
  return DOM_KEY_LOCATION2[DOM_KEY_LOCATION2.STANDARD = 0] = "STANDARD", DOM_KEY_LOCATION2[DOM_KEY_LOCATION2.LEFT = 1] = "LEFT", DOM_KEY_LOCATION2[DOM_KEY_LOCATION2.RIGHT = 2] = "RIGHT", DOM_KEY_LOCATION2[DOM_KEY_LOCATION2.NUMPAD = 3] = "NUMPAD", DOM_KEY_LOCATION2;
})({}), modifierKeys = [
  "Alt",
  "AltGraph",
  "Control",
  "Fn",
  "Meta",
  "Shift",
  "Symbol"
];
function isModifierKey(key) {
  return modifierKeys.includes(key);
}
var modifierLocks = [
  "CapsLock",
  "FnLock",
  "NumLock",
  "ScrollLock",
  "SymbolLock"
];
function isModifierLock(key) {
  return modifierLocks.includes(key);
}
var KeyboardHost = class {
  isKeyPressed(keyDef) {
    return this.pressed.has(String(keyDef.code));
  }
  getPressedKeys() {
    return this.pressed.values().map((p2) => p2.keyDef);
  }
  /** Press a key */
  async keydown(instance, keyDef) {
    let key = String(keyDef.key), code = String(keyDef.code), target = getActiveElementOrBody(instance.config.document);
    this.setKeydownTarget(target), this.pressed.add(code, keyDef), isModifierKey(key) && (this.modifiers[key] = !0);
    let unprevented = instance.dispatchUIEvent(target, "keydown", {
      key,
      code
    });
    isModifierLock(key) && !this.modifiers[key] && (this.modifiers[key] = !0, this.modifierLockStart[key] = !0), unprevented && this.pressed.setUnprevented(code), unprevented && this.hasKeyPress(key) && instance.dispatchUIEvent(getActiveElementOrBody(instance.config.document), "keypress", {
      key,
      code,
      charCode: keyDef.key === "Enter" ? 13 : String(keyDef.key).charCodeAt(0)
    });
  }
  /** Release a key */
  async keyup(instance, keyDef) {
    let key = String(keyDef.key), code = String(keyDef.code), unprevented = this.pressed.isUnprevented(code);
    this.pressed.delete(code), isModifierKey(key) && !this.pressed.values().find((p2) => p2.keyDef.key === key) && (this.modifiers[key] = !1), instance.dispatchUIEvent(getActiveElementOrBody(instance.config.document), "keyup", {
      key,
      code
    }, !unprevented), isModifierLock(key) && this.modifiers[key] && (this.modifierLockStart[key] ? this.modifierLockStart[key] = !1 : this.modifiers[key] = !1);
  }
  setKeydownTarget(target) {
    target !== this.lastKeydownTarget && (this.carryChar = ""), this.lastKeydownTarget = target;
  }
  hasKeyPress(key) {
    return (key.length === 1 || key === "Enter") && !this.modifiers.Control && !this.modifiers.Alt;
  }
  constructor(system) {
    _define_property3(this, "system", void 0), _define_property3(this, "modifiers", {
      Alt: !1,
      AltGraph: !1,
      CapsLock: !1,
      Control: !1,
      Fn: !1,
      FnLock: !1,
      Meta: !1,
      NumLock: !1,
      ScrollLock: !1,
      Shift: !1,
      Symbol: !1,
      SymbolLock: !1
    }), _define_property3(this, "pressed", new class {
      add(code, keyDef) {
        var _this_registry, _code, _;
        (_ = (_this_registry = this.registry)[_code = code]) !== null && _ !== void 0 || (_this_registry[_code] = {
          keyDef,
          unpreventedDefault: !1
        });
      }
      has(code) {
        return !!this.registry[code];
      }
      setUnprevented(code) {
        let o2 = this.registry[code];
        o2 && (o2.unpreventedDefault = !0);
      }
      isUnprevented(code) {
        var _this_registry_code;
        return !!(!((_this_registry_code = this.registry[code]) === null || _this_registry_code === void 0) && _this_registry_code.unpreventedDefault);
      }
      delete(code) {
        delete this.registry[code];
      }
      values() {
        return Object.values(this.registry);
      }
      constructor() {
        _define_property3(this, "registry", {});
      }
    }()), _define_property3(this, "carryChar", ""), _define_property3(this, "lastKeydownTarget", void 0), _define_property3(this, "modifierLockStart", {}), this.system = system;
  }
};

// ../node_modules/@testing-library/user-event/dist/esm/keyboard/keyMap.js
var defaultKeyMap = [
  // alphanumeric block - writing system
  ..."0123456789".split("").map((c2) => ({
    code: `Digit${c2}`,
    key: c2
  })),
  ...")!@#$%^&*(".split("").map((c2, i2) => ({
    code: `Digit${i2}`,
    key: c2,
    shiftKey: !0
  })),
  ..."abcdefghijklmnopqrstuvwxyz".split("").map((c2) => ({
    code: `Key${c2.toUpperCase()}`,
    key: c2
  })),
  ..."ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("").map((c2) => ({
    code: `Key${c2}`,
    key: c2,
    shiftKey: !0
  })),
  {
    code: "BracketLeft",
    key: "["
  },
  {
    code: "BracketLeft",
    key: "{",
    shiftKey: !0
  },
  {
    code: "BracketRight",
    key: "]"
  },
  {
    code: "BracketRight",
    key: "}",
    shiftKey: !0
  },
  // alphanumeric block - functional
  {
    code: "Space",
    key: " "
  },
  {
    code: "AltLeft",
    key: "Alt",
    location: DOM_KEY_LOCATION.LEFT
  },
  {
    code: "AltRight",
    key: "Alt",
    location: DOM_KEY_LOCATION.RIGHT
  },
  {
    code: "ShiftLeft",
    key: "Shift",
    location: DOM_KEY_LOCATION.LEFT
  },
  {
    code: "ShiftRight",
    key: "Shift",
    location: DOM_KEY_LOCATION.RIGHT
  },
  {
    code: "ControlLeft",
    key: "Control",
    location: DOM_KEY_LOCATION.LEFT
  },
  {
    code: "ControlRight",
    key: "Control",
    location: DOM_KEY_LOCATION.RIGHT
  },
  {
    code: "MetaLeft",
    key: "Meta",
    location: DOM_KEY_LOCATION.LEFT
  },
  {
    code: "MetaRight",
    key: "Meta",
    location: DOM_KEY_LOCATION.RIGHT
  },
  {
    code: "OSLeft",
    key: "OS",
    location: DOM_KEY_LOCATION.LEFT
  },
  {
    code: "OSRight",
    key: "OS",
    location: DOM_KEY_LOCATION.RIGHT
  },
  {
    code: "ContextMenu",
    key: "ContextMenu"
  },
  {
    code: "Tab",
    key: "Tab"
  },
  {
    code: "CapsLock",
    key: "CapsLock"
  },
  {
    code: "Backspace",
    key: "Backspace"
  },
  {
    code: "Enter",
    key: "Enter"
  },
  // function
  {
    code: "Escape",
    key: "Escape"
  },
  // arrows
  {
    code: "ArrowUp",
    key: "ArrowUp"
  },
  {
    code: "ArrowDown",
    key: "ArrowDown"
  },
  {
    code: "ArrowLeft",
    key: "ArrowLeft"
  },
  {
    code: "ArrowRight",
    key: "ArrowRight"
  },
  // control pad
  {
    code: "Home",
    key: "Home"
  },
  {
    code: "End",
    key: "End"
  },
  {
    code: "Delete",
    key: "Delete"
  },
  {
    code: "PageUp",
    key: "PageUp"
  },
  {
    code: "PageDown",
    key: "PageDown"
  },
  // Special keys that are not part of a default US-layout but included for specific behavior
  {
    code: "Fn",
    key: "Fn"
  },
  {
    code: "Symbol",
    key: "Symbol"
  },
  {
    code: "AltRight",
    key: "AltGraph"
  }
];

// ../node_modules/@testing-library/user-event/dist/esm/pointer/keyMap.js
var defaultKeyMap2 = [
  {
    name: "MouseLeft",
    pointerType: "mouse",
    button: "primary"
  },
  {
    name: "MouseRight",
    pointerType: "mouse",
    button: "secondary"
  },
  {
    name: "MouseMiddle",
    pointerType: "mouse",
    button: "auxiliary"
  },
  {
    name: "TouchA",
    pointerType: "touch"
  },
  {
    name: "TouchB",
    pointerType: "touch"
  },
  {
    name: "TouchC",
    pointerType: "touch"
  }
];

// ../node_modules/@testing-library/user-event/dist/esm/system/pointer/buttons.js
function _define_property4(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}
var Buttons = class {
  getButtons() {
    let v2 = 0;
    for (let button of Object.keys(this.pressed))
      v2 |= 2 ** Number(button);
    return v2;
  }
  down(keyDef) {
    let button = getMouseButtonId(keyDef.button);
    if (button in this.pressed) {
      this.pressed[button].push(keyDef);
      return;
    }
    return this.pressed[button] = [
      keyDef
    ], button;
  }
  up(keyDef) {
    let button = getMouseButtonId(keyDef.button);
    if (button in this.pressed && (this.pressed[button] = this.pressed[button].filter((k2) => k2.name !== keyDef.name), this.pressed[button].length === 0))
      return delete this.pressed[button], button;
  }
  constructor() {
    _define_property4(this, "pressed", {});
  }
}, MouseButton = {
  primary: 0,
  secondary: 1,
  auxiliary: 2,
  back: 3,
  X1: 3,
  forward: 4,
  X2: 4
};
function getMouseButtonId(button = 0) {
  return button in MouseButton ? MouseButton[button] : Number(button);
}
var MouseButtonFlip = {
  1: 2,
  2: 1
};
function getMouseEventButton(button) {
  return button = getMouseButtonId(button), button in MouseButtonFlip ? MouseButtonFlip[button] : button;
}

// ../node_modules/@testing-library/user-event/dist/esm/system/pointer/device.js
function _define_property5(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}
var Device = class {
  get countPressed() {
    return this.pressedKeys.size;
  }
  isPressed(keyDef) {
    return this.pressedKeys.has(keyDef.name);
  }
  addPressed(keyDef) {
    return this.pressedKeys.add(keyDef.name);
  }
  removePressed(keyDef) {
    return this.pressedKeys.delete(keyDef.name);
  }
  constructor() {
    _define_property5(this, "pressedKeys", /* @__PURE__ */ new Set());
  }
};

// ../node_modules/@testing-library/user-event/dist/esm/utils/misc/getTreeDiff.js
function getTreeDiff(a2, b2) {
  let treeA = [];
  for (let el = a2; el; el = el.parentElement)
    treeA.push(el);
  let treeB = [];
  for (let el = b2; el; el = el.parentElement)
    treeB.push(el);
  let i2 = 0;
  for (; !(i2 >= treeA.length || i2 >= treeB.length || treeA[treeA.length - 1 - i2] !== treeB[treeB.length - 1 - i2]); i2++)
    ;
  return [
    treeA.slice(0, treeA.length - i2),
    treeB.slice(0, treeB.length - i2),
    treeB.slice(treeB.length - i2)
  ];
}

// ../node_modules/@testing-library/user-event/dist/esm/event/selection/resolveCaretPosition.js
function resolveCaretPosition({ target, node, offset: offset2 }) {
  return hasOwnSelection(target) ? {
    node: target,
    offset: offset2 ?? getUIValue(target).length
  } : node ? {
    node,
    offset: offset2 ?? (node.nodeType === 3 ? node.nodeValue.length : node.childNodes.length)
  } : findNodeAtTextOffset(target, offset2);
}
function findNodeAtTextOffset(node, offset2, isRoot = !0) {
  let i2 = offset2 === void 0 ? node.childNodes.length - 1 : 0, step2 = offset2 === void 0 ? -1 : 1;
  for (; offset2 === void 0 ? i2 >= (isRoot ? Math.max(node.childNodes.length - 1, 0) : 0) : i2 <= node.childNodes.length; ) {
    if (offset2 && i2 === node.childNodes.length)
      throw new Error("The given offset is out of bounds.");
    let c2 = node.childNodes.item(i2), text = String(c2.textContent);
    if (text.length)
      if (offset2 !== void 0 && text.length < offset2)
        offset2 -= text.length;
      else {
        if (c2.nodeType === 1)
          return findNodeAtTextOffset(c2, offset2, !1);
        if (c2.nodeType === 3)
          return {
            node: c2,
            offset: offset2 ?? c2.nodeValue.length
          };
      }
    i2 += step2;
  }
  return {
    node,
    offset: node.childNodes.length
  };
}

// ../node_modules/@testing-library/user-event/dist/esm/event/selection/setSelectionPerMouse.js
function setSelectionPerMouseDown({ document: document7, target, clickCount, node, offset: offset2 }) {
  if (hasNoSelection(target))
    return;
  let targetHasOwnSelection = hasOwnSelection(target), text = String(targetHasOwnSelection ? getUIValue(target) : target.textContent), [start, end] = node ? (
    // which elements might be considered in the same line of text.
    // TODO: support expanding initial range on multiple clicks if node is given
    [
      offset2,
      offset2
    ]
  ) : getTextRange(text, offset2, clickCount);
  if (targetHasOwnSelection)
    return setUISelection(target, {
      anchorOffset: start ?? text.length,
      focusOffset: end ?? text.length
    }), {
      node: target,
      start: start ?? 0,
      end: end ?? text.length
    };
  {
    let { node: startNode, offset: startOffset } = resolveCaretPosition({
      target,
      node,
      offset: start
    }), { node: endNode, offset: endOffset } = resolveCaretPosition({
      target,
      node,
      offset: end
    }), range = target.ownerDocument.createRange();
    try {
      range.setStart(startNode, startOffset), range.setEnd(endNode, endOffset);
    } catch {
      throw new Error("The given offset is out of bounds.");
    }
    let selection = document7.getSelection();
    return selection?.removeAllRanges(), selection?.addRange(range.cloneRange()), range;
  }
}
function getTextRange(text, pos, clickCount) {
  if (clickCount % 3 === 1 || text.length === 0)
    return [
      pos,
      pos
    ];
  let textPos = pos ?? text.length;
  return clickCount % 3 === 2 ? [
    textPos - text.substr(0, pos).match(/(\w+|\s+|\W)?$/)[0].length,
    pos === void 0 ? pos : pos + text.substr(pos).match(/^(\w+|\s+|\W)?/)[0].length
  ] : [
    textPos - text.substr(0, pos).match(/[^\r\n]*$/)[0].length,
    pos === void 0 ? pos : pos + text.substr(pos).match(/^[^\r\n]*/)[0].length
  ];
}

// ../node_modules/@testing-library/user-event/dist/esm/event/selection/modifySelectionPerMouse.js
function modifySelectionPerMouseMove(selectionRange, { document: document7, target, node, offset: offset2 }) {
  let selectionFocus = resolveCaretPosition({
    target,
    node,
    offset: offset2
  });
  if ("node" in selectionRange) {
    if (selectionFocus.node === selectionRange.node) {
      let anchorOffset = selectionFocus.offset < selectionRange.start ? selectionRange.end : selectionRange.start, focusOffset = selectionFocus.offset > selectionRange.end || selectionFocus.offset < selectionRange.start ? selectionFocus.offset : selectionRange.end;
      setUISelection(selectionRange.node, {
        anchorOffset,
        focusOffset
      });
    }
  } else {
    let range = selectionRange.cloneRange(), cmp = range.comparePoint(selectionFocus.node, selectionFocus.offset);
    cmp < 0 ? range.setStart(selectionFocus.node, selectionFocus.offset) : cmp > 0 && range.setEnd(selectionFocus.node, selectionFocus.offset);
    let selection = document7.getSelection();
    selection?.removeAllRanges(), selection?.addRange(range.cloneRange());
  }
}

// ../node_modules/@testing-library/user-event/dist/esm/system/pointer/shared.js
function isDifferentPointerPosition(positionA, positionB) {
  var _positionA_coords, _positionB_coords, _positionA_coords1, _positionB_coords1, _positionA_coords2, _positionB_coords2, _positionA_coords3, _positionB_coords3, _positionA_coords4, _positionB_coords4, _positionA_coords5, _positionB_coords5, _positionA_coords6, _positionB_coords6, _positionA_coords7, _positionB_coords7, _positionA_coords8, _positionB_coords8, _positionA_coords9, _positionB_coords9, _positionA_caret, _positionB_caret, _positionA_caret1, _positionB_caret1;
  return positionA.target !== positionB.target || ((_positionA_coords = positionA.coords) === null || _positionA_coords === void 0 ? void 0 : _positionA_coords.x) !== ((_positionB_coords = positionB.coords) === null || _positionB_coords === void 0 ? void 0 : _positionB_coords.x) || ((_positionA_coords1 = positionA.coords) === null || _positionA_coords1 === void 0 ? void 0 : _positionA_coords1.y) !== ((_positionB_coords1 = positionB.coords) === null || _positionB_coords1 === void 0 ? void 0 : _positionB_coords1.y) || ((_positionA_coords2 = positionA.coords) === null || _positionA_coords2 === void 0 ? void 0 : _positionA_coords2.clientX) !== ((_positionB_coords2 = positionB.coords) === null || _positionB_coords2 === void 0 ? void 0 : _positionB_coords2.clientX) || ((_positionA_coords3 = positionA.coords) === null || _positionA_coords3 === void 0 ? void 0 : _positionA_coords3.clientY) !== ((_positionB_coords3 = positionB.coords) === null || _positionB_coords3 === void 0 ? void 0 : _positionB_coords3.clientY) || ((_positionA_coords4 = positionA.coords) === null || _positionA_coords4 === void 0 ? void 0 : _positionA_coords4.offsetX) !== ((_positionB_coords4 = positionB.coords) === null || _positionB_coords4 === void 0 ? void 0 : _positionB_coords4.offsetX) || ((_positionA_coords5 = positionA.coords) === null || _positionA_coords5 === void 0 ? void 0 : _positionA_coords5.offsetY) !== ((_positionB_coords5 = positionB.coords) === null || _positionB_coords5 === void 0 ? void 0 : _positionB_coords5.offsetY) || ((_positionA_coords6 = positionA.coords) === null || _positionA_coords6 === void 0 ? void 0 : _positionA_coords6.pageX) !== ((_positionB_coords6 = positionB.coords) === null || _positionB_coords6 === void 0 ? void 0 : _positionB_coords6.pageX) || ((_positionA_coords7 = positionA.coords) === null || _positionA_coords7 === void 0 ? void 0 : _positionA_coords7.pageY) !== ((_positionB_coords7 = positionB.coords) === null || _positionB_coords7 === void 0 ? void 0 : _positionB_coords7.pageY) || ((_positionA_coords8 = positionA.coords) === null || _positionA_coords8 === void 0 ? void 0 : _positionA_coords8.screenX) !== ((_positionB_coords8 = positionB.coords) === null || _positionB_coords8 === void 0 ? void 0 : _positionB_coords8.screenX) || ((_positionA_coords9 = positionA.coords) === null || _positionA_coords9 === void 0 ? void 0 : _positionA_coords9.screenY) !== ((_positionB_coords9 = positionB.coords) === null || _positionB_coords9 === void 0 ? void 0 : _positionB_coords9.screenY) || ((_positionA_caret = positionA.caret) === null || _positionA_caret === void 0 ? void 0 : _positionA_caret.node) !== ((_positionB_caret = positionB.caret) === null || _positionB_caret === void 0 ? void 0 : _positionB_caret.node) || ((_positionA_caret1 = positionA.caret) === null || _positionA_caret1 === void 0 ? void 0 : _positionA_caret1.offset) !== ((_positionB_caret1 = positionB.caret) === null || _positionB_caret1 === void 0 ? void 0 : _positionB_caret1.offset);
}

// ../node_modules/@testing-library/user-event/dist/esm/system/pointer/mouse.js
function _define_property6(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}
var Mouse = class {
  move(instance, position, isPrevented) {
    let prevPosition = this.position, prevTarget = this.getTarget(instance);
    if (this.position = position, !isDifferentPointerPosition(prevPosition, position))
      return;
    let nextTarget = this.getTarget(instance), init2 = this.getEventInit("mousemove"), [leave, enter] = getTreeDiff(prevTarget, nextTarget);
    return {
      leave: () => {
        prevTarget !== nextTarget && (instance.dispatchUIEvent(prevTarget, "mouseout", init2), leave.forEach((el) => instance.dispatchUIEvent(el, "mouseleave", init2)));
      },
      enter: () => {
        prevTarget !== nextTarget && (instance.dispatchUIEvent(nextTarget, "mouseover", init2), enter.forEach((el) => instance.dispatchUIEvent(el, "mouseenter", init2)));
      },
      move: () => {
        isPrevented || (instance.dispatchUIEvent(nextTarget, "mousemove", init2), this.modifySelecting(instance));
      }
    };
  }
  down(instance, keyDef, isPrevented) {
    let button = this.buttons.down(keyDef);
    if (button === void 0)
      return;
    let target = this.getTarget(instance);
    this.buttonDownTarget[button] = target;
    let init2 = this.getEventInit("mousedown", keyDef.button), disabled = isDisabled2(target);
    !isPrevented && (disabled || instance.dispatchUIEvent(target, "mousedown", init2)) && (this.startSelecting(instance, init2.detail), focusElement(target)), !disabled && getMouseEventButton(keyDef.button) === 2 && instance.dispatchUIEvent(target, "contextmenu", this.getEventInit("contextmenu", keyDef.button));
  }
  up(instance, keyDef, isPrevented) {
    let button = this.buttons.up(keyDef);
    if (button === void 0)
      return;
    let target = this.getTarget(instance);
    if (!isDisabled2(target)) {
      if (!isPrevented) {
        let mouseUpInit = this.getEventInit("mouseup", keyDef.button);
        instance.dispatchUIEvent(target, "mouseup", mouseUpInit), this.endSelecting();
      }
      let clickTarget = getTreeDiff(this.buttonDownTarget[button], target)[2][0];
      if (clickTarget) {
        let init2 = this.getEventInit("click", keyDef.button);
        init2.detail && (instance.dispatchUIEvent(clickTarget, init2.button === 0 ? "click" : "auxclick", init2), init2.button === 0 && init2.detail === 2 && instance.dispatchUIEvent(clickTarget, "dblclick", {
          ...this.getEventInit("dblclick", keyDef.button),
          detail: init2.detail
        }));
      }
    }
  }
  resetClickCount() {
    this.clickCount.reset();
  }
  getEventInit(type5, button) {
    let init2 = {
      ...this.position.coords
    };
    return init2.button = getMouseEventButton(button), init2.buttons = this.buttons.getButtons(), type5 === "mousedown" ? init2.detail = this.clickCount.getOnDown(init2.button) : type5 === "mouseup" ? init2.detail = this.clickCount.getOnUp(init2.button) : (type5 === "click" || type5 === "auxclick") && (init2.detail = this.clickCount.incOnClick(init2.button)), init2;
  }
  getTarget(instance) {
    var _this_position_target;
    return (_this_position_target = this.position.target) !== null && _this_position_target !== void 0 ? _this_position_target : instance.config.document.body;
  }
  startSelecting(instance, clickCount) {
    var _this_position_caret, _this_position_caret1;
    this.selecting = setSelectionPerMouseDown({
      document: instance.config.document,
      target: this.getTarget(instance),
      node: (_this_position_caret = this.position.caret) === null || _this_position_caret === void 0 ? void 0 : _this_position_caret.node,
      offset: (_this_position_caret1 = this.position.caret) === null || _this_position_caret1 === void 0 ? void 0 : _this_position_caret1.offset,
      clickCount
    });
  }
  modifySelecting(instance) {
    var _this_position_caret, _this_position_caret1;
    this.selecting && modifySelectionPerMouseMove(this.selecting, {
      document: instance.config.document,
      target: this.getTarget(instance),
      node: (_this_position_caret = this.position.caret) === null || _this_position_caret === void 0 ? void 0 : _this_position_caret.node,
      offset: (_this_position_caret1 = this.position.caret) === null || _this_position_caret1 === void 0 ? void 0 : _this_position_caret1.offset
    });
  }
  endSelecting() {
    this.selecting = void 0;
  }
  constructor() {
    _define_property6(this, "position", {}), _define_property6(this, "buttons", new Buttons()), _define_property6(this, "selecting", void 0), _define_property6(this, "buttonDownTarget", {}), _define_property6(this, "clickCount", new class {
      incOnClick(button) {
        let current = this.down[button] === void 0 ? void 0 : Number(this.down[button]) + 1;
        return this.count = this.count[button] === void 0 ? {} : {
          [button]: Number(this.count[button]) + 1
        }, current;
      }
      getOnDown(button) {
        var _this_count_button;
        this.down = {
          [button]: (_this_count_button = this.count[button]) !== null && _this_count_button !== void 0 ? _this_count_button : 0
        };
        var _this_count_button1;
        return this.count = {
          [button]: (_this_count_button1 = this.count[button]) !== null && _this_count_button1 !== void 0 ? _this_count_button1 : 0
        }, Number(this.count[button]) + 1;
      }
      getOnUp(button) {
        return this.down[button] === void 0 ? void 0 : Number(this.down[button]) + 1;
      }
      reset() {
        this.count = {};
      }
      constructor() {
        _define_property6(this, "down", {}), _define_property6(this, "count", {});
      }
    }());
  }
};

// ../node_modules/@testing-library/user-event/dist/esm/utils/pointer/cssPointerEvents.js
function hasPointerEvents(instance, element) {
  var _checkPointerEvents;
  return ((_checkPointerEvents = checkPointerEvents(instance, element)) === null || _checkPointerEvents === void 0 ? void 0 : _checkPointerEvents.pointerEvents) !== "none";
}
function closestPointerEventsDeclaration(element) {
  let window2 = getWindow(element);
  for (let el = element, tree = []; el?.ownerDocument; el = el.parentElement) {
    tree.push(el);
    let pointerEvents = window2.getComputedStyle(el).pointerEvents;
    if (pointerEvents && ![
      "inherit",
      "unset"
    ].includes(pointerEvents))
      return {
        pointerEvents,
        tree
      };
  }
}
var PointerEventsCheck = Symbol("Last check for pointer-events");
function checkPointerEvents(instance, element) {
  let lastCheck = element[PointerEventsCheck];
  if (!(instance.config.pointerEventsCheck !== PointerEventsCheckLevel.Never && (!lastCheck || hasBitFlag(instance.config.pointerEventsCheck, PointerEventsCheckLevel.EachApiCall) && lastCheck[ApiLevel.Call] !== getLevelRef(instance, ApiLevel.Call) || hasBitFlag(instance.config.pointerEventsCheck, PointerEventsCheckLevel.EachTrigger) && lastCheck[ApiLevel.Trigger] !== getLevelRef(instance, ApiLevel.Trigger))))
    return lastCheck?.result;
  let declaration = closestPointerEventsDeclaration(element);
  return element[PointerEventsCheck] = {
    [ApiLevel.Call]: getLevelRef(instance, ApiLevel.Call),
    [ApiLevel.Trigger]: getLevelRef(instance, ApiLevel.Trigger),
    result: declaration
  }, declaration;
}
function assertPointerEvents(instance, element) {
  let declaration = checkPointerEvents(instance, element);
  if (declaration?.pointerEvents === "none")
    throw new Error([
      `Unable to perform pointer interaction as the element ${declaration.tree.length > 1 ? "inherits" : "has"} \`pointer-events: none\`:`,
      "",
      printTree(declaration.tree)
    ].join(`
`));
}
function printTree(tree) {
  return tree.reverse().map((el, i2) => [
    "".padEnd(i2),
    el.tagName,
    el.id && `#${el.id}`,
    el.hasAttribute("data-testid") && `(testId=${el.getAttribute("data-testid")})`,
    getLabelDescr(el),
    tree.length > 1 && i2 === 0 && "  <-- This element declared `pointer-events: none`",
    tree.length > 1 && i2 === tree.length - 1 && "  <-- Asserted pointer events here"
  ].filter(Boolean).join("")).join(`
`);
}
function getLabelDescr(element) {
  var _element_labels;
  let label;
  if (element.hasAttribute("aria-label"))
    label = element.getAttribute("aria-label");
  else if (element.hasAttribute("aria-labelledby")) {
    var _element_ownerDocument_getElementById_textContent, _element_ownerDocument_getElementById;
    label = (_element_ownerDocument_getElementById = element.ownerDocument.getElementById(element.getAttribute("aria-labelledby"))) === null || _element_ownerDocument_getElementById === void 0 || (_element_ownerDocument_getElementById_textContent = _element_ownerDocument_getElementById.textContent) === null || _element_ownerDocument_getElementById_textContent === void 0 ? void 0 : _element_ownerDocument_getElementById_textContent.trim();
  } else if (isElementType(element, [
    "button",
    "input",
    "meter",
    "output",
    "progress",
    "select",
    "textarea"
  ]) && (!((_element_labels = element.labels) === null || _element_labels === void 0) && _element_labels.length))
    label = Array.from(element.labels).map((el) => {
      var _el_textContent;
      return (_el_textContent = el.textContent) === null || _el_textContent === void 0 ? void 0 : _el_textContent.trim();
    }).join("|");
  else if (isElementType(element, "button")) {
    var _element_textContent;
    label = (_element_textContent = element.textContent) === null || _element_textContent === void 0 ? void 0 : _element_textContent.trim();
  }
  return label = label?.replace(/\n/g, "  "), Number(label?.length) > 30 && (label = `${label?.substring(0, 29)}\u2026`), label ? `(label=${label})` : "";
}
function hasBitFlag(conf, flag3) {
  return (conf & flag3) > 0;
}

// ../node_modules/@testing-library/user-event/dist/esm/system/pointer/pointer.js
function _define_property7(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}
var Pointer = class {
  init(instance) {
    let target = this.getTarget(instance), [, enter] = getTreeDiff(null, target), init2 = this.getEventInit();
    return assertPointerEvents(instance, target), instance.dispatchUIEvent(target, "pointerover", init2), enter.forEach((el) => instance.dispatchUIEvent(el, "pointerenter", init2)), this;
  }
  move(instance, position) {
    let prevPosition = this.position, prevTarget = this.getTarget(instance);
    if (this.position = position, !isDifferentPointerPosition(prevPosition, position))
      return;
    let nextTarget = this.getTarget(instance), init2 = this.getEventInit(-1), [leave, enter] = getTreeDiff(prevTarget, nextTarget);
    return {
      leave: () => {
        hasPointerEvents(instance, prevTarget) && prevTarget !== nextTarget && (instance.dispatchUIEvent(prevTarget, "pointerout", init2), leave.forEach((el) => instance.dispatchUIEvent(el, "pointerleave", init2)));
      },
      enter: () => {
        assertPointerEvents(instance, nextTarget), prevTarget !== nextTarget && (instance.dispatchUIEvent(nextTarget, "pointerover", init2), enter.forEach((el) => instance.dispatchUIEvent(el, "pointerenter", init2)));
      },
      move: () => {
        instance.dispatchUIEvent(nextTarget, "pointermove", init2);
      }
    };
  }
  down(instance, button = 0) {
    if (this.isDown)
      return;
    let target = this.getTarget(instance);
    assertPointerEvents(instance, target), this.isDown = !0, this.isPrevented = !instance.dispatchUIEvent(target, "pointerdown", this.getEventInit(button));
  }
  up(instance, button = 0) {
    if (!this.isDown)
      return;
    let target = this.getTarget(instance);
    assertPointerEvents(instance, target), this.isPrevented = !1, this.isDown = !1, instance.dispatchUIEvent(target, "pointerup", this.getEventInit(button));
  }
  release(instance) {
    let target = this.getTarget(instance), [leave] = getTreeDiff(target, null), init2 = this.getEventInit();
    hasPointerEvents(instance, target) && (instance.dispatchUIEvent(target, "pointerout", init2), leave.forEach((el) => instance.dispatchUIEvent(el, "pointerleave", init2))), this.isCancelled = !0;
  }
  getTarget(instance) {
    var _this_position_target;
    return (_this_position_target = this.position.target) !== null && _this_position_target !== void 0 ? _this_position_target : instance.config.document.body;
  }
  getEventInit(button) {
    return {
      ...this.position.coords,
      pointerId: this.pointerId,
      pointerType: this.pointerType,
      isPrimary: this.isPrimary,
      button: getMouseEventButton(button),
      buttons: this.buttons.getButtons()
    };
  }
  constructor({ pointerId, pointerType, isPrimary }, buttons) {
    _define_property7(this, "pointerId", void 0), _define_property7(this, "pointerType", void 0), _define_property7(this, "isPrimary", void 0), _define_property7(this, "buttons", void 0), _define_property7(this, "isMultitouch", !1), _define_property7(this, "isCancelled", !1), _define_property7(this, "isDown", !1), _define_property7(this, "isPrevented", !1), _define_property7(this, "position", {}), this.pointerId = pointerId, this.pointerType = pointerType, this.isPrimary = isPrimary, this.isMultitouch = !isPrimary, this.buttons = buttons;
  }
};

// ../node_modules/@testing-library/user-event/dist/esm/system/pointer/index.js
function _define_property8(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}
var PointerHost = class {
  isKeyPressed(keyDef) {
    return this.devices.get(keyDef.pointerType).isPressed(keyDef);
  }
  async press(instance, keyDef, position) {
    this.devices.get(keyDef.pointerType).addPressed(keyDef), this.buttons.down(keyDef);
    let pointerName = this.getPointerName(keyDef), pointer4 = keyDef.pointerType === "touch" ? this.pointers.new(pointerName, keyDef.pointerType, this.buttons) : this.pointers.get(pointerName);
    pointer4.position = position, pointer4.pointerType !== "touch" && (this.mouse.position = position), pointer4.pointerType === "touch" && pointer4.init(instance), pointer4.down(instance, keyDef.button), pointer4.pointerType !== "touch" && this.mouse.down(instance, keyDef, pointer4.isPrevented);
  }
  async move(instance, pointerName, position) {
    let pointer4 = this.pointers.get(pointerName), pointermove = pointer4.move(instance, position), mousemove = pointer4.pointerType === "touch" ? void 0 : this.mouse.move(instance, position, pointer4.isPrevented);
    pointermove?.leave(), mousemove?.leave(), pointermove?.enter(), mousemove?.enter(), pointermove?.move(), mousemove?.move();
  }
  async release(instance, keyDef, position) {
    let device = this.devices.get(keyDef.pointerType);
    device.removePressed(keyDef), this.buttons.up(keyDef);
    let pointer4 = this.pointers.get(this.getPointerName(keyDef)), isPrevented = pointer4.isPrevented;
    if (pointer4.position = position, pointer4.pointerType !== "touch" && (this.mouse.position = position), device.countPressed === 0 && pointer4.up(instance, keyDef.button), pointer4.pointerType === "touch" && pointer4.release(instance), pointer4.pointerType === "touch" && !pointer4.isMultitouch) {
      let mousemove = this.mouse.move(instance, position, isPrevented);
      mousemove?.leave(), mousemove?.enter(), mousemove?.move(), this.mouse.down(instance, keyDef, isPrevented);
    }
    if (!pointer4.isMultitouch) {
      let mousemove = this.mouse.move(instance, position, isPrevented);
      mousemove?.leave(), mousemove?.enter(), mousemove?.move(), this.mouse.up(instance, keyDef, isPrevented);
    }
  }
  getPointerName(keyDef) {
    return keyDef.pointerType === "touch" ? keyDef.name : keyDef.pointerType;
  }
  getPreviousPosition(pointerName) {
    return this.pointers.has(pointerName) ? this.pointers.get(pointerName).position : void 0;
  }
  resetClickCount() {
    this.mouse.resetClickCount();
  }
  getMouseTarget(instance) {
    var _this_mouse_position_target;
    return (_this_mouse_position_target = this.mouse.position.target) !== null && _this_mouse_position_target !== void 0 ? _this_mouse_position_target : instance.config.document.body;
  }
  setMousePosition(position) {
    this.mouse.position = position, this.pointers.get("mouse").position = position;
  }
  constructor(system) {
    _define_property8(this, "system", void 0), _define_property8(this, "mouse", void 0), _define_property8(this, "buttons", void 0), _define_property8(this, "devices", new class {
      get(k2) {
        var _this_registry, _k, _;
        return (_ = (_this_registry = this.registry)[_k = k2]) !== null && _ !== void 0 ? _ : _this_registry[_k] = new Device();
      }
      constructor() {
        _define_property8(this, "registry", {});
      }
    }()), _define_property8(this, "pointers", new class {
      new(pointerName, pointerType, buttons) {
        let isPrimary = pointerType !== "touch" || !Object.values(this.registry).some((p2) => p2.pointerType === "touch" && !p2.isCancelled);
        return isPrimary || Object.values(this.registry).forEach((p2) => {
          p2.pointerType === pointerType && !p2.isCancelled && (p2.isMultitouch = !0);
        }), this.registry[pointerName] = new Pointer({
          pointerId: this.nextId++,
          pointerType,
          isPrimary
        }, buttons), this.registry[pointerName];
      }
      get(pointerName) {
        if (!this.has(pointerName))
          throw new Error(`Trying to access pointer "${pointerName}" which does not exist.`);
        return this.registry[pointerName];
      }
      has(pointerName) {
        return pointerName in this.registry;
      }
      constructor() {
        _define_property8(this, "registry", {}), _define_property8(this, "nextId", 1);
      }
    }()), this.system = system, this.buttons = new Buttons(), this.mouse = new Mouse(), this.pointers.new("mouse", "mouse", this.buttons);
  }
};

// ../node_modules/@testing-library/user-event/dist/esm/system/index.js
function _define_property9(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}
var System = class {
  getUIEventModifiers() {
    return {
      altKey: this.keyboard.modifiers.Alt,
      ctrlKey: this.keyboard.modifiers.Control,
      metaKey: this.keyboard.modifiers.Meta,
      shiftKey: this.keyboard.modifiers.Shift,
      modifierAltGraph: this.keyboard.modifiers.AltGraph,
      modifierCapsLock: this.keyboard.modifiers.CapsLock,
      modifierFn: this.keyboard.modifiers.Fn,
      modifierFnLock: this.keyboard.modifiers.FnLock,
      modifierNumLock: this.keyboard.modifiers.NumLock,
      modifierScrollLock: this.keyboard.modifiers.ScrollLock,
      modifierSymbol: this.keyboard.modifiers.Symbol,
      modifierSymbolLock: this.keyboard.modifiers.SymbolLock
    };
  }
  constructor() {
    _define_property9(this, "keyboard", new KeyboardHost(this)), _define_property9(this, "pointer", new PointerHost(this));
  }
};

// ../node_modules/@testing-library/user-event/dist/esm/convenience/click.js
async function click(element) {
  let pointerIn = [];
  return this.config.skipHover || pointerIn.push({
    target: element
  }), pointerIn.push({
    keys: "[MouseLeft]",
    target: element
  }), this.pointer(pointerIn);
}
async function dblClick(element) {
  return this.pointer([
    {
      target: element
    },
    "[MouseLeft][MouseLeft]"
  ]);
}
async function tripleClick(element) {
  return this.pointer([
    {
      target: element
    },
    "[MouseLeft][MouseLeft][MouseLeft]"
  ]);
}

// ../node_modules/@testing-library/user-event/dist/esm/convenience/hover.js
async function hover(element) {
  return this.pointer({
    target: element
  });
}
async function unhover(element) {
  return assertPointerEvents(this, this.system.pointer.getMouseTarget(this)), this.pointer({
    target: element.ownerDocument.body
  });
}

// ../node_modules/@testing-library/user-event/dist/esm/convenience/tab.js
async function tab({ shift } = {}) {
  return this.keyboard(shift === !0 ? "{Shift>}{Tab}{/Shift}" : shift === !1 ? "[/ShiftLeft][/ShiftRight]{Tab}" : "{Tab}");
}

// ../node_modules/@testing-library/user-event/dist/esm/utils/keyDef/readNextDescriptor.js
var bracketDict = (function(bracketDict2) {
  return bracketDict2["{"] = "}", bracketDict2["["] = "]", bracketDict2;
})(bracketDict || {});
function readNextDescriptor(text, context) {
  let pos = 0, startBracket = text[pos] in bracketDict ? text[pos] : "";
  pos += startBracket.length;
  let type5 = new RegExp(`^\\${startBracket}{2}`).test(text) ? "" : startBracket;
  return {
    type: type5,
    ...type5 === "" ? readPrintableChar(text, pos, context) : readTag(text, pos, type5, context)
  };
}
function readPrintableChar(text, pos, context) {
  let descriptor = text[pos];
  return assertDescriptor(descriptor, text, pos, context), pos += descriptor.length, {
    consumedLength: pos,
    descriptor,
    releasePrevious: !1,
    releaseSelf: !0,
    repeat: 1
  };
}
function readTag(text, pos, startBracket, context) {
  var _text_slice_match, _text_slice_match1;
  let releasePreviousModifier = text[pos] === "/" ? "/" : "";
  pos += releasePreviousModifier.length;
  let escapedDescriptor = startBracket === "{" && text[pos] === "\\";
  pos += Number(escapedDescriptor);
  let descriptor = escapedDescriptor ? text[pos] : (_text_slice_match = text.slice(pos).match(startBracket === "{" ? /^\w+|^[^}>/]/ : /^\w+/)) === null || _text_slice_match === void 0 ? void 0 : _text_slice_match[0];
  assertDescriptor(descriptor, text, pos, context), pos += descriptor.length;
  var _text_slice_match_;
  let repeatModifier = (_text_slice_match_ = (_text_slice_match1 = text.slice(pos).match(/^>\d+/)) === null || _text_slice_match1 === void 0 ? void 0 : _text_slice_match1[0]) !== null && _text_slice_match_ !== void 0 ? _text_slice_match_ : "";
  pos += repeatModifier.length;
  let releaseSelfModifier = text[pos] === "/" || !repeatModifier && text[pos] === ">" ? text[pos] : "";
  pos += releaseSelfModifier.length;
  let expectedEndBracket = bracketDict[startBracket], endBracket = text[pos] === expectedEndBracket ? expectedEndBracket : "";
  if (!endBracket)
    throw new Error(getErrorMessage([
      !repeatModifier && "repeat modifier",
      !releaseSelfModifier && "release modifier",
      `"${expectedEndBracket}"`
    ].filter(Boolean).join(" or "), text[pos], text, context));
  return pos += endBracket.length, {
    consumedLength: pos,
    descriptor,
    releasePrevious: !!releasePreviousModifier,
    repeat: repeatModifier ? Math.max(Number(repeatModifier.substr(1)), 1) : 1,
    releaseSelf: hasReleaseSelf(releaseSelfModifier, repeatModifier)
  };
}
function assertDescriptor(descriptor, text, pos, context) {
  if (!descriptor)
    throw new Error(getErrorMessage("key descriptor", text[pos], text, context));
}
function hasReleaseSelf(releaseSelfModifier, repeatModifier) {
  if (releaseSelfModifier)
    return releaseSelfModifier === "/";
  if (repeatModifier)
    return !1;
}
function getErrorMessage(expected, found, text, context) {
  return `Expected ${expected} but found "${found ?? ""}" in "${text}"
    See ${context === "pointer" ? "https://testing-library.com/docs/user-event/pointer#pressing-a-button-or-touching-the-screen" : "https://testing-library.com/docs/user-event/keyboard"}
    for more information about how userEvent parses your input.`;
}

// ../node_modules/@testing-library/user-event/dist/esm/keyboard/parseKeyDef.js
function parseKeyDef(keyboardMap, text) {
  let defs = [];
  do {
    let { type: type5, descriptor, consumedLength, releasePrevious, releaseSelf = !0, repeat } = readNextDescriptor(text, "keyboard");
    var _keyboardMap_find;
    let keyDef = (_keyboardMap_find = keyboardMap.find((def) => {
      if (type5 === "[") {
        var _def_code;
        return ((_def_code = def.code) === null || _def_code === void 0 ? void 0 : _def_code.toLowerCase()) === descriptor.toLowerCase();
      } else if (type5 === "{") {
        var _def_key;
        return ((_def_key = def.key) === null || _def_key === void 0 ? void 0 : _def_key.toLowerCase()) === descriptor.toLowerCase();
      }
      return def.key === descriptor;
    })) !== null && _keyboardMap_find !== void 0 ? _keyboardMap_find : {
      key: "Unknown",
      code: "Unknown",
      [type5 === "[" ? "code" : "key"]: descriptor
    };
    defs.push({
      keyDef,
      releasePrevious,
      releaseSelf,
      repeat
    }), text = text.slice(consumedLength);
  } while (text);
  return defs;
}

// ../node_modules/@testing-library/user-event/dist/esm/keyboard/index.js
async function keyboard(text) {
  let actions2 = parseKeyDef(this.config.keyboardMap, text);
  for (let i2 = 0; i2 < actions2.length; i2++)
    await wait(this.config), await keyboardAction(this, actions2[i2]);
}
async function keyboardAction(instance, { keyDef, releasePrevious, releaseSelf, repeat }) {
  let { system } = instance;
  if (system.keyboard.isKeyPressed(keyDef) && await system.keyboard.keyup(instance, keyDef), !releasePrevious) {
    for (let i2 = 1; i2 <= repeat; i2++)
      await system.keyboard.keydown(instance, keyDef), i2 < repeat && await wait(instance.config);
    releaseSelf && await system.keyboard.keyup(instance, keyDef);
  }
}
async function releaseAllKeys(instance) {
  for (let k2 of instance.system.keyboard.getPressedKeys())
    await instance.system.keyboard.keyup(instance, k2);
}

// ../node_modules/@testing-library/user-event/dist/esm/document/copySelection.js
function copySelection(target) {
  let data = hasOwnSelection(target) ? {
    "text/plain": readSelectedValueFromInput(target)
  } : {
    "text/plain": String(target.ownerDocument.getSelection())
  }, dt = createDataTransfer(getWindow(target));
  for (let type5 in data)
    data[type5] && dt.setData(type5, data[type5]);
  return dt;
}
function readSelectedValueFromInput(target) {
  let sel = getUISelection(target);
  return getUIValue(target).substring(sel.startOffset, sel.endOffset);
}

// ../node_modules/@testing-library/user-event/dist/esm/clipboard/copy.js
async function copy() {
  let doc = this.config.document;
  var _doc_activeElement;
  let target = (_doc_activeElement = doc.activeElement) !== null && _doc_activeElement !== void 0 ? _doc_activeElement : (
    /* istanbul ignore next */
    doc.body
  ), clipboardData = copySelection(target);
  if (clipboardData.items.length !== 0)
    return this.dispatchUIEvent(target, "copy", {
      clipboardData
    }) && this.config.writeToClipboard && await writeDataTransferToClipboard(doc, clipboardData), clipboardData;
}

// ../node_modules/@testing-library/user-event/dist/esm/clipboard/cut.js
async function cut() {
  let doc = this.config.document;
  var _doc_activeElement;
  let target = (_doc_activeElement = doc.activeElement) !== null && _doc_activeElement !== void 0 ? _doc_activeElement : (
    /* istanbul ignore next */
    doc.body
  ), clipboardData = copySelection(target);
  if (clipboardData.items.length !== 0)
    return this.dispatchUIEvent(target, "cut", {
      clipboardData
    }) && this.config.writeToClipboard && await writeDataTransferToClipboard(target.ownerDocument, clipboardData), clipboardData;
}

// ../node_modules/@testing-library/user-event/dist/esm/clipboard/paste.js
async function paste(clipboardData) {
  let doc = this.config.document;
  var _doc_activeElement;
  let target = (_doc_activeElement = doc.activeElement) !== null && _doc_activeElement !== void 0 ? _doc_activeElement : (
    /* istanbul ignore next */
    doc.body
  );
  var _ref;
  let dataTransfer = (_ref = typeof clipboardData == "string" ? getClipboardDataFromString(doc, clipboardData) : clipboardData) !== null && _ref !== void 0 ? _ref : await readDataTransferFromClipboard(doc).catch(() => {
    throw new Error("`userEvent.paste()` without `clipboardData` requires the `ClipboardAPI` to be available.");
  });
  this.dispatchUIEvent(target, "paste", {
    clipboardData: dataTransfer
  });
}
function getClipboardDataFromString(doc, text) {
  let dt = createDataTransfer(getWindow(doc));
  return dt.setData("text", text), dt;
}

// ../node_modules/@testing-library/user-event/dist/esm/pointer/parseKeyDef.js
function parseKeyDef2(pointerMap, keys2) {
  let defs = [];
  do {
    let { descriptor, consumedLength, releasePrevious, releaseSelf = !0 } = readNextDescriptor(keys2, "pointer"), keyDef = pointerMap.find((p2) => p2.name === descriptor);
    keyDef && defs.push({
      keyDef,
      releasePrevious,
      releaseSelf
    }), keys2 = keys2.slice(consumedLength);
  } while (keys2);
  return defs;
}

// ../node_modules/@testing-library/user-event/dist/esm/pointer/index.js
async function pointer(input2) {
  let { pointerMap } = this.config, actions2 = [];
  (Array.isArray(input2) ? input2 : [
    input2
  ]).forEach((actionInput) => {
    typeof actionInput == "string" ? actions2.push(...parseKeyDef2(pointerMap, actionInput)) : "keys" in actionInput ? actions2.push(...parseKeyDef2(pointerMap, actionInput.keys).map((i2) => ({
      ...actionInput,
      ...i2
    }))) : actions2.push(actionInput);
  });
  for (let i2 = 0; i2 < actions2.length; i2++)
    await wait(this.config), await pointerAction(this, actions2[i2]);
  this.system.pointer.resetClickCount();
}
async function pointerAction(instance, action2) {
  var _previousPosition_caret, _previousPosition_caret1;
  let pointerName = "pointerName" in action2 && action2.pointerName ? action2.pointerName : "keyDef" in action2 ? instance.system.pointer.getPointerName(action2.keyDef) : "mouse", previousPosition = instance.system.pointer.getPreviousPosition(pointerName);
  var _action_target, _action_coords, _action_node, _action_offset;
  let position = {
    target: (_action_target = action2.target) !== null && _action_target !== void 0 ? _action_target : getPrevTarget(instance, previousPosition),
    coords: (_action_coords = action2.coords) !== null && _action_coords !== void 0 ? _action_coords : previousPosition?.coords,
    caret: {
      node: (_action_node = action2.node) !== null && _action_node !== void 0 ? _action_node : hasCaretPosition(action2) || previousPosition == null || (_previousPosition_caret = previousPosition.caret) === null || _previousPosition_caret === void 0 ? void 0 : _previousPosition_caret.node,
      offset: (_action_offset = action2.offset) !== null && _action_offset !== void 0 ? _action_offset : hasCaretPosition(action2) || previousPosition == null || (_previousPosition_caret1 = previousPosition.caret) === null || _previousPosition_caret1 === void 0 ? void 0 : _previousPosition_caret1.offset
    }
  };
  "keyDef" in action2 ? (instance.system.pointer.isKeyPressed(action2.keyDef) && (setLevelRef(instance, ApiLevel.Trigger), await instance.system.pointer.release(instance, action2.keyDef, position)), action2.releasePrevious || (setLevelRef(instance, ApiLevel.Trigger), await instance.system.pointer.press(instance, action2.keyDef, position), action2.releaseSelf && (setLevelRef(instance, ApiLevel.Trigger), await instance.system.pointer.release(instance, action2.keyDef, position)))) : (setLevelRef(instance, ApiLevel.Trigger), await instance.system.pointer.move(instance, pointerName, position));
}
function hasCaretPosition(action2) {
  var _action_target, _ref;
  return !!((_ref = (_action_target = action2.target) !== null && _action_target !== void 0 ? _action_target : action2.node) !== null && _ref !== void 0 ? _ref : action2.offset !== void 0);
}
function getPrevTarget(instance, position) {
  if (!position)
    throw new Error("This pointer has no previous position. Provide a target property!");
  var _position_target;
  return (_position_target = position.target) !== null && _position_target !== void 0 ? _position_target : instance.config.document.body;
}

// ../node_modules/@testing-library/user-event/dist/esm/utility/clear.js
async function clear(element) {
  if (!isEditable(element) || isDisabled2(element))
    throw new Error("clear()` is only supported on editable elements.");
  if (focusElement(element), element.ownerDocument.activeElement !== element)
    throw new Error("The element to be cleared could not be focused.");
  if (selectAll(element), !isAllSelected(element))
    throw new Error("The element content to be cleared could not be selected.");
  input(this, element, "", "deleteContentBackward");
}

// ../node_modules/@testing-library/user-event/dist/esm/utility/selectOptions.js
async function selectOptions(select, values) {
  return selectOptionsBase.call(this, !0, select, values);
}
async function deselectOptions(select, values) {
  return selectOptionsBase.call(this, !1, select, values);
}
async function selectOptionsBase(newValue, select, values) {
  if (!newValue && !select.multiple)
    throw getConfig2().getElementError("Unable to deselect an option in a non-multiple select. Use selectOptions to change the selection instead.", select);
  let valArray = Array.isArray(values) ? values : [
    values
  ], allOptions = Array.from(select.querySelectorAll('option, [role="option"]')), selectedOptions = valArray.map((val) => {
    if (typeof val != "string" && allOptions.includes(val))
      return val;
    {
      let matchingOption = allOptions.find((o2) => o2.value === val || o2.innerHTML === val);
      if (matchingOption)
        return matchingOption;
      throw getConfig2().getElementError(`Value "${String(val)}" not found in options`, select);
    }
  }).filter((option) => !isDisabled2(option));
  if (isDisabled2(select) || !selectedOptions.length) return;
  let selectOption = (option) => {
    option.selected = newValue, this.dispatchUIEvent(select, "input", {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }), this.dispatchUIEvent(select, "change");
  };
  if (isElementType(select, "select"))
    if (select.multiple)
      for (let option of selectedOptions) {
        let withPointerEvents = this.config.pointerEventsCheck === 0 ? !0 : hasPointerEvents(this, option);
        withPointerEvents && (this.dispatchUIEvent(option, "pointerover"), this.dispatchUIEvent(select, "pointerenter"), this.dispatchUIEvent(option, "mouseover"), this.dispatchUIEvent(select, "mouseenter"), this.dispatchUIEvent(option, "pointermove"), this.dispatchUIEvent(option, "mousemove"), this.dispatchUIEvent(option, "pointerdown"), this.dispatchUIEvent(option, "mousedown")), focusElement(select), withPointerEvents && (this.dispatchUIEvent(option, "pointerup"), this.dispatchUIEvent(option, "mouseup")), selectOption(option), withPointerEvents && this.dispatchUIEvent(option, "click"), await wait(this.config);
      }
    else if (selectedOptions.length === 1) {
      let withPointerEvents = this.config.pointerEventsCheck === 0 ? !0 : hasPointerEvents(this, select);
      withPointerEvents ? await this.click(select) : focusElement(select), selectOption(selectedOptions[0]), withPointerEvents && (this.dispatchUIEvent(select, "pointerover"), this.dispatchUIEvent(select, "pointerenter"), this.dispatchUIEvent(select, "mouseover"), this.dispatchUIEvent(select, "mouseenter"), this.dispatchUIEvent(select, "pointerup"), this.dispatchUIEvent(select, "mouseup"), this.dispatchUIEvent(select, "click")), await wait(this.config);
    } else
      throw getConfig2().getElementError("Cannot select multiple options on a non-multiple select", select);
  else if (select.getAttribute("role") === "listbox")
    for (let option of selectedOptions)
      await this.click(option), await this.unhover(option);
  else
    throw getConfig2().getElementError("Cannot select options on elements that are neither select nor listbox elements", select);
}

// ../node_modules/@testing-library/user-event/dist/esm/utility/type.js
async function type3(element, text, { skipClick = this.config.skipClick, skipAutoClose = this.config.skipAutoClose, initialSelectionStart, initialSelectionEnd } = {}) {
  element.disabled || (skipClick || await this.click(element), initialSelectionStart !== void 0 && setSelectionRange(element, initialSelectionStart, initialSelectionEnd ?? initialSelectionStart), await this.keyboard(text), skipAutoClose || await releaseAllKeys(this));
}

// ../node_modules/@testing-library/user-event/dist/esm/utils/edit/setFiles.js
var fakeFiles = Symbol("files and value properties are mocked");
function restoreProperty(obj, prop, descriptor) {
  descriptor ? Object.defineProperty(obj, prop, descriptor) : delete obj[prop];
}
function setFiles(el, files) {
  var _el_fakeFiles;
  (_el_fakeFiles = el[fakeFiles]) === null || _el_fakeFiles === void 0 || _el_fakeFiles.restore();
  let typeDescr = Object.getOwnPropertyDescriptor(el, "type"), valueDescr = Object.getOwnPropertyDescriptor(el, "value"), filesDescr = Object.getOwnPropertyDescriptor(el, "files");
  function restore() {
    restoreProperty(el, "type", typeDescr), restoreProperty(el, "value", valueDescr), restoreProperty(el, "files", filesDescr);
  }
  el[fakeFiles] = {
    restore
  }, Object.defineProperties(el, {
    files: {
      configurable: !0,
      get: () => files
    },
    value: {
      configurable: !0,
      get: () => files.length ? `C:\\fakepath\\${files[0].name}` : "",
      set(v2) {
        if (v2 === "")
          restore();
        else {
          var _valueDescr_set;
          valueDescr == null || (_valueDescr_set = valueDescr.set) === null || _valueDescr_set === void 0 || _valueDescr_set.call(el, v2);
        }
      }
    },
    type: {
      configurable: !0,
      get: () => "file",
      set(v2) {
        v2 !== "file" && (restore(), el.type = v2);
      }
    }
  });
}

// ../node_modules/@testing-library/user-event/dist/esm/utility/upload.js
async function upload(element, fileOrFiles) {
  let input2 = isElementType(element, "label") ? element.control : element;
  if (!input2 || !isElementType(input2, "input", {
    type: "file"
  }))
    throw new TypeError(`The ${input2 === element ? "given" : "associated"} ${input2?.tagName} element does not accept file uploads`);
  if (isDisabled2(element)) return;
  let files = (Array.isArray(fileOrFiles) ? fileOrFiles : [
    fileOrFiles
  ]).filter((file) => !this.config.applyAccept || isAcceptableFile(file, input2.accept)).slice(0, input2.multiple ? void 0 : 1), fileDialog = () => {
    var _input_files;
    files.length === ((_input_files = input2.files) === null || _input_files === void 0 ? void 0 : _input_files.length) && files.every((f4, i2) => {
      var _input_files2;
      return f4 === ((_input_files2 = input2.files) === null || _input_files2 === void 0 ? void 0 : _input_files2.item(i2));
    }) || (setFiles(input2, createFileList(getWindow(element), files)), this.dispatchUIEvent(input2, "input"), this.dispatchUIEvent(input2, "change"));
  };
  input2.addEventListener("fileDialog", fileDialog), await this.click(element), input2.removeEventListener("fileDialog", fileDialog);
}
function normalize3(nameOrType) {
  return nameOrType.toLowerCase().replace(/(\.|\/)jpg\b/g, "$1jpeg");
}
function isAcceptableFile(file, accept) {
  if (!accept)
    return !0;
  let wildcards = [
    "audio/*",
    "image/*",
    "video/*"
  ];
  return normalize3(accept).trim().split(/\s*,\s*/).some((acceptToken) => acceptToken.startsWith(".") ? normalize3(file.name).endsWith(acceptToken) : wildcards.includes(acceptToken) ? normalize3(file.type).startsWith(acceptToken.replace("*", "")) : normalize3(file.type) === acceptToken);
}

// ../node_modules/@testing-library/user-event/dist/esm/setup/api.js
var userEventApi = {
  click,
  dblClick,
  tripleClick,
  hover,
  unhover,
  tab,
  keyboard,
  copy,
  cut,
  paste,
  pointer,
  clear,
  deselectOptions,
  selectOptions,
  type: type3,
  upload
};

// ../node_modules/@testing-library/user-event/dist/esm/setup/wrapAsync.js
function wrapAsync(implementation) {
  return getConfig2().asyncWrapper(implementation);
}

// ../node_modules/@testing-library/user-event/dist/esm/setup/setup.js
var defaultOptionsDirect = {
  applyAccept: !0,
  autoModify: !0,
  delay: 0,
  document: globalThis.document,
  keyboardMap: defaultKeyMap,
  pointerMap: defaultKeyMap2,
  pointerEventsCheck: PointerEventsCheckLevel.EachApiCall,
  skipAutoClose: !1,
  skipClick: !1,
  skipHover: !1,
  writeToClipboard: !1,
  advanceTimers: () => Promise.resolve()
}, defaultOptionsSetup = {
  ...defaultOptionsDirect,
  writeToClipboard: !0
};
function createConfig(options = {}, defaults = defaultOptionsSetup, node) {
  let document7 = getDocument2(options, node, defaults);
  return {
    ...defaults,
    ...options,
    document: document7
  };
}
function setupMain(options = {}) {
  let config4 = createConfig(options);
  prepareDocument(config4.document), patchFocus(getWindow(config4.document).HTMLElement);
  var _config_document_defaultView;
  let view = (_config_document_defaultView = config4.document.defaultView) !== null && _config_document_defaultView !== void 0 ? _config_document_defaultView : (
    /* istanbul ignore next */
    globalThis.window
  );
  return attachClipboardStubToView(view), createInstance(config4).api;
}
function setupDirect({ keyboardState, pointerState, ...options } = {}, node) {
  let config4 = createConfig(options, defaultOptionsDirect, node);
  prepareDocument(config4.document), patchFocus(getWindow(config4.document).HTMLElement);
  var _ref;
  let system = (_ref = pointerState ?? keyboardState) !== null && _ref !== void 0 ? _ref : new System();
  return {
    api: createInstance(config4, system).api,
    system
  };
}
function setupSub(options) {
  return createInstance({
    ...this.config,
    ...options
  }, this.system).api;
}
function wrapAndBindImpl(instance, impl) {
  function method(...args) {
    return setLevelRef(instance, ApiLevel.Call), wrapAsync(() => impl.apply(instance, args).then(async (ret) => (await wait(instance.config), ret)));
  }
  return Object.defineProperty(method, "name", {
    get: () => impl.name
  }), method;
}
function createInstance(config4, system = new System()) {
  let instance = {};
  return Object.assign(instance, {
    config: config4,
    dispatchEvent: dispatchEvent.bind(instance),
    dispatchUIEvent: dispatchUIEvent.bind(instance),
    system,
    levelRefs: {},
    ...userEventApi
  }), {
    instance,
    api: {
      ...Object.fromEntries(Object.entries(userEventApi).map(([name, api]) => [
        name,
        wrapAndBindImpl(instance, api)
      ])),
      setup: setupSub.bind(instance)
    }
  };
}
function getDocument2(options, node, defaults) {
  var _options_document, _ref;
  return (_ref = (_options_document = options.document) !== null && _options_document !== void 0 ? _options_document : node && getDocumentFromNode(node)) !== null && _ref !== void 0 ? _ref : defaults.document;
}

// ../node_modules/@testing-library/user-event/dist/esm/setup/directApi.js
var directApi_exports = {};
__export(directApi_exports, {
  clear: () => clear2,
  click: () => click2,
  copy: () => copy2,
  cut: () => cut2,
  dblClick: () => dblClick2,
  deselectOptions: () => deselectOptions2,
  hover: () => hover2,
  keyboard: () => keyboard2,
  paste: () => paste2,
  pointer: () => pointer2,
  selectOptions: () => selectOptions2,
  tab: () => tab2,
  tripleClick: () => tripleClick2,
  type: () => type4,
  unhover: () => unhover2,
  upload: () => upload2
});
function clear2(element) {
  return setupDirect().api.clear(element);
}
function click2(element, options = {}) {
  return setupDirect(options, element).api.click(element);
}
function copy2(options = {}) {
  return setupDirect(options).api.copy();
}
function cut2(options = {}) {
  return setupDirect(options).api.cut();
}
function dblClick2(element, options = {}) {
  return setupDirect(options).api.dblClick(element);
}
function deselectOptions2(select, values, options = {}) {
  return setupDirect(options).api.deselectOptions(select, values);
}
function hover2(element, options = {}) {
  return setupDirect(options).api.hover(element);
}
async function keyboard2(text, options = {}) {
  let { api, system } = setupDirect(options);
  return api.keyboard(text).then(() => system);
}
async function pointer2(input2, options = {}) {
  let { api, system } = setupDirect(options);
  return api.pointer(input2).then(() => system);
}
function paste2(clipboardData, options) {
  return setupDirect(options).api.paste(clipboardData);
}
function selectOptions2(select, values, options = {}) {
  return setupDirect(options).api.selectOptions(select, values);
}
function tripleClick2(element, options = {}) {
  return setupDirect(options).api.tripleClick(element);
}
function type4(element, text, options = {}) {
  return setupDirect(options, element).api.type(element, text, options);
}
function unhover2(element, options = {}) {
  let { api, system } = setupDirect(options);
  return system.pointer.setMousePosition({
    target: element
  }), api.unhover(element);
}
function upload2(element, fileOrFiles, options = {}) {
  return setupDirect(options).api.upload(element, fileOrFiles);
}
function tab2(options = {}) {
  return setupDirect().api.tab(options);
}

// ../node_modules/@testing-library/user-event/dist/esm/setup/index.js
var userEvent = {
  ...directApi_exports,
  setup: setupMain
};

// src/test/testing-library.ts
var testingLibrary = instrument(
  { ...dom_esm_exports },
  {
    getKeys: (obj) => Object.keys(obj).filter((key) => key !== "eventWrapper"),
    intercept: (method, path) => path[0] === "fireEvent" || method.startsWith("find") || method.startsWith("waitFor")
  }
);
testingLibrary.screen = new Proxy(testingLibrary.screen, {
  get(target, prop, receiver) {
    return typeof window < "u" && globalThis.location?.href?.includes("viewMode=docs") && once.warn(dedent`
        You are using Testing Library's \`screen\` object while the story is rendered in docs mode. This will likely lead to issues, as multiple stories are rendered in the same page and therefore screen will potentially find multiple elements. Use the \`canvas\` utility from the story context instead, which will scope the queries to each story's canvas.

        More info: https://storybook.js.org/docs/writing-tests/interaction-testing?ref=error#querying-the-canvas
      `), Reflect.get(target, prop, receiver);
  }
});
var {
  buildQueries: buildQueries2,
  configure: configure2,
  createEvent: createEvent3,
  fireEvent: fireEvent2,
  findAllByAltText: findAllByAltText2,
  findAllByDisplayValue: findAllByDisplayValue2,
  findAllByLabelText: findAllByLabelText2,
  findAllByPlaceholderText: findAllByPlaceholderText2,
  findAllByRole: findAllByRole2,
  findAllByTestId: findAllByTestId2,
  findAllByText: findAllByText2,
  findAllByTitle: findAllByTitle2,
  findByAltText: findByAltText2,
  findByDisplayValue: findByDisplayValue2,
  findByLabelText: findByLabelText2,
  findByPlaceholderText: findByPlaceholderText2,
  findByRole: findByRole2,
  findByTestId: findByTestId2,
  findByText: findByText2,
  findByTitle: findByTitle2,
  getAllByAltText: getAllByAltText2,
  getAllByDisplayValue: getAllByDisplayValue2,
  getAllByLabelText: getAllByLabelText2,
  getAllByPlaceholderText: getAllByPlaceholderText2,
  getAllByRole: getAllByRole2,
  getAllByTestId: getAllByTestId2,
  getAllByText: getAllByText2,
  getAllByTitle: getAllByTitle2,
  getByAltText: getByAltText2,
  getByDisplayValue: getByDisplayValue2,
  getByLabelText: getByLabelText2,
  getByPlaceholderText: getByPlaceholderText2,
  getByRole: getByRole2,
  getByTestId: getByTestId2,
  getByText: getByText2,
  getByTitle: getByTitle2,
  getConfig: getConfig3,
  getDefaultNormalizer: getDefaultNormalizer2,
  getElementError: getElementError2,
  getNodeText: getNodeText2,
  getQueriesForElement: getQueriesForElement2,
  getRoles: getRoles2,
  getSuggestedQuery: getSuggestedQuery2,
  isInaccessible: isInaccessible2,
  logDOM: logDOM2,
  logRoles: logRoles2,
  prettyDOM: prettyDOM2,
  queries: queries2,
  queryAllByAltText: queryAllByAltText2,
  queryAllByAttribute: queryAllByAttribute2,
  queryAllByDisplayValue: queryAllByDisplayValue2,
  queryAllByLabelText: queryAllByLabelText2,
  queryAllByPlaceholderText: queryAllByPlaceholderText2,
  queryAllByRole: queryAllByRole2,
  queryAllByTestId: queryAllByTestId2,
  queryAllByText: queryAllByText2,
  queryAllByTitle: queryAllByTitle2,
  queryByAltText: queryByAltText2,
  queryByAttribute: queryByAttribute2,
  queryByDisplayValue: queryByDisplayValue2,
  queryByLabelText: queryByLabelText2,
  queryByPlaceholderText: queryByPlaceholderText2,
  queryByRole: queryByRole2,
  queryByTestId: queryByTestId2,
  queryByText: queryByText2,
  queryByTitle: queryByTitle2,
  queryHelpers: queryHelpers2,
  screen: screen2,
  waitFor: waitFor2,
  waitForElementToBeRemoved: waitForElementToBeRemoved2,
  within,
  prettyFormat: prettyFormat2
} = testingLibrary, uninstrumentedUserEvent = userEvent, { userEvent: userEvent2 } = instrument(
  { userEvent },
  { intercept: !0, getKeys: (obj) => Object.keys(obj).filter((key) => key !== "eventWrapper") }
);

// src/test/index.ts
var { expect: expect3 } = instrument(
  { expect: expect2 },
  {
    getKeys: (obj, depth) => {
      if ("constructor" in obj && obj.constructor === Assertion) {
        let privateApi = ["assert", "__methods", "__flags", "_obj"], keys2 = Object.keys(Object.getPrototypeOf(obj)).filter(
          (it) => !privateApi.includes(it)
        );
        return depth > 2 ? keys2 : [...keys2, "not"];
      }
      return "any" in obj ? Object.keys(obj).filter((it) => it !== "any") : Object.keys(obj);
    },
    mutate: !0,
    intercept: (method) => method !== "expect"
  }
), sb = {
  mock: () => {
  }
};

// src/actions/loaders.ts
var subscribed = !1, logActionsWhenMockCalled = (context) => {
  let { parameters: parameters2 } = context;
  parameters2?.actions?.disable || subscribed || (onMockCall((mock, args) => {
    let name = mock.getMockName();
    name !== "spy" && name !== "vi.fn()" && (!/^next\/.*::/.test(name) || [
      "next/router::useRouter()",
      "next/navigation::useRouter()",
      "next/navigation::redirect",
      "next/cache::",
      "next/headers::cookies().set",
      "next/headers::cookies().delete",
      "next/headers::headers().set",
      "next/headers::headers().delete"
    ].some((prefix2) => name.startsWith(prefix2))) && action(name)(args);
  }), subscribed = !0);
}, loaders = [logActionsWhenMockCalled];

// src/actions/preview.ts
var preview_default = () => ({
  ...addArgs_exports,
  ...loaders_exports
});

// src/backgrounds/constants.ts
var ADDON_ID2 = "storybook/background", PARAM_KEY2 = "backgrounds";
var EVENTS2 = {
  UPDATE: `${ADDON_ID2}/update`
};

// src/backgrounds/defaults.ts
var DEFAULT_BACKGROUNDS = {
  light: { name: "light", value: "#F8F8F8" },
  dark: { name: "dark", value: "#333" }
};

// src/backgrounds/utils.ts
var { document: document3 } = globalThis, isReduceMotionEnabled = () => globalThis?.matchMedia ? !!globalThis.matchMedia("(prefers-reduced-motion: reduce)")?.matches : !1, clearStyles = (selector) => {
  (Array.isArray(selector) ? selector : [selector]).forEach(clearStyle);
}, clearStyle = (selector) => {
  if (!document3)
    return;
  let element = document3.getElementById(selector);
  element && element.parentElement && element.parentElement.removeChild(element);
}, addGridStyle = (selector, css) => {
  if (!document3)
    return;
  let existingStyle = document3.getElementById(selector);
  if (existingStyle)
    existingStyle.innerHTML !== css && (existingStyle.innerHTML = css);
  else {
    let style = document3.createElement("style");
    style.setAttribute("id", selector), style.innerHTML = css, document3.head.appendChild(style);
  }
}, addBackgroundStyle = (selector, css, storyId) => {
  if (!document3)
    return;
  let existingStyle = document3.getElementById(selector);
  if (existingStyle)
    existingStyle.innerHTML !== css && (existingStyle.innerHTML = css);
  else {
    let style = document3.createElement("style");
    style.setAttribute("id", selector), style.innerHTML = css;
    let gridStyleSelector = `addon-backgrounds-grid${storyId ? `-docs-${storyId}` : ""}`, existingGridStyle = document3.getElementById(gridStyleSelector);
    existingGridStyle ? existingGridStyle.parentElement?.insertBefore(style, existingGridStyle) : document3.head.appendChild(style);
  }
};

// src/backgrounds/decorator.ts
var defaultGrid = {
  cellSize: 100,
  cellAmount: 10,
  opacity: 0.8
}, BG_SELECTOR_BASE = "addon-backgrounds", GRID_SELECTOR_BASE = "addon-backgrounds-grid", transitionStyle = isReduceMotionEnabled() ? "" : "transition: background-color 0.3s;", withBackgroundAndGrid = (StoryFn, context) => {
  let { globals = {}, parameters: parameters2 = {}, viewMode, id } = context, {
    options = DEFAULT_BACKGROUNDS,
    disable,
    grid = defaultGrid
  } = parameters2[PARAM_KEY2] || {}, data = globals[PARAM_KEY2] || {}, backgroundName = typeof data == "string" ? data : data?.value, item = backgroundName ? options[backgroundName] : void 0, value = typeof item == "string" ? item : item?.value || "transparent", showGrid = typeof data == "string" ? !1 : data.grid || !1, shownBackground = !!item && !disable, backgroundSelector = viewMode === "docs" ? `#anchor--${id} .docs-story` : ".sb-show-main", gridSelector = viewMode === "docs" ? `#anchor--${id} .docs-story` : ".sb-show-main", isLayoutPadded = parameters2.layout === void 0 || parameters2.layout === "padded", defaultOffset = viewMode === "docs" ? 20 : isLayoutPadded ? 16 : 0, { cellAmount, cellSize, opacity, offsetX = defaultOffset, offsetY = defaultOffset } = grid, backgroundSelectorId = viewMode === "docs" ? `${BG_SELECTOR_BASE}-docs-${id}` : `${BG_SELECTOR_BASE}-color`, backgroundTarget = viewMode === "docs" ? id : null;
  useEffect(() => {
    let backgroundStyles = `
    ${backgroundSelector} {
      background: ${value} !important;
      ${transitionStyle}
      }`;
    if (!shownBackground) {
      clearStyles(backgroundSelectorId);
      return;
    }
    addBackgroundStyle(backgroundSelectorId, backgroundStyles, backgroundTarget);
  }, [backgroundSelector, backgroundSelectorId, backgroundTarget, shownBackground, value]);
  let gridSelectorId = viewMode === "docs" ? `${GRID_SELECTOR_BASE}-docs-${id}` : `${GRID_SELECTOR_BASE}`;
  return useEffect(() => {
    if (!showGrid) {
      clearStyles(gridSelectorId);
      return;
    }
    let gridSize = [
      `${cellSize * cellAmount}px ${cellSize * cellAmount}px`,
      `${cellSize * cellAmount}px ${cellSize * cellAmount}px`,
      `${cellSize}px ${cellSize}px`,
      `${cellSize}px ${cellSize}px`
    ].join(", "), gridStyles = `
        ${gridSelector} {
          background-size: ${gridSize} !important;
          background-position: ${offsetX}px ${offsetY}px, ${offsetX}px ${offsetY}px, ${offsetX}px ${offsetY}px, ${offsetX}px ${offsetY}px !important;
          background-blend-mode: difference !important;
          background-image: linear-gradient(rgba(130, 130, 130, ${opacity}) 1px, transparent 1px),
           linear-gradient(90deg, rgba(130, 130, 130, ${opacity}) 1px, transparent 1px),
           linear-gradient(rgba(130, 130, 130, ${opacity / 2}) 1px, transparent 1px),
           linear-gradient(90deg, rgba(130, 130, 130, ${opacity / 2}) 1px, transparent 1px) !important;
        }
      `;
    addGridStyle(gridSelectorId, gridStyles);
  }, [cellAmount, cellSize, gridSelector, gridSelectorId, showGrid, offsetX, offsetY, opacity]), StoryFn();
};

// src/backgrounds/preview.ts
var decorators = globalThis.FEATURES?.backgrounds ? [withBackgroundAndGrid] : [], parameters = {
  [PARAM_KEY2]: {
    grid: {
      cellSize: 20,
      opacity: 0.5,
      cellAmount: 5
    },
    disable: !1
  }
}, initialGlobals = {
  [PARAM_KEY2]: { value: void 0, grid: !1 }
}, preview_default2 = () => ({
  decorators,
  parameters,
  initialGlobals
});

// src/component-testing/preview.ts
var { step } = instrument(
  {
    // It seems like the label is unused, but the instrumenter has access to it
    // The context will be bounded later in StoryRender, so that the user can write just:
    // await step("label", (context) => {
    //   // labeled step
    // });
    step: async (label, play, context) => play(context)
  },
  { intercept: !0 }
), preview_default3 = () => ({
  parameters: {
    throwPlayFunctionExceptions: !1
  },
  runStep: step
});

// src/highlight/constants.ts
var ADDON_ID3 = "storybook/highlight", HIGHLIGHT = `${ADDON_ID3}/add`, REMOVE_HIGHLIGHT = `${ADDON_ID3}/remove`, RESET_HIGHLIGHT = `${ADDON_ID3}/reset`, SCROLL_INTO_VIEW = `${ADDON_ID3}/scroll-into-view`, MAX_Z_INDEX = 2147483647, MIN_TOUCH_AREA_SIZE = 28;

// src/highlight/icons.ts
var iconPaths = {
  chevronLeft: [
    "M9.10355 10.1464C9.29882 10.3417 9.29882 10.6583 9.10355 10.8536C8.90829 11.0488 8.59171 11.0488 8.39645 10.8536L4.89645 7.35355C4.70118 7.15829 4.70118 6.84171 4.89645 6.64645L8.39645 3.14645C8.59171 2.95118 8.90829 2.95118 9.10355 3.14645C9.29882 3.34171 9.29882 3.65829 9.10355 3.85355L5.95711 7L9.10355 10.1464Z"
  ],
  chevronRight: [
    "M4.89645 10.1464C4.70118 10.3417 4.70118 10.6583 4.89645 10.8536C5.09171 11.0488 5.40829 11.0488 5.60355 10.8536L9.10355 7.35355C9.29882 7.15829 9.29882 6.84171 9.10355 6.64645L5.60355 3.14645C5.40829 2.95118 5.09171 2.95118 4.89645 3.14645C4.70118 3.34171 4.70118 3.65829 4.89645 3.85355L8.04289 7L4.89645 10.1464Z"
  ],
  info: [
    "M7 5.5a.5.5 0 01.5.5v4a.5.5 0 01-1 0V6a.5.5 0 01.5-.5zM7 4.5A.75.75 0 107 3a.75.75 0 000 1.5z",
    "M7 14A7 7 0 107 0a7 7 0 000 14zm0-1A6 6 0 107 1a6 6 0 000 12z"
  ],
  shareAlt: [
    "M2 1.004a1 1 0 00-1 1v10a1 1 0 001 1h10a1 1 0 001-1v-4.5a.5.5 0 00-1 0v4.5H2v-10h4.5a.5.5 0 000-1H2z",
    "M7.354 7.357L12 2.711v1.793a.5.5 0 001 0v-3a.5.5 0 00-.5-.5h-3a.5.5 0 100 1h1.793L6.646 6.65a.5.5 0 10.708.707z"
  ]
};

// src/highlight/utils.ts
var svgElements = "svg,path,rect,circle,line,polyline,polygon,ellipse,text".split(","), createElement = (type5, props = {}, children) => {
  let element = svgElements.includes(type5) ? document.createElementNS("http://www.w3.org/2000/svg", type5) : document.createElement(type5);
  return Object.entries(props).forEach(([key, val]) => {
    /[A-Z]/.test(key) ? (key === "onClick" && (element.addEventListener("click", val), element.addEventListener("keydown", (e2) => {
      (e2.key === "Enter" || e2.key === " ") && (e2.preventDefault(), val());
    })), key === "onMouseEnter" && element.addEventListener("mouseenter", val), key === "onMouseLeave" && element.addEventListener("mouseleave", val)) : element.setAttribute(key, val);
  }), children?.forEach((child) => {
    if (!(child == null || child === !1))
      try {
        element.appendChild(child);
      } catch {
        element.appendChild(document.createTextNode(String(child)));
      }
  }), element;
}, createIcon = (name) => iconPaths[name] && createElement(
  "svg",
  { width: "14", height: "14", viewBox: "0 0 14 14", xmlns: "http://www.w3.org/2000/svg" },
  iconPaths[name].map(
    (d) => createElement("path", {
      fill: "currentColor",
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d
    })
  )
), normalizeOptions = (options) => {
  if ("elements" in options) {
    let { elements, color, style } = options;
    return {
      id: void 0,
      priority: 0,
      selectors: elements,
      styles: {
        outline: `2px ${style} ${color}`,
        outlineOffset: "2px",
        boxShadow: "0 0 0 6px rgba(255,255,255,0.6)"
      },
      menu: void 0
    };
  }
  let { menu, ...rest } = options;
  return {
    id: void 0,
    priority: 0,
    styles: {
      outline: "2px dashed #029cfd"
    },
    ...rest,
    menu: Array.isArray(menu) ? menu.every(Array.isArray) ? menu : [menu] : void 0
  };
}, isFunction2 = (obj) => obj instanceof Function, state = /* @__PURE__ */ new Map(), listeners2 = /* @__PURE__ */ new Map(), teardowns = /* @__PURE__ */ new Map(), useStore = (initialValue2) => {
  let key = Symbol();
  return listeners2.set(key, []), state.set(key, initialValue2), { get: () => state.get(key), set: (update) => {
    let current = state.get(key), next = isFunction2(update) ? update(current) : update;
    next !== current && (state.set(key, next), listeners2.get(key)?.forEach((listener) => {
      teardowns.get(listener)?.(), teardowns.set(listener, listener(next));
    }));
  }, subscribe: (listener) => (listeners2.get(key)?.push(listener), () => {
    let list = listeners2.get(key);
    list && listeners2.set(
      key,
      list.filter((l2) => l2 !== listener)
    );
  }), teardown: () => {
    listeners2.get(key)?.forEach((listener) => {
      teardowns.get(listener)?.(), teardowns.delete(listener);
    }), listeners2.delete(key), state.delete(key);
  } };
}, mapElements = (highlights) => {
  let root2 = document.getElementById("storybook-root"), map2 = /* @__PURE__ */ new Map();
  for (let highlight of highlights) {
    let { priority = 0 } = highlight;
    for (let selector of highlight.selectors) {
      let elements = [
        ...document.querySelectorAll(
          // Elements matching the selector, excluding storybook elements and their descendants.
          // Necessary to find portaled elements (e.g. children of `body`).
          `:is(${selector}):not([id^="storybook-"], [id^="storybook-"] *, [class^="sb-"], [class^="sb-"] *)`
        ),
        // Elements matching the selector inside the storybook root, as these were excluded above.
        ...root2?.querySelectorAll(selector) || []
      ];
      for (let element of elements) {
        let existing = map2.get(element);
        (!existing || existing.priority <= priority) && map2.set(element, {
          ...highlight,
          priority,
          selectors: Array.from(new Set((existing?.selectors || []).concat(selector)))
        });
      }
    }
  }
  return map2;
}, mapBoxes = (elements) => Array.from(elements.entries()).map(([element, { selectors, styles: styles3, hoverStyles, focusStyles, menu }]) => {
  let { top, left, width, height } = element.getBoundingClientRect(), { position } = getComputedStyle(element);
  return {
    element,
    selectors,
    styles: styles3,
    hoverStyles,
    focusStyles,
    menu,
    top: position === "fixed" ? top : top + window.scrollY,
    left: position === "fixed" ? left : left + window.scrollX,
    width,
    height
  };
}).sort((a2, b2) => b2.width * b2.height - a2.width * a2.height), isOverMenu = (menuElement, coordinates) => {
  let menu = menuElement.getBoundingClientRect(), { x: x2, y: y2 } = coordinates;
  return menu?.top && menu?.left && x2 >= menu.left && x2 <= menu.left + menu.width && y2 >= menu.top && y2 <= menu.top + menu.height;
}, isTargeted = (box, boxElement, coordinates) => {
  if (!boxElement || !coordinates)
    return !1;
  let { left, top, width, height } = box;
  height < MIN_TOUCH_AREA_SIZE && (top = top - Math.round((MIN_TOUCH_AREA_SIZE - height) / 2), height = MIN_TOUCH_AREA_SIZE), width < MIN_TOUCH_AREA_SIZE && (left = left - Math.round((MIN_TOUCH_AREA_SIZE - width) / 2), width = MIN_TOUCH_AREA_SIZE), boxElement.style.position === "fixed" && (left += window.scrollX, top += window.scrollY);
  let { x: x2, y: y2 } = coordinates;
  return x2 >= left && x2 <= left + width && y2 >= top && y2 <= top + height;
}, keepInViewport = (element, targetCoordinates, options = {}) => {
  let { x: x2, y: y2 } = targetCoordinates, { margin = 5, topOffset = 0, centered = !1 } = options, { scrollX, scrollY, innerHeight: windowHeight, innerWidth: windowWidth } = window, top = Math.min(
    element.style.position === "fixed" ? y2 - scrollY : y2,
    windowHeight - element.clientHeight - margin - topOffset + scrollY
  ), leftOffset = centered ? element.clientWidth / 2 : 0, left = element.style.position === "fixed" ? Math.max(Math.min(x2 - scrollX, windowWidth - leftOffset - margin), leftOffset + margin) : Math.max(
    Math.min(x2, windowWidth - leftOffset - margin + scrollX),
    leftOffset + margin + scrollX
  );
  Object.assign(element.style, {
    ...left !== x2 && { left: `${left}px` },
    ...top !== y2 && { top: `${top}px` }
  });
}, showPopover = (element) => {
  window.HTMLElement.prototype.hasOwnProperty("showPopover") && element.showPopover();
}, hidePopover = (element) => {
  window.HTMLElement.prototype.hasOwnProperty("showPopover") && element.hidePopover();
}, getEventDetails = (target) => ({
  top: target.top,
  left: target.left,
  width: target.width,
  height: target.height,
  selectors: target.selectors,
  element: {
    attributes: Object.fromEntries(
      Array.from(target.element.attributes).map((attr) => [attr.name, attr.value])
    ),
    localName: target.element.localName,
    tagName: target.element.tagName,
    outerHTML: target.element.outerHTML
  }
});

// src/highlight/useHighlights.ts
var menuId = "storybook-highlights-menu", rootId = "storybook-highlights-root", storybookRootId = "storybook-root", useHighlights = (channel) => {
  if (globalThis.__STORYBOOK_HIGHLIGHT_INITIALIZED)
    return;
  globalThis.__STORYBOOK_HIGHLIGHT_INITIALIZED = !0;
  let { document: document7 } = globalThis, highlights = useStore([]), elements = useStore(/* @__PURE__ */ new Map()), boxes = useStore([]), clickCoords = useStore(), hoverCoords = useStore(), targets = useStore([]), hovered = useStore([]), focused = useStore(), selected = useStore(), root2 = document7.getElementById(rootId);
  highlights.subscribe(() => {
    root2 || (root2 = createElement("div", { id: rootId }), document7.body.appendChild(root2));
  }), highlights.subscribe((value) => {
    let storybookRoot = document7.getElementById(storybookRootId);
    if (!storybookRoot)
      return;
    elements.set(mapElements(value));
    let observer = new MutationObserver(() => elements.set(mapElements(value)));
    return observer.observe(storybookRoot, { subtree: !0, childList: !0 }), () => {
      observer.disconnect();
    };
  }), elements.subscribe((value) => {
    let updateBoxes = () => requestAnimationFrame(() => boxes.set(mapBoxes(value))), observer = new ResizeObserver(updateBoxes);
    observer.observe(document7.body), Array.from(value.keys()).forEach((element) => observer.observe(element));
    let scrollers = Array.from(document7.body.querySelectorAll("*")).filter((el) => {
      let { overflow, overflowX, overflowY } = window.getComputedStyle(el);
      return ["auto", "scroll"].some((o2) => [overflow, overflowX, overflowY].includes(o2));
    });
    return scrollers.forEach((element) => element.addEventListener("scroll", updateBoxes)), () => {
      observer.disconnect(), scrollers.forEach((element) => element.removeEventListener("scroll", updateBoxes));
    };
  }), elements.subscribe((value) => {
    let sticky = Array.from(value.keys()).filter(({ style }) => style.position === "sticky"), updateBoxes = () => requestAnimationFrame(() => {
      boxes.set(
        (current) => current.map((box) => {
          if (sticky.includes(box.element)) {
            let { top, left } = box.element.getBoundingClientRect();
            return { ...box, top: top + window.scrollY, left: left + window.scrollX };
          }
          return box;
        })
      );
    });
    return document7.addEventListener("scroll", updateBoxes), () => document7.removeEventListener("scroll", updateBoxes);
  }), elements.subscribe((value) => {
    targets.set((t2) => t2.filter(({ element }) => value.has(element)));
  }), targets.subscribe((value) => {
    value.length ? (selected.set((s3) => value.some((t2) => t2.element === s3?.element) ? s3 : void 0), focused.set((s3) => value.some((t2) => t2.element === s3?.element) ? s3 : void 0)) : (selected.set(void 0), focused.set(void 0), clickCoords.set(void 0));
  });
  let styleElementByHighlight = new Map(/* @__PURE__ */ new Map());
  highlights.subscribe((value) => {
    value.forEach(({ keyframes }) => {
      if (keyframes) {
        let style = styleElementByHighlight.get(keyframes);
        style || (style = document7.createElement("style"), style.setAttribute("data-highlight", "keyframes"), styleElementByHighlight.set(keyframes, style), document7.head.appendChild(style)), style.innerHTML = keyframes;
      }
    }), styleElementByHighlight.forEach((style, keyframes) => {
      value.some((v2) => v2.keyframes === keyframes) || (style.remove(), styleElementByHighlight.delete(keyframes));
    });
  });
  let boxElementByTargetElement = new Map(/* @__PURE__ */ new Map());
  boxes.subscribe((value) => {
    value.forEach((box) => {
      let boxElement = boxElementByTargetElement.get(box.element);
      if (root2 && !boxElement) {
        let props = {
          popover: "manual",
          "data-highlight-dimensions": `w${box.width.toFixed(0)}h${box.height.toFixed(0)}`,
          "data-highlight-coordinates": `x${box.left.toFixed(0)}y${box.top.toFixed(0)}`
        };
        boxElement = root2.appendChild(
          createElement("div", props, [createElement("div")])
        ), boxElementByTargetElement.set(box.element, boxElement);
      }
    }), boxElementByTargetElement.forEach((box, element) => {
      value.some(({ element: e2 }) => e2 === element) || (box.remove(), boxElementByTargetElement.delete(element));
    });
  }), boxes.subscribe((value) => {
    let targetable = value.filter((box) => box.menu);
    if (!targetable.length)
      return;
    let onClick = (event) => {
      requestAnimationFrame(() => {
        let menu = document7.getElementById(menuId), coords = { x: event.pageX, y: event.pageY };
        if (menu && !isOverMenu(menu, coords)) {
          let results = targetable.filter((box) => {
            let boxElement = boxElementByTargetElement.get(box.element);
            return isTargeted(box, boxElement, coords);
          });
          clickCoords.set(results.length ? coords : void 0), targets.set(results);
        }
      });
    };
    return document7.addEventListener("click", onClick), () => document7.removeEventListener("click", onClick);
  });
  let updateHovered = () => {
    let menu = document7.getElementById(menuId), coords = hoverCoords.get();
    !coords || menu && isOverMenu(menu, coords) || hovered.set((current) => {
      let update = boxes.get().filter((box) => {
        let boxElement = boxElementByTargetElement.get(box.element);
        return isTargeted(box, boxElement, coords);
      }), existing = current.filter((box) => update.includes(box)), additions = update.filter((box) => !current.includes(box)), hasRemovals = current.length - existing.length;
      return additions.length || hasRemovals ? [...existing, ...additions] : current;
    });
  };
  hoverCoords.subscribe(updateHovered), boxes.subscribe(updateHovered);
  let updateBoxStyles = () => {
    let selectedElement = selected.get(), targetElements = selectedElement ? [selectedElement] : targets.get(), focusedElement = targetElements.length === 1 ? targetElements[0] : focused.get(), isMenuOpen = clickCoords.get() !== void 0;
    boxes.get().forEach((box) => {
      let boxElement = boxElementByTargetElement.get(box.element);
      if (boxElement) {
        let isFocused = focusedElement === box, isHovered = isMenuOpen ? focusedElement ? isFocused : targetElements.includes(box) : hovered.get()?.includes(box);
        Object.assign(boxElement.style, {
          animation: "none",
          background: "transparent",
          border: "none",
          boxSizing: "border-box",
          outline: "none",
          outlineOffset: "0px",
          ...box.styles,
          ...isHovered ? box.hoverStyles : {},
          ...isFocused ? box.focusStyles : {},
          position: getComputedStyle(box.element).position === "fixed" ? "fixed" : "absolute",
          zIndex: MAX_Z_INDEX - 10,
          top: `${box.top}px`,
          left: `${box.left}px`,
          width: `${box.width}px`,
          height: `${box.height}px`,
          margin: 0,
          padding: 0,
          cursor: box.menu && isHovered ? "pointer" : "default",
          pointerEvents: box.menu ? "auto" : "none",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          overflow: "visible"
        }), Object.assign(boxElement.children[0].style, {
          width: "100%",
          height: "100%",
          minHeight: `${MIN_TOUCH_AREA_SIZE}px`,
          minWidth: `${MIN_TOUCH_AREA_SIZE}px`,
          boxSizing: "content-box",
          padding: boxElement.style.outlineWidth || "0px"
        }), showPopover(boxElement);
      }
    });
  };
  boxes.subscribe(updateBoxStyles), targets.subscribe(updateBoxStyles), hovered.subscribe(updateBoxStyles), focused.subscribe(updateBoxStyles), selected.subscribe(updateBoxStyles);
  let renderMenu = () => {
    if (!root2)
      return;
    let menu = document7.getElementById(menuId);
    if (menu)
      menu.innerHTML = "";
    else {
      let props = { id: menuId, popover: "manual" };
      menu = root2.appendChild(createElement("div", props)), root2.appendChild(
        createElement("style", {}, [
          `
            #${menuId} {
              position: absolute;
              z-index: ${MAX_Z_INDEX};
              width: 300px;
              padding: 0px;
              margin: 15px 0 0 0;
              transform: translateX(-50%);
              font-family: "Nunito Sans", -apple-system, ".SFNSText-Regular", "San Francisco", BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", Helvetica, Arial, sans-serif;
              font-size: 12px;
              background: white;
              border: none;
              border-radius: 6px;
              box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.05), 0 5px 15px 0 rgba(0, 0, 0, 0.1);
              color: #2E3438;
            }
            #${menuId} ul {
              list-style: none;
              margin: 0;
              padding: 0;
            }
            #${menuId} > ul {
              max-height: 300px;
              overflow-y: auto;
              padding: 4px 0;
            }
            #${menuId} li {
              padding: 0 4px;
              margin: 0;
            }
            #${menuId} li > :not(ul) {
              display: flex;
              padding: 8px;
              margin: 0;
              align-items: center;
              gap: 8px;
              border-radius: 4px;
            }
            #${menuId} button {
              width: 100%;
              border: 0;
              background: transparent;
              color: inherit;
              text-align: left;
              font-family: inherit;
              font-size: inherit;
            }
            #${menuId} button:focus-visible {
              outline-color: #029CFD;
            }
            #${menuId} button:hover {
              background: rgba(2, 156, 253, 0.07);
              color: #029CFD;
              cursor: pointer;
            }
            #${menuId} li code {
              white-space: nowrap;
              overflow: hidden;
              text-overflow: ellipsis;
              line-height: 16px;
              font-size: 11px;
            }
            #${menuId} li svg {
              flex-shrink: 0;
              margin: 1px;
              color: #73828C;
            }
            #${menuId} li > button:hover svg, #${menuId} li > button:focus-visible svg {
              color: #029CFD;
            }
            #${menuId} .element-list li svg {
              display: none;
            }
            #${menuId} li.selectable svg, #${menuId} li.selected svg {
              display: block;
            }
            #${menuId} .menu-list {
              border-top: 1px solid rgba(38, 85, 115, 0.15);
            }
            #${menuId} .menu-list > li:not(:last-child) {
              padding-bottom: 4px;
              margin-bottom: 4px;
              border-bottom: 1px solid rgba(38, 85, 115, 0.15);
            }
            #${menuId} .menu-items, #${menuId} .menu-items li {
              padding: 0;
            }
            #${menuId} .menu-item {
              display: flex;
            }
            #${menuId} .menu-item-content {
              display: flex;
              flex-direction: column;
              flex-grow: 1;
            }
          `
        ])
      );
    }
    let selectedElement = selected.get(), elementList = selectedElement ? [selectedElement] : targets.get();
    if (elementList.length && (menu.style.position = getComputedStyle(elementList[0].element).position === "fixed" ? "fixed" : "absolute", menu.appendChild(
      createElement(
        "ul",
        { class: "element-list" },
        elementList.map((target) => {
          let selectable = elementList.length > 1 && !!target.menu?.some(
            (group) => group.some(
              (item) => !item.selectors || item.selectors.some((s3) => target.selectors.includes(s3))
            )
          ), props = selectable ? {
            class: "selectable",
            onClick: () => selected.set(target),
            onMouseEnter: () => focused.set(target),
            onMouseLeave: () => focused.set(void 0)
          } : selectedElement ? { class: "selected", onClick: () => selected.set(void 0) } : {}, asButton = selectable || selectedElement;
          return createElement("li", props, [
            createElement(asButton ? "button" : "div", asButton ? { type: "button" } : {}, [
              selectedElement ? createIcon("chevronLeft") : null,
              createElement("code", {}, [target.element.outerHTML]),
              selectable ? createIcon("chevronRight") : null
            ])
          ]);
        })
      )
    )), selected.get() || targets.get().length === 1) {
      let target = selected.get() || targets.get()[0], menuGroups = target.menu?.filter(
        (group) => group.some(
          (item) => !item.selectors || item.selectors.some((s3) => target.selectors.includes(s3))
        )
      );
      menuGroups?.length && menu.appendChild(
        createElement(
          "ul",
          { class: "menu-list" },
          menuGroups.map(
            (menuItems) => createElement("li", {}, [
              createElement(
                "ul",
                { class: "menu-items" },
                menuItems.map(
                  ({ id, title, description, iconLeft, iconRight, clickEvent: event }) => {
                    let onClick = event && (() => channel.emit(event, id, getEventDetails(target)));
                    return createElement("li", {}, [
                      createElement(
                        onClick ? "button" : "div",
                        onClick ? { class: "menu-item", type: "button", onClick } : { class: "menu-item" },
                        [
                          iconLeft ? createIcon(iconLeft) : null,
                          createElement("div", { class: "menu-item-content" }, [
                            createElement(description ? "strong" : "span", {}, [title]),
                            description && createElement("span", {}, [description])
                          ]),
                          iconRight ? createIcon(iconRight) : null
                        ]
                      )
                    ]);
                  }
                )
              )
            ])
          )
        )
      );
    }
    let coords = clickCoords.get();
    coords ? (Object.assign(menu.style, {
      display: "block",
      left: `${menu.style.position === "fixed" ? coords.x - window.scrollX : coords.x}px`,
      top: `${menu.style.position === "fixed" ? coords.y - window.scrollY : coords.y}px`
    }), showPopover(menu), requestAnimationFrame(() => keepInViewport(menu, coords, { topOffset: 15, centered: !0 }))) : (hidePopover(menu), Object.assign(menu.style, { display: "none" }));
  };
  targets.subscribe(renderMenu), selected.subscribe(renderMenu);
  let addHighlight = (highlight) => {
    let info = normalizeOptions(highlight);
    highlights.set((value) => {
      let others = info.id ? value.filter((h3) => h3.id !== info.id) : value;
      return info.selectors?.length ? [...others, info] : others;
    });
  }, removeHighlight = (id) => {
    id && highlights.set((value) => value.filter((h3) => h3.id !== id));
  }, resetState = () => {
    highlights.set([]), elements.set(/* @__PURE__ */ new Map()), boxes.set([]), clickCoords.set(void 0), hoverCoords.set(void 0), targets.set([]), hovered.set([]), focused.set(void 0), selected.set(void 0);
  }, removeTimeout, scrollIntoView = (target, options) => {
    let id = "scrollIntoView-highlight";
    clearTimeout(removeTimeout), removeHighlight(id);
    let element = document7.querySelector(target);
    if (!element) {
      console.warn(`Cannot scroll into view: ${target} not found`);
      return;
    }
    element.scrollIntoView({ behavior: "smooth", block: "center", ...options });
    let keyframeName = `kf-${Math.random().toString(36).substring(2, 15)}`;
    highlights.set((value) => [
      ...value,
      {
        id,
        priority: 1e3,
        selectors: [target],
        styles: {
          outline: "2px solid #1EA7FD",
          outlineOffset: "-1px",
          animation: `${keyframeName} 3s linear forwards`
        },
        keyframes: `@keyframes ${keyframeName} {
          0% { outline: 2px solid #1EA7FD; }
          20% { outline: 2px solid #1EA7FD00; }
          40% { outline: 2px solid #1EA7FD; }
          60% { outline: 2px solid #1EA7FD00; }
          80% { outline: 2px solid #1EA7FD; }
          100% { outline: 2px solid #1EA7FD00; }
        }`
      }
    ]), removeTimeout = setTimeout(() => removeHighlight(id), 3500);
  }, onMouseMove = (event) => {
    requestAnimationFrame(() => hoverCoords.set({ x: event.pageX, y: event.pageY }));
  };
  document7.body.addEventListener("mousemove", onMouseMove), channel.on(HIGHLIGHT, addHighlight), channel.on(REMOVE_HIGHLIGHT, removeHighlight), channel.on(RESET_HIGHLIGHT, resetState), channel.on(SCROLL_INTO_VIEW, scrollIntoView), channel.on(STORY_RENDER_PHASE_CHANGED, ({ newPhase }) => {
    newPhase === "loading" && resetState();
  });
};

// src/highlight/preview.ts
globalThis?.FEATURES?.highlight && addons?.ready && addons.ready().then(useHighlights);
var preview_default4 = () => ({});

// src/measure/constants.ts
var ADDON_ID4 = "storybook/measure-addon", TOOL_ID = `${ADDON_ID4}/tool`, PARAM_KEY3 = "measureEnabled", EVENTS3 = {
  RESULT: `${ADDON_ID4}/result`,
  REQUEST: `${ADDON_ID4}/request`,
  CLEAR: `${ADDON_ID4}/clear`
};

// src/measure/box-model/canvas.ts
function getDocumentWidthAndHeight() {
  let container = scope.document.documentElement, height = Math.max(container.scrollHeight, container.offsetHeight);
  return { width: Math.max(container.scrollWidth, container.offsetWidth), height };
}
function createCanvas() {
  let canvas = scope.document.createElement("canvas");
  canvas.id = "storybook-addon-measure";
  let context = canvas.getContext("2d");
  invariant(context != null);
  let { width, height } = getDocumentWidthAndHeight();
  return setCanvasWidthAndHeight(canvas, context, { width, height }), canvas.style.position = "absolute", canvas.style.left = "0", canvas.style.top = "0", canvas.style.zIndex = "2147483647", canvas.style.pointerEvents = "none", scope.document.body.appendChild(canvas), { canvas, context, width, height };
}
function setCanvasWidthAndHeight(canvas, context, { width, height }) {
  canvas.style.width = `${width}px`, canvas.style.height = `${height}px`;
  let scale = scope.window.devicePixelRatio;
  canvas.width = Math.floor(width * scale), canvas.height = Math.floor(height * scale), context.scale(scale, scale);
}
var state2 = {};
function init() {
  state2.canvas || (state2 = createCanvas());
}
function clear3() {
  state2.context && state2.context.clearRect(0, 0, state2.width ?? 0, state2.height ?? 0);
}
function draw(callback) {
  clear3(), callback(state2.context);
}
function rescale() {
  invariant(state2.canvas, "Canvas should exist in the state."), invariant(state2.context, "Context should exist in the state."), setCanvasWidthAndHeight(state2.canvas, state2.context, { width: 0, height: 0 });
  let { width, height } = getDocumentWidthAndHeight();
  setCanvasWidthAndHeight(state2.canvas, state2.context, { width, height }), state2.width = width, state2.height = height;
}
function destroy() {
  state2.canvas && (clear3(), state2.canvas.parentNode?.removeChild(state2.canvas), state2 = {});
}

// src/measure/box-model/labels.ts
var colors = {
  margin: "#f6b26b",
  border: "#ffe599",
  padding: "#93c47d",
  content: "#6fa8dc",
  text: "#232020"
}, labelPadding = 6;
function roundedRect(context, { x: x2, y: y2, w: w2, h: h3, r: r2 }) {
  x2 = x2 - w2 / 2, y2 = y2 - h3 / 2, w2 < 2 * r2 && (r2 = w2 / 2), h3 < 2 * r2 && (r2 = h3 / 2), context.beginPath(), context.moveTo(x2 + r2, y2), context.arcTo(x2 + w2, y2, x2 + w2, y2 + h3, r2), context.arcTo(x2 + w2, y2 + h3, x2, y2 + h3, r2), context.arcTo(x2, y2 + h3, x2, y2, r2), context.arcTo(x2, y2, x2 + w2, y2, r2), context.closePath();
}
function positionCoordinate(position, { padding, border, width, height, top, left }) {
  let contentWidth = width - border.left - border.right - padding.left - padding.right, contentHeight = height - padding.top - padding.bottom - border.top - border.bottom, x2 = left + border.left + padding.left, y2 = top + border.top + padding.top;
  return position === "top" ? x2 += contentWidth / 2 : position === "right" ? (x2 += contentWidth, y2 += contentHeight / 2) : position === "bottom" ? (x2 += contentWidth / 2, y2 += contentHeight) : position === "left" ? y2 += contentHeight / 2 : position === "center" && (x2 += contentWidth / 2, y2 += contentHeight / 2), { x: x2, y: y2 };
}
function offset(type5, position, { margin, border, padding }, labelPaddingSize, external) {
  let shift = (dir) => 0, offsetX = 0, offsetY = 0, locationMultiplier = external ? 1 : 0.5, labelPaddingShift = external ? labelPaddingSize * 2 : 0;
  return type5 === "padding" ? shift = (dir) => padding[dir] * locationMultiplier + labelPaddingShift : type5 === "border" ? shift = (dir) => padding[dir] + border[dir] * locationMultiplier + labelPaddingShift : type5 === "margin" && (shift = (dir) => padding[dir] + border[dir] + margin[dir] * locationMultiplier + labelPaddingShift), position === "top" ? offsetY = -shift("top") : position === "right" ? offsetX = shift("right") : position === "bottom" ? offsetY = shift("bottom") : position === "left" && (offsetX = -shift("left")), { offsetX, offsetY };
}
function collide(a2, b2) {
  return Math.abs(a2.x - b2.x) < Math.abs(a2.w + b2.w) / 2 && Math.abs(a2.y - b2.y) < Math.abs(a2.h + b2.h) / 2;
}
function overlapAdjustment(position, currentRect, prevRect) {
  return position === "top" ? currentRect.y = prevRect.y - prevRect.h - labelPadding : position === "right" ? currentRect.x = prevRect.x + prevRect.w / 2 + labelPadding + currentRect.w / 2 : position === "bottom" ? currentRect.y = prevRect.y + prevRect.h + labelPadding : position === "left" && (currentRect.x = prevRect.x - prevRect.w / 2 - labelPadding - currentRect.w / 2), { x: currentRect.x, y: currentRect.y };
}
function textWithRect(context, type5, { x: x2, y: y2, w: w2, h: h3 }, text) {
  return roundedRect(context, { x: x2, y: y2, w: w2, h: h3, r: 3 }), context.fillStyle = `${colors[type5]}dd`, context.fill(), context.strokeStyle = colors[type5], context.stroke(), context.fillStyle = colors.text, context.fillText(text, x2, y2), roundedRect(context, { x: x2, y: y2, w: w2, h: h3, r: 3 }), context.fillStyle = `${colors[type5]}dd`, context.fill(), context.strokeStyle = colors[type5], context.stroke(), context.fillStyle = colors.text, context.fillText(text, x2, y2), { x: x2, y: y2, w: w2, h: h3 };
}
function configureText(context, text) {
  context.font = "600 12px monospace", context.textBaseline = "middle", context.textAlign = "center";
  let metrics = context.measureText(text), actualHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent, w2 = metrics.width + labelPadding * 2, h3 = actualHeight + labelPadding * 2;
  return { w: w2, h: h3 };
}
function drawLabel(context, measurements, { type: type5, position = "center", text }, prevRect, external = !1) {
  let { x: x2, y: y2 } = positionCoordinate(position, measurements), { offsetX, offsetY } = offset(type5, position, measurements, labelPadding + 1, external);
  x2 += offsetX, y2 += offsetY;
  let { w: w2, h: h3 } = configureText(context, text);
  if (prevRect && collide({ x: x2, y: y2, w: w2, h: h3 }, prevRect)) {
    let adjusted = overlapAdjustment(position, { x: x2, y: y2, w: w2, h: h3 }, prevRect);
    x2 = adjusted.x, y2 = adjusted.y;
  }
  return textWithRect(context, type5, { x: x2, y: y2, w: w2, h: h3 }, text);
}
function floatingOffset(alignment, { w: w2, h: h3 }) {
  let deltaW = w2 * 0.5 + labelPadding, deltaH = h3 * 0.5 + labelPadding;
  return {
    offsetX: (alignment.x === "left" ? -1 : 1) * deltaW,
    offsetY: (alignment.y === "top" ? -1 : 1) * deltaH
  };
}
function drawFloatingLabel(context, measurements, { type: type5, text }) {
  let { floatingAlignment: floatingAlignment2, extremities } = measurements, x2 = extremities[floatingAlignment2.x], y2 = extremities[floatingAlignment2.y], { w: w2, h: h3 } = configureText(context, text), { offsetX, offsetY } = floatingOffset(floatingAlignment2, {
    w: w2,
    h: h3
  });
  return x2 += offsetX, y2 += offsetY, textWithRect(context, type5, { x: x2, y: y2, w: w2, h: h3 }, text);
}
function drawStack(context, measurements, stack, external) {
  let rects = [];
  stack.forEach((l2, idx) => {
    let rect = external && l2.position === "center" ? drawFloatingLabel(context, measurements, l2) : drawLabel(context, measurements, l2, rects[idx - 1], external);
    rects[idx] = rect;
  });
}
function labelStacks(context, measurements, labels, externalLabels) {
  let stacks = labels.reduce((acc, l2) => (Object.prototype.hasOwnProperty.call(acc, l2.position) || (acc[l2.position] = []), acc[l2.position]?.push(l2), acc), {});
  stacks.top && drawStack(context, measurements, stacks.top, externalLabels), stacks.right && drawStack(context, measurements, stacks.right, externalLabels), stacks.bottom && drawStack(context, measurements, stacks.bottom, externalLabels), stacks.left && drawStack(context, measurements, stacks.left, externalLabels), stacks.center && drawStack(context, measurements, stacks.center, externalLabels);
}

// src/measure/box-model/visualizer.ts
var colors2 = {
  margin: "#f6b26ba8",
  border: "#ffe599a8",
  padding: "#93c47d8c",
  content: "#6fa8dca8"
}, SMALL_NODE_SIZE = 30;
function pxToNumber(px) {
  return parseInt(px.replace("px", ""), 10);
}
function round(value) {
  return Number.isInteger(value) ? value : value.toFixed(2);
}
function filterZeroValues(labels) {
  return labels.filter((l2) => l2.text !== 0 && l2.text !== "0");
}
function floatingAlignment(extremities) {
  let windowExtremities = {
    top: scope.window.scrollY,
    bottom: scope.window.scrollY + scope.window.innerHeight,
    left: scope.window.scrollX,
    right: scope.window.scrollX + scope.window.innerWidth
  }, distances = {
    top: Math.abs(windowExtremities.top - extremities.top),
    bottom: Math.abs(windowExtremities.bottom - extremities.bottom),
    left: Math.abs(windowExtremities.left - extremities.left),
    right: Math.abs(windowExtremities.right - extremities.right)
  };
  return {
    x: distances.left > distances.right ? "left" : "right",
    y: distances.top > distances.bottom ? "top" : "bottom"
  };
}
function measureElement(element) {
  let style = scope.getComputedStyle(element), { top, left, right, bottom, width, height } = element.getBoundingClientRect(), {
    marginTop,
    marginBottom,
    marginLeft,
    marginRight,
    paddingTop,
    paddingBottom,
    paddingLeft,
    paddingRight,
    borderBottomWidth,
    borderTopWidth,
    borderLeftWidth,
    borderRightWidth
  } = style;
  top = top + scope.window.scrollY, left = left + scope.window.scrollX, bottom = bottom + scope.window.scrollY, right = right + scope.window.scrollX;
  let margin = {
    top: pxToNumber(marginTop),
    bottom: pxToNumber(marginBottom),
    left: pxToNumber(marginLeft),
    right: pxToNumber(marginRight)
  }, padding = {
    top: pxToNumber(paddingTop),
    bottom: pxToNumber(paddingBottom),
    left: pxToNumber(paddingLeft),
    right: pxToNumber(paddingRight)
  }, border = {
    top: pxToNumber(borderTopWidth),
    bottom: pxToNumber(borderBottomWidth),
    left: pxToNumber(borderLeftWidth),
    right: pxToNumber(borderRightWidth)
  }, extremities = {
    top: top - margin.top,
    bottom: bottom + margin.bottom,
    left: left - margin.left,
    right: right + margin.right
  };
  return {
    margin,
    padding,
    border,
    top,
    left,
    bottom,
    right,
    width,
    height,
    extremities,
    floatingAlignment: floatingAlignment(extremities)
  };
}
function drawMargin(context, { margin, width, height, top, left, bottom, right }) {
  let marginHeight = height + margin.bottom + margin.top;
  context.fillStyle = colors2.margin, context.fillRect(left, top - margin.top, width, margin.top), context.fillRect(right, top - margin.top, margin.right, marginHeight), context.fillRect(left, bottom, width, margin.bottom), context.fillRect(left - margin.left, top - margin.top, margin.left, marginHeight);
  let marginLabels = [
    {
      type: "margin",
      text: round(margin.top),
      position: "top"
    },
    {
      type: "margin",
      text: round(margin.right),
      position: "right"
    },
    {
      type: "margin",
      text: round(margin.bottom),
      position: "bottom"
    },
    {
      type: "margin",
      text: round(margin.left),
      position: "left"
    }
  ];
  return filterZeroValues(marginLabels);
}
function drawPadding(context, { padding, border, width, height, top, left, bottom, right }) {
  let paddingWidth = width - border.left - border.right, paddingHeight = height - padding.top - padding.bottom - border.top - border.bottom;
  context.fillStyle = colors2.padding, context.fillRect(left + border.left, top + border.top, paddingWidth, padding.top), context.fillRect(
    right - padding.right - border.right,
    top + padding.top + border.top,
    padding.right,
    paddingHeight
  ), context.fillRect(
    left + border.left,
    bottom - padding.bottom - border.bottom,
    paddingWidth,
    padding.bottom
  ), context.fillRect(left + border.left, top + padding.top + border.top, padding.left, paddingHeight);
  let paddingLabels = [
    {
      type: "padding",
      text: padding.top,
      position: "top"
    },
    {
      type: "padding",
      text: padding.right,
      position: "right"
    },
    {
      type: "padding",
      text: padding.bottom,
      position: "bottom"
    },
    {
      type: "padding",
      text: padding.left,
      position: "left"
    }
  ];
  return filterZeroValues(paddingLabels);
}
function drawBorder(context, { border, width, height, top, left, bottom, right }) {
  let borderHeight = height - border.top - border.bottom;
  context.fillStyle = colors2.border, context.fillRect(left, top, width, border.top), context.fillRect(left, bottom - border.bottom, width, border.bottom), context.fillRect(left, top + border.top, border.left, borderHeight), context.fillRect(right - border.right, top + border.top, border.right, borderHeight);
  let borderLabels = [
    {
      type: "border",
      text: border.top,
      position: "top"
    },
    {
      type: "border",
      text: border.right,
      position: "right"
    },
    {
      type: "border",
      text: border.bottom,
      position: "bottom"
    },
    {
      type: "border",
      text: border.left,
      position: "left"
    }
  ];
  return filterZeroValues(borderLabels);
}
function drawContent(context, { padding, border, width, height, top, left }) {
  let contentWidth = width - border.left - border.right - padding.left - padding.right, contentHeight = height - padding.top - padding.bottom - border.top - border.bottom;
  return context.fillStyle = colors2.content, context.fillRect(
    left + border.left + padding.left,
    top + border.top + padding.top,
    contentWidth,
    contentHeight
  ), [
    {
      type: "content",
      position: "center",
      text: `${round(contentWidth)} x ${round(contentHeight)}`
    }
  ];
}
function drawBoxModel(element) {
  return (context) => {
    if (element && context) {
      let measurements = measureElement(element), marginLabels = drawMargin(context, measurements), paddingLabels = drawPadding(context, measurements), borderLabels = drawBorder(context, measurements), contentLabels = drawContent(context, measurements), externalLabels = measurements.width <= SMALL_NODE_SIZE * 3 || measurements.height <= SMALL_NODE_SIZE;
      labelStacks(
        context,
        measurements,
        [...contentLabels, ...paddingLabels, ...borderLabels, ...marginLabels],
        externalLabels
      );
    }
  };
}
function drawSelectedElement(element) {
  draw(drawBoxModel(element));
}

// src/measure/util.ts
var deepElementFromPoint = (x2, y2) => {
  let element = scope.document.elementFromPoint(x2, y2), crawlShadows = (node) => {
    if (node && node.shadowRoot) {
      let nestedElement = node.shadowRoot.elementFromPoint(x2, y2);
      return node.isEqualNode(nestedElement) ? node : nestedElement.shadowRoot ? crawlShadows(nestedElement) : nestedElement;
    }
    return node;
  };
  return crawlShadows(element) || element;
};

// src/measure/withMeasure.ts
var nodeAtPointerRef, pointer3 = { x: 0, y: 0 };
function findAndDrawElement(x2, y2) {
  nodeAtPointerRef = deepElementFromPoint(x2, y2), drawSelectedElement(nodeAtPointerRef);
}
var withMeasure = (StoryFn, context) => {
  let { measureEnabled } = context.globals || {};
  return useEffect(() => {
    if (typeof globalThis.document > "u")
      return;
    let onPointerMove = (event) => {
      window.requestAnimationFrame(() => {
        event.stopPropagation(), pointer3.x = event.clientX, pointer3.y = event.clientY;
      });
    };
    return globalThis.document.addEventListener("pointermove", onPointerMove), () => {
      globalThis.document.removeEventListener("pointermove", onPointerMove);
    };
  }, []), useEffect(() => {
    let onPointerOver = (event) => {
      window.requestAnimationFrame(() => {
        event.stopPropagation(), findAndDrawElement(event.clientX, event.clientY);
      });
    }, onResize = () => {
      window.requestAnimationFrame(() => {
        rescale();
      });
    };
    return context.viewMode === "story" && measureEnabled && (globalThis.document.addEventListener("pointerover", onPointerOver), init(), globalThis.window.addEventListener("resize", onResize), findAndDrawElement(pointer3.x, pointer3.y)), () => {
      globalThis.window.removeEventListener("resize", onResize), destroy();
    };
  }, [measureEnabled, context.viewMode]), StoryFn();
};

// src/measure/preview.ts
var decorators2 = globalThis.FEATURES?.measure ? [withMeasure] : [], initialGlobals2 = {
  [PARAM_KEY3]: !1
}, preview_default5 = () => ({
  decorators: decorators2,
  initialGlobals: initialGlobals2
});

// src/outline/constants.ts
var PARAM_KEY4 = "outline";

// src/outline/helpers.ts
var clearStyles2 = (selector) => {
  (Array.isArray(selector) ? selector : [selector]).forEach(clearStyle2);
}, clearStyle2 = (input2) => {
  let selector = typeof input2 == "string" ? input2 : input2.join(""), element = scope.document.getElementById(selector);
  element && element.parentElement && element.parentElement.removeChild(element);
}, addOutlineStyles = (selector, css) => {
  let existingStyle = scope.document.getElementById(selector);
  if (existingStyle)
    existingStyle.innerHTML !== css && (existingStyle.innerHTML = css);
  else {
    let style = scope.document.createElement("style");
    style.setAttribute("id", selector), style.innerHTML = css, scope.document.head.appendChild(style);
  }
};

// src/outline/outlineCSS.ts
function outlineCSS(selector) {
  return dedent`
    ${selector} body {
      outline: 1px solid #2980b9 !important;
    }

    ${selector} article {
      outline: 1px solid #3498db !important;
    }

    ${selector} nav {
      outline: 1px solid #0088c3 !important;
    }

    ${selector} aside {
      outline: 1px solid #33a0ce !important;
    }

    ${selector} section {
      outline: 1px solid #66b8da !important;
    }

    ${selector} header {
      outline: 1px solid #99cfe7 !important;
    }

    ${selector} footer {
      outline: 1px solid #cce7f3 !important;
    }

    ${selector} h1 {
      outline: 1px solid #162544 !important;
    }

    ${selector} h2 {
      outline: 1px solid #314e6e !important;
    }

    ${selector} h3 {
      outline: 1px solid #3e5e85 !important;
    }

    ${selector} h4 {
      outline: 1px solid #449baf !important;
    }

    ${selector} h5 {
      outline: 1px solid #c7d1cb !important;
    }

    ${selector} h6 {
      outline: 1px solid #4371d0 !important;
    }

    ${selector} main {
      outline: 1px solid #2f4f90 !important;
    }

    ${selector} address {
      outline: 1px solid #1a2c51 !important;
    }

    ${selector} div {
      outline: 1px solid #036cdb !important;
    }

    ${selector} p {
      outline: 1px solid #ac050b !important;
    }

    ${selector} hr {
      outline: 1px solid #ff063f !important;
    }

    ${selector} pre {
      outline: 1px solid #850440 !important;
    }

    ${selector} blockquote {
      outline: 1px solid #f1b8e7 !important;
    }

    ${selector} ol {
      outline: 1px solid #ff050c !important;
    }

    ${selector} ul {
      outline: 1px solid #d90416 !important;
    }

    ${selector} li {
      outline: 1px solid #d90416 !important;
    }

    ${selector} dl {
      outline: 1px solid #fd3427 !important;
    }

    ${selector} dt {
      outline: 1px solid #ff0043 !important;
    }

    ${selector} dd {
      outline: 1px solid #e80174 !important;
    }

    ${selector} figure {
      outline: 1px solid #ff00bb !important;
    }

    ${selector} figcaption {
      outline: 1px solid #bf0032 !important;
    }

    ${selector} table {
      outline: 1px solid #00cc99 !important;
    }

    ${selector} caption {
      outline: 1px solid #37ffc4 !important;
    }

    ${selector} thead {
      outline: 1px solid #98daca !important;
    }

    ${selector} tbody {
      outline: 1px solid #64a7a0 !important;
    }

    ${selector} tfoot {
      outline: 1px solid #22746b !important;
    }

    ${selector} tr {
      outline: 1px solid #86c0b2 !important;
    }

    ${selector} th {
      outline: 1px solid #a1e7d6 !important;
    }

    ${selector} td {
      outline: 1px solid #3f5a54 !important;
    }

    ${selector} col {
      outline: 1px solid #6c9a8f !important;
    }

    ${selector} colgroup {
      outline: 1px solid #6c9a9d !important;
    }

    ${selector} button {
      outline: 1px solid #da8301 !important;
    }

    ${selector} datalist {
      outline: 1px solid #c06000 !important;
    }

    ${selector} fieldset {
      outline: 1px solid #d95100 !important;
    }

    ${selector} form {
      outline: 1px solid #d23600 !important;
    }

    ${selector} input {
      outline: 1px solid #fca600 !important;
    }

    ${selector} keygen {
      outline: 1px solid #b31e00 !important;
    }

    ${selector} label {
      outline: 1px solid #ee8900 !important;
    }

    ${selector} legend {
      outline: 1px solid #de6d00 !important;
    }

    ${selector} meter {
      outline: 1px solid #e8630c !important;
    }

    ${selector} optgroup {
      outline: 1px solid #b33600 !important;
    }

    ${selector} option {
      outline: 1px solid #ff8a00 !important;
    }

    ${selector} output {
      outline: 1px solid #ff9619 !important;
    }

    ${selector} progress {
      outline: 1px solid #e57c00 !important;
    }

    ${selector} select {
      outline: 1px solid #e26e0f !important;
    }

    ${selector} textarea {
      outline: 1px solid #cc5400 !important;
    }

    ${selector} details {
      outline: 1px solid #33848f !important;
    }

    ${selector} summary {
      outline: 1px solid #60a1a6 !important;
    }

    ${selector} command {
      outline: 1px solid #438da1 !important;
    }

    ${selector} menu {
      outline: 1px solid #449da6 !important;
    }

    ${selector} del {
      outline: 1px solid #bf0000 !important;
    }

    ${selector} ins {
      outline: 1px solid #400000 !important;
    }

    ${selector} img {
      outline: 1px solid #22746b !important;
    }

    ${selector} iframe {
      outline: 1px solid #64a7a0 !important;
    }

    ${selector} embed {
      outline: 1px solid #98daca !important;
    }

    ${selector} object {
      outline: 1px solid #00cc99 !important;
    }

    ${selector} param {
      outline: 1px solid #37ffc4 !important;
    }

    ${selector} video {
      outline: 1px solid #6ee866 !important;
    }

    ${selector} audio {
      outline: 1px solid #027353 !important;
    }

    ${selector} source {
      outline: 1px solid #012426 !important;
    }

    ${selector} canvas {
      outline: 1px solid #a2f570 !important;
    }

    ${selector} track {
      outline: 1px solid #59a600 !important;
    }

    ${selector} map {
      outline: 1px solid #7be500 !important;
    }

    ${selector} area {
      outline: 1px solid #305900 !important;
    }

    ${selector} a {
      outline: 1px solid #ff62ab !important;
    }

    ${selector} em {
      outline: 1px solid #800b41 !important;
    }

    ${selector} strong {
      outline: 1px solid #ff1583 !important;
    }

    ${selector} i {
      outline: 1px solid #803156 !important;
    }

    ${selector} b {
      outline: 1px solid #cc1169 !important;
    }

    ${selector} u {
      outline: 1px solid #ff0430 !important;
    }

    ${selector} s {
      outline: 1px solid #f805e3 !important;
    }

    ${selector} small {
      outline: 1px solid #d107b2 !important;
    }

    ${selector} abbr {
      outline: 1px solid #4a0263 !important;
    }

    ${selector} q {
      outline: 1px solid #240018 !important;
    }

    ${selector} cite {
      outline: 1px solid #64003c !important;
    }

    ${selector} dfn {
      outline: 1px solid #b4005a !important;
    }

    ${selector} sub {
      outline: 1px solid #dba0c8 !important;
    }

    ${selector} sup {
      outline: 1px solid #cc0256 !important;
    }

    ${selector} time {
      outline: 1px solid #d6606d !important;
    }

    ${selector} code {
      outline: 1px solid #e04251 !important;
    }

    ${selector} kbd {
      outline: 1px solid #5e001f !important;
    }

    ${selector} samp {
      outline: 1px solid #9c0033 !important;
    }

    ${selector} var {
      outline: 1px solid #d90047 !important;
    }

    ${selector} mark {
      outline: 1px solid #ff0053 !important;
    }

    ${selector} bdi {
      outline: 1px solid #bf3668 !important;
    }

    ${selector} bdo {
      outline: 1px solid #6f1400 !important;
    }

    ${selector} ruby {
      outline: 1px solid #ff7b93 !important;
    }

    ${selector} rt {
      outline: 1px solid #ff2f54 !important;
    }

    ${selector} rp {
      outline: 1px solid #803e49 !important;
    }

    ${selector} span {
      outline: 1px solid #cc2643 !important;
    }

    ${selector} br {
      outline: 1px solid #db687d !important;
    }

    ${selector} wbr {
      outline: 1px solid #db175b !important;
    }`;
}

// src/outline/withOutline.ts
var withOutline = (StoryFn, context) => {
  let globals = context.globals || {}, isActive = [!0, "true"].includes(globals[PARAM_KEY4]), isInDocs = context.viewMode === "docs", outlineStyles = useMemo(() => outlineCSS(isInDocs ? '[data-story-block="true"]' : ".sb-show-main"), [context]);
  return useEffect(() => {
    let selectorId = isInDocs ? `addon-outline-docs-${context.id}` : "addon-outline";
    return isActive ? addOutlineStyles(selectorId, outlineStyles) : clearStyles2(selectorId), () => {
      clearStyles2(selectorId);
    };
  }, [isActive, outlineStyles, context]), StoryFn();
};

// src/outline/preview.ts
var decorators3 = globalThis.FEATURES?.outline ? [withOutline] : [], initialGlobals3 = {
  [PARAM_KEY4]: !1
}, preview_default6 = () => ({ decorators: decorators3, initialGlobals: initialGlobals3 });

// src/test/preview.ts
var resetAllMocksLoader = ({ parameters: parameters2 }) => {
  parameters2?.test?.mockReset === !0 ? resetAllMocks() : parameters2?.test?.clearMocks === !0 ? clearAllMocks() : parameters2?.test?.restoreMocks !== !1 && restoreAllMocks();
}, traverseArgs = (value, depth = 0, key) => {
  if (depth > 5 || value == null)
    return value;
  if (isMockFunction(value))
    return key && value.mockName(key), value;
  if (typeof value == "function" && "isAction" in value && value.isAction && !("implicit" in value && value.implicit)) {
    let mock = fn2(value);
    return key && mock.mockName(key), mock;
  }
  if (Array.isArray(value)) {
    depth++;
    for (let i2 = 0; i2 < value.length; i2++)
      Object.getOwnPropertyDescriptor(value, i2)?.writable && (value[i2] = traverseArgs(value[i2], depth));
    return value;
  }
  if (typeof value == "object" && value.constructor === Object) {
    depth++;
    for (let [k2, v2] of Object.entries(value))
      Object.getOwnPropertyDescriptor(value, k2)?.writable && (value[k2] = traverseArgs(v2, depth, k2));
    return value;
  }
  return value;
}, nameSpiesAndWrapActionsInSpies = ({ initialArgs }) => {
  traverseArgs(initialArgs);
}, patchedFocus = !1, enhanceContext = async (context) => {
  globalThis.HTMLElement && context.canvasElement instanceof globalThis.HTMLElement && (context.canvas = within(context.canvasElement));
  let clipboard = globalThis.window?.navigator?.clipboard;
  if (clipboard && (context.userEvent = instrument(
    { userEvent: uninstrumentedUserEvent.setup() },
    {
      intercept: !0,
      getKeys: (obj) => Object.keys(obj).filter((key) => key !== "eventWrapper")
    }
  ).userEvent, Object.defineProperty(globalThis.window.navigator, "clipboard", {
    get: () => clipboard,
    configurable: !0
  }), !patchedFocus)) {
    let originalFocus = HTMLElement.prototype.focus, currentFocus = HTMLElement.prototype.focus, focusingElements = /* @__PURE__ */ new Set();
    Object.defineProperties(HTMLElement.prototype, {
      focus: {
        configurable: !0,
        set: (newFocus) => {
          currentFocus = newFocus;
        },
        get() {
          return focusingElements.has(this) ? originalFocus : (focusingElements.add(this), setTimeout(() => focusingElements.delete(this), 0), currentFocus);
        }
      }
    }), patchedFocus = !0;
  }
}, preview_default7 = () => ({
  loaders: [resetAllMocksLoader, nameSpiesAndWrapActionsInSpies, enhanceContext]
});

// src/viewport/constants.ts
var ADDON_ID5 = "storybook/viewport", PARAM_KEY5 = "viewport", PANEL_ID2 = `${ADDON_ID5}/panel`, TOOL_ID2 = `${ADDON_ID5}/tool`;

// src/viewport/preview.ts
var initialGlobals4 = {
  [PARAM_KEY5]: { value: void 0, isRotated: !1 }
}, preview_default8 = () => ({
  initialGlobals: initialGlobals4
});

// src/csf/core-annotations.ts
function getCoreAnnotations() {
  return [
    // @ts-expect-error CJS fallback
    (preview_default5.default ?? preview_default5)(),
    // @ts-expect-error CJS fallback
    (preview_default2.default ?? preview_default2)(),
    // @ts-expect-error CJS fallback
    (preview_default4.default ?? preview_default4)(),
    // @ts-expect-error CJS fallback
    (preview_default6.default ?? preview_default6)(),
    // @ts-expect-error CJS fallback
    (preview_default8.default ?? preview_default8)(),
    // @ts-expect-error CJS fallback
    (preview_default.default ?? preview_default)(),
    // @ts-expect-error CJS fallback
    (preview_default3.default ?? preview_default3)(),
    // @ts-expect-error CJS fallback
    (preview_default7.default ?? preview_default7)()
  ];
}

// src/csf/csf-factories.ts
function isMeta(input2) {
  return input2 != null && typeof input2 == "object" && "_tag" in input2 && input2?._tag === "Meta";
}
function isStory(input2) {
  return input2 != null && typeof input2 == "object" && "_tag" in input2 && input2?._tag === "Story";
}
function getStoryChildren(story) {
  return "__children" in story ? story.__children : [];
}

// src/csf/index.ts
var sanitize = (string) => string.toLowerCase().replace(/[ '`~!@#$%^&*()_|+\-=?;:'",.<>\{\}\[\]\\\/]/gi, "-").replace(/-+/g, "-").replace(/^-+/, "").replace(/-+$/, ""), sanitizeSafe = (string, part) => {
  let sanitized = sanitize(string);
  if (sanitized === "")
    throw new Error(`Invalid ${part} '${string}', must include alphanumeric characters`);
  return sanitized;
}, toId = (kind, name) => `${sanitizeSafe(kind, "kind")}${name ? `--${sanitizeSafe(name, "name")}` : ""}`, toTestId = (parentId, testName2) => `${parentId}:${sanitizeSafe(testName2, "test")}`, storyNameFromExport = (key) => toStartCaseStr(key);
function matches3(storyKey, arrayOrRegex) {
  return Array.isArray(arrayOrRegex) ? arrayOrRegex.includes(storyKey) : storyKey.match(arrayOrRegex);
}
function isExportStory(key, { includeStories, excludeStories }) {
  return (
    // https://babeljs.io/docs/en/babel-plugin-transform-modules-commonjs
    key !== "__esModule" && (!includeStories || matches3(key, includeStories)) && (!excludeStories || !matches3(key, excludeStories))
  );
}
var combineTags = (...tags) => {
  let result = tags.reduce((acc, tag) => (tag.startsWith("!") ? acc.delete(tag.slice(1)) : acc.add(tag), acc), /* @__PURE__ */ new Set());
  return Array.from(result);
};

// ../node_modules/es-toolkit/dist/compat/_internal/getSymbols.mjs
function getSymbols(object) {
  return Object.getOwnPropertySymbols(object).filter((symbol) => Object.prototype.propertyIsEnumerable.call(object, symbol));
}

// ../node_modules/es-toolkit/dist/compat/_internal/getTag.mjs
function getTag2(value) {
  return value == null ? value === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(value);
}

// ../node_modules/es-toolkit/dist/compat/_internal/tags.mjs
var regexpTag = "[object RegExp]", stringTag = "[object String]", numberTag = "[object Number]", booleanTag = "[object Boolean]", argumentsTag = "[object Arguments]", symbolTag2 = "[object Symbol]", dateTag = "[object Date]", mapTag = "[object Map]", setTag = "[object Set]", arrayTag = "[object Array]", functionTag = "[object Function]", arrayBufferTag = "[object ArrayBuffer]", objectTag = "[object Object]", errorTag = "[object Error]", dataViewTag = "[object DataView]", uint8ArrayTag = "[object Uint8Array]", uint8ClampedArrayTag = "[object Uint8ClampedArray]", uint16ArrayTag = "[object Uint16Array]", uint32ArrayTag = "[object Uint32Array]", bigUint64ArrayTag = "[object BigUint64Array]", int8ArrayTag = "[object Int8Array]", int16ArrayTag = "[object Int16Array]", int32ArrayTag = "[object Int32Array]", bigInt64ArrayTag = "[object BigInt64Array]", float32ArrayTag = "[object Float32Array]", float64ArrayTag = "[object Float64Array]";

// ../node_modules/es-toolkit/dist/predicate/isPlainObject.mjs
function isPlainObject(value) {
  if (!value || typeof value != "object")
    return !1;
  let proto = Object.getPrototypeOf(value);
  return proto === null || proto === Object.prototype || Object.getPrototypeOf(proto) === null ? Object.prototype.toString.call(value) === "[object Object]" : !1;
}

// ../node_modules/es-toolkit/dist/object/mapValues.mjs
function mapValues(object, getNewValue) {
  let result = {}, keys2 = Object.keys(object);
  for (let i2 = 0; i2 < keys2.length; i2++) {
    let key = keys2[i2], value = object[key];
    result[key] = getNewValue(value, key, object);
  }
  return result;
}

// ../node_modules/es-toolkit/dist/object/pickBy.mjs
function pickBy(obj, shouldPick) {
  let result = {}, keys2 = Object.keys(obj);
  for (let i2 = 0; i2 < keys2.length; i2++) {
    let key = keys2[i2], value = obj[key];
    shouldPick(value, key) && (result[key] = value);
  }
  return result;
}

// ../node_modules/es-toolkit/dist/string/words.mjs
var CASE_SPLIT_PATTERN = new RegExp("\\p{Lu}?\\p{Ll}+|[0-9]+|\\p{Lu}+(?!\\p{Ll})|\\p{Emoji_Presentation}|\\p{Extended_Pictographic}|\\p{L}+", "gu");

// src/preview-api/modules/store/StoryStore.ts
var import_memoizerific2 = __toESM(require_memoizerific(), 1);

// ../node_modules/es-toolkit/dist/compat/util/eq.mjs
function eq3(value, other) {
  return value === other || Number.isNaN(value) && Number.isNaN(other);
}

// ../node_modules/es-toolkit/dist/predicate/isEqualWith.mjs
function isEqualWith(a2, b2, areValuesEqual) {
  return isEqualWithImpl(a2, b2, void 0, void 0, void 0, void 0, areValuesEqual);
}
function isEqualWithImpl(a2, b2, property, aParent, bParent, stack, areValuesEqual) {
  let result = areValuesEqual(a2, b2, property, aParent, bParent, stack);
  if (result !== void 0)
    return result;
  if (typeof a2 == typeof b2)
    switch (typeof a2) {
      case "bigint":
      case "string":
      case "boolean":
      case "symbol":
      case "undefined":
        return a2 === b2;
      case "number":
        return a2 === b2 || Object.is(a2, b2);
      case "function":
        return a2 === b2;
      case "object":
        return areObjectsEqual(a2, b2, stack, areValuesEqual);
    }
  return areObjectsEqual(a2, b2, stack, areValuesEqual);
}
function areObjectsEqual(a2, b2, stack, areValuesEqual) {
  if (Object.is(a2, b2))
    return !0;
  let aTag = getTag2(a2), bTag = getTag2(b2);
  if (aTag === argumentsTag && (aTag = objectTag), bTag === argumentsTag && (bTag = objectTag), aTag !== bTag)
    return !1;
  switch (aTag) {
    case stringTag:
      return a2.toString() === b2.toString();
    case numberTag: {
      let x2 = a2.valueOf(), y2 = b2.valueOf();
      return eq3(x2, y2);
    }
    case booleanTag:
    case dateTag:
    case symbolTag2:
      return Object.is(a2.valueOf(), b2.valueOf());
    case regexpTag:
      return a2.source === b2.source && a2.flags === b2.flags;
    case functionTag:
      return a2 === b2;
  }
  stack = stack ?? /* @__PURE__ */ new Map();
  let aStack = stack.get(a2), bStack = stack.get(b2);
  if (aStack != null && bStack != null)
    return aStack === b2;
  stack.set(a2, b2), stack.set(b2, a2);
  try {
    switch (aTag) {
      case mapTag: {
        if (a2.size !== b2.size)
          return !1;
        for (let [key, value] of a2.entries())
          if (!b2.has(key) || !isEqualWithImpl(value, b2.get(key), key, a2, b2, stack, areValuesEqual))
            return !1;
        return !0;
      }
      case setTag: {
        if (a2.size !== b2.size)
          return !1;
        let aValues = Array.from(a2.values()), bValues = Array.from(b2.values());
        for (let i2 = 0; i2 < aValues.length; i2++) {
          let aValue = aValues[i2], index2 = bValues.findIndex((bValue) => isEqualWithImpl(aValue, bValue, void 0, a2, b2, stack, areValuesEqual));
          if (index2 === -1)
            return !1;
          bValues.splice(index2, 1);
        }
        return !0;
      }
      case arrayTag:
      case uint8ArrayTag:
      case uint8ClampedArrayTag:
      case uint16ArrayTag:
      case uint32ArrayTag:
      case bigUint64ArrayTag:
      case int8ArrayTag:
      case int16ArrayTag:
      case int32ArrayTag:
      case bigInt64ArrayTag:
      case float32ArrayTag:
      case float64ArrayTag: {
        if (typeof Buffer < "u" && Buffer.isBuffer(a2) !== Buffer.isBuffer(b2) || a2.length !== b2.length)
          return !1;
        for (let i2 = 0; i2 < a2.length; i2++)
          if (!isEqualWithImpl(a2[i2], b2[i2], i2, a2, b2, stack, areValuesEqual))
            return !1;
        return !0;
      }
      case arrayBufferTag:
        return a2.byteLength !== b2.byteLength ? !1 : areObjectsEqual(new Uint8Array(a2), new Uint8Array(b2), stack, areValuesEqual);
      case dataViewTag:
        return a2.byteLength !== b2.byteLength || a2.byteOffset !== b2.byteOffset ? !1 : areObjectsEqual(new Uint8Array(a2), new Uint8Array(b2), stack, areValuesEqual);
      case errorTag:
        return a2.name === b2.name && a2.message === b2.message;
      case objectTag: {
        if (!(areObjectsEqual(a2.constructor, b2.constructor, stack, areValuesEqual) || isPlainObject(a2) && isPlainObject(b2)))
          return !1;
        let aKeys = [...Object.keys(a2), ...getSymbols(a2)], bKeys = [...Object.keys(b2), ...getSymbols(b2)];
        if (aKeys.length !== bKeys.length)
          return !1;
        for (let i2 = 0; i2 < aKeys.length; i2++) {
          let propKey = aKeys[i2], aProp = a2[propKey];
          if (!Object.hasOwn(b2, propKey))
            return !1;
          let bProp = b2[propKey];
          if (!isEqualWithImpl(aProp, bProp, propKey, a2, b2, stack, areValuesEqual))
            return !1;
        }
        return !0;
      }
      default:
        return !1;
    }
  } finally {
    stack.delete(a2), stack.delete(b2);
  }
}

// ../node_modules/es-toolkit/dist/function/noop.mjs
function noop2() {
}

// ../node_modules/es-toolkit/dist/predicate/isEqual.mjs
function isEqual2(a2, b2) {
  return isEqualWith(a2, b2, noop2);
}

// src/preview-api/modules/store/args.ts
var INCOMPATIBLE = Symbol("incompatible"), map = (arg, argType) => {
  let type5 = argType.type;
  if (arg == null || !type5 || argType.mapping)
    return arg;
  switch (type5.name) {
    case "string":
      return String(arg);
    case "enum":
      return arg;
    case "number":
      return Number(arg);
    case "boolean":
      return String(arg) === "true";
    case "array":
      return !type5.value || !Array.isArray(arg) ? INCOMPATIBLE : arg.reduce((acc, item, index2) => {
        let mapped = map(item, { type: type5.value });
        return mapped !== INCOMPATIBLE && (acc[index2] = mapped), acc;
      }, new Array(arg.length));
    case "object":
      return typeof arg == "string" || typeof arg == "number" ? arg : !type5.value || typeof arg != "object" ? INCOMPATIBLE : Object.entries(arg).reduce((acc, [key, val]) => {
        let mapped = map(val, { type: type5.value[key] });
        return mapped === INCOMPATIBLE ? acc : Object.assign(acc, { [key]: mapped });
      }, {});
    case "other": {
      let isPrimitiveArg = typeof arg == "string" || typeof arg == "number" || typeof arg == "boolean";
      return type5.value === "ReactNode" && isPrimitiveArg ? arg : INCOMPATIBLE;
    }
    default:
      return INCOMPATIBLE;
  }
}, mapArgsToTypes = (args, argTypes) => Object.entries(args).reduce((acc, [key, value]) => {
  if (!argTypes[key])
    return acc;
  let mapped = map(value, argTypes[key]);
  return mapped === INCOMPATIBLE ? acc : Object.assign(acc, { [key]: mapped });
}, {}), combineArgs = (value, update) => Array.isArray(value) && Array.isArray(update) ? update.reduce(
  (acc, upd, index2) => (acc[index2] = combineArgs(value[index2], update[index2]), acc),
  [...value]
).filter((v2) => v2 !== void 0) : !isPlainObject(value) || !isPlainObject(update) ? update : Object.keys({ ...value, ...update }).reduce((acc, key) => {
  if (key in update) {
    let combined = combineArgs(value[key], update[key]);
    combined !== void 0 && (acc[key] = combined);
  } else
    acc[key] = value[key];
  return acc;
}, {}), validateOptions2 = (args, argTypes) => Object.entries(argTypes).reduce((acc, [key, { options }]) => {
  function allowArg() {
    return key in args && (acc[key] = args[key]), acc;
  }
  if (!options)
    return allowArg();
  if (!Array.isArray(options))
    return once.error(dedent`
        Invalid argType: '${key}.options' should be an array.

        More info: https://storybook.js.org/docs/api/arg-types?ref=error
      `), allowArg();
  if (options.some((opt) => opt && ["object", "function"].includes(typeof opt)))
    return once.error(dedent`
        Invalid argType: '${key}.options' should only contain primitives. Use a 'mapping' for complex values.

        More info: https://storybook.js.org/docs/writing-stories/args?ref=error#mapping-to-complex-arg-values
      `), allowArg();
  let isArray3 = Array.isArray(args[key]), invalidIndex = isArray3 && args[key].findIndex((val) => !options.includes(val)), isValidArray = isArray3 && invalidIndex === -1;
  if (args[key] === void 0 || options.includes(args[key]) || isValidArray)
    return allowArg();
  let field = isArray3 ? `${key}[${invalidIndex}]` : key, supportedOptions = options.map((opt) => typeof opt == "string" ? `'${opt}'` : String(opt)).join(", ");
  return once.warn(`Received illegal value for '${field}'. Supported options: ${supportedOptions}`), acc;
}, {}), DEEPLY_EQUAL = Symbol("Deeply equal"), deepDiff = (value, update) => {
  if (typeof value != typeof update)
    return update;
  if (isEqual2(value, update))
    return DEEPLY_EQUAL;
  if (Array.isArray(value) && Array.isArray(update)) {
    let res = update.reduce((acc, upd, index2) => {
      let diff2 = deepDiff(value[index2], upd);
      return diff2 !== DEEPLY_EQUAL && (acc[index2] = diff2), acc;
    }, new Array(update.length));
    return update.length >= value.length ? res : res.concat(new Array(value.length - update.length).fill(void 0));
  }
  return isPlainObject(value) && isPlainObject(update) ? Object.keys({ ...value, ...update }).reduce((acc, key) => {
    let diff2 = deepDiff(value?.[key], update?.[key]);
    return diff2 === DEEPLY_EQUAL ? acc : Object.assign(acc, { [key]: diff2 });
  }, {}) : update;
}, UNTARGETED = "UNTARGETED";
function groupArgsByTarget({
  args,
  argTypes
}) {
  let groupedArgs = {};
  return Object.entries(args).forEach(([name, value]) => {
    let { target = UNTARGETED } = argTypes[name] || {};
    groupedArgs[target] = groupedArgs[target] || {}, groupedArgs[target][name] = value;
  }), groupedArgs;
}

// src/preview-api/modules/store/ArgsStore.ts
function deleteUndefined(obj) {
  return Object.keys(obj).forEach((key) => obj[key] === void 0 && delete obj[key]), obj;
}
var ArgsStore = class {
  constructor() {
    this.initialArgsByStoryId = {};
    this.argsByStoryId = {};
  }
  get(storyId) {
    if (!(storyId in this.argsByStoryId))
      throw new Error(`No args known for ${storyId} -- has it been rendered yet?`);
    return this.argsByStoryId[storyId];
  }
  setInitial(story) {
    if (!this.initialArgsByStoryId[story.id])
      this.initialArgsByStoryId[story.id] = story.initialArgs, this.argsByStoryId[story.id] = story.initialArgs;
    else if (this.initialArgsByStoryId[story.id] !== story.initialArgs) {
      let delta = deepDiff(this.initialArgsByStoryId[story.id], this.argsByStoryId[story.id]);
      this.initialArgsByStoryId[story.id] = story.initialArgs, this.argsByStoryId[story.id] = story.initialArgs, delta !== DEEPLY_EQUAL && this.updateFromDelta(story, delta);
    }
  }
  updateFromDelta(story, delta) {
    let validatedDelta = validateOptions2(delta, story.argTypes);
    this.argsByStoryId[story.id] = combineArgs(this.argsByStoryId[story.id], validatedDelta);
  }
  updateFromPersisted(story, persisted) {
    let mappedPersisted = mapArgsToTypes(persisted, story.argTypes);
    return this.updateFromDelta(story, mappedPersisted);
  }
  update(storyId, argsUpdate) {
    if (!(storyId in this.argsByStoryId))
      throw new Error(`No args known for ${storyId} -- has it been rendered yet?`);
    this.argsByStoryId[storyId] = deleteUndefined({
      ...this.argsByStoryId[storyId],
      ...argsUpdate
    });
  }
};

// src/preview-api/modules/store/csf/getValuesFromArgTypes.ts
var getValuesFromArgTypes = (argTypes = {}) => Object.entries(argTypes).reduce((acc, [arg, { defaultValue }]) => (typeof defaultValue < "u" && (acc[arg] = defaultValue), acc), {});

// src/preview-api/modules/store/GlobalsStore.ts
var GlobalsStore = class {
  constructor({
    globals = {},
    globalTypes = {}
  }) {
    this.set({ globals, globalTypes });
  }
  set({ globals = {}, globalTypes = {} }) {
    let delta = this.initialGlobals && deepDiff(this.initialGlobals, this.globals);
    this.allowedGlobalNames = /* @__PURE__ */ new Set([...Object.keys(globals), ...Object.keys(globalTypes)]);
    let defaultGlobals = getValuesFromArgTypes(globalTypes);
    this.initialGlobals = { ...defaultGlobals, ...globals }, this.globals = this.initialGlobals, delta && delta !== DEEPLY_EQUAL && this.updateFromPersisted(delta);
  }
  filterAllowedGlobals(globals) {
    return Object.entries(globals).reduce((acc, [key, value]) => (this.allowedGlobalNames.has(key) ? acc[key] = value : logger.warn(
      `Attempted to set a global (${key}) that is not defined in initial globals or globalTypes`
    ), acc), {});
  }
  updateFromPersisted(persisted) {
    let allowedUrlGlobals = this.filterAllowedGlobals(persisted);
    this.globals = { ...this.globals, ...allowedUrlGlobals };
  }
  get() {
    return this.globals;
  }
  update(newGlobals) {
    this.globals = { ...this.globals, ...this.filterAllowedGlobals(newGlobals) };
    for (let key in newGlobals)
      newGlobals[key] === void 0 && (this.globals[key] = this.initialGlobals[key]);
  }
};

// src/preview-api/modules/store/StoryIndexStore.ts
var import_memoizerific = __toESM(require_memoizerific(), 1), getImportPathMap = (0, import_memoizerific.default)(1)(
  (entries) => Object.values(entries).reduce(
    (acc, entry) => (acc[entry.importPath] = acc[entry.importPath] || entry, acc),
    {}
  )
), StoryIndexStore = class {
  constructor({ entries } = { v: 5, entries: {} }) {
    this.entries = entries;
  }
  entryFromSpecifier(specifier) {
    let entries = Object.values(this.entries);
    if (specifier === "*")
      return entries[0];
    if (typeof specifier == "string")
      return this.entries[specifier] ? this.entries[specifier] : entries.find((entry) => entry.id.startsWith(specifier));
    let { name, title } = specifier;
    return entries.find((entry) => entry.name === name && entry.title === title);
  }
  storyIdToEntry(storyId) {
    let storyEntry = this.entries[storyId];
    if (!storyEntry)
      throw new MissingStoryAfterHmrError({ storyId });
    return storyEntry;
  }
  importPathToEntry(importPath) {
    return getImportPathMap(this.entries)[importPath];
  }
};

// src/preview-api/modules/store/csf/normalizeInputTypes.ts
var normalizeType = (type5) => typeof type5 == "string" ? { name: type5 } : type5, normalizeControl = (control) => typeof control == "string" ? { type: control } : control, normalizeInputType = (inputType, key) => {
  let { type: type5, control, ...rest } = inputType, normalized = {
    name: key,
    ...rest
  };
  return type5 && (normalized.type = normalizeType(type5)), control ? normalized.control = normalizeControl(control) : control === !1 && (normalized.control = { disable: !0 }), normalized;
}, normalizeInputTypes = (inputTypes) => mapValues(inputTypes, normalizeInputType);

// src/preview-api/modules/store/csf/normalizeArrays.ts
var normalizeArrays = (array) => Array.isArray(array) ? array : array ? [array] : [];

// src/preview-api/modules/store/csf/normalizeStory.ts
var deprecatedStoryAnnotation = dedent`
CSF .story annotations deprecated; annotate story functions directly:
- StoryFn.story.name => StoryFn.storyName
- StoryFn.story.(parameters|decorators) => StoryFn.(parameters|decorators)
See https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#hoisted-csf-annotations for details and codemod.
`;
function normalizeStory(key, storyAnnotations, meta) {
  let storyObject = storyAnnotations, userStoryFn = typeof storyAnnotations == "function" ? storyAnnotations : null, { story } = storyObject;
  story && (logger.debug("deprecated story", story), deprecate(deprecatedStoryAnnotation));
  let exportName = storyNameFromExport(key), name = typeof storyObject != "function" && storyObject.name || storyObject.storyName || story?.name || exportName, decorators4 = [
    ...normalizeArrays(storyObject.decorators),
    ...normalizeArrays(story?.decorators)
  ], parameters2 = { ...story?.parameters, ...storyObject.parameters }, args = { ...story?.args, ...storyObject.args }, argTypes = { ...story?.argTypes, ...storyObject.argTypes }, loaders2 = [...normalizeArrays(storyObject.loaders), ...normalizeArrays(story?.loaders)], beforeEach = [
    ...normalizeArrays(storyObject.beforeEach),
    ...normalizeArrays(story?.beforeEach)
  ], afterEach = [
    ...normalizeArrays(storyObject.afterEach),
    ...normalizeArrays(story?.afterEach)
  ], { render, play, tags = [], globals = {} } = storyObject, id = parameters2.__id || toId(meta.id, exportName);
  return {
    moduleExport: storyAnnotations,
    id,
    name,
    tags,
    decorators: decorators4,
    parameters: parameters2,
    args,
    argTypes: normalizeInputTypes(argTypes),
    loaders: loaders2,
    beforeEach,
    afterEach,
    globals,
    ...render && { render },
    ...userStoryFn && { userStoryFn },
    ...play && { play }
  };
}

// src/preview-api/modules/store/csf/normalizeComponentAnnotations.ts
function normalizeComponentAnnotations(defaultExport, title = defaultExport.title, importPath) {
  let { id, argTypes } = defaultExport;
  return {
    id: sanitize(id || title),
    ...defaultExport,
    title,
    ...argTypes && { argTypes: normalizeInputTypes(argTypes) },
    parameters: {
      fileName: importPath,
      ...defaultExport.parameters
    }
  };
}

// src/preview-api/modules/store/csf/processCSFFile.ts
var checkGlobals = (parameters2) => {
  let { globals, globalTypes } = parameters2;
  (globals || globalTypes) && logger.error(
    "Global args/argTypes can only be set globally",
    JSON.stringify({
      globals,
      globalTypes
    })
  );
}, checkStorySort = (parameters2) => {
  let { options } = parameters2;
  options?.storySort && logger.error("The storySort option parameter can only be set globally");
}, checkDisallowedParameters = (parameters2) => {
  parameters2 && (checkGlobals(parameters2), checkStorySort(parameters2));
};
function processCSFFile(moduleExports, importPath, title) {
  let { default: defaultExport, __namedExportsOrder, ...namedExports } = moduleExports, firstStory = Object.values(namedExports)[0];
  if (isStory(firstStory)) {
    let meta2 = normalizeComponentAnnotations(firstStory.meta.input, title, importPath);
    checkDisallowedParameters(meta2.parameters);
    let csfFile2 = { meta: meta2, stories: {}, moduleExports };
    return Object.keys(namedExports).forEach((key) => {
      if (isExportStory(key, meta2)) {
        let story = namedExports[key], storyMeta = normalizeStory(key, story.input, meta2);
        checkDisallowedParameters(storyMeta.parameters), csfFile2.stories[storyMeta.id] = storyMeta, getStoryChildren(story).forEach((child) => {
          let name = child.input.name, childId = toTestId(storyMeta.id, name);
          child.input.parameters ??= {}, child.input.parameters.__id = childId, csfFile2.stories[childId] = normalizeStory(name, child.input, meta2);
        });
      }
    }), csfFile2.projectAnnotations = firstStory.meta.preview.composed, csfFile2;
  }
  let meta = normalizeComponentAnnotations(
    defaultExport,
    title,
    importPath
  );
  checkDisallowedParameters(meta.parameters);
  let csfFile = { meta, stories: {}, moduleExports };
  return Object.keys(namedExports).forEach((key) => {
    if (isExportStory(key, meta)) {
      let storyMeta = normalizeStory(key, namedExports[key], meta);
      checkDisallowedParameters(storyMeta.parameters), csfFile.stories[storyMeta.id] = storyMeta;
    }
  }), csfFile;
}

// src/preview-api/modules/store/decorators.ts
function decorateStory(storyFn, decorator, bindWithContext) {
  let boundStoryFunction = bindWithContext(storyFn);
  return (context) => decorator(boundStoryFunction, context);
}
function sanitizeStoryContextUpdate({
  componentId,
  title,
  kind,
  id,
  name,
  story,
  parameters: parameters2,
  initialArgs,
  argTypes,
  ...update
} = {}) {
  return update;
}
function defaultDecorateStory(storyFn, decorators4) {
  let contextStore = {}, bindWithContext = (decoratedStoryFn) => (update) => {
    if (!contextStore.value)
      throw new Error("Decorated function called without init");
    return contextStore.value = {
      ...contextStore.value,
      ...sanitizeStoryContextUpdate(update)
    }, decoratedStoryFn(contextStore.value);
  }, decoratedWithContextStore = decorators4.reduce(
    (story, decorator) => decorateStory(story, decorator, bindWithContext),
    storyFn
  );
  return (context) => (contextStore.value = context, decoratedWithContextStore(context));
}

// src/preview-api/modules/store/parameters.ts
var combineParameters = (...parameterSets) => {
  let mergeKeys = {}, definedParametersSets = parameterSets.filter(Boolean), combined = definedParametersSets.reduce((acc, parameters2) => (Object.entries(parameters2).forEach(([key, value]) => {
    let existing = acc[key];
    Array.isArray(value) || typeof existing > "u" ? acc[key] = value : isPlainObject(value) && isPlainObject(existing) ? mergeKeys[key] = !0 : typeof value < "u" && (acc[key] = value);
  }), acc), {});
  return Object.keys(mergeKeys).forEach((key) => {
    let mergeValues = definedParametersSets.filter(Boolean).map((p2) => p2[key]).filter((value) => typeof value < "u");
    mergeValues.every((value) => isPlainObject(value)) ? combined[key] = combineParameters(...mergeValues) : combined[key] = mergeValues[mergeValues.length - 1];
  }), combined;
};

// src/preview-api/modules/store/csf/prepareStory.ts
function prepareStory(storyAnnotations, componentAnnotations, projectAnnotations) {
  let { moduleExport, id, name } = storyAnnotations || {}, partialAnnotations = preparePartialAnnotations(
    storyAnnotations,
    componentAnnotations,
    projectAnnotations
  ), applyLoaders = async (context) => {
    let loaded = {};
    for (let loaders2 of [
      normalizeArrays(projectAnnotations.loaders),
      normalizeArrays(componentAnnotations.loaders),
      normalizeArrays(storyAnnotations.loaders)
    ]) {
      if (context.abortSignal.aborted)
        return loaded;
      let loadResults = await Promise.all(loaders2.map((loader) => loader(context)));
      Object.assign(loaded, ...loadResults);
    }
    return loaded;
  }, applyBeforeEach = async (context) => {
    let cleanupCallbacks = new Array();
    for (let beforeEach of [
      ...normalizeArrays(projectAnnotations.beforeEach),
      ...normalizeArrays(componentAnnotations.beforeEach),
      ...normalizeArrays(storyAnnotations.beforeEach)
    ]) {
      if (context.abortSignal.aborted)
        return cleanupCallbacks;
      let cleanup = await beforeEach(context);
      cleanup && cleanupCallbacks.push(cleanup);
    }
    return cleanupCallbacks;
  }, applyAfterEach = async (context) => {
    let reversedFinalizers = [
      ...normalizeArrays(projectAnnotations.afterEach),
      ...normalizeArrays(componentAnnotations.afterEach),
      ...normalizeArrays(storyAnnotations.afterEach)
    ].reverse();
    for (let finalizer of reversedFinalizers) {
      if (context.abortSignal.aborted)
        return;
      await finalizer(context);
    }
  }, undecoratedStoryFn = (context) => context.originalStoryFn(context.args, context), { applyDecorators = defaultDecorateStory, runStep } = projectAnnotations, decorators4 = [
    ...normalizeArrays(storyAnnotations?.decorators),
    ...normalizeArrays(componentAnnotations?.decorators),
    ...normalizeArrays(projectAnnotations?.decorators)
  ], render = storyAnnotations?.userStoryFn || storyAnnotations?.render || componentAnnotations.render || projectAnnotations.render, decoratedStoryFn = applyHooks(applyDecorators)(undecoratedStoryFn, decorators4), unboundStoryFn = (context) => decoratedStoryFn(context), playFunction = storyAnnotations?.play ?? componentAnnotations?.play, usesMount = mountDestructured(playFunction);
  if (!render && !usesMount)
    throw new NoRenderFunctionError({ id });
  let defaultMount = (context) => async () => (await context.renderToCanvas(), context.canvas), mount = storyAnnotations.mount ?? componentAnnotations.mount ?? projectAnnotations.mount ?? defaultMount, testingLibraryRender = projectAnnotations.testingLibraryRender;
  return {
    storyGlobals: {},
    ...partialAnnotations,
    moduleExport,
    id,
    name,
    story: name,
    originalStoryFn: render,
    undecoratedStoryFn,
    unboundStoryFn,
    applyLoaders,
    applyBeforeEach,
    applyAfterEach,
    playFunction,
    runStep,
    mount,
    testingLibraryRender,
    renderToCanvas: projectAnnotations.renderToCanvas,
    usesMount
  };
}
function prepareMeta(componentAnnotations, projectAnnotations, moduleExport) {
  return {
    ...preparePartialAnnotations(void 0, componentAnnotations, projectAnnotations),
    moduleExport
  };
}
function preparePartialAnnotations(storyAnnotations, componentAnnotations, projectAnnotations) {
  let defaultTags = ["dev", "test"], extraTags = scope.DOCS_OPTIONS?.autodocs === !0 ? ["autodocs"] : [], overrideTags = storyAnnotations?.tags?.includes("test-fn") ? ["!autodocs"] : [], tags = combineTags(
    ...defaultTags,
    ...extraTags,
    ...projectAnnotations.tags ?? [],
    ...componentAnnotations.tags ?? [],
    ...overrideTags,
    ...storyAnnotations?.tags ?? []
  ), parameters2 = combineParameters(
    projectAnnotations.parameters,
    componentAnnotations.parameters,
    storyAnnotations?.parameters
  ), { argTypesEnhancers = [], argsEnhancers: argsEnhancers2 = [] } = projectAnnotations, passedArgTypes = combineParameters(
    projectAnnotations.argTypes,
    componentAnnotations.argTypes,
    storyAnnotations?.argTypes
  );
  if (storyAnnotations) {
    let render = storyAnnotations?.userStoryFn || storyAnnotations?.render || componentAnnotations.render || projectAnnotations.render;
    parameters2.__isArgsStory = render && render.length > 0;
  }
  let passedArgs = {
    ...projectAnnotations.args,
    ...componentAnnotations.args,
    ...storyAnnotations?.args
  }, storyGlobals = {
    ...componentAnnotations.globals,
    ...storyAnnotations?.globals
  }, contextForEnhancers = {
    componentId: componentAnnotations.id,
    title: componentAnnotations.title,
    kind: componentAnnotations.title,
    // Back compat
    id: storyAnnotations?.id || componentAnnotations.id,
    // if there's no story name, we create a fake one since enhancers expect a name
    name: storyAnnotations?.name || "__meta",
    story: storyAnnotations?.name || "__meta",
    // Back compat
    component: componentAnnotations.component,
    subcomponents: componentAnnotations.subcomponents,
    tags,
    parameters: parameters2,
    initialArgs: passedArgs,
    argTypes: passedArgTypes,
    storyGlobals
  };
  contextForEnhancers.argTypes = argTypesEnhancers.reduce(
    (accumulatedArgTypes, enhancer) => enhancer({ ...contextForEnhancers, argTypes: accumulatedArgTypes }),
    contextForEnhancers.argTypes
  );
  let initialArgsBeforeEnhancers = { ...passedArgs };
  contextForEnhancers.initialArgs = [...argsEnhancers2].reduce(
    (accumulatedArgs, enhancer) => ({
      ...accumulatedArgs,
      ...enhancer({
        ...contextForEnhancers,
        initialArgs: accumulatedArgs
      })
    }),
    initialArgsBeforeEnhancers
  );
  let { name, story, ...withoutStoryIdentifiers } = contextForEnhancers;
  return withoutStoryIdentifiers;
}
function prepareContext(context) {
  let { args: unmappedArgs } = context, targetedContext = {
    ...context,
    allArgs: void 0,
    argsByTarget: void 0
  };
  if (scope.FEATURES?.argTypeTargetsV7) {
    let argsByTarget = groupArgsByTarget(context);
    targetedContext = {
      ...context,
      allArgs: context.args,
      argsByTarget,
      args: argsByTarget[UNTARGETED] || {}
    };
  }
  let mappedArgs = Object.entries(targetedContext.args).reduce((acc, [key, val]) => {
    if (!targetedContext.argTypes[key]?.mapping)
      return acc[key] = val, acc;
    let mappingFn = (originalValue) => {
      let mapping = targetedContext.argTypes[key].mapping;
      return mapping && originalValue in mapping ? mapping[originalValue] : originalValue;
    };
    return acc[key] = Array.isArray(val) ? val.map(mappingFn) : mappingFn(val), acc;
  }, {}), includedArgs = Object.entries(mappedArgs).reduce((acc, [key, val]) => {
    let argType = targetedContext.argTypes[key] || {};
    return includeConditionalArg(argType, mappedArgs, targetedContext.globals) && (acc[key] = val), acc;
  }, {});
  return { ...targetedContext, unmappedArgs, args: includedArgs };
}

// src/preview-api/modules/store/inferArgTypes.ts
var inferType = (value, name, visited) => {
  let type5 = typeof value;
  switch (type5) {
    case "boolean":
    case "string":
    case "number":
    case "function":
    case "symbol":
      return { name: type5 };
    default:
      break;
  }
  return value ? visited.has(value) ? (logger.warn(dedent`
        We've detected a cycle in arg '${name}'. Args should be JSON-serializable.

        Consider using the mapping feature or fully custom args:
        - Mapping: https://storybook.js.org/docs/writing-stories/args#mapping-to-complex-arg-values
        - Custom args: https://storybook.js.org/docs/essentials/controls#fully-custom-args
      `), { name: "other", value: "cyclic object" }) : (visited.add(value), Array.isArray(value) ? { name: "array", value: value.length > 0 ? inferType(value[0], name, new Set(visited)) : { name: "other", value: "unknown" } } : { name: "object", value: mapValues(value, (field) => inferType(field, name, new Set(visited))) }) : { name: "object", value: {} };
}, inferArgTypes = (context) => {
  let { id, argTypes: userArgTypes = {}, initialArgs = {} } = context, argTypes = mapValues(initialArgs, (arg, key) => ({
    name: key,
    type: inferType(arg, `${id}.${key}`, /* @__PURE__ */ new Set())
  })), userArgTypesNames = mapValues(userArgTypes, (argType, key) => ({
    name: key
  }));
  return combineParameters(argTypes, userArgTypesNames, userArgTypes);
};
inferArgTypes.secondPass = !0;

// src/preview-api/modules/store/filterArgTypes.ts
var matches4 = (name, descriptor) => Array.isArray(descriptor) ? descriptor.includes(name) : name.match(descriptor), filterArgTypes = (argTypes, include2, exclude) => !include2 && !exclude ? argTypes : argTypes && pickBy(argTypes, (argType, key) => {
  let name = argType.name || key.toString();
  return !!(!include2 || matches4(name, include2)) && (!exclude || !matches4(name, exclude));
});

// src/preview-api/modules/store/inferControls.ts
var inferControl = (argType, name, matchers) => {
  let { type: type5, options } = argType;
  if (type5) {
    if (matchers.color && matchers.color.test(name)) {
      let controlType = type5.name;
      if (controlType === "string")
        return { control: { type: "color" } };
      controlType !== "enum" && logger.warn(
        `Addon controls: Control of type color only supports string, received "${controlType}" instead`
      );
    }
    if (matchers.date && matchers.date.test(name))
      return { control: { type: "date" } };
    switch (type5.name) {
      case "array":
        return { control: { type: "object" } };
      case "boolean":
        return { control: { type: "boolean" } };
      case "string":
        return { control: { type: "text" } };
      case "number":
        return { control: { type: "number" } };
      case "enum": {
        let { value } = type5;
        return { control: { type: value?.length <= 5 ? "radio" : "select" }, options: value };
      }
      case "function":
      case "symbol":
        return null;
      default:
        return { control: { type: options ? "select" : "object" } };
    }
  }
}, inferControls = (context) => {
  let {
    argTypes,
    parameters: { __isArgsStory, controls: { include: include2 = null, exclude = null, matchers = {} } = {} }
  } = context;
  if (!__isArgsStory)
    return argTypes;
  let filteredArgTypes = filterArgTypes(argTypes, include2, exclude), withControls = mapValues(filteredArgTypes, (argType, name) => argType?.type && inferControl(argType, name.toString(), matchers));
  return combineParameters(withControls, filteredArgTypes);
};
inferControls.secondPass = !0;

// src/preview-api/modules/store/csf/normalizeProjectAnnotations.ts
function normalizeProjectAnnotations({
  argTypes,
  globalTypes,
  argTypesEnhancers,
  decorators: decorators4,
  loaders: loaders2,
  beforeEach,
  afterEach,
  initialGlobals: initialGlobals5,
  ...annotations
}) {
  return {
    ...argTypes && { argTypes: normalizeInputTypes(argTypes) },
    ...globalTypes && { globalTypes: normalizeInputTypes(globalTypes) },
    decorators: normalizeArrays(decorators4),
    loaders: normalizeArrays(loaders2),
    beforeEach: normalizeArrays(beforeEach),
    afterEach: normalizeArrays(afterEach),
    argTypesEnhancers: [
      ...argTypesEnhancers || [],
      inferArgTypes,
      // There's an architectural decision to be made regarding embedded addons in core:
      //
      // Option 1: Keep embedded addons but ensure consistency by moving addon-specific code
      // (like inferControls) to live alongside the addon code itself. This maintains the
      // concept of core addons while improving code organization.
      //
      // Option 2: Fully integrate these addons into core, potentially moving UI components
      // into the manager and treating them as core features rather than addons. This is a
      // bigger architectural change requiring careful consideration.
      //
      // For now, we're keeping inferControls here as we need time to properly evaluate
      // these options and their implications. Some features (like Angular's cleanArgsDecorator)
      // currently rely on this behavior.
      //
      // TODO: Make an architectural decision on the handling of core addons
      inferControls
    ],
    initialGlobals: initialGlobals5,
    ...annotations
  };
}

// src/preview-api/modules/store/csf/beforeAll.ts
var composeBeforeAllHooks = (hooks) => async () => {
  let cleanups2 = [];
  for (let hook of hooks) {
    let cleanup = await hook();
    cleanup && cleanups2.unshift(cleanup);
  }
  return async () => {
    for (let cleanup of cleanups2)
      await cleanup();
  };
};

// src/preview-api/modules/store/csf/stepRunners.ts
function composeStepRunners(stepRunners) {
  return async (label, play, playContext) => {
    await stepRunners.reduceRight(
      (innerPlay, stepRunner) => async () => stepRunner(label, innerPlay, playContext),
      async () => play(playContext)
    )();
  };
}

// src/preview-api/modules/store/csf/composeConfigs.ts
function getField(moduleExportList, field) {
  return moduleExportList.map((xs) => xs.default?.[field] ?? xs[field]).filter(Boolean);
}
function getArrayField(moduleExportList, field, options = {}) {
  return getField(moduleExportList, field).reduce((prev, cur) => {
    let normalized = normalizeArrays(cur);
    return options.reverseFileOrder ? [...normalized, ...prev] : [...prev, ...normalized];
  }, []);
}
function getObjectField(moduleExportList, field) {
  return Object.assign({}, ...getField(moduleExportList, field));
}
function getSingletonField(moduleExportList, field) {
  return getField(moduleExportList, field).pop();
}
function composeConfigs(moduleExportList) {
  let allArgTypeEnhancers = getArrayField(moduleExportList, "argTypesEnhancers"), stepRunners = getField(moduleExportList, "runStep"), beforeAllHooks = getArrayField(moduleExportList, "beforeAll");
  return {
    parameters: combineParameters(...getField(moduleExportList, "parameters")),
    decorators: getArrayField(moduleExportList, "decorators", {
      reverseFileOrder: !(scope.FEATURES?.legacyDecoratorFileOrder ?? !1)
    }),
    args: getObjectField(moduleExportList, "args"),
    argsEnhancers: getArrayField(moduleExportList, "argsEnhancers"),
    argTypes: getObjectField(moduleExportList, "argTypes"),
    argTypesEnhancers: [
      ...allArgTypeEnhancers.filter((e2) => !e2.secondPass),
      ...allArgTypeEnhancers.filter((e2) => e2.secondPass)
    ],
    initialGlobals: getObjectField(moduleExportList, "initialGlobals"),
    globalTypes: getObjectField(moduleExportList, "globalTypes"),
    loaders: getArrayField(moduleExportList, "loaders"),
    beforeAll: composeBeforeAllHooks(beforeAllHooks),
    beforeEach: getArrayField(moduleExportList, "beforeEach"),
    afterEach: getArrayField(moduleExportList, "afterEach"),
    render: getSingletonField(moduleExportList, "render"),
    renderToCanvas: getSingletonField(moduleExportList, "renderToCanvas"),
    applyDecorators: getSingletonField(moduleExportList, "applyDecorators"),
    runStep: composeStepRunners(stepRunners),
    tags: getArrayField(moduleExportList, "tags"),
    mount: getSingletonField(moduleExportList, "mount"),
    testingLibraryRender: getSingletonField(moduleExportList, "testingLibraryRender")
  };
}

// src/preview-api/modules/preview-web/render/animation-utils.ts
function isTestEnvironment() {
  try {
    return (
      // @ts-expect-error This property exists in Vitest browser mode
      !!globalThis.__vitest_browser__ || !!globalThis.window?.navigator?.userAgent?.match(/StorybookTestRunner/)
    );
  } catch {
    return !1;
  }
}
function pauseAnimations(atEnd = !0) {
  if (!("document" in globalThis && "createElement" in globalThis.document))
    return () => {
    };
  let disableStyle = document.createElement("style");
  disableStyle.textContent = `*, *:before, *:after {
    animation: none !important;
  }`, document.head.appendChild(disableStyle);
  let pauseStyle = document.createElement("style");
  return pauseStyle.textContent = `*, *:before, *:after {
    animation-delay: 0s !important;
    animation-direction: ${atEnd ? "reverse" : "normal"} !important;
    animation-play-state: paused !important;
    transition: none !important;
  }`, document.head.appendChild(pauseStyle), document.body.clientHeight, document.head.removeChild(disableStyle), () => {
    pauseStyle.parentNode?.removeChild(pauseStyle);
  };
}
async function waitForAnimations(signal) {
  if (!("document" in globalThis && "getAnimations" in globalThis.document && "querySelectorAll" in globalThis.document))
    return;
  let timedOut = !1;
  await Promise.race([
    // After 50ms, retrieve any running animations and wait for them to finish
    // If new animations are created while waiting, we'll wait for them too
    new Promise((resolve) => {
      setTimeout(() => {
        let animationRoots = [globalThis.document, ...getShadowRoots(globalThis.document)], checkAnimationsFinished = async () => {
          if (timedOut || signal?.aborted)
            return;
          let runningAnimations = animationRoots.flatMap((el) => el?.getAnimations?.() || []).filter((a2) => a2.playState === "running" && !isInfiniteAnimation(a2));
          runningAnimations.length > 0 && (await Promise.all(runningAnimations.map((a2) => a2.finished)), await checkAnimationsFinished());
        };
        checkAnimationsFinished().then(resolve);
      }, 100);
    }),
    // If animations don't finish within the timeout, continue without waiting
    new Promise(
      (resolve) => setTimeout(() => {
        timedOut = !0, resolve(void 0);
      }, 5e3)
    )
  ]);
}
function getShadowRoots(doc) {
  return [doc, ...doc.querySelectorAll("*")].reduce((acc, el) => ("shadowRoot" in el && el.shadowRoot && acc.push(el.shadowRoot, ...getShadowRoots(el.shadowRoot)), acc), []);
}
function isInfiniteAnimation(anim) {
  if (anim instanceof CSSAnimation && anim.effect instanceof KeyframeEffect && anim.effect.target) {
    let style = getComputedStyle(anim.effect.target, anim.effect.pseudoElement), index2 = style.animationName?.split(", ").indexOf(anim.animationName);
    return style.animationIterationCount.split(", ")[index2] === "infinite";
  }
  return !1;
}

// src/preview-api/modules/store/reporter-api.ts
var ReporterAPI = class {
  constructor() {
    this.reports = [];
  }
  async addReport(report) {
    this.reports.push(report);
  }
};

// src/preview-api/modules/store/csf/csf-factory-utils.ts
function getCsfFactoryAnnotations(story, meta, projectAnnotations) {
  return isStory(story) ? {
    story: story.input,
    meta: story.meta.input,
    preview: story.meta.preview.composed
  } : { story, meta: isMeta(meta) ? meta.input : meta, preview: projectAnnotations };
}

// src/preview-api/modules/store/csf/portable-stories.ts
function setDefaultProjectAnnotations(_defaultProjectAnnotations) {
  globalThis.defaultProjectAnnotations = _defaultProjectAnnotations;
}
var DEFAULT_STORY_TITLE = "ComposedStory", DEFAULT_STORY_NAME = "Unnamed Story";
function extractAnnotation(annotation) {
  return annotation ? composeConfigs([annotation]) : {};
}
function setProjectAnnotations(projectAnnotations) {
  let annotations = Array.isArray(projectAnnotations) ? projectAnnotations : [projectAnnotations];
  return globalThis.globalProjectAnnotations = composeConfigs([
    ...getCoreAnnotations(),
    globalThis.defaultProjectAnnotations ?? {},
    composeConfigs(annotations.map(extractAnnotation))
  ]), globalThis.globalProjectAnnotations ?? {};
}
var cleanups = [];
function composeStory(storyAnnotations, componentAnnotations, projectAnnotations, defaultConfig, exportsName) {
  if (storyAnnotations === void 0)
    throw new Error("Expected a story but received undefined.");
  componentAnnotations.title = componentAnnotations.title ?? DEFAULT_STORY_TITLE;
  let normalizedComponentAnnotations = normalizeComponentAnnotations(componentAnnotations), storyName = exportsName || storyAnnotations.storyName || storyAnnotations.story?.name || storyAnnotations.name || DEFAULT_STORY_NAME, normalizedStory = normalizeStory(
    storyName,
    storyAnnotations,
    normalizedComponentAnnotations
  ), normalizedProjectAnnotations = normalizeProjectAnnotations(
    composeConfigs([
      defaultConfig ?? globalThis.globalProjectAnnotations ?? {},
      projectAnnotations ?? {}
    ])
  ), story = prepareStory(
    normalizedStory,
    normalizedComponentAnnotations,
    normalizedProjectAnnotations
  ), globals = {
    ...getValuesFromArgTypes(normalizedProjectAnnotations.globalTypes),
    ...normalizedProjectAnnotations.initialGlobals,
    ...story.storyGlobals
  }, reporting = new ReporterAPI(), initializeContext = () => {
    let context = prepareContext({
      hooks: new HooksContext(),
      globals,
      args: { ...story.initialArgs },
      viewMode: "story",
      reporting,
      loaded: {},
      abortSignal: new AbortController().signal,
      step: (label, play2) => story.runStep(label, play2, context),
      canvasElement: null,
      canvas: {},
      userEvent: {},
      globalTypes: normalizedProjectAnnotations.globalTypes,
      ...story,
      context: null,
      mount: null
    });
    return context.parameters.__isPortableStory = !0, context.context = context, story.renderToCanvas && (context.renderToCanvas = async () => {
      let unmount = await story.renderToCanvas?.(
        {
          componentId: story.componentId,
          title: story.title,
          id: story.id,
          name: story.name,
          tags: story.tags,
          showMain: () => {
          },
          showError: (error) => {
            throw new Error(`${error.title}
${error.description}`);
          },
          showException: (error) => {
            throw error;
          },
          forceRemount: !0,
          storyContext: context,
          storyFn: () => story.unboundStoryFn(context),
          unboundStoryFn: story.unboundStoryFn
        },
        context.canvasElement
      );
      unmount && cleanups.push(unmount);
    }), context.mount = story.mount(context), context;
  }, loadedContext, play = async (extraContext) => {
    let context = initializeContext();
    return context.canvasElement ??= globalThis?.document?.body, loadedContext && (context.loaded = loadedContext.loaded), Object.assign(context, extraContext), story.playFunction(context);
  }, run = (extraContext) => {
    let context = initializeContext();
    return Object.assign(context, extraContext), runStory(story, context);
  }, playFunction = story.playFunction ? play : void 0;
  return Object.assign(
    function(extraArgs) {
      let context = initializeContext();
      return loadedContext && (context.loaded = loadedContext.loaded), context.args = {
        ...context.initialArgs,
        ...extraArgs
      }, story.unboundStoryFn(context);
    },
    {
      id: story.id,
      storyName,
      load: async () => {
        for (let callback of [...cleanups].reverse())
          await callback();
        cleanups.length = 0;
        let context = initializeContext();
        context.loaded = await story.applyLoaders(context), cleanups.push(...(await story.applyBeforeEach(context)).filter(Boolean)), loadedContext = context;
      },
      globals,
      args: story.initialArgs,
      parameters: story.parameters,
      argTypes: story.argTypes,
      play: playFunction,
      run,
      reporting,
      tags: story.tags
    }
  );
}
var defaultComposeStory = (story, component, project, exportsName) => composeStory(story, component, project, {}, exportsName);
function composeStories(storiesImport, globalConfig, composeStoryFn = defaultComposeStory) {
  let { default: metaExport, __esModule, __namedExportsOrder, ...stories } = storiesImport, meta = metaExport;
  return Object.entries(stories).reduce(
    (storiesMap, [exportsName, story]) => {
      let { story: storyAnnotations, meta: componentAnnotations } = getCsfFactoryAnnotations(story);
      return !meta && componentAnnotations && (meta = componentAnnotations), isExportStory(exportsName, meta) ? Object.assign(storiesMap, {
        [exportsName]: composeStoryFn(storyAnnotations, meta, globalConfig, exportsName)
      }) : storiesMap;
    },
    {}
  );
}
function createPlaywrightTest(baseTest) {
  return baseTest.extend({
    mount: async ({ mount, page }, use2) => {
      await use2(async (storyRef, ...restArgs) => {
        if (!("__pw_type" in storyRef) || "__pw_type" in storyRef && storyRef.__pw_type !== "jsx")
          throw new Error(dedent`
              Portable stories in Playwright CT only work when referencing JSX elements.
              Please use JSX format for your components such as:

              instead of:
              await mount(MyComponent, { props: { foo: 'bar' } })

              do:
              await mount(<MyComponent foo="bar"/>)

              More info: https://storybook.js.org/docs/api/portable-stories/portable-stories-playwright?ref=error
            `);
        let { props, ...storyRefWithoutProps } = storyRef;
        await page.evaluate(async (wrappedStoryRef) => {
          let unwrappedStoryRef = await globalThis.__pwUnwrapObject?.(wrappedStoryRef);
          return ("__pw_type" in unwrappedStoryRef ? unwrappedStoryRef.type : unwrappedStoryRef)?.load?.();
        }, storyRefWithoutProps);
        let mountResult = await mount(storyRef, ...restArgs);
        return await page.evaluate(async (wrappedStoryRef) => {
          let unwrappedStoryRef = await globalThis.__pwUnwrapObject?.(wrappedStoryRef), story = "__pw_type" in unwrappedStoryRef ? unwrappedStoryRef.type : unwrappedStoryRef, canvasElement = document.querySelector("#root");
          return story?.play?.({ canvasElement });
        }, storyRefWithoutProps), mountResult;
      });
    }
  });
}
async function runStory(story, context) {
  for (let callback of [...cleanups].reverse())
    await callback();
  if (cleanups.length = 0, !context.canvasElement) {
    let container = document.createElement("div");
    globalThis?.document?.body?.appendChild(container), context.canvasElement = container, cleanups.push(() => {
      globalThis?.document?.body?.contains(container) && globalThis?.document?.body?.removeChild(container);
    });
  }
  if (context.loaded = await story.applyLoaders(context), context.abortSignal.aborted)
    return;
  cleanups.push(...(await story.applyBeforeEach(context)).filter(Boolean));
  let playFunction = story.playFunction, isMountDestructured = story.usesMount;
  if (isMountDestructured || await context.mount(), context.abortSignal.aborted)
    return;
  playFunction && (isMountDestructured || (context.mount = async () => {
    throw new MountMustBeDestructuredError({ playFunction: playFunction.toString() });
  }), await playFunction(context));
  let cleanUp;
  isTestEnvironment() ? cleanUp = pauseAnimations() : await waitForAnimations(context.abortSignal), await story.applyAfterEach(context), await cleanUp?.();
}

// src/preview-api/modules/store/StoryStore.ts
var CSF_CACHE_SIZE = 1e3, STORY_CACHE_SIZE = 1e4, StoryStore = class {
  constructor(storyIndex, importFn, projectAnnotations) {
    this.importFn = importFn;
    this.storyIndex = new StoryIndexStore(storyIndex), this.projectAnnotations = normalizeProjectAnnotations(
      composeConfigs([...getCoreAnnotations(), projectAnnotations])
    );
    let { initialGlobals: initialGlobals5, globalTypes } = this.projectAnnotations;
    this.args = new ArgsStore(), this.userGlobals = new GlobalsStore({ globals: initialGlobals5, globalTypes }), this.hooks = {}, this.cleanupCallbacks = {}, this.processCSFFileWithCache = (0, import_memoizerific2.default)(CSF_CACHE_SIZE)(processCSFFile), this.prepareMetaWithCache = (0, import_memoizerific2.default)(CSF_CACHE_SIZE)(prepareMeta), this.prepareStoryWithCache = (0, import_memoizerific2.default)(STORY_CACHE_SIZE)(prepareStory);
  }
  setProjectAnnotations(projectAnnotations) {
    this.projectAnnotations = normalizeProjectAnnotations(projectAnnotations);
    let { initialGlobals: initialGlobals5, globalTypes } = projectAnnotations;
    this.userGlobals.set({ globals: initialGlobals5, globalTypes });
  }
  // This means that one of the CSF files has changed.
  // If the `importFn` has changed, we will invalidate both caches.
  // If the `storyIndex` data has changed, we may or may not invalidate the caches, depending
  // on whether we've loaded the relevant files yet.
  async onStoriesChanged({
    importFn,
    storyIndex
  }) {
    importFn && (this.importFn = importFn), storyIndex && (this.storyIndex.entries = storyIndex.entries), this.cachedCSFFiles && await this.cacheAllCSFFiles();
  }
  // Get an entry from the index, waiting on initialization if necessary
  async storyIdToEntry(storyId) {
    return this.storyIndex.storyIdToEntry(storyId);
  }
  // To load a single CSF file to service a story we need to look up the importPath in the index
  async loadCSFFileByStoryId(storyId) {
    let { importPath, title } = this.storyIndex.storyIdToEntry(storyId), moduleExports = await this.importFn(importPath);
    return this.processCSFFileWithCache(moduleExports, importPath, title);
  }
  async loadAllCSFFiles() {
    let importPaths = {};
    return Object.entries(this.storyIndex.entries).forEach(([storyId, { importPath }]) => {
      importPaths[importPath] = storyId;
    }), (await Promise.all(
      Object.entries(importPaths).map(async ([importPath, storyId]) => ({
        importPath,
        csfFile: await this.loadCSFFileByStoryId(storyId)
      }))
    )).reduce(
      (acc, { importPath, csfFile }) => (acc[importPath] = csfFile, acc),
      {}
    );
  }
  async cacheAllCSFFiles() {
    this.cachedCSFFiles = await this.loadAllCSFFiles();
  }
  preparedMetaFromCSFFile({ csfFile }) {
    let componentAnnotations = csfFile.meta;
    return this.prepareMetaWithCache(
      componentAnnotations,
      this.projectAnnotations,
      csfFile.moduleExports.default
    );
  }
  // Load the CSF file for a story and prepare the story from it and the project annotations.
  async loadStory({ storyId }) {
    let csfFile = await this.loadCSFFileByStoryId(storyId);
    return this.storyFromCSFFile({ storyId, csfFile });
  }
  // This function is synchronous for convenience -- often times if you have a CSF file already
  // it is easier not to have to await `loadStory`.
  storyFromCSFFile({
    storyId,
    csfFile
  }) {
    let storyAnnotations = csfFile.stories[storyId];
    if (!storyAnnotations)
      throw new MissingStoryFromCsfFileError({ storyId });
    let componentAnnotations = csfFile.meta, story = this.prepareStoryWithCache(
      storyAnnotations,
      componentAnnotations,
      csfFile.projectAnnotations ?? this.projectAnnotations
    );
    return this.args.setInitial(story), this.hooks[story.id] = this.hooks[story.id] || new HooksContext(), story;
  }
  // If we have a CSF file we can get all the stories from it synchronously
  componentStoriesFromCSFFile({
    csfFile
  }) {
    return Object.keys(this.storyIndex.entries).filter((storyId) => !!csfFile.stories[storyId]).map((storyId) => this.storyFromCSFFile({ storyId, csfFile }));
  }
  async loadEntry(id) {
    let entry = await this.storyIdToEntry(id), storyImports = entry.type === "docs" ? entry.storiesImports : [], [entryExports, ...csfFiles] = await Promise.all([
      this.importFn(entry.importPath),
      ...storyImports.map((storyImportPath) => {
        let firstStoryEntry = this.storyIndex.importPathToEntry(storyImportPath);
        return this.loadCSFFileByStoryId(firstStoryEntry.id);
      })
    ]);
    return { entryExports, csfFiles };
  }
  // A prepared story does not include args, globals or hooks. These are stored in the story store
  // and updated separately to the (immutable) story.
  getStoryContext(story, { forceInitialArgs = !1 } = {}) {
    let userGlobals = this.userGlobals.get(), { initialGlobals: initialGlobals5 } = this.userGlobals, reporting = new ReporterAPI();
    return prepareContext({
      ...story,
      args: forceInitialArgs ? story.initialArgs : this.args.get(story.id),
      initialGlobals: initialGlobals5,
      globalTypes: this.projectAnnotations.globalTypes,
      userGlobals,
      reporting,
      globals: {
        ...userGlobals,
        ...story.storyGlobals
      },
      hooks: this.hooks[story.id]
    });
  }
  addCleanupCallbacks(story, ...callbacks) {
    this.cleanupCallbacks[story.id] = (this.cleanupCallbacks[story.id] || []).concat(callbacks);
  }
  async cleanupStory(story) {
    this.hooks[story.id].clean();
    let callbacks = this.cleanupCallbacks[story.id];
    if (callbacks)
      for (let callback of [...callbacks].reverse())
        await callback();
    delete this.cleanupCallbacks[story.id];
  }
  extract(options = { includeDocsOnly: !1 }) {
    let { cachedCSFFiles } = this;
    if (console.log("extract: extracting stories", cachedCSFFiles), !cachedCSFFiles)
      throw new CalledExtractOnStoreError();
    let stories = Object.entries(this.storyIndex.entries).reduce(
      (acc, [storyId, entry]) => {
        if (entry.type === "docs")
          return acc;
        let csfFile = cachedCSFFiles[entry.importPath], story = this.storyFromCSFFile({ storyId, csfFile });
        return !options.includeDocsOnly && story.parameters.docsOnly || (acc[storyId] = Object.entries(story).reduce(
          (storyAcc, [key, value]) => key === "story" && entry.subtype === "test" ? { ...storyAcc, story: entry.parentName } : key === "moduleExport" || typeof value == "function" ? storyAcc : Array.isArray(value) ? Object.assign(storyAcc, { [key]: value.slice().sort() }) : Object.assign(storyAcc, { [key]: value }),
          {
            args: story.initialArgs,
            globals: {
              ...this.userGlobals.initialGlobals,
              ...this.userGlobals.globals,
              ...story.storyGlobals
            },
            storyId: entry.parent ? entry.parent : storyId
          }
        )), acc;
      },
      {}
    );
    return console.log("extract: stories", stories), stories;
  }
};

// ../node_modules/slash/index.js
function slash2(path) {
  return path.startsWith("\\\\?\\") ? path : path.replace(/\\/g, "/");
}

// src/preview-api/modules/store/autoTitle.ts
var sanitize2 = (parts) => {
  if (parts.length === 0)
    return parts;
  let last = parts[parts.length - 1], lastStripped = last?.replace(/(?:[.](?:story|stories))?([.][^.]+)$/i, "");
  if (parts.length === 1)
    return [lastStripped];
  let nextToLast = parts[parts.length - 2];
  return lastStripped && nextToLast && lastStripped.toLowerCase() === nextToLast.toLowerCase() ? [...parts.slice(0, -2), lastStripped] : lastStripped && (/^(story|stories)([.][^.]+)$/i.test(last) || /^index$/i.test(lastStripped)) ? parts.slice(0, -1) : [...parts.slice(0, -1), lastStripped];
};
function pathJoin(paths) {
  return paths.flatMap((p2) => p2.split("/")).filter(Boolean).join("/");
}
var userOrAutoTitleFromSpecifier = (fileName, entry, userTitle) => {
  let { directory, importPathMatcher, titlePrefix = "" } = entry || {};
  typeof fileName == "number" && once.warn(dedent`
      CSF Auto-title received a numeric fileName. This typically happens when
      webpack is mis-configured in production mode. To force webpack to produce
      filenames, set optimization.moduleIds = "named" in your webpack config.
    `);
  let normalizedFileName = slash2(String(fileName));
  if (importPathMatcher.exec(normalizedFileName)) {
    if (!userTitle) {
      let suffix = normalizedFileName.replace(directory, ""), parts = pathJoin([titlePrefix, suffix]).split("/");
      return parts = sanitize2(parts), parts.join("/");
    }
    return titlePrefix ? pathJoin([titlePrefix, userTitle]) : userTitle;
  }
}, userOrAutoTitle = (fileName, storiesEntries, userTitle) => {
  for (let i2 = 0; i2 < storiesEntries.length; i2 += 1) {
    let title = userOrAutoTitleFromSpecifier(fileName, storiesEntries[i2], userTitle);
    if (title)
      return title;
  }
  return userTitle || void 0;
};

// src/preview-api/modules/store/storySort.ts
var STORY_KIND_PATH_SEPARATOR = /\s*\/\s*/, storySort = (options = {}) => (a2, b2) => {
  if (a2.title === b2.title && !options.includeNames)
    return 0;
  let method = options.method || "configure", order = options.order || [], storyTitleA = a2.title.trim().split(STORY_KIND_PATH_SEPARATOR), storyTitleB = b2.title.trim().split(STORY_KIND_PATH_SEPARATOR);
  options.includeNames && (storyTitleA.push(a2.name), storyTitleB.push(b2.name));
  let depth = 0;
  for (; storyTitleA[depth] || storyTitleB[depth]; ) {
    if (!storyTitleA[depth])
      return -1;
    if (!storyTitleB[depth])
      return 1;
    let nameA = storyTitleA[depth], nameB = storyTitleB[depth];
    if (nameA !== nameB) {
      let indexA = order.indexOf(nameA), indexB = order.indexOf(nameB), indexWildcard = order.indexOf("*");
      return indexA !== -1 || indexB !== -1 ? (indexA === -1 && (indexWildcard !== -1 ? indexA = indexWildcard : indexA = order.length), indexB === -1 && (indexWildcard !== -1 ? indexB = indexWildcard : indexB = order.length), indexA - indexB) : method === "configure" ? 0 : nameA.localeCompare(nameB, options.locales ? options.locales : void 0, {
        numeric: !0,
        sensitivity: "accent"
      });
    }
    let index2 = order.indexOf(nameA);
    index2 === -1 && (index2 = order.indexOf("*")), order = index2 !== -1 && Array.isArray(order[index2 + 1]) ? order[index2 + 1] : [], depth += 1;
  }
  return 0;
};

// src/preview-api/modules/store/sortStories.ts
var sortStoriesCommon = (stories, storySortParameter, fileNameOrder) => {
  if (storySortParameter) {
    let sortFn;
    typeof storySortParameter == "function" ? sortFn = storySortParameter : sortFn = storySort(storySortParameter), stories.sort(sortFn);
  } else
    stories.sort(
      (s1, s22) => fileNameOrder.indexOf(s1.importPath) - fileNameOrder.indexOf(s22.importPath)
    );
  return stories;
}, sortStoriesV7 = (stories, storySortParameter, fileNameOrder) => {
  try {
    return sortStoriesCommon(stories, storySortParameter, fileNameOrder);
  } catch (err) {
    throw new Error(dedent`
    Error sorting stories with sort parameter ${storySortParameter}:

    > ${err.message}

    Are you using a V6-style sort function in V7 mode?

    More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#v7-style-story-sort
  `);
  }
};

// src/preview-api/modules/preview-web/render/Render.ts
var PREPARE_ABORTED = new Error("prepareAborted");

// src/preview-api/modules/preview-web/render/StoryRender.ts
var { AbortController: AbortController2 } = globalThis;
function serializeError(error) {
  try {
    let { name = "Error", message = String(error), stack } = error;
    return { name, message, stack };
  } catch {
    return { name: "Error", message: String(error) };
  }
}
var StoryRender = class {
  constructor(channel, store, renderToScreen, callbacks, id, viewMode, renderOptions = { autoplay: !0, forceInitialArgs: !1 }, story) {
    this.channel = channel;
    this.store = store;
    this.renderToScreen = renderToScreen;
    this.callbacks = callbacks;
    this.id = id;
    this.viewMode = viewMode;
    this.renderOptions = renderOptions;
    this.type = "story";
    this.notYetRendered = !0;
    this.rerenderEnqueued = !1;
    this.disableKeyListeners = !1;
    this.teardownRender = () => {
    };
    this.torndown = !1;
    this.abortController = new AbortController2(), this.renderId = Date.now(), story && (this.story = story, this.phase = "preparing");
  }
  async runPhase(signal, phase, phaseFn) {
    this.phase = phase, this.channel.emit(STORY_RENDER_PHASE_CHANGED, {
      newPhase: this.phase,
      renderId: this.renderId,
      storyId: this.id
    }), phaseFn && (await phaseFn(), this.checkIfAborted(signal));
  }
  checkIfAborted(signal) {
    return signal.aborted && !["finished", "aborted", "errored"].includes(this.phase) && (this.phase = "aborted", this.channel.emit(STORY_RENDER_PHASE_CHANGED, {
      newPhase: this.phase,
      renderId: this.renderId,
      storyId: this.id
    })), signal.aborted;
  }
  async prepare() {
    if (await this.runPhase(this.abortController.signal, "preparing", async () => {
      this.story = await this.store.loadStory({ storyId: this.id });
    }), this.abortController.signal.aborted)
      throw await this.store.cleanupStory(this.story), PREPARE_ABORTED;
  }
  // The two story "renders" are equal and have both loaded the same story
  isEqual(other) {
    return !!(this.id === other.id && this.story && this.story === other.story);
  }
  isPreparing() {
    return ["preparing"].includes(this.phase);
  }
  isPending() {
    return ["loading", "beforeEach", "rendering", "playing", "afterEach"].includes(
      this.phase
    );
  }
  async renderToElement(canvasElement) {
    return this.canvasElement = canvasElement, this.render({ initial: !0, forceRemount: !0 });
  }
  storyContext() {
    if (!this.story)
      throw new Error("Cannot call storyContext before preparing");
    let { forceInitialArgs } = this.renderOptions;
    return this.store.getStoryContext(this.story, { forceInitialArgs });
  }
  async render({
    initial = !1,
    forceRemount = !1
  } = {}) {
    let { canvasElement } = this;
    if (!this.story)
      throw new Error("cannot render when not prepared");
    let story = this.story;
    if (!canvasElement)
      throw new Error("cannot render when canvasElement is unset");
    let {
      id,
      componentId,
      title,
      name,
      tags,
      applyLoaders,
      applyBeforeEach,
      applyAfterEach,
      unboundStoryFn,
      playFunction,
      runStep
    } = story;
    forceRemount && !initial && (this.cancelRender(), this.abortController = new AbortController2());
    let abortSignal = this.abortController.signal, mounted = !1, isMountDestructured = story.usesMount;
    try {
      let context = {
        ...this.storyContext(),
        viewMode: this.viewMode,
        abortSignal,
        canvasElement,
        loaded: {},
        step: (label, play) => runStep(label, play, context),
        context: null,
        canvas: {},
        userEvent: {},
        renderToCanvas: async () => {
          let teardown = await this.renderToScreen(renderContext, canvasElement);
          this.teardownRender = teardown || (() => {
          }), mounted = !0;
        },
        // The story provides (set in a renderer) a mount function that is a higher order function
        // (context) => (...args) => Canvas
        //
        // Before assigning it to the context, we resolve the context dependency,
        // so that a user can just call it as await mount(...args) in their play function.
        mount: async (...args) => {
          this.callbacks.showStoryDuringRender?.();
          let mountReturn = null;
          return await this.runPhase(abortSignal, "rendering", async () => {
            mountReturn = await story.mount(context)(...args);
          }), isMountDestructured && await this.runPhase(abortSignal, "playing"), mountReturn;
        }
      };
      context.context = context;
      let renderContext = {
        componentId,
        title,
        kind: title,
        id,
        name,
        story: name,
        tags,
        ...this.callbacks,
        showError: (error) => (this.phase = "errored", this.callbacks.showError(error)),
        showException: (error) => (this.phase = "errored", this.callbacks.showException(error)),
        forceRemount: forceRemount || this.notYetRendered,
        storyContext: context,
        storyFn: () => unboundStoryFn(context),
        unboundStoryFn
      };
      if (await this.runPhase(abortSignal, "loading", async () => {
        context.loaded = await applyLoaders(context);
      }), abortSignal.aborted)
        return;
      let cleanupCallbacks = await applyBeforeEach(context);
      if (this.store.addCleanupCallbacks(story, ...cleanupCallbacks), this.checkIfAborted(abortSignal) || (!mounted && !isMountDestructured && await context.mount(), this.notYetRendered = !1, abortSignal.aborted))
        return;
      let ignoreUnhandledErrors = this.story.parameters?.test?.dangerouslyIgnoreUnhandledErrors === !0, unhandledErrors = /* @__PURE__ */ new Set(), onError = (event) => {
        event.error && unhandledErrors.add(event.error);
      }, onUnhandledRejection = (event) => {
        event.reason && unhandledErrors.add(event.reason);
      };
      if (this.renderOptions.autoplay && forceRemount && playFunction && this.phase !== "errored") {
        window?.addEventListener?.("error", onError), window?.addEventListener?.("unhandledrejection", onUnhandledRejection), this.disableKeyListeners = !0;
        try {
          if (isMountDestructured ? await playFunction(context) : (context.mount = async () => {
            throw new MountMustBeDestructuredError({ playFunction: playFunction.toString() });
          }, await this.runPhase(abortSignal, "playing", async () => playFunction(context))), !mounted)
            throw new NoStoryMountedError();
          this.checkIfAborted(abortSignal), !ignoreUnhandledErrors && unhandledErrors.size > 0 ? await this.runPhase(abortSignal, "errored") : await this.runPhase(abortSignal, "played");
        } catch (error) {
          if (this.callbacks.showStoryDuringRender?.(), await this.runPhase(abortSignal, "errored", async () => {
            this.channel.emit(PLAY_FUNCTION_THREW_EXCEPTION, serializeError(error));
          }), this.story.parameters.throwPlayFunctionExceptions !== !1)
            throw error;
          console.error(error);
        }
        if (!ignoreUnhandledErrors && unhandledErrors.size > 0 && this.channel.emit(
          UNHANDLED_ERRORS_WHILE_PLAYING,
          Array.from(unhandledErrors).map(serializeError)
        ), this.disableKeyListeners = !1, window?.removeEventListener?.("unhandledrejection", onUnhandledRejection), window?.removeEventListener?.("error", onError), abortSignal.aborted)
          return;
      }
      await this.runPhase(abortSignal, "completing", async () => {
        isTestEnvironment() ? this.store.addCleanupCallbacks(story, pauseAnimations()) : await waitForAnimations(abortSignal);
      }), await this.runPhase(abortSignal, "completed", async () => {
        this.channel.emit(STORY_RENDERED, id);
      }), this.phase !== "errored" && await this.runPhase(abortSignal, "afterEach", async () => {
        await applyAfterEach(context);
      });
      let hasUnhandledErrors = !ignoreUnhandledErrors && unhandledErrors.size > 0, hasSomeReportsFailed = context.reporting.reports.some(
        (report) => report.status === "failed"
      ), hasStoryErrored = hasUnhandledErrors || hasSomeReportsFailed;
      await this.runPhase(
        abortSignal,
        "finished",
        async () => this.channel.emit(STORY_FINISHED, {
          storyId: id,
          status: hasStoryErrored ? "error" : "success",
          reporters: context.reporting.reports
        })
      );
    } catch (err) {
      this.phase = "errored", this.callbacks.showException(err), await this.runPhase(
        abortSignal,
        "finished",
        async () => this.channel.emit(STORY_FINISHED, {
          storyId: id,
          status: "error",
          reporters: []
        })
      );
    }
    this.rerenderEnqueued && (this.rerenderEnqueued = !1, this.render());
  }
  /**
   * Rerender the story. If the story is currently pending (loading/rendering), the rerender will be
   * enqueued, and will be executed after the current render is completed. Rerendering while playing
   * will not be enqueued, and will be executed immediately, to support rendering args changes while
   * playing.
   */
  async rerender() {
    if (this.isPending() && this.phase !== "playing")
      this.rerenderEnqueued = !0;
    else
      return this.render();
  }
  async remount() {
    return await this.teardown(), this.render({ forceRemount: !0 });
  }
  // If the story is torn down (either a new story is rendered or the docs page removes it)
  // we need to consider the fact that the initial render may not be finished
  // (possibly the loaders or the play function are still running). We use the controller
  // as a method to abort them, ASAP, but this is not foolproof as we cannot control what
  // happens inside the user's code.
  cancelRender() {
    this.abortController.abort();
  }
  cancelPlayFunction() {
    this.phase === "playing" && (this.abortController.abort(), this.runPhase(this.abortController.signal, "aborted"));
  }
  async teardown() {
    this.torndown = !0, this.cancelRender(), this.story && await this.store.cleanupStory(this.story);
    for (let i2 = 0; i2 < 3; i2 += 1) {
      if (!this.isPending()) {
        await this.teardownRender();
        return;
      }
      await new Promise((resolve) => setTimeout(resolve, 0));
    }
    window?.location?.reload?.(), await new Promise(() => {
    });
  }
};

// src/preview-api/modules/preview-web/Preview.tsx
var { fetch: fetch2 } = scope, STORY_INDEX_PATH = "./index.json", Preview = class {
  constructor(importFn, getProjectAnnotations, channel = addons.getChannel(), shouldInitialize = !0) {
    this.importFn = importFn;
    this.getProjectAnnotations = getProjectAnnotations;
    this.channel = channel;
    this.storyRenders = [];
    this.storeInitializationPromise = new Promise((resolve, reject) => {
      this.resolveStoreInitializationPromise = resolve, this.rejectStoreInitializationPromise = reject;
    }), shouldInitialize && this.initialize();
  }
  // Create a proxy object for `__STORYBOOK_STORY_STORE__` and `__STORYBOOK_PREVIEW__.storyStore`
  // That proxies through to the store once ready, and errors beforehand. This means we can set
  // `__STORYBOOK_STORY_STORE__ = __STORYBOOK_PREVIEW__.storyStore` without having to wait, and
  // similarly integrators can access the `storyStore` on the preview at any time, although
  // it is considered deprecated and we will no longer allow access in 9.0
  get storyStore() {
    return new Proxy(
      {},
      {
        get: (_, method) => {
          if (this.storyStoreValue)
            return deprecate("Accessing the Story Store is deprecated and will be removed in 9.0"), this.storyStoreValue[method];
          throw new StoryStoreAccessedBeforeInitializationError();
        }
      }
    );
  }
  // INITIALIZATION
  async initialize() {
    this.setupListeners();
    try {
      let projectAnnotations = await this.getProjectAnnotationsOrRenderError();
      await this.runBeforeAllHook(projectAnnotations), await this.initializeWithProjectAnnotations(projectAnnotations);
      let userAgent = globalThis?.navigator?.userAgent;
      await this.channel.emit(PREVIEW_INITIALIZED, { userAgent });
    } catch (err) {
      this.rejectStoreInitializationPromise(err);
    }
  }
  ready() {
    return this.storeInitializationPromise;
  }
  setupListeners() {
    this.channel.on(STORY_INDEX_INVALIDATED, this.onStoryIndexChanged.bind(this)), this.channel.on(UPDATE_GLOBALS, this.onUpdateGlobals.bind(this)), this.channel.on(UPDATE_STORY_ARGS, this.onUpdateArgs.bind(this)), this.channel.on(ARGTYPES_INFO_REQUEST, this.onRequestArgTypesInfo.bind(this)), this.channel.on(RESET_STORY_ARGS, this.onResetArgs.bind(this)), this.channel.on(FORCE_RE_RENDER, this.onForceReRender.bind(this)), this.channel.on(FORCE_REMOUNT, this.onForceRemount.bind(this)), this.channel.on(STORY_HOT_UPDATED, this.onStoryHotUpdated.bind(this));
  }
  async getProjectAnnotationsOrRenderError() {
    try {
      let projectAnnotations = await this.getProjectAnnotations();
      if (this.renderToCanvas = projectAnnotations.renderToCanvas, !this.renderToCanvas)
        throw new MissingRenderToCanvasError();
      return projectAnnotations;
    } catch (err) {
      throw this.renderPreviewEntryError("Error reading preview.js:", err), err;
    }
  }
  // If initialization gets as far as project annotations, this function runs.
  async initializeWithProjectAnnotations(projectAnnotations) {
    this.projectAnnotationsBeforeInitialization = projectAnnotations;
    try {
      let storyIndex = await this.getStoryIndexFromServer();
      return this.initializeWithStoryIndex(storyIndex);
    } catch (err) {
      throw this.renderPreviewEntryError("Error loading story index:", err), err;
    }
  }
  async runBeforeAllHook(projectAnnotations) {
    try {
      await this.beforeAllCleanup?.(), this.beforeAllCleanup = await projectAnnotations.beforeAll?.();
    } catch (err) {
      throw this.renderPreviewEntryError("Error in beforeAll hook:", err), err;
    }
  }
  async getStoryIndexFromServer() {
    let result = await fetch2(STORY_INDEX_PATH);
    if (result.status === 200)
      return result.json();
    throw new StoryIndexFetchError({ text: await result.text() });
  }
  // If initialization gets as far as the story index, this function runs.
  initializeWithStoryIndex(storyIndex) {
    if (!this.projectAnnotationsBeforeInitialization)
      throw new Error("Cannot call initializeWithStoryIndex until project annotations resolve");
    this.storyStoreValue = new StoryStore(
      storyIndex,
      this.importFn,
      this.projectAnnotationsBeforeInitialization
    ), delete this.projectAnnotationsBeforeInitialization, this.setInitialGlobals(), this.resolveStoreInitializationPromise();
  }
  async setInitialGlobals() {
    this.emitGlobals();
  }
  emitGlobals() {
    if (!this.storyStoreValue)
      throw new CalledPreviewMethodBeforeInitializationError({ methodName: "emitGlobals" });
    let payload = {
      globals: this.storyStoreValue.userGlobals.get() || {},
      globalTypes: this.storyStoreValue.projectAnnotations.globalTypes || {}
    };
    this.channel.emit(SET_GLOBALS, payload);
  }
  // EVENT HANDLERS
  // This happens when a config file gets reloaded
  async onGetProjectAnnotationsChanged({
    getProjectAnnotations
  }) {
    delete this.previewEntryError, this.getProjectAnnotations = getProjectAnnotations;
    let projectAnnotations = await this.getProjectAnnotationsOrRenderError();
    if (await this.runBeforeAllHook(projectAnnotations), !this.storyStoreValue) {
      await this.initializeWithProjectAnnotations(projectAnnotations);
      return;
    }
    this.storyStoreValue.setProjectAnnotations(projectAnnotations), this.emitGlobals();
  }
  async onStoryIndexChanged() {
    if (delete this.previewEntryError, !(!this.storyStoreValue && !this.projectAnnotationsBeforeInitialization))
      try {
        let storyIndex = await this.getStoryIndexFromServer();
        if (this.projectAnnotationsBeforeInitialization) {
          this.initializeWithStoryIndex(storyIndex);
          return;
        }
        await this.onStoriesChanged({ storyIndex });
      } catch (err) {
        throw this.renderPreviewEntryError("Error loading story index:", err), err;
      }
  }
  // This happens when a glob gets HMR-ed
  async onStoriesChanged({
    importFn,
    storyIndex
  }) {
    if (!this.storyStoreValue)
      throw new CalledPreviewMethodBeforeInitializationError({ methodName: "onStoriesChanged" });
    await this.storyStoreValue.onStoriesChanged({ importFn, storyIndex });
  }
  async onUpdateGlobals({
    globals: updatedGlobals,
    currentStory
  }) {
    if (this.storyStoreValue || await this.storeInitializationPromise, !this.storyStoreValue)
      throw new CalledPreviewMethodBeforeInitializationError({ methodName: "onUpdateGlobals" });
    if (this.storyStoreValue.userGlobals.update(updatedGlobals), currentStory) {
      let { initialGlobals: initialGlobals5, storyGlobals, userGlobals, globals } = this.storyStoreValue.getStoryContext(currentStory);
      this.channel.emit(GLOBALS_UPDATED, {
        initialGlobals: initialGlobals5,
        userGlobals,
        storyGlobals,
        globals
      });
    } else {
      let { initialGlobals: initialGlobals5, globals } = this.storyStoreValue.userGlobals;
      this.channel.emit(GLOBALS_UPDATED, {
        initialGlobals: initialGlobals5,
        userGlobals: globals,
        storyGlobals: {},
        globals
      });
    }
    await Promise.all(this.storyRenders.map((r2) => r2.rerender()));
  }
  async onUpdateArgs({ storyId, updatedArgs }) {
    if (!this.storyStoreValue)
      throw new CalledPreviewMethodBeforeInitializationError({ methodName: "onUpdateArgs" });
    this.storyStoreValue.args.update(storyId, updatedArgs), await Promise.all(
      this.storyRenders.filter((r2) => r2.id === storyId && !r2.renderOptions.forceInitialArgs).map(
        (r2) => (
          // We only run the play function, with in a force remount.
          // But when mount is destructured, the rendering happens inside of the play function.
          r2.story && r2.story.usesMount ? r2.remount() : r2.rerender()
        )
      )
    ), this.channel.emit(STORY_ARGS_UPDATED, {
      storyId,
      args: this.storyStoreValue.args.get(storyId)
    });
  }
  async onRequestArgTypesInfo({ id, payload }) {
    try {
      await this.storeInitializationPromise;
      let story = await this.storyStoreValue?.loadStory(payload);
      this.channel.emit(ARGTYPES_INFO_RESPONSE, {
        id,
        success: !0,
        payload: { argTypes: story?.argTypes || {} },
        error: null
      });
    } catch (e2) {
      this.channel.emit(ARGTYPES_INFO_RESPONSE, {
        id,
        success: !1,
        error: e2?.message
      });
    }
  }
  async onResetArgs({ storyId, argNames }) {
    if (!this.storyStoreValue)
      throw new CalledPreviewMethodBeforeInitializationError({ methodName: "onResetArgs" });
    let story = this.storyRenders.find((r2) => r2.id === storyId)?.story || await this.storyStoreValue.loadStory({ storyId }), updatedArgs = (argNames || [
      .../* @__PURE__ */ new Set([
        ...Object.keys(story.initialArgs),
        ...Object.keys(this.storyStoreValue.args.get(storyId))
      ])
    ]).reduce((acc, argName) => (acc[argName] = story.initialArgs[argName], acc), {});
    await this.onUpdateArgs({ storyId, updatedArgs });
  }
  // ForceReRender does not include a story id, so we simply must
  // re-render all stories in case they are relevant
  async onForceReRender() {
    await Promise.all(this.storyRenders.map((r2) => r2.rerender()));
  }
  async onForceRemount({ storyId }) {
    await Promise.all(this.storyRenders.filter((r2) => r2.id === storyId).map((r2) => r2.remount()));
  }
  async onStoryHotUpdated() {
    await Promise.all(this.storyRenders.map((r2) => r2.cancelPlayFunction()));
  }
  // Used by docs to render a story to a given element
  // Note this short-circuits the `prepare()` phase of the StoryRender,
  // main to be consistent with the previous behaviour. In the future,
  // we will change it to go ahead and load the story, which will end up being
  // "instant", although async.
  renderStoryToElement(story, element, callbacks, options) {
    if (!this.renderToCanvas || !this.storyStoreValue)
      throw new CalledPreviewMethodBeforeInitializationError({
        methodName: "renderStoryToElement"
      });
    let render = new StoryRender(
      this.channel,
      this.storyStoreValue,
      this.renderToCanvas,
      callbacks,
      story.id,
      "docs",
      options,
      story
    );
    return render.renderToElement(element), this.storyRenders.push(render), async () => {
      await this.teardownRender(render);
    };
  }
  async teardownRender(render, { viewModeChanged } = {}) {
    this.storyRenders = this.storyRenders.filter((r2) => r2 !== render), await render?.teardown?.({ viewModeChanged });
  }
  // API
  async loadStory({ storyId }) {
    if (!this.storyStoreValue)
      throw new CalledPreviewMethodBeforeInitializationError({ methodName: "loadStory" });
    return this.storyStoreValue.loadStory({ storyId });
  }
  getStoryContext(story, { forceInitialArgs = !1 } = {}) {
    if (!this.storyStoreValue)
      throw new CalledPreviewMethodBeforeInitializationError({ methodName: "getStoryContext" });
    return this.storyStoreValue.getStoryContext(story, { forceInitialArgs });
  }
  async extract(options) {
    if (!this.storyStoreValue)
      throw new CalledPreviewMethodBeforeInitializationError({ methodName: "extract" });
    if (this.previewEntryError)
      throw this.previewEntryError;
    return await this.storyStoreValue.cacheAllCSFFiles(), this.storyStoreValue.extract(options);
  }
  // UTILITIES
  renderPreviewEntryError(reason, err) {
    this.previewEntryError = err, logger.error(reason), logger.error(err), this.channel.emit(CONFIG_ERROR, err);
  }
};

// src/preview-api/modules/preview-web/docs-context/DocsContext.ts
var DocsContext = class {
  constructor(channel, store, renderStoryToElement, csfFiles) {
    this.channel = channel;
    this.store = store;
    this.renderStoryToElement = renderStoryToElement;
    this.storyIdByName = (storyName) => {
      let storyId = this.nameToStoryId.get(storyName);
      if (storyId)
        return storyId;
      throw new Error(`No story found with that name: ${storyName}`);
    };
    this.componentStories = () => this.componentStoriesValue;
    this.componentStoriesFromCSFFile = (csfFile) => this.store.componentStoriesFromCSFFile({ csfFile });
    this.storyById = (storyId) => {
      if (!storyId) {
        if (!this.primaryStory)
          throw new Error(
            "No primary story defined for docs entry. Did you forget to use `<Meta>`?"
          );
        return this.primaryStory;
      }
      let csfFile = this.storyIdToCSFFile.get(storyId);
      if (!csfFile)
        throw new Error(`Called \`storyById\` for story that was never loaded: ${storyId}`);
      return this.store.storyFromCSFFile({ storyId, csfFile });
    };
    this.getStoryContext = (story) => ({
      ...this.store.getStoryContext(story),
      loaded: {},
      viewMode: "docs"
    });
    this.loadStory = (id) => this.store.loadStory({ storyId: id });
    this.componentStoriesValue = [], this.storyIdToCSFFile = /* @__PURE__ */ new Map(), this.exportToStory = /* @__PURE__ */ new Map(), this.exportsToCSFFile = /* @__PURE__ */ new Map(), this.nameToStoryId = /* @__PURE__ */ new Map(), this.attachedCSFFiles = /* @__PURE__ */ new Set(), csfFiles.forEach((csfFile, index2) => {
      this.referenceCSFFile(csfFile);
    });
  }
  // This docs entry references this CSF file and can synchronously load the stories, as well
  // as reference them by module export. If the CSF is part of the "component" stories, they
  // can also be referenced by name and are in the componentStories list.
  referenceCSFFile(csfFile) {
    this.exportsToCSFFile.set(csfFile.moduleExports, csfFile), this.exportsToCSFFile.set(csfFile.moduleExports.default, csfFile), this.store.componentStoriesFromCSFFile({ csfFile }).forEach((story) => {
      let annotation = csfFile.stories[story.id];
      this.storyIdToCSFFile.set(annotation.id, csfFile), this.exportToStory.set(annotation.moduleExport, story);
    });
  }
  attachCSFFile(csfFile) {
    if (!this.exportsToCSFFile.has(csfFile.moduleExports))
      throw new Error("Cannot attach a CSF file that has not been referenced");
    if (this.attachedCSFFiles.has(csfFile))
      return;
    this.attachedCSFFiles.add(csfFile), this.store.componentStoriesFromCSFFile({ csfFile }).forEach((story) => {
      this.nameToStoryId.set(story.name, story.id), this.componentStoriesValue.push(story), this.primaryStory || (this.primaryStory = story);
    });
  }
  referenceMeta(metaExports, attach) {
    let resolved = this.resolveModuleExport(metaExports);
    if (resolved.type !== "meta")
      throw new Error(
        "<Meta of={} /> must reference a CSF file module export or meta export. Did you mistakenly reference your component instead of your CSF file?"
      );
    attach && this.attachCSFFile(resolved.csfFile);
  }
  get projectAnnotations() {
    let { projectAnnotations } = this.store;
    if (!projectAnnotations)
      throw new Error("Can't get projectAnnotations from DocsContext before they are initialized");
    return projectAnnotations;
  }
  resolveAttachedModuleExportType(moduleExportType) {
    if (moduleExportType === "story") {
      if (!this.primaryStory)
        throw new Error(
          "No primary story attached to this docs file, did you forget to use <Meta of={} />?"
        );
      return { type: "story", story: this.primaryStory };
    }
    if (this.attachedCSFFiles.size === 0)
      throw new Error(
        "No CSF file attached to this docs file, did you forget to use <Meta of={} />?"
      );
    let firstAttachedCSFFile = Array.from(this.attachedCSFFiles)[0];
    if (moduleExportType === "meta")
      return { type: "meta", csfFile: firstAttachedCSFFile };
    let { component } = firstAttachedCSFFile.meta;
    if (!component)
      throw new Error(
        "Attached CSF file does not defined a component, did you forget to export one?"
      );
    return { type: "component", component };
  }
  resolveModuleExport(moduleExportOrType) {
    let csfFile = this.exportsToCSFFile.get(moduleExportOrType);
    if (!csfFile && moduleExportOrType && typeof moduleExportOrType == "object" && "default" in moduleExportOrType && (csfFile = this.exportsToCSFFile.get(moduleExportOrType.default)), csfFile)
      return { type: "meta", csfFile };
    let story = this.exportToStory.get(
      isStory(moduleExportOrType) ? moduleExportOrType.input : moduleExportOrType
    );
    return story ? { type: "story", story } : { type: "component", component: moduleExportOrType };
  }
  resolveOf(moduleExportOrType, validTypes = []) {
    let resolved;
    if (["component", "meta", "story"].includes(moduleExportOrType)) {
      let type5 = moduleExportOrType;
      resolved = this.resolveAttachedModuleExportType(type5);
    } else
      resolved = this.resolveModuleExport(moduleExportOrType);
    if (validTypes.length && !validTypes.includes(resolved.type)) {
      let prettyType = resolved.type === "component" ? "component or unknown" : resolved.type;
      throw new Error(dedent`Invalid value passed to the 'of' prop. The value was resolved to a '${prettyType}' type but the only types for this block are: ${validTypes.join(
        ", "
      )}.
        - Did you pass a component to the 'of' prop when the block only supports a story or a meta?
        - ... or vice versa?
        - Did you pass a story, CSF file or meta to the 'of' prop that is not indexed, ie. is not targeted by the 'stories' globs in the main configuration?`);
    }
    switch (resolved.type) {
      case "component":
        return {
          ...resolved,
          projectAnnotations: this.projectAnnotations
        };
      case "meta":
        return {
          ...resolved,
          preparedMeta: this.store.preparedMetaFromCSFFile({ csfFile: resolved.csfFile })
        };
      case "story":
      default:
        return resolved;
    }
  }
};

// src/preview-api/modules/preview-web/render/CsfDocsRender.ts
var CsfDocsRender = class {
  constructor(channel, store, entry, callbacks) {
    this.channel = channel;
    this.store = store;
    this.entry = entry;
    this.callbacks = callbacks;
    this.type = "docs";
    this.subtype = "csf";
    this.torndown = !1;
    this.disableKeyListeners = !1;
    this.preparing = !1;
    this.id = entry.id, this.renderId = Date.now();
  }
  isPreparing() {
    return this.preparing;
  }
  async prepare() {
    this.preparing = !0;
    let { entryExports, csfFiles = [] } = await this.store.loadEntry(this.id);
    if (this.torndown)
      throw PREPARE_ABORTED;
    let { importPath, title } = this.entry, primaryCsfFile = this.store.processCSFFileWithCache(
      entryExports,
      importPath,
      title
    ), primaryStoryId = Object.keys(primaryCsfFile.stories)[0];
    this.story = this.store.storyFromCSFFile({ storyId: primaryStoryId, csfFile: primaryCsfFile }), this.csfFiles = [primaryCsfFile, ...csfFiles], this.preparing = !1;
  }
  isEqual(other) {
    return !!(this.id === other.id && this.story && this.story === other.story);
  }
  docsContext(renderStoryToElement) {
    if (!this.csfFiles)
      throw new Error("Cannot render docs before preparing");
    let docsContext = new DocsContext(
      this.channel,
      this.store,
      renderStoryToElement,
      this.csfFiles
    );
    return this.csfFiles.forEach((csfFile) => docsContext.attachCSFFile(csfFile)), docsContext;
  }
  async renderToElement(canvasElement, renderStoryToElement) {
    if (!this.story || !this.csfFiles)
      throw new Error("Cannot render docs before preparing");
    let docsContext = this.docsContext(renderStoryToElement), { docs: docsParameter } = this.story.parameters || {};
    if (!docsParameter)
      throw new Error(
        "Cannot render a story in viewMode=docs if `@storybook/addon-docs` is not installed"
      );
    let renderer = await docsParameter.renderer(), { render } = renderer, renderDocs = async () => {
      try {
        await render(docsContext, docsParameter, canvasElement), this.channel.emit(DOCS_RENDERED, this.id);
      } catch (err) {
        this.callbacks.showException(err);
      }
    };
    return this.rerender = async () => renderDocs(), this.teardownRender = async ({ viewModeChanged }) => {
      !viewModeChanged || !canvasElement || renderer.unmount(canvasElement);
    }, renderDocs();
  }
  async teardown({ viewModeChanged } = {}) {
    this.teardownRender?.({ viewModeChanged }), this.torndown = !0;
  }
};

// src/preview-api/modules/preview-web/render/MdxDocsRender.ts
var MdxDocsRender = class {
  constructor(channel, store, entry, callbacks) {
    this.channel = channel;
    this.store = store;
    this.entry = entry;
    this.callbacks = callbacks;
    this.type = "docs";
    this.subtype = "mdx";
    this.torndown = !1;
    this.disableKeyListeners = !1;
    this.preparing = !1;
    this.id = entry.id, this.renderId = Date.now();
  }
  isPreparing() {
    return this.preparing;
  }
  async prepare() {
    this.preparing = !0;
    let { entryExports, csfFiles = [] } = await this.store.loadEntry(this.id);
    if (this.torndown)
      throw PREPARE_ABORTED;
    this.csfFiles = csfFiles, this.exports = entryExports, this.preparing = !1;
  }
  isEqual(other) {
    return !!(this.id === other.id && this.exports && this.exports === other.exports);
  }
  docsContext(renderStoryToElement) {
    if (!this.csfFiles)
      throw new Error("Cannot render docs before preparing");
    return new DocsContext(
      this.channel,
      this.store,
      renderStoryToElement,
      this.csfFiles
    );
  }
  async renderToElement(canvasElement, renderStoryToElement) {
    if (!this.exports || !this.csfFiles || !this.store.projectAnnotations)
      throw new Error("Cannot render docs before preparing");
    let docsContext = this.docsContext(renderStoryToElement), { docs } = this.store.projectAnnotations.parameters ?? {};
    if (!docs)
      throw new Error(
        "Cannot render a story in viewMode=docs if `@storybook/addon-docs` is not installed"
      );
    let docsParameter = { ...docs, page: this.exports.default }, renderer = await docs.renderer(), { render } = renderer, renderDocs = async () => {
      try {
        await render(docsContext, docsParameter, canvasElement), this.channel.emit(DOCS_RENDERED, this.id);
      } catch (err) {
        this.callbacks.showException(err);
      }
    };
    return this.rerender = async () => renderDocs(), this.teardownRender = async ({ viewModeChanged } = {}) => {
      !viewModeChanged || !canvasElement || (renderer.unmount(canvasElement), this.torndown = !0);
    }, renderDocs();
  }
  async teardown({ viewModeChanged } = {}) {
    this.teardownRender?.({ viewModeChanged }), this.torndown = !0;
  }
};

// src/preview-api/modules/preview-web/PreviewWithSelection.tsx
var globalWindow = globalThis;
function focusInInput(event) {
  let target = event.composedPath && event.composedPath()[0] || event.target;
  return /input|textarea/i.test(target.tagName) || target.getAttribute("contenteditable") !== null;
}
var ATTACHED_MDX_TAG = "attached-mdx", UNATTACHED_MDX_TAG = "unattached-mdx";
function isMdxEntry({ tags }) {
  return tags?.includes(UNATTACHED_MDX_TAG) || tags?.includes(ATTACHED_MDX_TAG);
}
function isStoryRender(r2) {
  return r2.type === "story";
}
function isDocsRender(r2) {
  return r2.type === "docs";
}
function isCsfDocsRender(r2) {
  return isDocsRender(r2) && r2.subtype === "csf";
}
var PreviewWithSelection = class extends Preview {
  constructor(importFn, getProjectAnnotations, selectionStore, view) {
    super(importFn, getProjectAnnotations, void 0, !1);
    this.importFn = importFn;
    this.getProjectAnnotations = getProjectAnnotations;
    this.selectionStore = selectionStore;
    this.view = view;
    this.initialize();
  }
  setupListeners() {
    super.setupListeners(), globalWindow.onkeydown = this.onKeydown.bind(this), this.channel.on(SET_CURRENT_STORY, this.onSetCurrentStory.bind(this)), this.channel.on(UPDATE_QUERY_PARAMS, this.onUpdateQueryParams.bind(this)), this.channel.on(PRELOAD_ENTRIES, this.onPreloadStories.bind(this));
  }
  async setInitialGlobals() {
    if (!this.storyStoreValue)
      throw new CalledPreviewMethodBeforeInitializationError({ methodName: "setInitialGlobals" });
    let { globals } = this.selectionStore.selectionSpecifier || {};
    globals && this.storyStoreValue.userGlobals.updateFromPersisted(globals), this.emitGlobals();
  }
  // If initialization gets as far as the story index, this function runs.
  async initializeWithStoryIndex(storyIndex) {
    return await super.initializeWithStoryIndex(storyIndex), this.selectSpecifiedStory();
  }
  // Use the selection specifier to choose a story, then render it
  async selectSpecifiedStory() {
    if (!this.storyStoreValue)
      throw new CalledPreviewMethodBeforeInitializationError({
        methodName: "selectSpecifiedStory"
      });
    if (this.selectionStore.selection) {
      await this.renderSelection();
      return;
    }
    if (!this.selectionStore.selectionSpecifier) {
      this.renderMissingStory();
      return;
    }
    let { storySpecifier, args } = this.selectionStore.selectionSpecifier, entry = this.storyStoreValue.storyIndex.entryFromSpecifier(storySpecifier);
    if (!entry) {
      storySpecifier === "*" ? this.renderStoryLoadingException(storySpecifier, new EmptyIndexError()) : this.renderStoryLoadingException(
        storySpecifier,
        new NoStoryMatchError({ storySpecifier: storySpecifier.toString() })
      );
      return;
    }
    let { id: storyId, type: viewMode } = entry;
    this.selectionStore.setSelection({ storyId, viewMode }), this.channel.emit(STORY_SPECIFIED, this.selectionStore.selection), this.channel.emit(CURRENT_STORY_WAS_SET, this.selectionStore.selection), await this.renderSelection({ persistedArgs: args });
  }
  // EVENT HANDLERS
  // This happens when a config file gets reloaded
  async onGetProjectAnnotationsChanged({
    getProjectAnnotations
  }) {
    await super.onGetProjectAnnotationsChanged({ getProjectAnnotations }), this.selectionStore.selection && this.renderSelection();
  }
  // This happens when a glob gets HMR-ed
  async onStoriesChanged({
    importFn,
    storyIndex
  }) {
    await super.onStoriesChanged({ importFn, storyIndex }), this.selectionStore.selection ? await this.renderSelection() : await this.selectSpecifiedStory();
  }
  onKeydown(event) {
    if (!this.storyRenders.find((r2) => r2.disableKeyListeners) && !focusInInput(event)) {
      let { altKey, ctrlKey, metaKey, shiftKey, key, code, keyCode } = event;
      this.channel.emit(PREVIEW_KEYDOWN, {
        event: { altKey, ctrlKey, metaKey, shiftKey, key, code, keyCode }
      });
    }
  }
  async onSetCurrentStory(selection) {
    this.selectionStore.setSelection({ viewMode: "story", ...selection }), await this.storeInitializationPromise, this.channel.emit(CURRENT_STORY_WAS_SET, this.selectionStore.selection), this.renderSelection();
  }
  onUpdateQueryParams(queryParams) {
    this.selectionStore.setQueryParams(queryParams);
  }
  async onUpdateGlobals({ globals }) {
    let currentStory = this.currentRender instanceof StoryRender && this.currentRender.story || void 0;
    super.onUpdateGlobals({ globals, currentStory }), (this.currentRender instanceof MdxDocsRender || this.currentRender instanceof CsfDocsRender) && await this.currentRender.rerender?.();
  }
  async onUpdateArgs({ storyId, updatedArgs }) {
    super.onUpdateArgs({ storyId, updatedArgs });
  }
  async onPreloadStories({ ids }) {
    await this.storeInitializationPromise, this.storyStoreValue && await Promise.allSettled(ids.map((id) => this.storyStoreValue?.loadEntry(id)));
  }
  // RENDERING
  // We can either have:
  // - a story selected in "story" viewMode,
  //     in which case we render it to the root element, OR
  // - a story selected in "docs" viewMode,
  //     in which case we render the docsPage for that story
  async renderSelection({ persistedArgs } = {}) {
    let { renderToCanvas } = this;
    if (!this.storyStoreValue || !renderToCanvas)
      throw new CalledPreviewMethodBeforeInitializationError({ methodName: "renderSelection" });
    let { selection } = this.selectionStore;
    if (!selection)
      throw new Error("Cannot call renderSelection as no selection was made");
    let { storyId } = selection, entry;
    try {
      entry = await this.storyStoreValue.storyIdToEntry(storyId);
    } catch (err) {
      this.currentRender && await this.teardownRender(this.currentRender), this.renderStoryLoadingException(storyId, err);
      return;
    }
    let storyIdChanged = this.currentSelection?.storyId !== storyId, viewModeChanged = this.currentRender?.type !== entry.type;
    entry.type === "story" ? this.view.showPreparingStory({ immediate: viewModeChanged }) : this.view.showPreparingDocs({ immediate: viewModeChanged }), this.currentRender?.isPreparing() && await this.teardownRender(this.currentRender);
    let render;
    entry.type === "story" ? render = new StoryRender(
      this.channel,
      this.storyStoreValue,
      renderToCanvas,
      this.mainStoryCallbacks(storyId),
      storyId,
      "story"
    ) : isMdxEntry(entry) ? render = new MdxDocsRender(
      this.channel,
      this.storyStoreValue,
      entry,
      this.mainStoryCallbacks(storyId)
    ) : render = new CsfDocsRender(
      this.channel,
      this.storyStoreValue,
      entry,
      this.mainStoryCallbacks(storyId)
    );
    let lastSelection = this.currentSelection;
    this.currentSelection = selection;
    let lastRender = this.currentRender;
    this.currentRender = render;
    try {
      await render.prepare();
    } catch (err) {
      lastRender && await this.teardownRender(lastRender), err !== PREPARE_ABORTED && this.renderStoryLoadingException(storyId, err);
      return;
    }
    let implementationChanged = !storyIdChanged && lastRender && !render.isEqual(lastRender);
    if (persistedArgs && isStoryRender(render) && (invariant(!!render.story), this.storyStoreValue.args.updateFromPersisted(render.story, persistedArgs)), lastRender && !lastRender.torndown && !storyIdChanged && !implementationChanged && !viewModeChanged) {
      this.currentRender = lastRender, this.channel.emit(STORY_UNCHANGED, storyId), this.view.showMain();
      return;
    }
    if (lastRender && await this.teardownRender(lastRender, { viewModeChanged }), lastSelection && (storyIdChanged || viewModeChanged) && this.channel.emit(STORY_CHANGED, storyId), isStoryRender(render)) {
      invariant(!!render.story);
      let {
        parameters: parameters2,
        initialArgs,
        argTypes,
        unmappedArgs,
        initialGlobals: initialGlobals5,
        userGlobals,
        storyGlobals,
        globals
      } = this.storyStoreValue.getStoryContext(render.story);
      this.channel.emit(STORY_PREPARED, {
        id: storyId,
        parameters: parameters2,
        initialArgs,
        argTypes,
        args: unmappedArgs
      }), this.channel.emit(GLOBALS_UPDATED, { userGlobals, storyGlobals, globals, initialGlobals: initialGlobals5 });
    } else {
      let { parameters: parameters2 } = this.storyStoreValue.projectAnnotations, { initialGlobals: initialGlobals5, globals } = this.storyStoreValue.userGlobals;
      if (this.channel.emit(GLOBALS_UPDATED, {
        globals,
        initialGlobals: initialGlobals5,
        storyGlobals: {},
        userGlobals: globals
      }), isCsfDocsRender(render) || render.entry.tags?.includes(ATTACHED_MDX_TAG)) {
        if (!render.csfFiles)
          throw new MdxFileWithNoCsfReferencesError({ storyId });
        ({ parameters: parameters2 } = this.storyStoreValue.preparedMetaFromCSFFile({
          csfFile: render.csfFiles[0]
        }));
      }
      this.channel.emit(DOCS_PREPARED, {
        id: storyId,
        parameters: parameters2
      });
    }
    isStoryRender(render) ? (invariant(!!render.story), this.storyRenders.push(render), this.currentRender.renderToElement(
      this.view.prepareForStory(render.story)
    )) : this.currentRender.renderToElement(
      this.view.prepareForDocs(),
      // This argument is used for docs, which is currently only compatible with HTMLElements
      this.renderStoryToElement.bind(this)
    );
  }
  async teardownRender(render, { viewModeChanged = !1 } = {}) {
    this.storyRenders = this.storyRenders.filter((r2) => r2 !== render), await render?.teardown?.({ viewModeChanged });
  }
  // UTILITIES
  mainStoryCallbacks(storyId) {
    return {
      showStoryDuringRender: () => this.view.showStoryDuringRender(),
      showMain: () => this.view.showMain(),
      showError: (err) => this.renderError(storyId, err),
      showException: (err) => this.renderException(storyId, err)
    };
  }
  renderPreviewEntryError(reason, err) {
    super.renderPreviewEntryError(reason, err), this.view.showErrorDisplay(err);
  }
  renderMissingStory() {
    this.view.showNoPreview(), this.channel.emit(STORY_MISSING);
  }
  renderStoryLoadingException(storySpecifier, err) {
    logger.error(err), this.view.showErrorDisplay(err), this.channel.emit(STORY_MISSING, storySpecifier);
  }
  // renderException is used if we fail to render the story and it is uncaught by the app layer
  renderException(storyId, error) {
    let { name = "Error", message = String(error), stack } = error, renderId = this.currentRender?.renderId;
    this.channel.emit(STORY_THREW_EXCEPTION, { name, message, stack }), this.channel.emit(STORY_RENDER_PHASE_CHANGED, { newPhase: "errored", renderId, storyId }), this.view.showErrorDisplay(error), logger.error(`Error rendering story '${storyId}':`), logger.error(error);
  }
  // renderError is used by the various app layers to inform the user they have done something
  // wrong -- for instance returned the wrong thing from a story
  renderError(storyId, { title, description }) {
    let renderId = this.currentRender?.renderId;
    this.channel.emit(STORY_ERRORED, { title, description }), this.channel.emit(STORY_RENDER_PHASE_CHANGED, { newPhase: "errored", renderId, storyId }), this.view.showErrorDisplay({ message: title, stack: description }), logger.error(`Error rendering story ${title}: ${description}`);
  }
};

// src/preview-api/modules/preview-web/UrlStore.ts
var import_picoquery2 = __toESM(require_main(), 1);

// src/preview-api/modules/preview-web/parseArgsParam.ts
var import_picoquery = __toESM(require_main(), 1);
var VALIDATION_REGEXP = /^[a-zA-Z0-9 _-]*$/, NUMBER_REGEXP = /^-?[0-9]+(\.[0-9]+)?$/, HEX_REGEXP = /^#([a-f0-9]{3,4}|[a-f0-9]{6}|[a-f0-9]{8})$/i, COLOR_REGEXP = /^(rgba?|hsla?)\(([0-9]{1,3}),\s?([0-9]{1,3})%?,\s?([0-9]{1,3})%?,?\s?([0-9](\.[0-9]{1,2})?)?\)$/i, validateArgs = (key = "", value) => key === null || key === "" || !VALIDATION_REGEXP.test(key) ? !1 : value == null || value instanceof Date || typeof value == "number" || typeof value == "boolean" ? !0 : typeof value == "string" ? VALIDATION_REGEXP.test(value) || NUMBER_REGEXP.test(value) || HEX_REGEXP.test(value) || COLOR_REGEXP.test(value) : Array.isArray(value) ? value.every((v2) => validateArgs(key, v2)) : isPlainObject(value) ? Object.entries(value).every(([k2, v2]) => validateArgs(k2, v2)) : !1, QUERY_OPTIONS = {
  delimiter: ";",
  // we're parsing a single query param
  nesting: !0,
  arrayRepeat: !0,
  arrayRepeatSyntax: "bracket",
  nestingSyntax: "js",
  // objects are encoded using dot notation
  valueDeserializer(str2) {
    if (str2.startsWith("!")) {
      if (str2 === "!undefined")
        return;
      if (str2 === "!null")
        return null;
      if (str2 === "!true")
        return !0;
      if (str2 === "!false")
        return !1;
      if (str2.startsWith("!date(") && str2.endsWith(")"))
        return new Date(str2.replaceAll(" ", "+").slice(6, -1));
      if (str2.startsWith("!hex(") && str2.endsWith(")"))
        return `#${str2.slice(5, -1)}`;
      let color = str2.slice(1).match(COLOR_REGEXP);
      if (color)
        return str2.startsWith("!rgba") || str2.startsWith("!RGBA") ? `${color[1]}(${color[2]}, ${color[3]}, ${color[4]}, ${color[5]})` : str2.startsWith("!hsla") || str2.startsWith("!HSLA") ? `${color[1]}(${color[2]}, ${color[3]}%, ${color[4]}%, ${color[5]})` : str2.startsWith("!rgb") || str2.startsWith("!RGB") ? `${color[1]}(${color[2]}, ${color[3]}, ${color[4]})` : `${color[1]}(${color[2]}, ${color[3]}%, ${color[4]}%)`;
    }
    return NUMBER_REGEXP.test(str2) ? Number(str2) : str2;
  }
}, parseArgsParam = (argsString) => {
  let parts = argsString.split(";").map((part) => part.replace("=", "~").replace(":", "="));
  return Object.entries((0, import_picoquery.parse)(parts.join(";"), QUERY_OPTIONS)).reduce((acc, [key, value]) => validateArgs(key, value) ? Object.assign(acc, { [key]: value }) : (once.warn(dedent`
      Omitted potentially unsafe URL args.

      More info: https://storybook.js.org/docs/writing-stories/args#setting-args-through-the-url?ref=error
    `), acc), {});
};

// src/preview-api/modules/preview-web/UrlStore.ts
var { history, document: document4 } = scope;
function pathToId(path) {
  let match = (path || "").match(/^\/story\/(.+)/);
  if (!match)
    throw new Error(`Invalid path '${path}',  must start with '/story/'`);
  return match[1];
}
var getQueryString = ({
  selection,
  extraParams
}) => {
  let search = document4?.location.search.slice(1), { path, selectedKind, selectedStory, ...rest } = (0, import_picoquery2.parse)(search);
  return `?${(0, import_picoquery2.stringify)({
    ...rest,
    ...extraParams,
    ...selection && { id: selection.storyId, viewMode: selection.viewMode }
  })}`;
}, setPath = (selection) => {
  if (!selection)
    return;
  let query = getQueryString({ selection }), { hash = "" } = document4.location;
  document4.title = selection.storyId, history.replaceState({}, "", `${document4.location.pathname}${query}${hash}`);
}, isObject6 = (val) => val != null && typeof val == "object" && Array.isArray(val) === !1, getFirstString = (v2) => {
  if (v2 !== void 0) {
    if (typeof v2 == "string")
      return v2;
    if (Array.isArray(v2))
      return getFirstString(v2[0]);
    if (isObject6(v2))
      return getFirstString(
        Object.values(v2).filter(Boolean)
      );
  }
}, getSelectionSpecifierFromPath = () => {
  if (typeof document4 < "u") {
    let queryStr = document4.location.search.slice(1), query = (0, import_picoquery2.parse)(queryStr), args = typeof query.args == "string" ? parseArgsParam(query.args) : void 0, globals = typeof query.globals == "string" ? parseArgsParam(query.globals) : void 0, viewMode = getFirstString(query.viewMode);
    if (typeof viewMode != "string" || !viewMode)
      viewMode = "story";
    else if (!viewMode.match(/docs|story/))
      return null;
    let path = getFirstString(query.path), storyId = path ? pathToId(path) : getFirstString(query.id);
    if (storyId)
      return { storySpecifier: storyId, args, globals, viewMode };
  }
  return null;
}, UrlStore = class {
  constructor() {
    this.selectionSpecifier = getSelectionSpecifierFromPath();
  }
  setSelection(selection) {
    this.selection = selection, setPath(this.selection);
  }
  setQueryParams(queryParams) {
    let query = getQueryString({ extraParams: queryParams }), { hash = "" } = document4.location;
    history.replaceState({}, "", `${document4.location.pathname}${query}${hash}`);
  }
};

// src/preview-api/modules/preview-web/WebView.ts
var import_ansi_to_html = __toESM(require_ansi_to_html(), 1), import_picoquery3 = __toESM(require_main(), 1);
var { document: document5 } = scope, PREPARING_DELAY = 100, Mode = /* @__PURE__ */ ((Mode2) => (Mode2.MAIN = "MAIN", Mode2.NOPREVIEW = "NOPREVIEW", Mode2.PREPARING_STORY = "PREPARING_STORY", Mode2.PREPARING_DOCS = "PREPARING_DOCS", Mode2.ERROR = "ERROR", Mode2))(Mode || {}), classes = {
  PREPARING_STORY: "sb-show-preparing-story",
  PREPARING_DOCS: "sb-show-preparing-docs",
  MAIN: "sb-show-main",
  NOPREVIEW: "sb-show-nopreview",
  ERROR: "sb-show-errordisplay"
}, layoutClassMap = {
  centered: "sb-main-centered",
  fullscreen: "sb-main-fullscreen",
  padded: "sb-main-padded"
}, ansiConverter = new import_ansi_to_html.default({
  escapeXML: !0
}), WebView = class {
  constructor() {
    this.testing = !1;
    if (typeof document5 < "u") {
      let { __SPECIAL_TEST_PARAMETER__ } = (0, import_picoquery3.parse)(document5.location.search.slice(1));
      switch (__SPECIAL_TEST_PARAMETER__) {
        case "preparing-story": {
          this.showPreparingStory(), this.testing = !0;
          break;
        }
        case "preparing-docs": {
          this.showPreparingDocs(), this.testing = !0;
          break;
        }
        default:
      }
    }
  }
  // Get ready to render a story, returning the element to render to
  prepareForStory(story) {
    return this.showStory(), this.applyLayout(story.parameters.layout), document5.documentElement.scrollTop = 0, document5.documentElement.scrollLeft = 0, this.storyRoot();
  }
  storyRoot() {
    return document5.getElementById("storybook-root");
  }
  prepareForDocs() {
    return this.showMain(), this.showDocs(), this.applyLayout("fullscreen"), document5.documentElement.scrollTop = 0, document5.documentElement.scrollLeft = 0, this.docsRoot();
  }
  docsRoot() {
    return document5.getElementById("storybook-docs");
  }
  applyLayout(layout = "padded") {
    if (layout === "none") {
      document5.body.classList.remove(this.currentLayoutClass), this.currentLayoutClass = null;
      return;
    }
    this.checkIfLayoutExists(layout);
    let layoutClass = layoutClassMap[layout];
    document5.body.classList.remove(this.currentLayoutClass), document5.body.classList.add(layoutClass), this.currentLayoutClass = layoutClass;
  }
  checkIfLayoutExists(layout) {
    layoutClassMap[layout] || logger.warn(
      dedent`
          The desired layout: ${layout} is not a valid option.
          The possible options are: ${Object.keys(layoutClassMap).join(", ")}, none.
        `
    );
  }
  showMode(mode) {
    clearTimeout(this.preparingTimeout), Object.keys(Mode).forEach((otherMode) => {
      otherMode === mode ? document5.body.classList.add(classes[otherMode]) : document5.body.classList.remove(classes[otherMode]);
    });
  }
  showErrorDisplay({ message = "", stack = "" }) {
    let header = message, detail = stack, parts = message.split(`
`);
    parts.length > 1 && ([header] = parts, detail = parts.slice(1).join(`
`).replace(/^\n/, "")), document5.getElementById("error-message").innerHTML = ansiConverter.toHtml(header), document5.getElementById("error-stack").innerHTML = ansiConverter.toHtml(detail), this.showMode("ERROR" /* ERROR */);
  }
  showNoPreview() {
    this.testing || (this.showMode("NOPREVIEW" /* NOPREVIEW */), this.storyRoot()?.setAttribute("hidden", "true"), this.docsRoot()?.setAttribute("hidden", "true"));
  }
  showPreparingStory({ immediate = !1 } = {}) {
    clearTimeout(this.preparingTimeout), immediate ? this.showMode("PREPARING_STORY" /* PREPARING_STORY */) : this.preparingTimeout = setTimeout(
      () => this.showMode("PREPARING_STORY" /* PREPARING_STORY */),
      PREPARING_DELAY
    );
  }
  showPreparingDocs({ immediate = !1 } = {}) {
    clearTimeout(this.preparingTimeout), immediate ? this.showMode("PREPARING_DOCS" /* PREPARING_DOCS */) : this.preparingTimeout = setTimeout(() => this.showMode("PREPARING_DOCS" /* PREPARING_DOCS */), PREPARING_DELAY);
  }
  showMain() {
    this.showMode("MAIN" /* MAIN */);
  }
  showDocs() {
    this.storyRoot().setAttribute("hidden", "true"), this.docsRoot().removeAttribute("hidden");
  }
  showStory() {
    this.docsRoot().setAttribute("hidden", "true"), this.storyRoot().removeAttribute("hidden");
  }
  showStoryDuringRender() {
    document5.body.classList.add(classes.MAIN);
  }
};

// src/preview-api/modules/preview-web/PreviewWeb.tsx
var PreviewWeb = class extends PreviewWithSelection {
  constructor(importFn, getProjectAnnotations) {
    super(importFn, getProjectAnnotations, new UrlStore(), new WebView());
    this.importFn = importFn;
    this.getProjectAnnotations = getProjectAnnotations;
    scope.__STORYBOOK_PREVIEW__ = this;
  }
};

// src/preview-api/modules/preview-web/simulate-pageload.ts
var { document: document6 } = scope, runScriptTypes = [
  "application/javascript",
  "application/ecmascript",
  "application/x-ecmascript",
  "application/x-javascript",
  "text/ecmascript",
  "text/javascript",
  "text/javascript1.0",
  "text/javascript1.1",
  "text/javascript1.2",
  "text/javascript1.3",
  "text/javascript1.4",
  "text/javascript1.5",
  "text/jscript",
  "text/livescript",
  "text/x-ecmascript",
  "text/x-javascript",
  // Support modern javascript
  "module"
], SCRIPT = "script", SCRIPTS_ROOT_ID = "scripts-root";
function simulateDOMContentLoaded() {
  let DOMContentLoadedEvent = document6.createEvent("Event");
  DOMContentLoadedEvent.initEvent("DOMContentLoaded", !0, !0), document6.dispatchEvent(DOMContentLoadedEvent);
}
function insertScript($script, callback, $scriptRoot) {
  let scriptEl = document6.createElement("script");
  scriptEl.type = $script.type === "module" ? "module" : "text/javascript", $script.src ? (scriptEl.onload = callback, scriptEl.onerror = callback, scriptEl.src = $script.src) : scriptEl.textContent = $script.innerText, $scriptRoot ? $scriptRoot.appendChild(scriptEl) : document6.head.appendChild(scriptEl), $script.parentNode.removeChild($script), $script.src || callback();
}
function insertScriptsSequentially(scriptsToExecute, callback, index2 = 0) {
  scriptsToExecute[index2](() => {
    index2++, index2 === scriptsToExecute.length ? callback() : insertScriptsSequentially(scriptsToExecute, callback, index2);
  });
}
function simulatePageLoad($container) {
  let $scriptsRoot = document6.getElementById(SCRIPTS_ROOT_ID);
  $scriptsRoot ? $scriptsRoot.innerHTML = "" : ($scriptsRoot = document6.createElement("div"), $scriptsRoot.id = SCRIPTS_ROOT_ID, document6.body.appendChild($scriptsRoot));
  let $scripts = Array.from($container.querySelectorAll(SCRIPT));
  if ($scripts.length) {
    let scriptsToExecute = [];
    $scripts.forEach(($script) => {
      let typeAttr = $script.getAttribute("type");
      (!typeAttr || runScriptTypes.includes(typeAttr)) && scriptsToExecute.push((callback) => insertScript($script, callback, $scriptsRoot));
    }), scriptsToExecute.length && insertScriptsSequentially(scriptsToExecute, simulateDOMContentLoaded, void 0);
  } else
    simulateDOMContentLoaded();
}

// ../node_modules/comment-parser/es6/primitives.js
var Markers;
(function(Markers2) {
  Markers2.start = "/**", Markers2.nostart = "/***", Markers2.delim = "*", Markers2.end = "*/";
})(Markers = Markers || (Markers = {}));

// ../node_modules/comment-parser/es6/stringifier/index.js
function join(tokens) {
  return tokens.start + tokens.delimiter + tokens.postDelimiter + tokens.tag + tokens.postTag + tokens.type + tokens.postType + tokens.name + tokens.postName + tokens.description + tokens.end + tokens.lineEnd;
}
function getStringifier() {
  return (block) => block.source.map(({ tokens }) => join(tokens)).join(`
`);
}

// ../node_modules/comment-parser/es6/stringifier/inspect.js
var zeroWidth = {
  line: 0,
  start: 0,
  delimiter: 0,
  postDelimiter: 0,
  tag: 0,
  postTag: 0,
  name: 0,
  postName: 0,
  type: 0,
  postType: 0,
  description: 0,
  end: 0,
  lineEnd: 0
};
var fields = Object.keys(zeroWidth);

// ../node_modules/comment-parser/es6/index.js
var stringify4 = getStringifier();

// src/docs-tools/argTypes/jsdocParser.ts
var import_jsdoc_type_pratt_parser = __toESM(require_dist(), 1);
var jsdocStringifyRules = (0, import_jsdoc_type_pratt_parser.stringifyRules)(), originalJsdocStringifyObject = jsdocStringifyRules.JsdocTypeObject;
jsdocStringifyRules.JsdocTypeAny = () => "any";
jsdocStringifyRules.JsdocTypeObject = (result, transform) => `(${originalJsdocStringifyObject(result, transform)})`;
jsdocStringifyRules.JsdocTypeOptional = (result, transform) => transform(result.element);
jsdocStringifyRules.JsdocTypeNullable = (result, transform) => transform(result.element);
jsdocStringifyRules.JsdocTypeNotNullable = (result, transform) => transform(result.element);
jsdocStringifyRules.JsdocTypeUnion = (result, transform) => result.elements.map(transform).join("|");

// src/docs-tools/shared.ts
var ADDON_ID6 = "storybook/docs", PANEL_ID3 = `${ADDON_ID6}/panel`;
var SNIPPET_RENDERED = `${ADDON_ID6}/snippet-rendered`;

// src/preview-api/modules/preview-web/emitTransformCode.ts
async function emitTransformCode(source, context) {
  let transform = context.parameters?.docs?.source?.transform, { id, unmappedArgs } = context, transformed = transform && source ? transform?.(source, context) : source, result = transformed ? await transformed : void 0;
  addons.getChannel().emit(SNIPPET_RENDERED, {
    id,
    source: result,
    args: unmappedArgs
  });
}

// src/actions/runtime/configureActions.ts
var config3 = {
  depth: 10,
  clearOnStoryChange: !0,
  limit: 50
}, configureActions = (options = {}) => {
  Object.assign(config3, options);
};

// src/actions/runtime/action.ts
var findProto = (obj, callback) => {
  let proto = Object.getPrototypeOf(obj);
  return !proto || callback(proto) ? proto : findProto(proto, callback);
}, isReactSyntheticEvent = (e2) => !!(typeof e2 == "object" && e2 && findProto(e2, (proto) => /^Synthetic(?:Base)?Event$/.test(proto.constructor.name)) && typeof e2.persist == "function"), serializeArg = (a2) => {
  if (isReactSyntheticEvent(a2)) {
    let e2 = Object.create(
      a2.constructor.prototype,
      Object.getOwnPropertyDescriptors(a2)
    );
    e2.persist();
    let viewDescriptor = Object.getOwnPropertyDescriptor(e2, "view"), view = viewDescriptor?.value;
    return typeof view == "object" && view?.constructor.name === "Window" && Object.defineProperty(e2, "view", {
      ...viewDescriptor,
      value: Object.create(view.constructor.prototype)
    }), e2;
  }
  return a2;
};
function action(name, options = {}) {
  let actionOptions = {
    ...config3,
    ...options
  }, handler = function(...args) {
    if (options.implicit) {
      let storyRenderer = ("__STORYBOOK_PREVIEW__" in scope ? scope.__STORYBOOK_PREVIEW__ : void 0)?.storyRenders.find(
        (render) => render.phase === "playing" || render.phase === "rendering"
      );
      if (storyRenderer) {
        let deprecated = !globalThis?.FEATURES?.disallowImplicitActionsInRenderV8, error = new ImplicitActionsDuringRendering({
          phase: storyRenderer.phase,
          name,
          deprecated
        });
        if (deprecated)
          console.warn(error);
        else
          throw error;
      }
    }
    let channel = addons.getChannel(), id = Date.now().toString(36) + Math.random().toString(36).substring(2), minDepth = 5, serializedArgs = args.map(serializeArg), normalizedArgs = args.length > 1 ? serializedArgs : serializedArgs[0], actionDisplayToEmit = {
      id,
      count: 0,
      data: { name, args: normalizedArgs },
      options: {
        ...actionOptions,
        maxDepth: minDepth + (actionOptions.depth || 3)
      }
    };
    channel.emit(EVENT_ID, actionDisplayToEmit);
  };
  return handler.isAction = !0, handler.implicit = options.implicit, handler;
}

// src/actions/runtime/actions.ts
var actions = (...args) => {
  let options = config3, names = args;
  names.length === 1 && Array.isArray(names[0]) && ([names] = names), names.length !== 1 && typeof names[names.length - 1] != "string" && (options = {
    ...config3,
    ...names.pop()
  });
  let namesObject = names[0];
  (names.length !== 1 || typeof namesObject == "string") && (namesObject = {}, names.forEach((name) => {
    namesObject[name] = name;
  }));
  let actionsObject = {};
  return Object.keys(namesObject).forEach((name) => {
    actionsObject[name] = action(namesObject[name], options);
  }), actionsObject;
};

// src/preview/globals/runtime.ts
var globalsNameValueMap = {
  "@storybook/global": dist_exports,
  "storybook/test": test_exports,
  "storybook/actions": actions_exports,
  "storybook/preview-api": preview_api_exports,
  "storybook/internal/channels": channels_exports,
  "storybook/internal/client-logger": client_logger_exports,
  "storybook/internal/core-events": core_events_exports,
  "storybook/internal/types": types_exports,
  "storybook/internal/preview-errors": preview_errors_exports,
  "storybook/internal/preview-api": preview_api_exports
};

// src/preview/preview-navigator.ts
async function maybeSetupPreviewNavigator() {
  let url = new URL(window.location.href);
  if (url.searchParams.get("navigator") !== "true" || globalThis.__STORYBOOK_PREVIEW_NAVIGATOR__)
    return;
  globalThis.__STORYBOOK_PREVIEW_NAVIGATOR__ = !0;
  let index2 = await (await fetch("/index.json")).json(), currentEntryId = url.searchParams.get("id");
  if (!currentEntryId) {
    let firstEntry = Object.values(index2.entries)[0];
    firstEntry && (url.searchParams.set("id", firstEntry.id), url.searchParams.set("viewMode", firstEntry.type), window.location.href = url.toString());
    return;
  }
  setupPreviewNavigator(index2, currentEntryId);
}
var setupPreviewNavigator = async (index2, currentEntryId) => {
  let tree = { title: "", entries: {}, isActive: !0 };
  for (let entry of Object.values(index2.entries)) {
    let titleParts = entry.title.split("/"), currentNode = tree;
    for (let titlePart of titleParts)
      currentNode.entries || (currentNode.entries = {}), currentNode.entries[titlePart] ? currentEntryId === entry.id && (currentNode.entries[titlePart].isActive = !0) : currentNode.entries[titlePart] = {
        title: titlePart,
        isActive: currentEntryId === entry.id,
        entries: {}
      }, currentNode = currentNode.entries[titlePart];
    currentNode.entries || (currentNode.entries = {}), currentNode.entries[entry.name] = {
      id: entry.id,
      name: entry.name,
      href: `?id=${entry.id}&viewMode=${entry.type}&navigator=true`,
      isActive: currentEntryId === entry.id
    };
  }
  let createHtmlForNode = (node) => {
    if ("entries" in node && "title" in node) {
      let branchNode = node;
      return `
      <li class="sb-navigator-branch">
        <details${branchNode.isActive ? " open" : ""}>
          <summary class="sb-navigator-title">
            ${branchNode.title}
          </summary>
          <ul class="sb-navigator-entries" aria-label="${branchNode.title}">
            ${Object.values(branchNode.entries).map(createHtmlForNode).join("")}
          </ul>
        </details>
      </li>
      `;
    }
    let leafNode = node;
    return `
      <li class="sb-navigator-story-item">
        <a href="${leafNode.href}" 
           class="sb-navigator-story-link${leafNode.isActive ? " active" : ""}" 
           aria-current="${leafNode.isActive ? "location" : "false"}">${leafNode.name}</a>
      </li>
    `;
  }, navItems = Object.values(tree.entries).map(createHtmlForNode).join(""), nav = document.createElement("nav");
  nav.id = "sb-navigator-container", nav.setAttribute("role", "navigation"), nav.setAttribute("aria-label", "Story navigation"), nav.innerHTML = `
    <ul class="sb-navigator-list">${navItems}</ul>
  `, document.body.insertBefore(nav, document.body.firstChild);
  let style = document.createElement("style");
  style.id = "sb-navigator-style", style.textContent = `
    body {
      display: grid !important;
      grid-template-columns: 300px 1fr;
      font-family: 'Nunito', sans-serif;
      height: 100vh;
      margin: 0;

      --text-color: rgb(46, 52, 56);
      --bg-color: rgb(246, 249, 252);

      @media (prefers-color-scheme: dark) {
        --text-color: rgb(201, 205, 207);
        --bg-color: rgb(34, 36, 37);
      }
    }
    #storybook-root, #storybook-docs {
      overflow-y: auto;
      max-height: 100vh;
      max-width: 100%;
    }
    #sb-navigator-container, #sb-navigator-container * {
      box-sizing: border-box;
    }
    #sb-navigator-container {
        height: 100vh;
        overflow-y: auto;
        border-right: 1px solid #eee;
        padding: 1rem;
        font-size: 14px;
        color: var(--text-color);
        background-color: var(--bg-color);
        align-self: start;
        z-index: 1000;
    }
    .sb-main-padded #sb-navigator-container {
      margin: -1rem 1rem -1rem -1rem;
    }
    .sb-navigator-list {
      list-style-type: none;
      padding: 0;
      margin: 0;
    }
    .sb-navigator-branch {
      list-style-type: none;
    }
    .sb-navigator-item {
      margin-bottom: 15px;
    }
    .sb-navigator-title {
      color: var(--text-color);
      text-decoration: none;
      padding-block: 5px;
      cursor: pointer;
    }
    .sb-navigator-entries {
      padding-left: 15px;
    }
    .sb-navigator-story-item {
      margin-bottom: 8px;
      margin-left: 8px;
    }
    .sb-navigator-story-link {
      color: var(--text-color);
    }
    .sb-navigator-story-link.active {
      font-weight: bold;
      color: hsl(212 100 46);
    }
  `, document.head.appendChild(style), nav.querySelector(".sb-navigator-story-link.active")?.closest("details")?.scrollIntoView({ block: "center" });
};

// src/preview/utils.ts
var import_browser_dtector = __toESM(require_browser_dtector_umd_min(), 1), browserInfo;
function getBrowserInfo() {
  return browserInfo || (browserInfo = new import_browser_dtector.default(scope.navigator?.userAgent).getBrowserInfo()), browserInfo;
}
function prepareForTelemetry(error) {
  return error.browserInfo = getBrowserInfo(), error;
}

// src/preview/runtime.ts
function errorListener(args) {
  let error = args.error || args;
  error.fromStorybook && scope.sendTelemetryError(error);
}
function unhandledRejectionListener({ reason }) {
  reason.fromStorybook && scope.sendTelemetryError(reason);
}
function setup() {
  globalPackages.forEach((key) => {
    scope[globalsNameReferenceMap[key]] = globalsNameValueMap[key];
  }), scope.sendTelemetryError = (error) => {
    scope.__STORYBOOK_ADDONS_CHANNEL__.emit(TELEMETRY_ERROR, prepareForTelemetry(error));
  }, document.addEventListener("DOMContentLoaded", () => {
    scope.__STORYBOOK_ADDONS_CHANNEL__.on(MANAGER_INERT_ATTRIBUTE_CHANGED, (isInert) => {
      isInert ? document.body.setAttribute("inert", "true") : document.body.removeAttribute("inert");
    });
  }), scope.addEventListener("error", errorListener), scope.addEventListener("unhandledrejection", unhandledRejectionListener), maybeSetupPreviewNavigator();
}
setup();
export {
  setup
};
