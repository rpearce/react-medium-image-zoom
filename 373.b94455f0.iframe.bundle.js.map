{"version":3,"file":"373.b94455f0.iframe.bundle.js","mappings":";;AA4jBA;;;AAIA;AAIA;;;AAIA;;;;;AA+PA;AAudA;;;;;AAMA;;;;;;;;;;;AA0cA;;;AA60CA;;;;AAynBA;AAiLA;AACA;AAIA;ACjkEA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;AAGA","sources":["webpack://react-medium-image-zoom/./node_modules/.pnpm/storybook@10.0.0_@testing-library+dom@10.4.0_prettier@2.8.8_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/storybook/dist/_browser-chunks/chunk-W4QKLQSC.js","webpack://react-medium-image-zoom/./node_modules/.pnpm/storybook@10.0.0_@testing-library+dom@10.4.0_prettier@2.8.8_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/storybook/dist/csf/index.js"],"sourcesContent":["import {\n  require_main\n} from \"./chunk-Y3M7TW6K.js\";\nimport {\n  SNIPPET_RENDERED,\n  combineParameters\n} from \"./chunk-B4A3ADP3.js\";\nimport {\n  isEqual\n} from \"./chunk-ZNRFDIVA.js\";\nimport {\n  invariant\n} from \"./chunk-FUOHXXZT.js\";\nimport {\n  require_ansi_to_html\n} from \"./chunk-F4Q6SGTB.js\";\nimport {\n  isTestEnvironment,\n  pauseAnimations,\n  waitForAnimations\n} from \"./chunk-LYCSRYYR.js\";\nimport {\n  mapValues,\n  pickBy\n} from \"./chunk-UTNZYD2N.js\";\nimport {\n  isPlainObject\n} from \"./chunk-FSBVR7H5.js\";\nimport {\n  require_memoizerific\n} from \"./chunk-NVV6MIOE.js\";\nimport {\n  dedent\n} from \"./chunk-OPCDBBL3.js\";\nimport {\n  __name,\n  __toESM\n} from \"./chunk-MM7DTO55.js\";\n\n// src/preview-api/modules/addons/main.ts\nimport { global } from \"@storybook/global\";\n\n// src/preview-api/modules/addons/storybook-channel-mock.ts\nimport { Channel } from \"storybook/internal/channels\";\nfunction mockChannel() {\n  const transport = {\n    setHandler: /* @__PURE__ */ __name(() => {\n    }, \"setHandler\"),\n    send: /* @__PURE__ */ __name(() => {\n    }, \"send\")\n  };\n  return new Channel({ transport });\n}\n__name(mockChannel, \"mockChannel\");\n\n// src/preview-api/modules/addons/main.ts\nvar _AddonStore = class _AddonStore {\n  constructor() {\n    this.getChannel = /* @__PURE__ */ __name(() => {\n      if (!this.channel) {\n        const channel = mockChannel();\n        this.setChannel(channel);\n        return channel;\n      }\n      return this.channel;\n    }, \"getChannel\");\n    this.ready = /* @__PURE__ */ __name(() => this.promise, \"ready\");\n    this.hasChannel = /* @__PURE__ */ __name(() => !!this.channel, \"hasChannel\");\n    this.setChannel = /* @__PURE__ */ __name((channel) => {\n      this.channel = channel;\n      this.resolve();\n    }, \"setChannel\");\n    this.promise = new Promise((res) => {\n      this.resolve = () => res(this.getChannel());\n    });\n  }\n};\n__name(_AddonStore, \"AddonStore\");\nvar AddonStore = _AddonStore;\nvar KEY = \"__STORYBOOK_ADDONS_PREVIEW\";\nfunction getAddonsStore() {\n  if (!global[KEY]) {\n    global[KEY] = new AddonStore();\n  }\n  return global[KEY];\n}\n__name(getAddonsStore, \"getAddonsStore\");\nvar addons = getAddonsStore();\n\n// src/preview-api/modules/addons/hooks.ts\nimport { logger } from \"storybook/internal/client-logger\";\nimport {\n  FORCE_RE_RENDER,\n  RESET_STORY_ARGS,\n  STORY_RENDERED,\n  UPDATE_GLOBALS,\n  UPDATE_STORY_ARGS\n} from \"storybook/internal/core-events\";\nimport { global as global2 } from \"@storybook/global\";\nvar _HooksContext = class _HooksContext {\n  constructor() {\n    this.hookListsMap = void 0;\n    this.mountedDecorators = void 0;\n    this.prevMountedDecorators = void 0;\n    this.currentHooks = void 0;\n    this.nextHookIndex = void 0;\n    this.currentPhase = void 0;\n    this.currentEffects = void 0;\n    this.prevEffects = void 0;\n    this.currentDecoratorName = void 0;\n    this.hasUpdates = void 0;\n    this.currentContext = void 0;\n    this.renderListener = /* @__PURE__ */ __name((storyId) => {\n      if (storyId !== this.currentContext?.id) {\n        return;\n      }\n      this.triggerEffects();\n      this.currentContext = null;\n      this.removeRenderListeners();\n    }, \"renderListener\");\n    this.init();\n  }\n  init() {\n    this.hookListsMap = /* @__PURE__ */ new WeakMap();\n    this.mountedDecorators = /* @__PURE__ */ new Set();\n    this.prevMountedDecorators = /* @__PURE__ */ new Set();\n    this.currentHooks = [];\n    this.nextHookIndex = 0;\n    this.currentPhase = \"NONE\";\n    this.currentEffects = [];\n    this.prevEffects = [];\n    this.currentDecoratorName = null;\n    this.hasUpdates = false;\n    this.currentContext = null;\n  }\n  clean() {\n    this.prevEffects.forEach((effect) => {\n      if (effect.destroy) {\n        effect.destroy();\n      }\n    });\n    this.init();\n    this.removeRenderListeners();\n  }\n  getNextHook() {\n    const hook = this.currentHooks[this.nextHookIndex];\n    this.nextHookIndex += 1;\n    return hook;\n  }\n  triggerEffects() {\n    this.prevEffects.forEach((effect) => {\n      if (!this.currentEffects.includes(effect) && effect.destroy) {\n        effect.destroy();\n      }\n    });\n    this.currentEffects.forEach((effect) => {\n      if (!this.prevEffects.includes(effect)) {\n        effect.destroy = effect.create();\n      }\n    });\n    this.prevEffects = this.currentEffects;\n    this.currentEffects = [];\n  }\n  addRenderListeners() {\n    this.removeRenderListeners();\n    const channel = addons.getChannel();\n    channel.on(STORY_RENDERED, this.renderListener);\n  }\n  removeRenderListeners() {\n    const channel = addons.getChannel();\n    channel.removeListener(STORY_RENDERED, this.renderListener);\n  }\n};\n__name(_HooksContext, \"HooksContext\");\nvar HooksContext = _HooksContext;\nfunction hookify(fn) {\n  const hookified = /* @__PURE__ */ __name((...args) => {\n    const { hooks } = typeof args[0] === \"function\" ? args[1] : args[0];\n    const prevPhase = hooks.currentPhase;\n    const prevHooks = hooks.currentHooks;\n    const prevNextHookIndex = hooks.nextHookIndex;\n    const prevDecoratorName = hooks.currentDecoratorName;\n    hooks.currentDecoratorName = fn.name;\n    if (hooks.prevMountedDecorators.has(fn)) {\n      hooks.currentPhase = \"UPDATE\";\n      hooks.currentHooks = hooks.hookListsMap.get(fn) || [];\n    } else {\n      hooks.currentPhase = \"MOUNT\";\n      hooks.currentHooks = [];\n      hooks.hookListsMap.set(fn, hooks.currentHooks);\n      hooks.prevMountedDecorators.add(fn);\n    }\n    hooks.nextHookIndex = 0;\n    const prevContext = global2.STORYBOOK_HOOKS_CONTEXT;\n    global2.STORYBOOK_HOOKS_CONTEXT = hooks;\n    const result = fn(...args);\n    global2.STORYBOOK_HOOKS_CONTEXT = prevContext;\n    if (hooks.currentPhase === \"UPDATE\" && hooks.getNextHook() != null) {\n      throw new Error(\n        \"Rendered fewer hooks than expected. This may be caused by an accidental early return statement.\"\n      );\n    }\n    hooks.currentPhase = prevPhase;\n    hooks.currentHooks = prevHooks;\n    hooks.nextHookIndex = prevNextHookIndex;\n    hooks.currentDecoratorName = prevDecoratorName;\n    return result;\n  }, \"hookified\");\n  hookified.originalFn = fn;\n  return hookified;\n}\n__name(hookify, \"hookify\");\nvar numberOfRenders = 0;\nvar RENDER_LIMIT = 25;\nvar applyHooks = /* @__PURE__ */ __name((applyDecorators) => (storyFn, decorators) => {\n  const decorated = applyDecorators(\n    hookify(storyFn),\n    decorators.map((decorator) => hookify(decorator))\n  );\n  return (context) => {\n    const { hooks } = context;\n    hooks.prevMountedDecorators ??= /* @__PURE__ */ new Set();\n    hooks.mountedDecorators = /* @__PURE__ */ new Set([storyFn, ...decorators]);\n    hooks.currentContext = context;\n    hooks.hasUpdates = false;\n    let result = decorated(context);\n    numberOfRenders = 1;\n    while (hooks.hasUpdates) {\n      hooks.hasUpdates = false;\n      hooks.currentEffects = [];\n      result = decorated(context);\n      numberOfRenders += 1;\n      if (numberOfRenders > RENDER_LIMIT) {\n        throw new Error(\n          \"Too many re-renders. Storybook limits the number of renders to prevent an infinite loop.\"\n        );\n      }\n    }\n    hooks.addRenderListeners();\n    return result;\n  };\n}, \"applyHooks\");\nvar areDepsEqual = /* @__PURE__ */ __name((deps, nextDeps) => deps.length === nextDeps.length && deps.every((dep, i) => dep === nextDeps[i]), \"areDepsEqual\");\nvar invalidHooksError = /* @__PURE__ */ __name(() => new Error(\"Storybook preview hooks can only be called inside decorators and story functions.\"), \"invalidHooksError\");\nfunction getHooksContextOrNull() {\n  return global2.STORYBOOK_HOOKS_CONTEXT || null;\n}\n__name(getHooksContextOrNull, \"getHooksContextOrNull\");\nfunction getHooksContextOrThrow() {\n  const hooks = getHooksContextOrNull();\n  if (hooks == null) {\n    throw invalidHooksError();\n  }\n  return hooks;\n}\n__name(getHooksContextOrThrow, \"getHooksContextOrThrow\");\nfunction useHook(name, callback, deps) {\n  const hooks = getHooksContextOrThrow();\n  if (hooks.currentPhase === \"MOUNT\") {\n    if (deps != null && !Array.isArray(deps)) {\n      logger.warn(\n        `${name} received a final argument that is not an array (instead, received ${deps}). When specified, the final argument must be an array.`\n      );\n    }\n    const hook = { name, deps };\n    hooks.currentHooks.push(hook);\n    callback(hook);\n    return hook;\n  }\n  if (hooks.currentPhase === \"UPDATE\") {\n    const hook = hooks.getNextHook();\n    if (hook == null) {\n      throw new Error(\"Rendered more hooks than during the previous render.\");\n    }\n    if (hook.name !== name) {\n      logger.warn(\n        `Storybook has detected a change in the order of Hooks${hooks.currentDecoratorName ? ` called by ${hooks.currentDecoratorName}` : \"\"}. This will lead to bugs and errors if not fixed.`\n      );\n    }\n    if (deps != null && hook.deps == null) {\n      logger.warn(\n        `${name} received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.`\n      );\n    }\n    if (deps != null && hook.deps != null && deps.length !== hook.deps.length) {\n      logger.warn(`The final argument passed to ${name} changed size between renders. The order and size of this array must remain constant.\nPrevious: ${hook.deps}\nIncoming: ${deps}`);\n    }\n    if (deps == null || hook.deps == null || !areDepsEqual(deps, hook.deps)) {\n      callback(hook);\n      hook.deps = deps;\n    }\n    return hook;\n  }\n  throw invalidHooksError();\n}\n__name(useHook, \"useHook\");\nfunction useMemoLike(name, nextCreate, deps) {\n  const { memoizedState } = useHook(\n    name,\n    (hook) => {\n      hook.memoizedState = nextCreate();\n    },\n    deps\n  );\n  return memoizedState;\n}\n__name(useMemoLike, \"useMemoLike\");\nfunction useMemo(nextCreate, deps) {\n  return useMemoLike(\"useMemo\", nextCreate, deps);\n}\n__name(useMemo, \"useMemo\");\nfunction useCallback(callback, deps) {\n  return useMemoLike(\"useCallback\", () => callback, deps);\n}\n__name(useCallback, \"useCallback\");\nfunction useRefLike(name, initialValue) {\n  return useMemoLike(name, () => ({ current: initialValue }), []);\n}\n__name(useRefLike, \"useRefLike\");\nfunction useRef(initialValue) {\n  return useRefLike(\"useRef\", initialValue);\n}\n__name(useRef, \"useRef\");\nfunction triggerUpdate() {\n  const hooks = getHooksContextOrNull();\n  if (hooks != null && hooks.currentPhase !== \"NONE\") {\n    hooks.hasUpdates = true;\n  } else {\n    try {\n      addons.getChannel().emit(FORCE_RE_RENDER);\n    } catch (e) {\n      logger.warn(\"State updates of Storybook preview hooks work only in browser\");\n    }\n  }\n}\n__name(triggerUpdate, \"triggerUpdate\");\nfunction useStateLike(name, initialState) {\n  const stateRef = useRefLike(\n    name,\n    // @ts-expect-error S type should never be function, but there's no way to tell that to TypeScript\n    typeof initialState === \"function\" ? initialState() : initialState\n  );\n  const setState = /* @__PURE__ */ __name((update) => {\n    stateRef.current = typeof update === \"function\" ? update(stateRef.current) : update;\n    triggerUpdate();\n  }, \"setState\");\n  return [stateRef.current, setState];\n}\n__name(useStateLike, \"useStateLike\");\nfunction useState(initialState) {\n  return useStateLike(\"useState\", initialState);\n}\n__name(useState, \"useState\");\nfunction useReducer(reducer, initialArg, init) {\n  const initialState = init != null ? () => init(initialArg) : initialArg;\n  const [state, setState] = useStateLike(\"useReducer\", initialState);\n  const dispatch = /* @__PURE__ */ __name((action) => setState((prevState) => reducer(prevState, action)), \"dispatch\");\n  return [state, dispatch];\n}\n__name(useReducer, \"useReducer\");\nfunction useEffect(create, deps) {\n  const hooks = getHooksContextOrThrow();\n  const effect = useMemoLike(\"useEffect\", () => ({ create }), deps);\n  if (!hooks.currentEffects.includes(effect)) {\n    hooks.currentEffects.push(effect);\n  }\n}\n__name(useEffect, \"useEffect\");\nfunction useChannel(eventMap, deps = []) {\n  const channel = addons.getChannel();\n  useEffect(() => {\n    Object.entries(eventMap).forEach(([type, listener]) => channel.on(type, listener));\n    return () => {\n      Object.entries(eventMap).forEach(\n        ([type, listener]) => channel.removeListener(type, listener)\n      );\n    };\n  }, [...Object.keys(eventMap), ...deps]);\n  return useCallback(channel.emit.bind(channel), [channel]);\n}\n__name(useChannel, \"useChannel\");\nfunction useStoryContext() {\n  const { currentContext } = getHooksContextOrThrow();\n  if (currentContext == null) {\n    throw invalidHooksError();\n  }\n  return currentContext;\n}\n__name(useStoryContext, \"useStoryContext\");\nfunction useParameter(parameterKey, defaultValue) {\n  const { parameters } = useStoryContext();\n  if (parameterKey) {\n    return parameters[parameterKey] ?? defaultValue;\n  }\n  return void 0;\n}\n__name(useParameter, \"useParameter\");\nfunction useArgs() {\n  const channel = addons.getChannel();\n  const { id: storyId, args } = useStoryContext();\n  const updateArgs = useCallback(\n    (updatedArgs) => channel.emit(UPDATE_STORY_ARGS, { storyId, updatedArgs }),\n    [channel, storyId]\n  );\n  const resetArgs = useCallback(\n    (argNames) => channel.emit(RESET_STORY_ARGS, { storyId, argNames }),\n    [channel, storyId]\n  );\n  return [args, updateArgs, resetArgs];\n}\n__name(useArgs, \"useArgs\");\nfunction useGlobals() {\n  const channel = addons.getChannel();\n  const { globals } = useStoryContext();\n  const updateGlobals = useCallback(\n    (newGlobals) => channel.emit(UPDATE_GLOBALS, { globals: newGlobals }),\n    [channel]\n  );\n  return [globals, updateGlobals];\n}\n__name(useGlobals, \"useGlobals\");\n\n// src/preview-api/modules/addons/make-decorator.ts\nvar makeDecorator = /* @__PURE__ */ __name(({\n  name,\n  parameterName,\n  wrapper,\n  skipIfNoParametersOrOptions = false\n}) => {\n  const decorator = /* @__PURE__ */ __name((options) => (storyFn, context) => {\n    const parameters = context.parameters && context.parameters[parameterName];\n    if (parameters && parameters.disable) {\n      return storyFn(context);\n    }\n    if (skipIfNoParametersOrOptions && !options && !parameters) {\n      return storyFn(context);\n    }\n    return wrapper(storyFn, context, {\n      options,\n      parameters\n    });\n  }, \"decorator\");\n  return (...args) => {\n    if (typeof args[0] === \"function\") {\n      return decorator()(...args);\n    }\n    return (...innerArgs) => {\n      if (innerArgs.length > 1) {\n        if (args.length > 1) {\n          return decorator(args)(...innerArgs);\n        }\n        return decorator(...args)(...innerArgs);\n      }\n      throw new Error(\n        `Passing stories directly into ${name}() is not allowed,\n        instead use addDecorator(${name}) and pass options with the '${parameterName}' parameter`\n      );\n    };\n  };\n}, \"makeDecorator\");\n\n// src/preview-api/modules/store/StoryStore.ts\nimport { getCoreAnnotations as getCoreAnnotations2 } from \"storybook/internal/csf\";\nimport {\n  CalledExtractOnStoreError,\n  MissingStoryFromCsfFileError\n} from \"storybook/internal/preview-errors\";\nvar import_memoizerific2 = __toESM(require_memoizerific(), 1);\n\n// src/preview-api/modules/store/args.ts\nimport { once } from \"storybook/internal/client-logger\";\nvar INCOMPATIBLE = Symbol(\"incompatible\");\nvar map = /* @__PURE__ */ __name((arg, argType) => {\n  const type = argType.type;\n  if (arg === void 0 || arg === null || !type) {\n    return arg;\n  }\n  if (argType.mapping) {\n    return arg;\n  }\n  switch (type.name) {\n    case \"string\":\n      return String(arg);\n    case \"enum\":\n      return arg;\n    case \"number\":\n      return Number(arg);\n    case \"boolean\":\n      return String(arg) === \"true\";\n    case \"array\":\n      if (!type.value || !Array.isArray(arg)) {\n        return INCOMPATIBLE;\n      }\n      return arg.reduce((acc, item, index) => {\n        const mapped = map(item, { type: type.value });\n        if (mapped !== INCOMPATIBLE) {\n          acc[index] = mapped;\n        }\n        return acc;\n      }, new Array(arg.length));\n    case \"object\":\n      if (typeof arg === \"string\" || typeof arg === \"number\") {\n        return arg;\n      }\n      if (!type.value || typeof arg !== \"object\") {\n        return INCOMPATIBLE;\n      }\n      return Object.entries(arg).reduce((acc, [key, val]) => {\n        const mapped = map(val, { type: type.value[key] });\n        return mapped === INCOMPATIBLE ? acc : Object.assign(acc, { [key]: mapped });\n      }, {});\n    case \"other\": {\n      const isPrimitiveArg = typeof arg === \"string\" || typeof arg === \"number\" || typeof arg === \"boolean\";\n      if (type.value === \"ReactNode\" && isPrimitiveArg) {\n        return arg;\n      }\n      return INCOMPATIBLE;\n    }\n    default:\n      return INCOMPATIBLE;\n  }\n}, \"map\");\nvar mapArgsToTypes = /* @__PURE__ */ __name((args, argTypes) => {\n  return Object.entries(args).reduce((acc, [key, value]) => {\n    if (!argTypes[key]) {\n      return acc;\n    }\n    const mapped = map(value, argTypes[key]);\n    return mapped === INCOMPATIBLE ? acc : Object.assign(acc, { [key]: mapped });\n  }, {});\n}, \"mapArgsToTypes\");\nvar combineArgs = /* @__PURE__ */ __name((value, update) => {\n  if (Array.isArray(value) && Array.isArray(update)) {\n    return update.reduce(\n      (acc, upd, index) => {\n        acc[index] = combineArgs(value[index], update[index]);\n        return acc;\n      },\n      [...value]\n    ).filter((v) => v !== void 0);\n  }\n  if (!isPlainObject(value) || !isPlainObject(update)) {\n    return update;\n  }\n  return Object.keys({ ...value, ...update }).reduce((acc, key) => {\n    if (key in update) {\n      const combined = combineArgs(value[key], update[key]);\n      if (combined !== void 0) {\n        acc[key] = combined;\n      }\n    } else {\n      acc[key] = value[key];\n    }\n    return acc;\n  }, {});\n}, \"combineArgs\");\nvar validateOptions = /* @__PURE__ */ __name((args, argTypes) => {\n  return Object.entries(argTypes).reduce((acc, [key, { options }]) => {\n    function allowArg() {\n      if (key in args) {\n        acc[key] = args[key];\n      }\n      return acc;\n    }\n    __name(allowArg, \"allowArg\");\n    if (!options) {\n      return allowArg();\n    }\n    if (!Array.isArray(options)) {\n      once.error(dedent`\n        Invalid argType: '${key}.options' should be an array.\n\n        More info: https://storybook.js.org/docs/api/arg-types?ref=error\n      `);\n      return allowArg();\n    }\n    if (options.some((opt) => opt && [\"object\", \"function\"].includes(typeof opt))) {\n      once.error(dedent`\n        Invalid argType: '${key}.options' should only contain primitives. Use a 'mapping' for complex values.\n\n        More info: https://storybook.js.org/docs/writing-stories/args?ref=error#mapping-to-complex-arg-values\n      `);\n      return allowArg();\n    }\n    const isArray = Array.isArray(args[key]);\n    const invalidIndex = isArray && args[key].findIndex((val) => !options.includes(val));\n    const isValidArray = isArray && invalidIndex === -1;\n    if (args[key] === void 0 || options.includes(args[key]) || isValidArray) {\n      return allowArg();\n    }\n    const field = isArray ? `${key}[${invalidIndex}]` : key;\n    const supportedOptions = options.map((opt) => typeof opt === \"string\" ? `'${opt}'` : String(opt)).join(\", \");\n    once.warn(`Received illegal value for '${field}'. Supported options: ${supportedOptions}`);\n    return acc;\n  }, {});\n}, \"validateOptions\");\nvar DEEPLY_EQUAL = Symbol(\"Deeply equal\");\nvar deepDiff = /* @__PURE__ */ __name((value, update) => {\n  if (typeof value !== typeof update) {\n    return update;\n  }\n  if (isEqual(value, update)) {\n    return DEEPLY_EQUAL;\n  }\n  if (Array.isArray(value) && Array.isArray(update)) {\n    const res = update.reduce((acc, upd, index) => {\n      const diff = deepDiff(value[index], upd);\n      if (diff !== DEEPLY_EQUAL) {\n        acc[index] = diff;\n      }\n      return acc;\n    }, new Array(update.length));\n    if (update.length >= value.length) {\n      return res;\n    }\n    return res.concat(new Array(value.length - update.length).fill(void 0));\n  }\n  if (isPlainObject(value) && isPlainObject(update)) {\n    return Object.keys({ ...value, ...update }).reduce((acc, key) => {\n      const diff = deepDiff(value?.[key], update?.[key]);\n      return diff === DEEPLY_EQUAL ? acc : Object.assign(acc, { [key]: diff });\n    }, {});\n  }\n  return update;\n}, \"deepDiff\");\nvar UNTARGETED = \"UNTARGETED\";\nfunction groupArgsByTarget({\n  args,\n  argTypes\n}) {\n  const groupedArgs = {};\n  Object.entries(args).forEach(([name, value]) => {\n    const { target = UNTARGETED } = argTypes[name] || {};\n    groupedArgs[target] = groupedArgs[target] || {};\n    groupedArgs[target][name] = value;\n  });\n  return groupedArgs;\n}\n__name(groupArgsByTarget, \"groupArgsByTarget\");\n\n// src/preview-api/modules/store/ArgsStore.ts\nfunction deleteUndefined(obj) {\n  Object.keys(obj).forEach((key) => obj[key] === void 0 && delete obj[key]);\n  return obj;\n}\n__name(deleteUndefined, \"deleteUndefined\");\nvar _ArgsStore = class _ArgsStore {\n  constructor() {\n    this.initialArgsByStoryId = {};\n    this.argsByStoryId = {};\n  }\n  get(storyId) {\n    if (!(storyId in this.argsByStoryId)) {\n      throw new Error(`No args known for ${storyId} -- has it been rendered yet?`);\n    }\n    return this.argsByStoryId[storyId];\n  }\n  setInitial(story) {\n    if (!this.initialArgsByStoryId[story.id]) {\n      this.initialArgsByStoryId[story.id] = story.initialArgs;\n      this.argsByStoryId[story.id] = story.initialArgs;\n    } else if (this.initialArgsByStoryId[story.id] !== story.initialArgs) {\n      const delta = deepDiff(this.initialArgsByStoryId[story.id], this.argsByStoryId[story.id]);\n      this.initialArgsByStoryId[story.id] = story.initialArgs;\n      this.argsByStoryId[story.id] = story.initialArgs;\n      if (delta !== DEEPLY_EQUAL) {\n        this.updateFromDelta(story, delta);\n      }\n    }\n  }\n  updateFromDelta(story, delta) {\n    const validatedDelta = validateOptions(delta, story.argTypes);\n    this.argsByStoryId[story.id] = combineArgs(this.argsByStoryId[story.id], validatedDelta);\n  }\n  updateFromPersisted(story, persisted) {\n    const mappedPersisted = mapArgsToTypes(persisted, story.argTypes);\n    return this.updateFromDelta(story, mappedPersisted);\n  }\n  update(storyId, argsUpdate) {\n    if (!(storyId in this.argsByStoryId)) {\n      throw new Error(`No args known for ${storyId} -- has it been rendered yet?`);\n    }\n    this.argsByStoryId[storyId] = deleteUndefined({\n      ...this.argsByStoryId[storyId],\n      ...argsUpdate\n    });\n  }\n};\n__name(_ArgsStore, \"ArgsStore\");\nvar ArgsStore = _ArgsStore;\n\n// src/preview-api/modules/store/GlobalsStore.ts\nimport { logger as logger2 } from \"storybook/internal/client-logger\";\n\n// src/preview-api/modules/store/csf/getValuesFromArgTypes.ts\nvar getValuesFromArgTypes = /* @__PURE__ */ __name((argTypes = {}) => Object.entries(argTypes).reduce((acc, [arg, { defaultValue }]) => {\n  if (typeof defaultValue !== \"undefined\") {\n    acc[arg] = defaultValue;\n  }\n  return acc;\n}, {}), \"getValuesFromArgTypes\");\n\n// src/preview-api/modules/store/GlobalsStore.ts\nvar _GlobalsStore = class _GlobalsStore {\n  constructor({\n    globals = {},\n    globalTypes = {}\n  }) {\n    this.set({ globals, globalTypes });\n  }\n  set({ globals = {}, globalTypes = {} }) {\n    const delta = this.initialGlobals && deepDiff(this.initialGlobals, this.globals);\n    this.allowedGlobalNames = /* @__PURE__ */ new Set([...Object.keys(globals), ...Object.keys(globalTypes)]);\n    const defaultGlobals = getValuesFromArgTypes(globalTypes);\n    this.initialGlobals = { ...defaultGlobals, ...globals };\n    this.globals = this.initialGlobals;\n    if (delta && delta !== DEEPLY_EQUAL) {\n      this.updateFromPersisted(delta);\n    }\n  }\n  filterAllowedGlobals(globals) {\n    return Object.entries(globals).reduce((acc, [key, value]) => {\n      if (this.allowedGlobalNames.has(key)) {\n        acc[key] = value;\n      } else {\n        logger2.warn(\n          `Attempted to set a global (${key}) that is not defined in initial globals or globalTypes`\n        );\n      }\n      return acc;\n    }, {});\n  }\n  updateFromPersisted(persisted) {\n    const allowedUrlGlobals = this.filterAllowedGlobals(persisted);\n    this.globals = { ...this.globals, ...allowedUrlGlobals };\n  }\n  get() {\n    return this.globals;\n  }\n  update(newGlobals) {\n    this.globals = { ...this.globals, ...this.filterAllowedGlobals(newGlobals) };\n    for (const key in newGlobals) {\n      if (newGlobals[key] === void 0) {\n        this.globals[key] = this.initialGlobals[key];\n      }\n    }\n  }\n};\n__name(_GlobalsStore, \"GlobalsStore\");\nvar GlobalsStore = _GlobalsStore;\n\n// src/preview-api/modules/store/StoryIndexStore.ts\nvar import_memoizerific = __toESM(require_memoizerific(), 1);\nimport { MissingStoryAfterHmrError } from \"storybook/internal/preview-errors\";\nvar getImportPathMap = (0, import_memoizerific.default)(1)(\n  (entries) => Object.values(entries).reduce(\n    (acc, entry) => {\n      acc[entry.importPath] = acc[entry.importPath] || entry;\n      return acc;\n    },\n    {}\n  )\n);\nvar _StoryIndexStore = class _StoryIndexStore {\n  constructor({ entries } = { v: 5, entries: {} }) {\n    this.entries = entries;\n  }\n  entryFromSpecifier(specifier) {\n    const entries = Object.values(this.entries);\n    if (specifier === \"*\") {\n      return entries[0];\n    }\n    if (typeof specifier === \"string\") {\n      if (this.entries[specifier]) {\n        return this.entries[specifier];\n      }\n      return entries.find((entry) => entry.id.startsWith(specifier));\n    }\n    const { name, title } = specifier;\n    return entries.find((entry) => entry.name === name && entry.title === title);\n  }\n  storyIdToEntry(storyId) {\n    const storyEntry = this.entries[storyId];\n    if (!storyEntry) {\n      throw new MissingStoryAfterHmrError({ storyId });\n    }\n    return storyEntry;\n  }\n  importPathToEntry(importPath) {\n    return getImportPathMap(this.entries)[importPath];\n  }\n};\n__name(_StoryIndexStore, \"StoryIndexStore\");\nvar StoryIndexStore = _StoryIndexStore;\n\n// src/preview-api/modules/store/csf/normalizeInputTypes.ts\nvar normalizeType = /* @__PURE__ */ __name((type) => {\n  return typeof type === \"string\" ? { name: type } : type;\n}, \"normalizeType\");\nvar normalizeControl = /* @__PURE__ */ __name((control) => typeof control === \"string\" ? { type: control } : control, \"normalizeControl\");\nvar normalizeInputType = /* @__PURE__ */ __name((inputType, key) => {\n  const { type, control, ...rest } = inputType;\n  const normalized = {\n    name: key,\n    ...rest\n  };\n  if (type) {\n    normalized.type = normalizeType(type);\n  }\n  if (control) {\n    normalized.control = normalizeControl(control);\n  } else if (control === false) {\n    normalized.control = { disable: true };\n  }\n  return normalized;\n}, \"normalizeInputType\");\nvar normalizeInputTypes = /* @__PURE__ */ __name((inputTypes) => mapValues(inputTypes, normalizeInputType), \"normalizeInputTypes\");\n\n// src/preview-api/modules/store/csf/normalizeStory.ts\nimport { deprecate, logger as logger3 } from \"storybook/internal/client-logger\";\nimport { storyNameFromExport, toId } from \"storybook/internal/csf\";\n\n// src/preview-api/modules/store/csf/normalizeArrays.ts\nvar normalizeArrays = /* @__PURE__ */ __name((array) => {\n  if (Array.isArray(array)) {\n    return array;\n  }\n  return array ? [array] : [];\n}, \"normalizeArrays\");\n\n// src/preview-api/modules/store/csf/normalizeStory.ts\nvar deprecatedStoryAnnotation = dedent`\nCSF .story annotations deprecated; annotate story functions directly:\n- StoryFn.story.name => StoryFn.storyName\n- StoryFn.story.(parameters|decorators) => StoryFn.(parameters|decorators)\nSee https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#hoisted-csf-annotations for details and codemod.\n`;\nfunction normalizeStory(key, storyAnnotations, meta) {\n  const storyObject = storyAnnotations;\n  const userStoryFn = typeof storyAnnotations === \"function\" ? storyAnnotations : null;\n  const { story } = storyObject;\n  if (story) {\n    logger3.debug(\"deprecated story\", story);\n    deprecate(deprecatedStoryAnnotation);\n  }\n  const exportName = storyNameFromExport(key);\n  const name = typeof storyObject !== \"function\" && storyObject.name || storyObject.storyName || story?.name || exportName;\n  const decorators = [\n    ...normalizeArrays(storyObject.decorators),\n    ...normalizeArrays(story?.decorators)\n  ];\n  const parameters = { ...story?.parameters, ...storyObject.parameters };\n  const args = { ...story?.args, ...storyObject.args };\n  const argTypes = { ...story?.argTypes, ...storyObject.argTypes };\n  const loaders = [...normalizeArrays(storyObject.loaders), ...normalizeArrays(story?.loaders)];\n  const beforeEach = [\n    ...normalizeArrays(storyObject.beforeEach),\n    ...normalizeArrays(story?.beforeEach)\n  ];\n  const afterEach = [\n    ...normalizeArrays(storyObject.afterEach),\n    ...normalizeArrays(story?.afterEach)\n  ];\n  const { render, play, tags = [], globals = {} } = storyObject;\n  const id = parameters.__id || toId(meta.id, exportName);\n  return {\n    moduleExport: storyAnnotations,\n    id,\n    name,\n    tags,\n    decorators,\n    parameters,\n    args,\n    argTypes: normalizeInputTypes(argTypes),\n    loaders,\n    beforeEach,\n    afterEach,\n    globals,\n    ...render && { render },\n    ...userStoryFn && { userStoryFn },\n    ...play && { play }\n  };\n}\n__name(normalizeStory, \"normalizeStory\");\n\n// src/preview-api/modules/store/csf/processCSFFile.ts\nimport { logger as logger4 } from \"storybook/internal/client-logger\";\nimport { getStoryChildren, isExportStory, isStory, toTestId } from \"storybook/internal/csf\";\n\n// src/preview-api/modules/store/csf/normalizeComponentAnnotations.ts\nimport { sanitize } from \"storybook/internal/csf\";\nfunction normalizeComponentAnnotations(defaultExport, title = defaultExport.title, importPath) {\n  const { id, argTypes } = defaultExport;\n  return {\n    id: sanitize(id || title),\n    ...defaultExport,\n    title,\n    ...argTypes && { argTypes: normalizeInputTypes(argTypes) },\n    parameters: {\n      fileName: importPath,\n      ...defaultExport.parameters\n    }\n  };\n}\n__name(normalizeComponentAnnotations, \"normalizeComponentAnnotations\");\n\n// src/preview-api/modules/store/csf/processCSFFile.ts\nvar checkGlobals = /* @__PURE__ */ __name((parameters) => {\n  const { globals, globalTypes } = parameters;\n  if (globals || globalTypes) {\n    logger4.error(\n      \"Global args/argTypes can only be set globally\",\n      JSON.stringify({\n        globals,\n        globalTypes\n      })\n    );\n  }\n}, \"checkGlobals\");\nvar checkStorySort = /* @__PURE__ */ __name((parameters) => {\n  const { options } = parameters;\n  if (options?.storySort) {\n    logger4.error(\"The storySort option parameter can only be set globally\");\n  }\n}, \"checkStorySort\");\nvar checkDisallowedParameters = /* @__PURE__ */ __name((parameters) => {\n  if (!parameters) {\n    return;\n  }\n  checkGlobals(parameters);\n  checkStorySort(parameters);\n}, \"checkDisallowedParameters\");\nfunction processCSFFile(moduleExports, importPath, title) {\n  const { default: defaultExport, __namedExportsOrder, ...namedExports } = moduleExports;\n  const firstStory = Object.values(namedExports)[0];\n  if (isStory(firstStory)) {\n    const meta2 = normalizeComponentAnnotations(firstStory.meta.input, title, importPath);\n    checkDisallowedParameters(meta2.parameters);\n    const csfFile2 = { meta: meta2, stories: {}, moduleExports };\n    Object.keys(namedExports).forEach((key) => {\n      if (isExportStory(key, meta2)) {\n        const story = namedExports[key];\n        const storyMeta = normalizeStory(key, story.input, meta2);\n        checkDisallowedParameters(storyMeta.parameters);\n        csfFile2.stories[storyMeta.id] = storyMeta;\n        getStoryChildren(story).forEach((child) => {\n          const name = child.input.name;\n          const childId = toTestId(storyMeta.id, name);\n          child.input.parameters ??= {};\n          child.input.parameters.__id = childId;\n          csfFile2.stories[childId] = normalizeStory(name, child.input, meta2);\n        });\n      }\n    });\n    csfFile2.projectAnnotations = firstStory.meta.preview.composed;\n    return csfFile2;\n  }\n  const meta = normalizeComponentAnnotations(\n    defaultExport,\n    title,\n    importPath\n  );\n  checkDisallowedParameters(meta.parameters);\n  const csfFile = { meta, stories: {}, moduleExports };\n  Object.keys(namedExports).forEach((key) => {\n    if (isExportStory(key, meta)) {\n      const storyMeta = normalizeStory(key, namedExports[key], meta);\n      checkDisallowedParameters(storyMeta.parameters);\n      csfFile.stories[storyMeta.id] = storyMeta;\n    }\n  });\n  return csfFile;\n}\n__name(processCSFFile, \"processCSFFile\");\n\n// src/preview-api/modules/store/csf/prepareStory.ts\nimport { combineTags, includeConditionalArg } from \"storybook/internal/csf\";\nimport { NoRenderFunctionError } from \"storybook/internal/preview-errors\";\nimport { global as global3 } from \"@storybook/global\";\nimport { global as globalThis2 } from \"@storybook/global\";\n\n// src/preview-api/modules/preview-web/render/mount-utils.ts\nfunction mountDestructured(playFunction) {\n  return playFunction != null && getUsedProps(playFunction).includes(\"mount\");\n}\n__name(mountDestructured, \"mountDestructured\");\nfunction getUsedProps(fn) {\n  const match = fn.toString().match(/[^(]*\\(([^)]*)/);\n  if (!match) {\n    return [];\n  }\n  const args = splitByComma(match[1]);\n  if (!args.length) {\n    return [];\n  }\n  const first = args[0];\n  if (!(first.startsWith(\"{\") && first.endsWith(\"}\"))) {\n    return [];\n  }\n  const props = splitByComma(first.slice(1, -1).replace(/\\s/g, \"\")).map((prop) => {\n    return prop.replace(/:.*|=.*/g, \"\");\n  });\n  return props;\n}\n__name(getUsedProps, \"getUsedProps\");\nfunction splitByComma(s) {\n  const result = [];\n  const stack = [];\n  let start = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === \"{\" || s[i] === \"[\") {\n      stack.push(s[i] === \"{\" ? \"}\" : \"]\");\n    } else if (s[i] === stack[stack.length - 1]) {\n      stack.pop();\n    } else if (!stack.length && s[i] === \",\") {\n      const token = s.substring(start, i).trim();\n      if (token) {\n        result.push(token);\n      }\n      start = i + 1;\n    }\n  }\n  const lastToken = s.substring(start).trim();\n  if (lastToken) {\n    result.push(lastToken);\n  }\n  return result;\n}\n__name(splitByComma, \"splitByComma\");\n\n// src/preview-api/modules/store/decorators.ts\nfunction decorateStory(storyFn, decorator, bindWithContext) {\n  const boundStoryFunction = bindWithContext(storyFn);\n  return (context) => decorator(boundStoryFunction, context);\n}\n__name(decorateStory, \"decorateStory\");\nfunction sanitizeStoryContextUpdate({\n  componentId,\n  title,\n  kind,\n  id,\n  name,\n  story,\n  parameters,\n  initialArgs,\n  argTypes,\n  ...update\n} = {}) {\n  return update;\n}\n__name(sanitizeStoryContextUpdate, \"sanitizeStoryContextUpdate\");\nfunction defaultDecorateStory(storyFn, decorators) {\n  const contextStore = {};\n  const bindWithContext = /* @__PURE__ */ __name((decoratedStoryFn) => (update) => {\n    if (!contextStore.value) {\n      throw new Error(\"Decorated function called without init\");\n    }\n    contextStore.value = {\n      ...contextStore.value,\n      ...sanitizeStoryContextUpdate(update)\n    };\n    return decoratedStoryFn(contextStore.value);\n  }, \"bindWithContext\");\n  const decoratedWithContextStore = decorators.reduce(\n    (story, decorator) => decorateStory(story, decorator, bindWithContext),\n    storyFn\n  );\n  return (context) => {\n    contextStore.value = context;\n    return decoratedWithContextStore(context);\n  };\n}\n__name(defaultDecorateStory, \"defaultDecorateStory\");\n\n// src/preview-api/modules/store/csf/prepareStory.ts\nfunction prepareStory(storyAnnotations, componentAnnotations, projectAnnotations) {\n  const { moduleExport, id, name } = storyAnnotations || {};\n  const partialAnnotations = preparePartialAnnotations(\n    storyAnnotations,\n    componentAnnotations,\n    projectAnnotations\n  );\n  const applyLoaders = /* @__PURE__ */ __name(async (context) => {\n    const loaded = {};\n    for (const loaders of [\n      normalizeArrays(projectAnnotations.loaders),\n      normalizeArrays(componentAnnotations.loaders),\n      normalizeArrays(storyAnnotations.loaders)\n    ]) {\n      if (context.abortSignal.aborted) {\n        return loaded;\n      }\n      const loadResults = await Promise.all(loaders.map((loader) => loader(context)));\n      Object.assign(loaded, ...loadResults);\n    }\n    return loaded;\n  }, \"applyLoaders\");\n  const applyBeforeEach = /* @__PURE__ */ __name(async (context) => {\n    const cleanupCallbacks = new Array();\n    for (const beforeEach of [\n      ...normalizeArrays(projectAnnotations.beforeEach),\n      ...normalizeArrays(componentAnnotations.beforeEach),\n      ...normalizeArrays(storyAnnotations.beforeEach)\n    ]) {\n      if (context.abortSignal.aborted) {\n        return cleanupCallbacks;\n      }\n      const cleanup = await beforeEach(context);\n      if (cleanup) {\n        cleanupCallbacks.push(cleanup);\n      }\n    }\n    return cleanupCallbacks;\n  }, \"applyBeforeEach\");\n  const applyAfterEach = /* @__PURE__ */ __name(async (context) => {\n    const reversedFinalizers = [\n      ...normalizeArrays(projectAnnotations.afterEach),\n      ...normalizeArrays(componentAnnotations.afterEach),\n      ...normalizeArrays(storyAnnotations.afterEach)\n    ].reverse();\n    for (const finalizer of reversedFinalizers) {\n      if (context.abortSignal.aborted) {\n        return;\n      }\n      await finalizer(context);\n    }\n  }, \"applyAfterEach\");\n  const undecoratedStoryFn = /* @__PURE__ */ __name((context) => context.originalStoryFn(context.args, context), \"undecoratedStoryFn\");\n  const { applyDecorators = defaultDecorateStory, runStep } = projectAnnotations;\n  const decorators = [\n    ...normalizeArrays(storyAnnotations?.decorators),\n    ...normalizeArrays(componentAnnotations?.decorators),\n    ...normalizeArrays(projectAnnotations?.decorators)\n  ];\n  const render = storyAnnotations?.userStoryFn || storyAnnotations?.render || componentAnnotations.render || projectAnnotations.render;\n  const decoratedStoryFn = applyHooks(applyDecorators)(undecoratedStoryFn, decorators);\n  const unboundStoryFn = /* @__PURE__ */ __name((context) => decoratedStoryFn(context), \"unboundStoryFn\");\n  const playFunction = storyAnnotations?.play ?? componentAnnotations?.play;\n  const usesMount = mountDestructured(playFunction);\n  if (!render && !usesMount) {\n    throw new NoRenderFunctionError({ id });\n  }\n  const defaultMount = /* @__PURE__ */ __name((context) => {\n    return async () => {\n      await context.renderToCanvas();\n      return context.canvas;\n    };\n  }, \"defaultMount\");\n  const mount = storyAnnotations.mount ?? componentAnnotations.mount ?? projectAnnotations.mount ?? defaultMount;\n  const testingLibraryRender = projectAnnotations.testingLibraryRender;\n  return {\n    storyGlobals: {},\n    ...partialAnnotations,\n    moduleExport,\n    id,\n    name,\n    story: name,\n    originalStoryFn: render,\n    undecoratedStoryFn,\n    unboundStoryFn,\n    applyLoaders,\n    applyBeforeEach,\n    applyAfterEach,\n    playFunction,\n    runStep,\n    mount,\n    testingLibraryRender,\n    renderToCanvas: projectAnnotations.renderToCanvas,\n    usesMount\n  };\n}\n__name(prepareStory, \"prepareStory\");\nfunction prepareMeta(componentAnnotations, projectAnnotations, moduleExport) {\n  return {\n    ...preparePartialAnnotations(void 0, componentAnnotations, projectAnnotations),\n    moduleExport\n  };\n}\n__name(prepareMeta, \"prepareMeta\");\nfunction preparePartialAnnotations(storyAnnotations, componentAnnotations, projectAnnotations) {\n  const defaultTags = [\"dev\", \"test\"];\n  const extraTags = globalThis2.DOCS_OPTIONS?.autodocs === true ? [\"autodocs\"] : [];\n  const overrideTags = storyAnnotations?.tags?.includes(\"test-fn\") ? [\"!autodocs\"] : [];\n  const tags = combineTags(\n    ...defaultTags,\n    ...extraTags,\n    ...projectAnnotations.tags ?? [],\n    ...componentAnnotations.tags ?? [],\n    ...overrideTags,\n    ...storyAnnotations?.tags ?? []\n  );\n  const parameters = combineParameters(\n    projectAnnotations.parameters,\n    componentAnnotations.parameters,\n    storyAnnotations?.parameters\n  );\n  const { argTypesEnhancers = [], argsEnhancers = [] } = projectAnnotations;\n  const passedArgTypes = combineParameters(\n    projectAnnotations.argTypes,\n    componentAnnotations.argTypes,\n    storyAnnotations?.argTypes\n  );\n  if (storyAnnotations) {\n    const render = storyAnnotations?.userStoryFn || storyAnnotations?.render || componentAnnotations.render || projectAnnotations.render;\n    parameters.__isArgsStory = render && render.length > 0;\n  }\n  const passedArgs = {\n    ...projectAnnotations.args,\n    ...componentAnnotations.args,\n    ...storyAnnotations?.args\n  };\n  const storyGlobals = {\n    ...componentAnnotations.globals,\n    ...storyAnnotations?.globals\n  };\n  const contextForEnhancers = {\n    componentId: componentAnnotations.id,\n    title: componentAnnotations.title,\n    kind: componentAnnotations.title,\n    // Back compat\n    id: storyAnnotations?.id || componentAnnotations.id,\n    // if there's no story name, we create a fake one since enhancers expect a name\n    name: storyAnnotations?.name || \"__meta\",\n    story: storyAnnotations?.name || \"__meta\",\n    // Back compat\n    component: componentAnnotations.component,\n    subcomponents: componentAnnotations.subcomponents,\n    tags,\n    parameters,\n    initialArgs: passedArgs,\n    argTypes: passedArgTypes,\n    storyGlobals\n  };\n  contextForEnhancers.argTypes = argTypesEnhancers.reduce(\n    (accumulatedArgTypes, enhancer) => enhancer({ ...contextForEnhancers, argTypes: accumulatedArgTypes }),\n    contextForEnhancers.argTypes\n  );\n  const initialArgsBeforeEnhancers = { ...passedArgs };\n  contextForEnhancers.initialArgs = [...argsEnhancers].reduce(\n    (accumulatedArgs, enhancer) => ({\n      ...accumulatedArgs,\n      ...enhancer({\n        ...contextForEnhancers,\n        initialArgs: accumulatedArgs\n      })\n    }),\n    initialArgsBeforeEnhancers\n  );\n  const { name, story, ...withoutStoryIdentifiers } = contextForEnhancers;\n  return withoutStoryIdentifiers;\n}\n__name(preparePartialAnnotations, \"preparePartialAnnotations\");\nfunction prepareContext(context) {\n  const { args: unmappedArgs } = context;\n  let targetedContext = {\n    ...context,\n    allArgs: void 0,\n    argsByTarget: void 0\n  };\n  if (global3.FEATURES?.argTypeTargetsV7) {\n    const argsByTarget = groupArgsByTarget(context);\n    targetedContext = {\n      ...context,\n      allArgs: context.args,\n      argsByTarget,\n      args: argsByTarget[UNTARGETED] || {}\n    };\n  }\n  const mappedArgs = Object.entries(targetedContext.args).reduce((acc, [key, val]) => {\n    if (!targetedContext.argTypes[key]?.mapping) {\n      acc[key] = val;\n      return acc;\n    }\n    const mappingFn = /* @__PURE__ */ __name((originalValue) => {\n      const mapping = targetedContext.argTypes[key].mapping;\n      return mapping && originalValue in mapping ? mapping[originalValue] : originalValue;\n    }, \"mappingFn\");\n    acc[key] = Array.isArray(val) ? val.map(mappingFn) : mappingFn(val);\n    return acc;\n  }, {});\n  const includedArgs = Object.entries(mappedArgs).reduce((acc, [key, val]) => {\n    const argType = targetedContext.argTypes[key] || {};\n    if (includeConditionalArg(argType, mappedArgs, targetedContext.globals)) {\n      acc[key] = val;\n    }\n    return acc;\n  }, {});\n  return { ...targetedContext, unmappedArgs, args: includedArgs };\n}\n__name(prepareContext, \"prepareContext\");\n\n// src/preview-api/modules/store/inferArgTypes.ts\nimport { logger as logger5 } from \"storybook/internal/client-logger\";\nvar inferType = /* @__PURE__ */ __name((value, name, visited) => {\n  const type = typeof value;\n  switch (type) {\n    case \"boolean\":\n    case \"string\":\n    case \"number\":\n    case \"function\":\n    case \"symbol\":\n      return { name: type };\n    default:\n      break;\n  }\n  if (value) {\n    if (visited.has(value)) {\n      logger5.warn(dedent`\n        We've detected a cycle in arg '${name}'. Args should be JSON-serializable.\n\n        Consider using the mapping feature or fully custom args:\n        - Mapping: https://storybook.js.org/docs/writing-stories/args#mapping-to-complex-arg-values\n        - Custom args: https://storybook.js.org/docs/essentials/controls#fully-custom-args\n      `);\n      return { name: \"other\", value: \"cyclic object\" };\n    }\n    visited.add(value);\n    if (Array.isArray(value)) {\n      const childType = value.length > 0 ? inferType(value[0], name, new Set(visited)) : { name: \"other\", value: \"unknown\" };\n      return { name: \"array\", value: childType };\n    }\n    const fieldTypes = mapValues(value, (field) => inferType(field, name, new Set(visited)));\n    return { name: \"object\", value: fieldTypes };\n  }\n  return { name: \"object\", value: {} };\n}, \"inferType\");\nvar inferArgTypes = /* @__PURE__ */ __name((context) => {\n  const { id, argTypes: userArgTypes = {}, initialArgs = {} } = context;\n  const argTypes = mapValues(initialArgs, (arg, key) => ({\n    name: key,\n    type: inferType(arg, `${id}.${key}`, /* @__PURE__ */ new Set())\n  }));\n  const userArgTypesNames = mapValues(userArgTypes, (argType, key) => ({\n    name: key\n  }));\n  return combineParameters(argTypes, userArgTypesNames, userArgTypes);\n}, \"inferArgTypes\");\ninferArgTypes.secondPass = true;\n\n// src/preview-api/modules/store/inferControls.ts\nimport { logger as logger6 } from \"storybook/internal/client-logger\";\n\n// src/preview-api/modules/store/filterArgTypes.ts\nvar matches = /* @__PURE__ */ __name((name, descriptor) => Array.isArray(descriptor) ? descriptor.includes(name) : name.match(descriptor), \"matches\");\nvar filterArgTypes = /* @__PURE__ */ __name((argTypes, include, exclude) => {\n  if (!include && !exclude) {\n    return argTypes;\n  }\n  return argTypes && pickBy(argTypes, (argType, key) => {\n    const name = argType.name || key.toString();\n    return !!(!include || matches(name, include)) && (!exclude || !matches(name, exclude));\n  });\n}, \"filterArgTypes\");\n\n// src/preview-api/modules/store/inferControls.ts\nvar inferControl = /* @__PURE__ */ __name((argType, name, matchers) => {\n  const { type, options } = argType;\n  if (!type) {\n    return void 0;\n  }\n  if (matchers.color && matchers.color.test(name)) {\n    const controlType = type.name;\n    if (controlType === \"string\") {\n      return { control: { type: \"color\" } };\n    }\n    if (controlType !== \"enum\") {\n      logger6.warn(\n        `Addon controls: Control of type color only supports string, received \"${controlType}\" instead`\n      );\n    }\n  }\n  if (matchers.date && matchers.date.test(name)) {\n    return { control: { type: \"date\" } };\n  }\n  switch (type.name) {\n    case \"array\":\n      return { control: { type: \"object\" } };\n    case \"boolean\":\n      return { control: { type: \"boolean\" } };\n    case \"string\":\n      return { control: { type: \"text\" } };\n    case \"number\":\n      return { control: { type: \"number\" } };\n    case \"enum\": {\n      const { value } = type;\n      return { control: { type: value?.length <= 5 ? \"radio\" : \"select\" }, options: value };\n    }\n    case \"function\":\n    case \"symbol\":\n      return null;\n    default:\n      return { control: { type: options ? \"select\" : \"object\" } };\n  }\n}, \"inferControl\");\nvar inferControls = /* @__PURE__ */ __name((context) => {\n  const {\n    argTypes,\n    parameters: { __isArgsStory, controls: { include = null, exclude = null, matchers = {} } = {} }\n  } = context;\n  if (!__isArgsStory) {\n    return argTypes;\n  }\n  const filteredArgTypes = filterArgTypes(argTypes, include, exclude);\n  const withControls = mapValues(filteredArgTypes, (argType, name) => {\n    return argType?.type && inferControl(argType, name.toString(), matchers);\n  });\n  return combineParameters(withControls, filteredArgTypes);\n}, \"inferControls\");\ninferControls.secondPass = true;\n\n// src/preview-api/modules/store/csf/normalizeProjectAnnotations.ts\nfunction normalizeProjectAnnotations({\n  argTypes,\n  globalTypes,\n  argTypesEnhancers,\n  decorators,\n  loaders,\n  beforeEach,\n  afterEach,\n  initialGlobals,\n  ...annotations\n}) {\n  return {\n    ...argTypes && { argTypes: normalizeInputTypes(argTypes) },\n    ...globalTypes && { globalTypes: normalizeInputTypes(globalTypes) },\n    decorators: normalizeArrays(decorators),\n    loaders: normalizeArrays(loaders),\n    beforeEach: normalizeArrays(beforeEach),\n    afterEach: normalizeArrays(afterEach),\n    argTypesEnhancers: [\n      ...argTypesEnhancers || [],\n      inferArgTypes,\n      // There's an architectural decision to be made regarding embedded addons in core:\n      //\n      // Option 1: Keep embedded addons but ensure consistency by moving addon-specific code\n      // (like inferControls) to live alongside the addon code itself. This maintains the\n      // concept of core addons while improving code organization.\n      //\n      // Option 2: Fully integrate these addons into core, potentially moving UI components\n      // into the manager and treating them as core features rather than addons. This is a\n      // bigger architectural change requiring careful consideration.\n      //\n      // For now, we're keeping inferControls here as we need time to properly evaluate\n      // these options and their implications. Some features (like Angular's cleanArgsDecorator)\n      // currently rely on this behavior.\n      //\n      // TODO: Make an architectural decision on the handling of core addons\n      inferControls\n    ],\n    initialGlobals,\n    ...annotations\n  };\n}\n__name(normalizeProjectAnnotations, \"normalizeProjectAnnotations\");\n\n// src/preview-api/modules/store/csf/composeConfigs.ts\nimport { global as global4 } from \"@storybook/global\";\n\n// src/preview-api/modules/store/csf/beforeAll.ts\nvar composeBeforeAllHooks = /* @__PURE__ */ __name((hooks) => {\n  return async () => {\n    const cleanups2 = [];\n    for (const hook of hooks) {\n      const cleanup = await hook();\n      if (cleanup) {\n        cleanups2.unshift(cleanup);\n      }\n    }\n    return async () => {\n      for (const cleanup of cleanups2) {\n        await cleanup();\n      }\n    };\n  };\n}, \"composeBeforeAllHooks\");\n\n// src/preview-api/modules/store/csf/stepRunners.ts\nfunction composeStepRunners(stepRunners) {\n  return async (label, play, playContext) => {\n    const composedPlay = stepRunners.reduceRight(\n      (innerPlay, stepRunner) => async () => stepRunner(label, innerPlay, playContext),\n      async () => play(playContext)\n    );\n    await composedPlay();\n  };\n}\n__name(composeStepRunners, \"composeStepRunners\");\n\n// src/preview-api/modules/store/csf/composeConfigs.ts\nfunction getField(moduleExportList, field) {\n  return moduleExportList.map((xs) => xs.default?.[field] ?? xs[field]).filter(Boolean);\n}\n__name(getField, \"getField\");\nfunction getArrayField(moduleExportList, field, options = {}) {\n  return getField(moduleExportList, field).reduce((prev, cur) => {\n    const normalized = normalizeArrays(cur);\n    return options.reverseFileOrder ? [...normalized, ...prev] : [...prev, ...normalized];\n  }, []);\n}\n__name(getArrayField, \"getArrayField\");\nfunction getObjectField(moduleExportList, field) {\n  return Object.assign({}, ...getField(moduleExportList, field));\n}\n__name(getObjectField, \"getObjectField\");\nfunction getSingletonField(moduleExportList, field) {\n  return getField(moduleExportList, field).pop();\n}\n__name(getSingletonField, \"getSingletonField\");\nfunction composeConfigs(moduleExportList) {\n  const allArgTypeEnhancers = getArrayField(moduleExportList, \"argTypesEnhancers\");\n  const stepRunners = getField(moduleExportList, \"runStep\");\n  const beforeAllHooks = getArrayField(moduleExportList, \"beforeAll\");\n  return {\n    parameters: combineParameters(...getField(moduleExportList, \"parameters\")),\n    decorators: getArrayField(moduleExportList, \"decorators\", {\n      reverseFileOrder: !(global4.FEATURES?.legacyDecoratorFileOrder ?? false)\n    }),\n    args: getObjectField(moduleExportList, \"args\"),\n    argsEnhancers: getArrayField(moduleExportList, \"argsEnhancers\"),\n    argTypes: getObjectField(moduleExportList, \"argTypes\"),\n    argTypesEnhancers: [\n      ...allArgTypeEnhancers.filter((e) => !e.secondPass),\n      ...allArgTypeEnhancers.filter((e) => e.secondPass)\n    ],\n    initialGlobals: getObjectField(moduleExportList, \"initialGlobals\"),\n    globalTypes: getObjectField(moduleExportList, \"globalTypes\"),\n    loaders: getArrayField(moduleExportList, \"loaders\"),\n    beforeAll: composeBeforeAllHooks(beforeAllHooks),\n    beforeEach: getArrayField(moduleExportList, \"beforeEach\"),\n    afterEach: getArrayField(moduleExportList, \"afterEach\"),\n    render: getSingletonField(moduleExportList, \"render\"),\n    renderToCanvas: getSingletonField(moduleExportList, \"renderToCanvas\"),\n    applyDecorators: getSingletonField(moduleExportList, \"applyDecorators\"),\n    runStep: composeStepRunners(stepRunners),\n    tags: getArrayField(moduleExportList, \"tags\"),\n    mount: getSingletonField(moduleExportList, \"mount\"),\n    testingLibraryRender: getSingletonField(moduleExportList, \"testingLibraryRender\")\n  };\n}\n__name(composeConfigs, \"composeConfigs\");\n\n// src/preview-api/modules/store/csf/portable-stories.ts\nimport { isExportStory as isExportStory2 } from \"storybook/internal/csf\";\nimport { getCoreAnnotations } from \"storybook/internal/csf\";\nimport { MountMustBeDestructuredError } from \"storybook/internal/preview-errors\";\n\n// src/preview-api/modules/store/reporter-api.ts\nvar _ReporterAPI = class _ReporterAPI {\n  constructor() {\n    this.reports = [];\n  }\n  async addReport(report) {\n    this.reports.push(report);\n  }\n};\n__name(_ReporterAPI, \"ReporterAPI\");\nvar ReporterAPI = _ReporterAPI;\n\n// src/preview-api/modules/store/csf/csf-factory-utils.ts\nimport { isMeta, isStory as isStory2 } from \"storybook/internal/csf\";\nfunction getCsfFactoryAnnotations(story, meta, projectAnnotations) {\n  return isStory2(story) ? {\n    story: story.input,\n    meta: story.meta.input,\n    preview: story.meta.preview.composed\n  } : { story, meta: isMeta(meta) ? meta.input : meta, preview: projectAnnotations };\n}\n__name(getCsfFactoryAnnotations, \"getCsfFactoryAnnotations\");\n\n// src/preview-api/modules/store/csf/portable-stories.ts\nfunction setDefaultProjectAnnotations(_defaultProjectAnnotations) {\n  globalThis.defaultProjectAnnotations = _defaultProjectAnnotations;\n}\n__name(setDefaultProjectAnnotations, \"setDefaultProjectAnnotations\");\nvar DEFAULT_STORY_TITLE = \"ComposedStory\";\nvar DEFAULT_STORY_NAME = \"Unnamed Story\";\nfunction extractAnnotation(annotation) {\n  if (!annotation) {\n    return {};\n  }\n  return composeConfigs([annotation]);\n}\n__name(extractAnnotation, \"extractAnnotation\");\nfunction setProjectAnnotations(projectAnnotations) {\n  const annotations = Array.isArray(projectAnnotations) ? projectAnnotations : [projectAnnotations];\n  globalThis.globalProjectAnnotations = composeConfigs([\n    ...getCoreAnnotations(),\n    globalThis.defaultProjectAnnotations ?? {},\n    composeConfigs(annotations.map(extractAnnotation))\n  ]);\n  return globalThis.globalProjectAnnotations ?? {};\n}\n__name(setProjectAnnotations, \"setProjectAnnotations\");\nvar cleanups = [];\nfunction composeStory(storyAnnotations, componentAnnotations, projectAnnotations, defaultConfig, exportsName) {\n  if (storyAnnotations === void 0) {\n    throw new Error(\"Expected a story but received undefined.\");\n  }\n  componentAnnotations.title = componentAnnotations.title ?? DEFAULT_STORY_TITLE;\n  const normalizedComponentAnnotations = normalizeComponentAnnotations(componentAnnotations);\n  const storyName = exportsName || storyAnnotations.storyName || storyAnnotations.story?.name || storyAnnotations.name || DEFAULT_STORY_NAME;\n  const normalizedStory = normalizeStory(\n    storyName,\n    storyAnnotations,\n    normalizedComponentAnnotations\n  );\n  const normalizedProjectAnnotations = normalizeProjectAnnotations(\n    composeConfigs([\n      defaultConfig ?? globalThis.globalProjectAnnotations ?? {},\n      projectAnnotations ?? {}\n    ])\n  );\n  const story = prepareStory(\n    normalizedStory,\n    normalizedComponentAnnotations,\n    normalizedProjectAnnotations\n  );\n  const globalsFromGlobalTypes = getValuesFromArgTypes(normalizedProjectAnnotations.globalTypes);\n  const globals = {\n    ...globalsFromGlobalTypes,\n    ...normalizedProjectAnnotations.initialGlobals,\n    ...story.storyGlobals\n  };\n  const reporting = new ReporterAPI();\n  const initializeContext = /* @__PURE__ */ __name(() => {\n    const context = prepareContext({\n      hooks: new HooksContext(),\n      globals,\n      args: { ...story.initialArgs },\n      viewMode: \"story\",\n      reporting,\n      loaded: {},\n      abortSignal: new AbortController().signal,\n      step: /* @__PURE__ */ __name((label, play2) => story.runStep(label, play2, context), \"step\"),\n      canvasElement: null,\n      canvas: {},\n      userEvent: {},\n      globalTypes: normalizedProjectAnnotations.globalTypes,\n      ...story,\n      context: null,\n      mount: null\n    });\n    context.parameters.__isPortableStory = true;\n    context.context = context;\n    if (story.renderToCanvas) {\n      context.renderToCanvas = async () => {\n        const unmount = await story.renderToCanvas?.(\n          {\n            componentId: story.componentId,\n            title: story.title,\n            id: story.id,\n            name: story.name,\n            tags: story.tags,\n            showMain: /* @__PURE__ */ __name(() => {\n            }, \"showMain\"),\n            showError: /* @__PURE__ */ __name((error) => {\n              throw new Error(`${error.title}\n${error.description}`);\n            }, \"showError\"),\n            showException: /* @__PURE__ */ __name((error) => {\n              throw error;\n            }, \"showException\"),\n            forceRemount: true,\n            storyContext: context,\n            storyFn: /* @__PURE__ */ __name(() => story.unboundStoryFn(context), \"storyFn\"),\n            unboundStoryFn: story.unboundStoryFn\n          },\n          context.canvasElement\n        );\n        if (unmount) {\n          cleanups.push(unmount);\n        }\n      };\n    }\n    context.mount = story.mount(context);\n    return context;\n  }, \"initializeContext\");\n  let loadedContext;\n  const play = /* @__PURE__ */ __name(async (extraContext) => {\n    const context = initializeContext();\n    context.canvasElement ??= globalThis?.document?.body;\n    if (loadedContext) {\n      context.loaded = loadedContext.loaded;\n    }\n    Object.assign(context, extraContext);\n    return story.playFunction(context);\n  }, \"play\");\n  const run = /* @__PURE__ */ __name((extraContext) => {\n    const context = initializeContext();\n    Object.assign(context, extraContext);\n    return runStory(story, context);\n  }, \"run\");\n  const playFunction = story.playFunction ? play : void 0;\n  const composedStory = Object.assign(\n    /* @__PURE__ */ __name(function storyFn(extraArgs) {\n      const context = initializeContext();\n      if (loadedContext) {\n        context.loaded = loadedContext.loaded;\n      }\n      context.args = {\n        ...context.initialArgs,\n        ...extraArgs\n      };\n      return story.unboundStoryFn(context);\n    }, \"storyFn\"),\n    {\n      id: story.id,\n      storyName,\n      load: /* @__PURE__ */ __name(async () => {\n        for (const callback of [...cleanups].reverse()) {\n          await callback();\n        }\n        cleanups.length = 0;\n        const context = initializeContext();\n        context.loaded = await story.applyLoaders(context);\n        cleanups.push(...(await story.applyBeforeEach(context)).filter(Boolean));\n        loadedContext = context;\n      }, \"load\"),\n      globals,\n      args: story.initialArgs,\n      parameters: story.parameters,\n      argTypes: story.argTypes,\n      play: playFunction,\n      run,\n      reporting,\n      tags: story.tags\n    }\n  );\n  return composedStory;\n}\n__name(composeStory, \"composeStory\");\nvar defaultComposeStory = /* @__PURE__ */ __name((story, component, project, exportsName) => composeStory(story, component, project, {}, exportsName), \"defaultComposeStory\");\nfunction composeStories(storiesImport, globalConfig, composeStoryFn = defaultComposeStory) {\n  const { default: metaExport, __esModule, __namedExportsOrder, ...stories } = storiesImport;\n  let meta = metaExport;\n  const composedStories = Object.entries(stories).reduce(\n    (storiesMap, [exportsName, story]) => {\n      const { story: storyAnnotations, meta: componentAnnotations } = getCsfFactoryAnnotations(story);\n      if (!meta && componentAnnotations) {\n        meta = componentAnnotations;\n      }\n      if (!isExportStory2(exportsName, meta)) {\n        return storiesMap;\n      }\n      const result = Object.assign(storiesMap, {\n        [exportsName]: composeStoryFn(storyAnnotations, meta, globalConfig, exportsName)\n      });\n      return result;\n    },\n    {}\n  );\n  return composedStories;\n}\n__name(composeStories, \"composeStories\");\nfunction createPlaywrightTest(baseTest) {\n  return baseTest.extend({\n    mount: /* @__PURE__ */ __name(async ({ mount, page }, use) => {\n      await use(async (storyRef, ...restArgs) => {\n        if (!(\"__pw_type\" in storyRef) || \"__pw_type\" in storyRef && storyRef.__pw_type !== \"jsx\") {\n          throw new Error(dedent`\n              Portable stories in Playwright CT only work when referencing JSX elements.\n              Please use JSX format for your components such as:\n\n              instead of:\n              await mount(MyComponent, { props: { foo: 'bar' } })\n\n              do:\n              await mount(<MyComponent foo=\"bar\"/>)\n\n              More info: https://storybook.js.org/docs/api/portable-stories/portable-stories-playwright?ref=error\n            `);\n        }\n        const { props, ...storyRefWithoutProps } = storyRef;\n        await page.evaluate(async (wrappedStoryRef) => {\n          const unwrappedStoryRef = await globalThis.__pwUnwrapObject?.(wrappedStoryRef);\n          const story = \"__pw_type\" in unwrappedStoryRef ? unwrappedStoryRef.type : unwrappedStoryRef;\n          return story?.load?.();\n        }, storyRefWithoutProps);\n        const mountResult = await mount(storyRef, ...restArgs);\n        await page.evaluate(async (wrappedStoryRef) => {\n          const unwrappedStoryRef = await globalThis.__pwUnwrapObject?.(wrappedStoryRef);\n          const story = \"__pw_type\" in unwrappedStoryRef ? unwrappedStoryRef.type : unwrappedStoryRef;\n          const canvasElement = document.querySelector(\"#root\");\n          return story?.play?.({ canvasElement });\n        }, storyRefWithoutProps);\n        return mountResult;\n      });\n    }, \"mount\")\n  });\n}\n__name(createPlaywrightTest, \"createPlaywrightTest\");\nasync function runStory(story, context) {\n  for (const callback of [...cleanups].reverse()) {\n    await callback();\n  }\n  cleanups.length = 0;\n  if (!context.canvasElement) {\n    const container = document.createElement(\"div\");\n    globalThis?.document?.body?.appendChild(container);\n    context.canvasElement = container;\n    cleanups.push(() => {\n      if (globalThis?.document?.body?.contains(container)) {\n        globalThis?.document?.body?.removeChild(container);\n      }\n    });\n  }\n  context.loaded = await story.applyLoaders(context);\n  if (context.abortSignal.aborted) {\n    return;\n  }\n  cleanups.push(...(await story.applyBeforeEach(context)).filter(Boolean));\n  const playFunction = story.playFunction;\n  const isMountDestructured = story.usesMount;\n  if (!isMountDestructured) {\n    await context.mount();\n  }\n  if (context.abortSignal.aborted) {\n    return;\n  }\n  if (playFunction) {\n    if (!isMountDestructured) {\n      context.mount = async () => {\n        throw new MountMustBeDestructuredError({ playFunction: playFunction.toString() });\n      };\n    }\n    await playFunction(context);\n  }\n  let cleanUp;\n  if (isTestEnvironment()) {\n    cleanUp = pauseAnimations();\n  } else {\n    await waitForAnimations(context.abortSignal);\n  }\n  await story.applyAfterEach(context);\n  await cleanUp?.();\n}\n__name(runStory, \"runStory\");\n\n// src/preview-api/modules/store/StoryStore.ts\nvar CSF_CACHE_SIZE = 1e3;\nvar STORY_CACHE_SIZE = 1e4;\nvar _StoryStore = class _StoryStore {\n  constructor(storyIndex, importFn, projectAnnotations) {\n    this.importFn = importFn;\n    this.storyIndex = new StoryIndexStore(storyIndex);\n    this.projectAnnotations = normalizeProjectAnnotations(\n      composeConfigs([...getCoreAnnotations2(), projectAnnotations])\n    );\n    const { initialGlobals, globalTypes } = this.projectAnnotations;\n    this.args = new ArgsStore();\n    this.userGlobals = new GlobalsStore({ globals: initialGlobals, globalTypes });\n    this.hooks = {};\n    this.cleanupCallbacks = {};\n    this.processCSFFileWithCache = (0, import_memoizerific2.default)(CSF_CACHE_SIZE)(processCSFFile);\n    this.prepareMetaWithCache = (0, import_memoizerific2.default)(CSF_CACHE_SIZE)(prepareMeta);\n    this.prepareStoryWithCache = (0, import_memoizerific2.default)(STORY_CACHE_SIZE)(prepareStory);\n  }\n  setProjectAnnotations(projectAnnotations) {\n    this.projectAnnotations = normalizeProjectAnnotations(projectAnnotations);\n    const { initialGlobals, globalTypes } = projectAnnotations;\n    this.userGlobals.set({ globals: initialGlobals, globalTypes });\n  }\n  // This means that one of the CSF files has changed.\n  // If the `importFn` has changed, we will invalidate both caches.\n  // If the `storyIndex` data has changed, we may or may not invalidate the caches, depending\n  // on whether we've loaded the relevant files yet.\n  async onStoriesChanged({\n    importFn,\n    storyIndex\n  }) {\n    if (importFn) {\n      this.importFn = importFn;\n    }\n    if (storyIndex) {\n      this.storyIndex.entries = storyIndex.entries;\n    }\n    if (this.cachedCSFFiles) {\n      await this.cacheAllCSFFiles();\n    }\n  }\n  // Get an entry from the index, waiting on initialization if necessary\n  async storyIdToEntry(storyId) {\n    return this.storyIndex.storyIdToEntry(storyId);\n  }\n  // To load a single CSF file to service a story we need to look up the importPath in the index\n  async loadCSFFileByStoryId(storyId) {\n    const { importPath, title } = this.storyIndex.storyIdToEntry(storyId);\n    const moduleExports = await this.importFn(importPath);\n    return this.processCSFFileWithCache(moduleExports, importPath, title);\n  }\n  async loadAllCSFFiles() {\n    const importPaths = {};\n    Object.entries(this.storyIndex.entries).forEach(([storyId, { importPath }]) => {\n      importPaths[importPath] = storyId;\n    });\n    const list = await Promise.all(\n      Object.entries(importPaths).map(async ([importPath, storyId]) => ({\n        importPath,\n        csfFile: await this.loadCSFFileByStoryId(storyId)\n      }))\n    );\n    return list.reduce(\n      (acc, { importPath, csfFile }) => {\n        acc[importPath] = csfFile;\n        return acc;\n      },\n      {}\n    );\n  }\n  async cacheAllCSFFiles() {\n    this.cachedCSFFiles = await this.loadAllCSFFiles();\n  }\n  preparedMetaFromCSFFile({ csfFile }) {\n    const componentAnnotations = csfFile.meta;\n    return this.prepareMetaWithCache(\n      componentAnnotations,\n      this.projectAnnotations,\n      csfFile.moduleExports.default\n    );\n  }\n  // Load the CSF file for a story and prepare the story from it and the project annotations.\n  async loadStory({ storyId }) {\n    const csfFile = await this.loadCSFFileByStoryId(storyId);\n    return this.storyFromCSFFile({ storyId, csfFile });\n  }\n  // This function is synchronous for convenience -- often times if you have a CSF file already\n  // it is easier not to have to await `loadStory`.\n  storyFromCSFFile({\n    storyId,\n    csfFile\n  }) {\n    const storyAnnotations = csfFile.stories[storyId];\n    if (!storyAnnotations) {\n      throw new MissingStoryFromCsfFileError({ storyId });\n    }\n    const componentAnnotations = csfFile.meta;\n    const story = this.prepareStoryWithCache(\n      storyAnnotations,\n      componentAnnotations,\n      csfFile.projectAnnotations ?? this.projectAnnotations\n    );\n    this.args.setInitial(story);\n    this.hooks[story.id] = this.hooks[story.id] || new HooksContext();\n    return story;\n  }\n  // If we have a CSF file we can get all the stories from it synchronously\n  componentStoriesFromCSFFile({\n    csfFile\n  }) {\n    return Object.keys(this.storyIndex.entries).filter((storyId) => !!csfFile.stories[storyId]).map((storyId) => this.storyFromCSFFile({ storyId, csfFile }));\n  }\n  async loadEntry(id) {\n    const entry = await this.storyIdToEntry(id);\n    const storyImports = entry.type === \"docs\" ? entry.storiesImports : [];\n    const [entryExports, ...csfFiles] = await Promise.all([\n      this.importFn(entry.importPath),\n      ...storyImports.map((storyImportPath) => {\n        const firstStoryEntry = this.storyIndex.importPathToEntry(storyImportPath);\n        return this.loadCSFFileByStoryId(firstStoryEntry.id);\n      })\n    ]);\n    return { entryExports, csfFiles };\n  }\n  // A prepared story does not include args, globals or hooks. These are stored in the story store\n  // and updated separately to the (immutable) story.\n  getStoryContext(story, { forceInitialArgs = false } = {}) {\n    const userGlobals = this.userGlobals.get();\n    const { initialGlobals } = this.userGlobals;\n    const reporting = new ReporterAPI();\n    return prepareContext({\n      ...story,\n      args: forceInitialArgs ? story.initialArgs : this.args.get(story.id),\n      initialGlobals,\n      globalTypes: this.projectAnnotations.globalTypes,\n      userGlobals,\n      reporting,\n      globals: {\n        ...userGlobals,\n        ...story.storyGlobals\n      },\n      hooks: this.hooks[story.id]\n    });\n  }\n  addCleanupCallbacks(story, ...callbacks) {\n    this.cleanupCallbacks[story.id] = (this.cleanupCallbacks[story.id] || []).concat(callbacks);\n  }\n  async cleanupStory(story) {\n    this.hooks[story.id].clean();\n    const callbacks = this.cleanupCallbacks[story.id];\n    if (callbacks) {\n      for (const callback of [...callbacks].reverse()) {\n        await callback();\n      }\n    }\n    delete this.cleanupCallbacks[story.id];\n  }\n  extract(options = { includeDocsOnly: false }) {\n    const { cachedCSFFiles } = this;\n    console.log(\"extract: extracting stories\", cachedCSFFiles);\n    if (!cachedCSFFiles) {\n      throw new CalledExtractOnStoreError();\n    }\n    const stories = Object.entries(this.storyIndex.entries).reduce(\n      (acc, [storyId, entry]) => {\n        if (entry.type === \"docs\") {\n          return acc;\n        }\n        const csfFile = cachedCSFFiles[entry.importPath];\n        const story = this.storyFromCSFFile({ storyId, csfFile });\n        if (!options.includeDocsOnly && story.parameters.docsOnly) {\n          return acc;\n        }\n        acc[storyId] = Object.entries(story).reduce(\n          (storyAcc, [key, value]) => {\n            if (key === \"story\" && entry.subtype === \"test\") {\n              return { ...storyAcc, story: entry.parentName };\n            }\n            if (key === \"moduleExport\") {\n              return storyAcc;\n            }\n            if (typeof value === \"function\") {\n              return storyAcc;\n            }\n            if (Array.isArray(value)) {\n              return Object.assign(storyAcc, { [key]: value.slice().sort() });\n            }\n            return Object.assign(storyAcc, { [key]: value });\n          },\n          {\n            args: story.initialArgs,\n            globals: {\n              ...this.userGlobals.initialGlobals,\n              ...this.userGlobals.globals,\n              ...story.storyGlobals\n            },\n            storyId: entry.parent ? entry.parent : storyId\n          }\n        );\n        return acc;\n      },\n      {}\n    );\n    console.log(\"extract: stories\", stories);\n    return stories;\n  }\n};\n__name(_StoryStore, \"StoryStore\");\nvar StoryStore = _StoryStore;\n\n// src/preview-api/modules/store/autoTitle.ts\nimport { once as once2 } from \"storybook/internal/client-logger\";\n\n// ../node_modules/slash/index.js\nfunction slash(path) {\n  const isExtendedLengthPath = path.startsWith(\"\\\\\\\\?\\\\\");\n  if (isExtendedLengthPath) {\n    return path;\n  }\n  return path.replace(/\\\\/g, \"/\");\n}\n__name(slash, \"slash\");\n\n// src/preview-api/modules/store/autoTitle.ts\nvar sanitize2 = /* @__PURE__ */ __name((parts) => {\n  if (parts.length === 0) {\n    return parts;\n  }\n  const last = parts[parts.length - 1];\n  const lastStripped = last?.replace(/(?:[.](?:story|stories))?([.][^.]+)$/i, \"\");\n  if (parts.length === 1) {\n    return [lastStripped];\n  }\n  const nextToLast = parts[parts.length - 2];\n  if (lastStripped && nextToLast && lastStripped.toLowerCase() === nextToLast.toLowerCase()) {\n    return [...parts.slice(0, -2), lastStripped];\n  }\n  return lastStripped && (/^(story|stories)([.][^.]+)$/i.test(last) || /^index$/i.test(lastStripped)) ? parts.slice(0, -1) : [...parts.slice(0, -1), lastStripped];\n}, \"sanitize\");\nfunction pathJoin(paths) {\n  return paths.flatMap((p) => p.split(\"/\")).filter(Boolean).join(\"/\");\n}\n__name(pathJoin, \"pathJoin\");\nvar userOrAutoTitleFromSpecifier = /* @__PURE__ */ __name((fileName, entry, userTitle) => {\n  const { directory, importPathMatcher, titlePrefix = \"\" } = entry || {};\n  if (typeof fileName === \"number\") {\n    once2.warn(dedent`\n      CSF Auto-title received a numeric fileName. This typically happens when\n      webpack is mis-configured in production mode. To force webpack to produce\n      filenames, set optimization.moduleIds = \"named\" in your webpack config.\n    `);\n  }\n  const normalizedFileName = slash(String(fileName));\n  if (importPathMatcher.exec(normalizedFileName)) {\n    if (!userTitle) {\n      const suffix = normalizedFileName.replace(directory, \"\");\n      let parts = pathJoin([titlePrefix, suffix]).split(\"/\");\n      parts = sanitize2(parts);\n      return parts.join(\"/\");\n    }\n    if (!titlePrefix) {\n      return userTitle;\n    }\n    return pathJoin([titlePrefix, userTitle]);\n  }\n  return void 0;\n}, \"userOrAutoTitleFromSpecifier\");\nvar userOrAutoTitle = /* @__PURE__ */ __name((fileName, storiesEntries, userTitle) => {\n  for (let i = 0; i < storiesEntries.length; i += 1) {\n    const title = userOrAutoTitleFromSpecifier(fileName, storiesEntries[i], userTitle);\n    if (title) {\n      return title;\n    }\n  }\n  return userTitle || void 0;\n}, \"userOrAutoTitle\");\n\n// src/preview-api/modules/store/storySort.ts\nvar STORY_KIND_PATH_SEPARATOR = /\\s*\\/\\s*/;\nvar storySort = /* @__PURE__ */ __name((options = {}) => (a, b) => {\n  if (a.title === b.title && !options.includeNames) {\n    return 0;\n  }\n  const method = options.method || \"configure\";\n  let order = options.order || [];\n  const storyTitleA = a.title.trim().split(STORY_KIND_PATH_SEPARATOR);\n  const storyTitleB = b.title.trim().split(STORY_KIND_PATH_SEPARATOR);\n  if (options.includeNames) {\n    storyTitleA.push(a.name);\n    storyTitleB.push(b.name);\n  }\n  let depth = 0;\n  while (storyTitleA[depth] || storyTitleB[depth]) {\n    if (!storyTitleA[depth]) {\n      return -1;\n    }\n    if (!storyTitleB[depth]) {\n      return 1;\n    }\n    const nameA = storyTitleA[depth];\n    const nameB = storyTitleB[depth];\n    if (nameA !== nameB) {\n      let indexA = order.indexOf(nameA);\n      let indexB = order.indexOf(nameB);\n      const indexWildcard = order.indexOf(\"*\");\n      if (indexA !== -1 || indexB !== -1) {\n        if (indexA === -1) {\n          if (indexWildcard !== -1) {\n            indexA = indexWildcard;\n          } else {\n            indexA = order.length;\n          }\n        }\n        if (indexB === -1) {\n          if (indexWildcard !== -1) {\n            indexB = indexWildcard;\n          } else {\n            indexB = order.length;\n          }\n        }\n        return indexA - indexB;\n      }\n      if (method === \"configure\") {\n        return 0;\n      }\n      return nameA.localeCompare(nameB, options.locales ? options.locales : void 0, {\n        numeric: true,\n        sensitivity: \"accent\"\n      });\n    }\n    let index = order.indexOf(nameA);\n    if (index === -1) {\n      index = order.indexOf(\"*\");\n    }\n    order = index !== -1 && Array.isArray(order[index + 1]) ? order[index + 1] : [];\n    depth += 1;\n  }\n  return 0;\n}, \"storySort\");\n\n// src/preview-api/modules/store/sortStories.ts\nvar sortStoriesCommon = /* @__PURE__ */ __name((stories, storySortParameter, fileNameOrder) => {\n  if (storySortParameter) {\n    let sortFn;\n    if (typeof storySortParameter === \"function\") {\n      sortFn = storySortParameter;\n    } else {\n      sortFn = storySort(storySortParameter);\n    }\n    stories.sort(sortFn);\n  } else {\n    stories.sort(\n      (s1, s2) => fileNameOrder.indexOf(s1.importPath) - fileNameOrder.indexOf(s2.importPath)\n    );\n  }\n  return stories;\n}, \"sortStoriesCommon\");\nvar sortStoriesV7 = /* @__PURE__ */ __name((stories, storySortParameter, fileNameOrder) => {\n  try {\n    return sortStoriesCommon(stories, storySortParameter, fileNameOrder);\n  } catch (err) {\n    throw new Error(dedent`\n    Error sorting stories with sort parameter ${storySortParameter}:\n\n    > ${err.message}\n\n    Are you using a V6-style sort function in V7 mode?\n\n    More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#v7-style-story-sort\n  `);\n  }\n}, \"sortStoriesV7\");\n\n// src/preview-api/modules/preview-web/Preview.tsx\nimport { deprecate as deprecate2, logger as logger7 } from \"storybook/internal/client-logger\";\nimport {\n  ARGTYPES_INFO_REQUEST,\n  ARGTYPES_INFO_RESPONSE,\n  CONFIG_ERROR,\n  FORCE_REMOUNT,\n  FORCE_RE_RENDER as FORCE_RE_RENDER2,\n  GLOBALS_UPDATED,\n  PREVIEW_INITIALIZED,\n  RESET_STORY_ARGS as RESET_STORY_ARGS2,\n  SET_GLOBALS,\n  STORY_ARGS_UPDATED,\n  STORY_HOT_UPDATED,\n  STORY_INDEX_INVALIDATED,\n  UPDATE_GLOBALS as UPDATE_GLOBALS2,\n  UPDATE_STORY_ARGS as UPDATE_STORY_ARGS2\n} from \"storybook/internal/core-events\";\nimport {\n  CalledPreviewMethodBeforeInitializationError,\n  MissingRenderToCanvasError,\n  StoryIndexFetchError,\n  StoryStoreAccessedBeforeInitializationError\n} from \"storybook/internal/preview-errors\";\nimport { global as global5 } from \"@storybook/global\";\n\n// src/preview-api/modules/preview-web/render/StoryRender.ts\nimport {\n  PLAY_FUNCTION_THREW_EXCEPTION,\n  STORY_FINISHED,\n  STORY_RENDERED as STORY_RENDERED2,\n  STORY_RENDER_PHASE_CHANGED,\n  UNHANDLED_ERRORS_WHILE_PLAYING\n} from \"storybook/internal/core-events\";\nimport {\n  MountMustBeDestructuredError as MountMustBeDestructuredError2,\n  NoStoryMountedError\n} from \"storybook/internal/preview-errors\";\n\n// src/preview-api/modules/preview-web/render/Render.ts\nvar PREPARE_ABORTED = new Error(\"prepareAborted\");\n\n// src/preview-api/modules/preview-web/render/StoryRender.ts\nvar { AbortController: AbortController2 } = globalThis;\nfunction serializeError(error) {\n  try {\n    const { name = \"Error\", message = String(error), stack } = error;\n    return { name, message, stack };\n  } catch (e) {\n    return { name: \"Error\", message: String(error) };\n  }\n}\n__name(serializeError, \"serializeError\");\nvar _StoryRender = class _StoryRender {\n  constructor(channel, store, renderToScreen, callbacks, id, viewMode, renderOptions = { autoplay: true, forceInitialArgs: false }, story) {\n    this.channel = channel;\n    this.store = store;\n    this.renderToScreen = renderToScreen;\n    this.callbacks = callbacks;\n    this.id = id;\n    this.viewMode = viewMode;\n    this.renderOptions = renderOptions;\n    this.type = \"story\";\n    this.notYetRendered = true;\n    this.rerenderEnqueued = false;\n    this.disableKeyListeners = false;\n    this.teardownRender = /* @__PURE__ */ __name(() => {\n    }, \"teardownRender\");\n    this.torndown = false;\n    this.abortController = new AbortController2();\n    this.renderId = Date.now();\n    if (story) {\n      this.story = story;\n      this.phase = \"preparing\";\n    }\n  }\n  async runPhase(signal, phase, phaseFn) {\n    this.phase = phase;\n    this.channel.emit(STORY_RENDER_PHASE_CHANGED, {\n      newPhase: this.phase,\n      renderId: this.renderId,\n      storyId: this.id\n    });\n    if (phaseFn) {\n      await phaseFn();\n      this.checkIfAborted(signal);\n    }\n  }\n  checkIfAborted(signal) {\n    if (signal.aborted && ![\"finished\", \"aborted\", \"errored\"].includes(this.phase)) {\n      this.phase = \"aborted\";\n      this.channel.emit(STORY_RENDER_PHASE_CHANGED, {\n        newPhase: this.phase,\n        renderId: this.renderId,\n        storyId: this.id\n      });\n    }\n    return signal.aborted;\n  }\n  async prepare() {\n    await this.runPhase(this.abortController.signal, \"preparing\", async () => {\n      this.story = await this.store.loadStory({ storyId: this.id });\n    });\n    if (this.abortController.signal.aborted) {\n      await this.store.cleanupStory(this.story);\n      throw PREPARE_ABORTED;\n    }\n  }\n  // The two story \"renders\" are equal and have both loaded the same story\n  isEqual(other) {\n    return !!(this.id === other.id && this.story && this.story === other.story);\n  }\n  isPreparing() {\n    return [\"preparing\"].includes(this.phase);\n  }\n  isPending() {\n    return [\"loading\", \"beforeEach\", \"rendering\", \"playing\", \"afterEach\"].includes(\n      this.phase\n    );\n  }\n  async renderToElement(canvasElement) {\n    this.canvasElement = canvasElement;\n    return this.render({ initial: true, forceRemount: true });\n  }\n  storyContext() {\n    if (!this.story) {\n      throw new Error(`Cannot call storyContext before preparing`);\n    }\n    const { forceInitialArgs } = this.renderOptions;\n    return this.store.getStoryContext(this.story, { forceInitialArgs });\n  }\n  async render({\n    initial = false,\n    forceRemount = false\n  } = {}) {\n    const { canvasElement } = this;\n    if (!this.story) {\n      throw new Error(\"cannot render when not prepared\");\n    }\n    const story = this.story;\n    if (!canvasElement) {\n      throw new Error(\"cannot render when canvasElement is unset\");\n    }\n    const {\n      id,\n      componentId,\n      title,\n      name,\n      tags,\n      applyLoaders,\n      applyBeforeEach,\n      applyAfterEach,\n      unboundStoryFn,\n      playFunction,\n      runStep\n    } = story;\n    if (forceRemount && !initial) {\n      this.cancelRender();\n      this.abortController = new AbortController2();\n    }\n    const abortSignal = this.abortController.signal;\n    let mounted = false;\n    const isMountDestructured = story.usesMount;\n    try {\n      const context = {\n        ...this.storyContext(),\n        viewMode: this.viewMode,\n        abortSignal,\n        canvasElement,\n        loaded: {},\n        step: /* @__PURE__ */ __name((label, play) => runStep(label, play, context), \"step\"),\n        context: null,\n        canvas: {},\n        userEvent: {},\n        renderToCanvas: /* @__PURE__ */ __name(async () => {\n          const teardown = await this.renderToScreen(renderContext, canvasElement);\n          this.teardownRender = teardown || (() => {\n          });\n          mounted = true;\n        }, \"renderToCanvas\"),\n        // The story provides (set in a renderer) a mount function that is a higher order function\n        // (context) => (...args) => Canvas\n        //\n        // Before assigning it to the context, we resolve the context dependency,\n        // so that a user can just call it as await mount(...args) in their play function.\n        mount: /* @__PURE__ */ __name(async (...args) => {\n          this.callbacks.showStoryDuringRender?.();\n          let mountReturn = null;\n          await this.runPhase(abortSignal, \"rendering\", async () => {\n            mountReturn = await story.mount(context)(...args);\n          });\n          if (isMountDestructured) {\n            await this.runPhase(abortSignal, \"playing\");\n          }\n          return mountReturn;\n        }, \"mount\")\n      };\n      context.context = context;\n      const renderContext = {\n        componentId,\n        title,\n        kind: title,\n        id,\n        name,\n        story: name,\n        tags,\n        ...this.callbacks,\n        showError: /* @__PURE__ */ __name((error) => {\n          this.phase = \"errored\";\n          return this.callbacks.showError(error);\n        }, \"showError\"),\n        showException: /* @__PURE__ */ __name((error) => {\n          this.phase = \"errored\";\n          return this.callbacks.showException(error);\n        }, \"showException\"),\n        forceRemount: forceRemount || this.notYetRendered,\n        storyContext: context,\n        storyFn: /* @__PURE__ */ __name(() => unboundStoryFn(context), \"storyFn\"),\n        unboundStoryFn\n      };\n      await this.runPhase(abortSignal, \"loading\", async () => {\n        context.loaded = await applyLoaders(context);\n      });\n      if (abortSignal.aborted) {\n        return;\n      }\n      const cleanupCallbacks = await applyBeforeEach(context);\n      this.store.addCleanupCallbacks(story, ...cleanupCallbacks);\n      if (this.checkIfAborted(abortSignal)) {\n        return;\n      }\n      if (!mounted && !isMountDestructured) {\n        await context.mount();\n      }\n      this.notYetRendered = false;\n      if (abortSignal.aborted) {\n        return;\n      }\n      const ignoreUnhandledErrors = this.story.parameters?.test?.dangerouslyIgnoreUnhandledErrors === true;\n      const unhandledErrors = /* @__PURE__ */ new Set();\n      const onError = /* @__PURE__ */ __name((event) => {\n        if (event.error) {\n          unhandledErrors.add(event.error);\n        }\n      }, \"onError\");\n      const onUnhandledRejection = /* @__PURE__ */ __name((event) => {\n        if (event.reason) {\n          unhandledErrors.add(event.reason);\n        }\n      }, \"onUnhandledRejection\");\n      if (this.renderOptions.autoplay && forceRemount && playFunction && this.phase !== \"errored\") {\n        window?.addEventListener?.(\"error\", onError);\n        window?.addEventListener?.(\"unhandledrejection\", onUnhandledRejection);\n        this.disableKeyListeners = true;\n        try {\n          if (!isMountDestructured) {\n            context.mount = async () => {\n              throw new MountMustBeDestructuredError2({ playFunction: playFunction.toString() });\n            };\n            await this.runPhase(abortSignal, \"playing\", async () => playFunction(context));\n          } else {\n            await playFunction(context);\n          }\n          if (!mounted) {\n            throw new NoStoryMountedError();\n          }\n          this.checkIfAborted(abortSignal);\n          if (!ignoreUnhandledErrors && unhandledErrors.size > 0) {\n            await this.runPhase(abortSignal, \"errored\");\n          } else {\n            await this.runPhase(abortSignal, \"played\");\n          }\n        } catch (error) {\n          this.callbacks.showStoryDuringRender?.();\n          await this.runPhase(abortSignal, \"errored\", async () => {\n            this.channel.emit(PLAY_FUNCTION_THREW_EXCEPTION, serializeError(error));\n          });\n          if (this.story.parameters.throwPlayFunctionExceptions !== false) {\n            throw error;\n          }\n          console.error(error);\n        }\n        if (!ignoreUnhandledErrors && unhandledErrors.size > 0) {\n          this.channel.emit(\n            UNHANDLED_ERRORS_WHILE_PLAYING,\n            Array.from(unhandledErrors).map(serializeError)\n          );\n        }\n        this.disableKeyListeners = false;\n        window?.removeEventListener?.(\"unhandledrejection\", onUnhandledRejection);\n        window?.removeEventListener?.(\"error\", onError);\n        if (abortSignal.aborted) {\n          return;\n        }\n      }\n      await this.runPhase(abortSignal, \"completing\", async () => {\n        if (isTestEnvironment()) {\n          this.store.addCleanupCallbacks(story, pauseAnimations());\n        } else {\n          await waitForAnimations(abortSignal);\n        }\n      });\n      await this.runPhase(abortSignal, \"completed\", async () => {\n        this.channel.emit(STORY_RENDERED2, id);\n      });\n      if (this.phase !== \"errored\") {\n        await this.runPhase(abortSignal, \"afterEach\", async () => {\n          await applyAfterEach(context);\n        });\n      }\n      const hasUnhandledErrors = !ignoreUnhandledErrors && unhandledErrors.size > 0;\n      const hasSomeReportsFailed = context.reporting.reports.some(\n        (report) => report.status === \"failed\"\n      );\n      const hasStoryErrored = hasUnhandledErrors || hasSomeReportsFailed;\n      await this.runPhase(\n        abortSignal,\n        \"finished\",\n        async () => this.channel.emit(STORY_FINISHED, {\n          storyId: id,\n          status: hasStoryErrored ? \"error\" : \"success\",\n          reporters: context.reporting.reports\n        })\n      );\n    } catch (err) {\n      this.phase = \"errored\";\n      this.callbacks.showException(err);\n      await this.runPhase(\n        abortSignal,\n        \"finished\",\n        async () => this.channel.emit(STORY_FINISHED, {\n          storyId: id,\n          status: \"error\",\n          reporters: []\n        })\n      );\n    }\n    if (this.rerenderEnqueued) {\n      this.rerenderEnqueued = false;\n      this.render();\n    }\n  }\n  /**\n   * Rerender the story. If the story is currently pending (loading/rendering), the rerender will be\n   * enqueued, and will be executed after the current render is completed. Rerendering while playing\n   * will not be enqueued, and will be executed immediately, to support rendering args changes while\n   * playing.\n   */\n  async rerender() {\n    if (this.isPending() && this.phase !== \"playing\") {\n      this.rerenderEnqueued = true;\n    } else {\n      return this.render();\n    }\n  }\n  async remount() {\n    await this.teardown();\n    return this.render({ forceRemount: true });\n  }\n  // If the story is torn down (either a new story is rendered or the docs page removes it)\n  // we need to consider the fact that the initial render may not be finished\n  // (possibly the loaders or the play function are still running). We use the controller\n  // as a method to abort them, ASAP, but this is not foolproof as we cannot control what\n  // happens inside the user's code.\n  cancelRender() {\n    this.abortController.abort();\n  }\n  cancelPlayFunction() {\n    if (this.phase === \"playing\") {\n      this.abortController.abort();\n      this.runPhase(this.abortController.signal, \"aborted\");\n    }\n  }\n  async teardown() {\n    this.torndown = true;\n    this.cancelRender();\n    if (this.story) {\n      await this.store.cleanupStory(this.story);\n    }\n    for (let i = 0; i < 3; i += 1) {\n      if (!this.isPending()) {\n        await this.teardownRender();\n        return;\n      }\n      await new Promise((resolve) => setTimeout(resolve, 0));\n    }\n    window?.location?.reload?.();\n    await new Promise(() => {\n    });\n  }\n};\n__name(_StoryRender, \"StoryRender\");\nvar StoryRender = _StoryRender;\n\n// src/preview-api/modules/preview-web/Preview.tsx\nvar { fetch } = global5;\nvar STORY_INDEX_PATH = \"./index.json\";\nvar _Preview = class _Preview {\n  constructor(importFn, getProjectAnnotations, channel = addons.getChannel(), shouldInitialize = true) {\n    this.importFn = importFn;\n    this.getProjectAnnotations = getProjectAnnotations;\n    this.channel = channel;\n    this.storyRenders = [];\n    this.storeInitializationPromise = new Promise((resolve, reject) => {\n      this.resolveStoreInitializationPromise = resolve;\n      this.rejectStoreInitializationPromise = reject;\n    });\n    if (shouldInitialize) {\n      this.initialize();\n    }\n  }\n  // Create a proxy object for `__STORYBOOK_STORY_STORE__` and `__STORYBOOK_PREVIEW__.storyStore`\n  // That proxies through to the store once ready, and errors beforehand. This means we can set\n  // `__STORYBOOK_STORY_STORE__ = __STORYBOOK_PREVIEW__.storyStore` without having to wait, and\n  // similarly integrators can access the `storyStore` on the preview at any time, although\n  // it is considered deprecated and we will no longer allow access in 9.0\n  get storyStore() {\n    return new Proxy(\n      {},\n      {\n        get: /* @__PURE__ */ __name((_, method) => {\n          if (this.storyStoreValue) {\n            deprecate2(\"Accessing the Story Store is deprecated and will be removed in 9.0\");\n            return this.storyStoreValue[method];\n          }\n          throw new StoryStoreAccessedBeforeInitializationError();\n        }, \"get\")\n      }\n    );\n  }\n  // INITIALIZATION\n  async initialize() {\n    this.setupListeners();\n    try {\n      const projectAnnotations = await this.getProjectAnnotationsOrRenderError();\n      await this.runBeforeAllHook(projectAnnotations);\n      await this.initializeWithProjectAnnotations(projectAnnotations);\n      const userAgent = globalThis?.navigator?.userAgent;\n      await this.channel.emit(PREVIEW_INITIALIZED, { userAgent });\n    } catch (err) {\n      this.rejectStoreInitializationPromise(err);\n    }\n  }\n  ready() {\n    return this.storeInitializationPromise;\n  }\n  setupListeners() {\n    this.channel.on(STORY_INDEX_INVALIDATED, this.onStoryIndexChanged.bind(this));\n    this.channel.on(UPDATE_GLOBALS2, this.onUpdateGlobals.bind(this));\n    this.channel.on(UPDATE_STORY_ARGS2, this.onUpdateArgs.bind(this));\n    this.channel.on(ARGTYPES_INFO_REQUEST, this.onRequestArgTypesInfo.bind(this));\n    this.channel.on(RESET_STORY_ARGS2, this.onResetArgs.bind(this));\n    this.channel.on(FORCE_RE_RENDER2, this.onForceReRender.bind(this));\n    this.channel.on(FORCE_REMOUNT, this.onForceRemount.bind(this));\n    this.channel.on(STORY_HOT_UPDATED, this.onStoryHotUpdated.bind(this));\n  }\n  async getProjectAnnotationsOrRenderError() {\n    try {\n      const projectAnnotations = await this.getProjectAnnotations();\n      this.renderToCanvas = projectAnnotations.renderToCanvas;\n      if (!this.renderToCanvas) {\n        throw new MissingRenderToCanvasError();\n      }\n      return projectAnnotations;\n    } catch (err) {\n      this.renderPreviewEntryError(\"Error reading preview.js:\", err);\n      throw err;\n    }\n  }\n  // If initialization gets as far as project annotations, this function runs.\n  async initializeWithProjectAnnotations(projectAnnotations) {\n    this.projectAnnotationsBeforeInitialization = projectAnnotations;\n    try {\n      const storyIndex = await this.getStoryIndexFromServer();\n      return this.initializeWithStoryIndex(storyIndex);\n    } catch (err) {\n      this.renderPreviewEntryError(\"Error loading story index:\", err);\n      throw err;\n    }\n  }\n  async runBeforeAllHook(projectAnnotations) {\n    try {\n      await this.beforeAllCleanup?.();\n      this.beforeAllCleanup = await projectAnnotations.beforeAll?.();\n    } catch (err) {\n      this.renderPreviewEntryError(\"Error in beforeAll hook:\", err);\n      throw err;\n    }\n  }\n  async getStoryIndexFromServer() {\n    const result = await fetch(STORY_INDEX_PATH);\n    if (result.status === 200) {\n      return result.json();\n    }\n    throw new StoryIndexFetchError({ text: await result.text() });\n  }\n  // If initialization gets as far as the story index, this function runs.\n  initializeWithStoryIndex(storyIndex) {\n    if (!this.projectAnnotationsBeforeInitialization) {\n      throw new Error(\"Cannot call initializeWithStoryIndex until project annotations resolve\");\n    }\n    this.storyStoreValue = new StoryStore(\n      storyIndex,\n      this.importFn,\n      this.projectAnnotationsBeforeInitialization\n    );\n    delete this.projectAnnotationsBeforeInitialization;\n    this.setInitialGlobals();\n    this.resolveStoreInitializationPromise();\n  }\n  async setInitialGlobals() {\n    this.emitGlobals();\n  }\n  emitGlobals() {\n    if (!this.storyStoreValue) {\n      throw new CalledPreviewMethodBeforeInitializationError({ methodName: \"emitGlobals\" });\n    }\n    const payload = {\n      globals: this.storyStoreValue.userGlobals.get() || {},\n      globalTypes: this.storyStoreValue.projectAnnotations.globalTypes || {}\n    };\n    this.channel.emit(SET_GLOBALS, payload);\n  }\n  // EVENT HANDLERS\n  // This happens when a config file gets reloaded\n  async onGetProjectAnnotationsChanged({\n    getProjectAnnotations\n  }) {\n    delete this.previewEntryError;\n    this.getProjectAnnotations = getProjectAnnotations;\n    const projectAnnotations = await this.getProjectAnnotationsOrRenderError();\n    await this.runBeforeAllHook(projectAnnotations);\n    if (!this.storyStoreValue) {\n      await this.initializeWithProjectAnnotations(projectAnnotations);\n      return;\n    }\n    this.storyStoreValue.setProjectAnnotations(projectAnnotations);\n    this.emitGlobals();\n  }\n  async onStoryIndexChanged() {\n    delete this.previewEntryError;\n    if (!this.storyStoreValue && !this.projectAnnotationsBeforeInitialization) {\n      return;\n    }\n    try {\n      const storyIndex = await this.getStoryIndexFromServer();\n      if (this.projectAnnotationsBeforeInitialization) {\n        this.initializeWithStoryIndex(storyIndex);\n        return;\n      }\n      await this.onStoriesChanged({ storyIndex });\n    } catch (err) {\n      this.renderPreviewEntryError(\"Error loading story index:\", err);\n      throw err;\n    }\n  }\n  // This happens when a glob gets HMR-ed\n  async onStoriesChanged({\n    importFn,\n    storyIndex\n  }) {\n    if (!this.storyStoreValue) {\n      throw new CalledPreviewMethodBeforeInitializationError({ methodName: \"onStoriesChanged\" });\n    }\n    await this.storyStoreValue.onStoriesChanged({ importFn, storyIndex });\n  }\n  async onUpdateGlobals({\n    globals: updatedGlobals,\n    currentStory\n  }) {\n    if (!this.storyStoreValue) {\n      await this.storeInitializationPromise;\n    }\n    if (!this.storyStoreValue) {\n      throw new CalledPreviewMethodBeforeInitializationError({ methodName: \"onUpdateGlobals\" });\n    }\n    this.storyStoreValue.userGlobals.update(updatedGlobals);\n    if (currentStory) {\n      const { initialGlobals, storyGlobals, userGlobals, globals } = this.storyStoreValue.getStoryContext(currentStory);\n      this.channel.emit(GLOBALS_UPDATED, {\n        initialGlobals,\n        userGlobals,\n        storyGlobals,\n        globals\n      });\n    } else {\n      const { initialGlobals, globals } = this.storyStoreValue.userGlobals;\n      this.channel.emit(GLOBALS_UPDATED, {\n        initialGlobals,\n        userGlobals: globals,\n        storyGlobals: {},\n        globals\n      });\n    }\n    await Promise.all(this.storyRenders.map((r) => r.rerender()));\n  }\n  async onUpdateArgs({ storyId, updatedArgs }) {\n    if (!this.storyStoreValue) {\n      throw new CalledPreviewMethodBeforeInitializationError({ methodName: \"onUpdateArgs\" });\n    }\n    this.storyStoreValue.args.update(storyId, updatedArgs);\n    await Promise.all(\n      this.storyRenders.filter((r) => r.id === storyId && !r.renderOptions.forceInitialArgs).map(\n        (r) => (\n          // We only run the play function, with in a force remount.\n          // But when mount is destructured, the rendering happens inside of the play function.\n          r.story && r.story.usesMount ? r.remount() : r.rerender()\n        )\n      )\n    );\n    this.channel.emit(STORY_ARGS_UPDATED, {\n      storyId,\n      args: this.storyStoreValue.args.get(storyId)\n    });\n  }\n  async onRequestArgTypesInfo({ id, payload }) {\n    try {\n      await this.storeInitializationPromise;\n      const story = await this.storyStoreValue?.loadStory(payload);\n      this.channel.emit(ARGTYPES_INFO_RESPONSE, {\n        id,\n        success: true,\n        payload: { argTypes: story?.argTypes || {} },\n        error: null\n      });\n    } catch (e) {\n      this.channel.emit(ARGTYPES_INFO_RESPONSE, {\n        id,\n        success: false,\n        error: e?.message\n      });\n    }\n  }\n  async onResetArgs({ storyId, argNames }) {\n    if (!this.storyStoreValue) {\n      throw new CalledPreviewMethodBeforeInitializationError({ methodName: \"onResetArgs\" });\n    }\n    const render = this.storyRenders.find((r) => r.id === storyId);\n    const story = render?.story || await this.storyStoreValue.loadStory({ storyId });\n    const argNamesToReset = argNames || [\n      .../* @__PURE__ */ new Set([\n        ...Object.keys(story.initialArgs),\n        ...Object.keys(this.storyStoreValue.args.get(storyId))\n      ])\n    ];\n    const updatedArgs = argNamesToReset.reduce((acc, argName) => {\n      acc[argName] = story.initialArgs[argName];\n      return acc;\n    }, {});\n    await this.onUpdateArgs({ storyId, updatedArgs });\n  }\n  // ForceReRender does not include a story id, so we simply must\n  // re-render all stories in case they are relevant\n  async onForceReRender() {\n    await Promise.all(this.storyRenders.map((r) => r.rerender()));\n  }\n  async onForceRemount({ storyId }) {\n    await Promise.all(this.storyRenders.filter((r) => r.id === storyId).map((r) => r.remount()));\n  }\n  async onStoryHotUpdated() {\n    await Promise.all(this.storyRenders.map((r) => r.cancelPlayFunction()));\n  }\n  // Used by docs to render a story to a given element\n  // Note this short-circuits the `prepare()` phase of the StoryRender,\n  // main to be consistent with the previous behaviour. In the future,\n  // we will change it to go ahead and load the story, which will end up being\n  // \"instant\", although async.\n  renderStoryToElement(story, element, callbacks, options) {\n    if (!this.renderToCanvas || !this.storyStoreValue) {\n      throw new CalledPreviewMethodBeforeInitializationError({\n        methodName: \"renderStoryToElement\"\n      });\n    }\n    const render = new StoryRender(\n      this.channel,\n      this.storyStoreValue,\n      this.renderToCanvas,\n      callbacks,\n      story.id,\n      \"docs\",\n      options,\n      story\n    );\n    render.renderToElement(element);\n    this.storyRenders.push(render);\n    return async () => {\n      await this.teardownRender(render);\n    };\n  }\n  async teardownRender(render, { viewModeChanged } = {}) {\n    this.storyRenders = this.storyRenders.filter((r) => r !== render);\n    await render?.teardown?.({ viewModeChanged });\n  }\n  // API\n  async loadStory({ storyId }) {\n    if (!this.storyStoreValue) {\n      throw new CalledPreviewMethodBeforeInitializationError({ methodName: \"loadStory\" });\n    }\n    return this.storyStoreValue.loadStory({ storyId });\n  }\n  getStoryContext(story, { forceInitialArgs = false } = {}) {\n    if (!this.storyStoreValue) {\n      throw new CalledPreviewMethodBeforeInitializationError({ methodName: \"getStoryContext\" });\n    }\n    return this.storyStoreValue.getStoryContext(story, { forceInitialArgs });\n  }\n  async extract(options) {\n    if (!this.storyStoreValue) {\n      throw new CalledPreviewMethodBeforeInitializationError({ methodName: \"extract\" });\n    }\n    if (this.previewEntryError) {\n      throw this.previewEntryError;\n    }\n    await this.storyStoreValue.cacheAllCSFFiles();\n    return this.storyStoreValue.extract(options);\n  }\n  // UTILITIES\n  renderPreviewEntryError(reason, err) {\n    this.previewEntryError = err;\n    logger7.error(reason);\n    logger7.error(err);\n    this.channel.emit(CONFIG_ERROR, err);\n  }\n};\n__name(_Preview, \"Preview\");\nvar Preview = _Preview;\n\n// src/preview-api/modules/preview-web/PreviewWeb.tsx\nimport { global as global8 } from \"@storybook/global\";\n\n// src/preview-api/modules/preview-web/PreviewWithSelection.tsx\nimport { logger as logger8 } from \"storybook/internal/client-logger\";\nimport {\n  CURRENT_STORY_WAS_SET,\n  DOCS_PREPARED,\n  GLOBALS_UPDATED as GLOBALS_UPDATED2,\n  PRELOAD_ENTRIES,\n  PREVIEW_KEYDOWN,\n  SET_CURRENT_STORY,\n  STORY_CHANGED,\n  STORY_ERRORED,\n  STORY_MISSING,\n  STORY_PREPARED,\n  STORY_RENDER_PHASE_CHANGED as STORY_RENDER_PHASE_CHANGED2,\n  STORY_SPECIFIED,\n  STORY_THREW_EXCEPTION,\n  STORY_UNCHANGED,\n  UPDATE_QUERY_PARAMS\n} from \"storybook/internal/core-events\";\nimport {\n  CalledPreviewMethodBeforeInitializationError as CalledPreviewMethodBeforeInitializationError2,\n  EmptyIndexError,\n  MdxFileWithNoCsfReferencesError,\n  NoStoryMatchError\n} from \"storybook/internal/preview-errors\";\n\n// src/preview-api/modules/preview-web/render/CsfDocsRender.ts\nimport { DOCS_RENDERED } from \"storybook/internal/core-events\";\n\n// src/preview-api/modules/preview-web/docs-context/DocsContext.ts\nimport { isStory as isStory3 } from \"storybook/internal/csf\";\nvar _DocsContext = class _DocsContext {\n  constructor(channel, store, renderStoryToElement, csfFiles) {\n    this.channel = channel;\n    this.store = store;\n    this.renderStoryToElement = renderStoryToElement;\n    this.storyIdByName = /* @__PURE__ */ __name((storyName) => {\n      const storyId = this.nameToStoryId.get(storyName);\n      if (storyId) {\n        return storyId;\n      }\n      throw new Error(`No story found with that name: ${storyName}`);\n    }, \"storyIdByName\");\n    this.componentStories = /* @__PURE__ */ __name(() => {\n      return this.componentStoriesValue;\n    }, \"componentStories\");\n    this.componentStoriesFromCSFFile = /* @__PURE__ */ __name((csfFile) => {\n      return this.store.componentStoriesFromCSFFile({ csfFile });\n    }, \"componentStoriesFromCSFFile\");\n    this.storyById = /* @__PURE__ */ __name((storyId) => {\n      if (!storyId) {\n        if (!this.primaryStory) {\n          throw new Error(\n            `No primary story defined for docs entry. Did you forget to use \\`<Meta>\\`?`\n          );\n        }\n        return this.primaryStory;\n      }\n      const csfFile = this.storyIdToCSFFile.get(storyId);\n      if (!csfFile) {\n        throw new Error(`Called \\`storyById\\` for story that was never loaded: ${storyId}`);\n      }\n      return this.store.storyFromCSFFile({ storyId, csfFile });\n    }, \"storyById\");\n    this.getStoryContext = /* @__PURE__ */ __name((story) => {\n      return {\n        ...this.store.getStoryContext(story),\n        loaded: {},\n        viewMode: \"docs\"\n      };\n    }, \"getStoryContext\");\n    this.loadStory = /* @__PURE__ */ __name((id) => {\n      return this.store.loadStory({ storyId: id });\n    }, \"loadStory\");\n    this.componentStoriesValue = [];\n    this.storyIdToCSFFile = /* @__PURE__ */ new Map();\n    this.exportToStory = /* @__PURE__ */ new Map();\n    this.exportsToCSFFile = /* @__PURE__ */ new Map();\n    this.nameToStoryId = /* @__PURE__ */ new Map();\n    this.attachedCSFFiles = /* @__PURE__ */ new Set();\n    csfFiles.forEach((csfFile, index) => {\n      this.referenceCSFFile(csfFile);\n    });\n  }\n  // This docs entry references this CSF file and can synchronously load the stories, as well\n  // as reference them by module export. If the CSF is part of the \"component\" stories, they\n  // can also be referenced by name and are in the componentStories list.\n  referenceCSFFile(csfFile) {\n    this.exportsToCSFFile.set(csfFile.moduleExports, csfFile);\n    this.exportsToCSFFile.set(csfFile.moduleExports.default, csfFile);\n    const stories = this.store.componentStoriesFromCSFFile({ csfFile });\n    stories.forEach((story) => {\n      const annotation = csfFile.stories[story.id];\n      this.storyIdToCSFFile.set(annotation.id, csfFile);\n      this.exportToStory.set(annotation.moduleExport, story);\n    });\n  }\n  attachCSFFile(csfFile) {\n    if (!this.exportsToCSFFile.has(csfFile.moduleExports)) {\n      throw new Error(\"Cannot attach a CSF file that has not been referenced\");\n    }\n    if (this.attachedCSFFiles.has(csfFile)) {\n      return;\n    }\n    this.attachedCSFFiles.add(csfFile);\n    const stories = this.store.componentStoriesFromCSFFile({ csfFile });\n    stories.forEach((story) => {\n      this.nameToStoryId.set(story.name, story.id);\n      this.componentStoriesValue.push(story);\n      if (!this.primaryStory) {\n        this.primaryStory = story;\n      }\n    });\n  }\n  referenceMeta(metaExports, attach) {\n    const resolved = this.resolveModuleExport(metaExports);\n    if (resolved.type !== \"meta\") {\n      throw new Error(\n        \"<Meta of={} /> must reference a CSF file module export or meta export. Did you mistakenly reference your component instead of your CSF file?\"\n      );\n    }\n    if (attach) {\n      this.attachCSFFile(resolved.csfFile);\n    }\n  }\n  get projectAnnotations() {\n    const { projectAnnotations } = this.store;\n    if (!projectAnnotations) {\n      throw new Error(\"Can't get projectAnnotations from DocsContext before they are initialized\");\n    }\n    return projectAnnotations;\n  }\n  resolveAttachedModuleExportType(moduleExportType) {\n    if (moduleExportType === \"story\") {\n      if (!this.primaryStory) {\n        throw new Error(\n          `No primary story attached to this docs file, did you forget to use <Meta of={} />?`\n        );\n      }\n      return { type: \"story\", story: this.primaryStory };\n    }\n    if (this.attachedCSFFiles.size === 0) {\n      throw new Error(\n        `No CSF file attached to this docs file, did you forget to use <Meta of={} />?`\n      );\n    }\n    const firstAttachedCSFFile = Array.from(this.attachedCSFFiles)[0];\n    if (moduleExportType === \"meta\") {\n      return { type: \"meta\", csfFile: firstAttachedCSFFile };\n    }\n    const { component } = firstAttachedCSFFile.meta;\n    if (!component) {\n      throw new Error(\n        `Attached CSF file does not defined a component, did you forget to export one?`\n      );\n    }\n    return { type: \"component\", component };\n  }\n  resolveModuleExport(moduleExportOrType) {\n    const csfFile = this.exportsToCSFFile.get(moduleExportOrType);\n    if (csfFile) {\n      return { type: \"meta\", csfFile };\n    }\n    const story = this.exportToStory.get(\n      isStory3(moduleExportOrType) ? moduleExportOrType.input : moduleExportOrType\n    );\n    if (story) {\n      return { type: \"story\", story };\n    }\n    return { type: \"component\", component: moduleExportOrType };\n  }\n  resolveOf(moduleExportOrType, validTypes = []) {\n    let resolved;\n    if ([\"component\", \"meta\", \"story\"].includes(moduleExportOrType)) {\n      const type = moduleExportOrType;\n      resolved = this.resolveAttachedModuleExportType(type);\n    } else {\n      resolved = this.resolveModuleExport(moduleExportOrType);\n    }\n    if (validTypes.length && !validTypes.includes(resolved.type)) {\n      const prettyType = resolved.type === \"component\" ? \"component or unknown\" : resolved.type;\n      throw new Error(dedent`Invalid value passed to the 'of' prop. The value was resolved to a '${prettyType}' type but the only types for this block are: ${validTypes.join(\n        \", \"\n      )}.\n        - Did you pass a component to the 'of' prop when the block only supports a story or a meta?\n        - ... or vice versa?\n        - Did you pass a story, CSF file or meta to the 'of' prop that is not indexed, ie. is not targeted by the 'stories' globs in the main configuration?`);\n    }\n    switch (resolved.type) {\n      case \"component\": {\n        return {\n          ...resolved,\n          projectAnnotations: this.projectAnnotations\n        };\n      }\n      case \"meta\": {\n        return {\n          ...resolved,\n          preparedMeta: this.store.preparedMetaFromCSFFile({ csfFile: resolved.csfFile })\n        };\n      }\n      case \"story\":\n      default: {\n        return resolved;\n      }\n    }\n  }\n};\n__name(_DocsContext, \"DocsContext\");\nvar DocsContext = _DocsContext;\n\n// src/preview-api/modules/preview-web/render/CsfDocsRender.ts\nvar _CsfDocsRender = class _CsfDocsRender {\n  constructor(channel, store, entry, callbacks) {\n    this.channel = channel;\n    this.store = store;\n    this.entry = entry;\n    this.callbacks = callbacks;\n    this.type = \"docs\";\n    this.subtype = \"csf\";\n    this.torndown = false;\n    this.disableKeyListeners = false;\n    this.preparing = false;\n    this.id = entry.id;\n    this.renderId = Date.now();\n  }\n  isPreparing() {\n    return this.preparing;\n  }\n  async prepare() {\n    this.preparing = true;\n    const { entryExports, csfFiles = [] } = await this.store.loadEntry(this.id);\n    if (this.torndown) {\n      throw PREPARE_ABORTED;\n    }\n    const { importPath, title } = this.entry;\n    const primaryCsfFile = this.store.processCSFFileWithCache(\n      entryExports,\n      importPath,\n      title\n    );\n    const primaryStoryId = Object.keys(primaryCsfFile.stories)[0];\n    this.story = this.store.storyFromCSFFile({ storyId: primaryStoryId, csfFile: primaryCsfFile });\n    this.csfFiles = [primaryCsfFile, ...csfFiles];\n    this.preparing = false;\n  }\n  isEqual(other) {\n    return !!(this.id === other.id && this.story && this.story === other.story);\n  }\n  docsContext(renderStoryToElement) {\n    if (!this.csfFiles) {\n      throw new Error(\"Cannot render docs before preparing\");\n    }\n    const docsContext = new DocsContext(\n      this.channel,\n      this.store,\n      renderStoryToElement,\n      this.csfFiles\n    );\n    this.csfFiles.forEach((csfFile) => docsContext.attachCSFFile(csfFile));\n    return docsContext;\n  }\n  async renderToElement(canvasElement, renderStoryToElement) {\n    if (!this.story || !this.csfFiles) {\n      throw new Error(\"Cannot render docs before preparing\");\n    }\n    const docsContext = this.docsContext(renderStoryToElement);\n    const { docs: docsParameter } = this.story.parameters || {};\n    if (!docsParameter) {\n      throw new Error(\n        `Cannot render a story in viewMode=docs if \\`@storybook/addon-docs\\` is not installed`\n      );\n    }\n    const renderer = await docsParameter.renderer();\n    const { render } = renderer;\n    const renderDocs = /* @__PURE__ */ __name(async () => {\n      try {\n        await render(docsContext, docsParameter, canvasElement);\n        this.channel.emit(DOCS_RENDERED, this.id);\n      } catch (err) {\n        this.callbacks.showException(err);\n      }\n    }, \"renderDocs\");\n    this.rerender = async () => renderDocs();\n    this.teardownRender = async ({ viewModeChanged }) => {\n      if (!viewModeChanged || !canvasElement) {\n        return;\n      }\n      renderer.unmount(canvasElement);\n    };\n    return renderDocs();\n  }\n  async teardown({ viewModeChanged } = {}) {\n    this.teardownRender?.({ viewModeChanged });\n    this.torndown = true;\n  }\n};\n__name(_CsfDocsRender, \"CsfDocsRender\");\nvar CsfDocsRender = _CsfDocsRender;\n\n// src/preview-api/modules/preview-web/render/MdxDocsRender.ts\nimport { DOCS_RENDERED as DOCS_RENDERED2 } from \"storybook/internal/core-events\";\nvar _MdxDocsRender = class _MdxDocsRender {\n  constructor(channel, store, entry, callbacks) {\n    this.channel = channel;\n    this.store = store;\n    this.entry = entry;\n    this.callbacks = callbacks;\n    this.type = \"docs\";\n    this.subtype = \"mdx\";\n    this.torndown = false;\n    this.disableKeyListeners = false;\n    this.preparing = false;\n    this.id = entry.id;\n    this.renderId = Date.now();\n  }\n  isPreparing() {\n    return this.preparing;\n  }\n  async prepare() {\n    this.preparing = true;\n    const { entryExports, csfFiles = [] } = await this.store.loadEntry(this.id);\n    if (this.torndown) {\n      throw PREPARE_ABORTED;\n    }\n    this.csfFiles = csfFiles;\n    this.exports = entryExports;\n    this.preparing = false;\n  }\n  isEqual(other) {\n    return !!(this.id === other.id && this.exports && this.exports === other.exports);\n  }\n  docsContext(renderStoryToElement) {\n    if (!this.csfFiles) {\n      throw new Error(\"Cannot render docs before preparing\");\n    }\n    return new DocsContext(\n      this.channel,\n      this.store,\n      renderStoryToElement,\n      this.csfFiles\n    );\n  }\n  async renderToElement(canvasElement, renderStoryToElement) {\n    if (!this.exports || !this.csfFiles || !this.store.projectAnnotations) {\n      throw new Error(\"Cannot render docs before preparing\");\n    }\n    const docsContext = this.docsContext(renderStoryToElement);\n    const { docs } = this.store.projectAnnotations.parameters ?? {};\n    if (!docs) {\n      throw new Error(\n        `Cannot render a story in viewMode=docs if \\`@storybook/addon-docs\\` is not installed`\n      );\n    }\n    const docsParameter = { ...docs, page: this.exports.default };\n    const renderer = await docs.renderer();\n    const { render } = renderer;\n    const renderDocs = /* @__PURE__ */ __name(async () => {\n      try {\n        await render(docsContext, docsParameter, canvasElement);\n        this.channel.emit(DOCS_RENDERED2, this.id);\n      } catch (err) {\n        this.callbacks.showException(err);\n      }\n    }, \"renderDocs\");\n    this.rerender = async () => renderDocs();\n    this.teardownRender = async ({ viewModeChanged } = {}) => {\n      if (!viewModeChanged || !canvasElement) {\n        return;\n      }\n      renderer.unmount(canvasElement);\n      this.torndown = true;\n    };\n    return renderDocs();\n  }\n  async teardown({ viewModeChanged } = {}) {\n    this.teardownRender?.({ viewModeChanged });\n    this.torndown = true;\n  }\n};\n__name(_MdxDocsRender, \"MdxDocsRender\");\nvar MdxDocsRender = _MdxDocsRender;\n\n// src/preview-api/modules/preview-web/PreviewWithSelection.tsx\nvar globalWindow = globalThis;\nfunction focusInInput(event) {\n  const target = event.composedPath && event.composedPath()[0] || event.target;\n  return /input|textarea/i.test(target.tagName) || target.getAttribute(\"contenteditable\") !== null;\n}\n__name(focusInInput, \"focusInInput\");\nvar ATTACHED_MDX_TAG = \"attached-mdx\";\nvar UNATTACHED_MDX_TAG = \"unattached-mdx\";\nfunction isMdxEntry({ tags }) {\n  return tags?.includes(UNATTACHED_MDX_TAG) || tags?.includes(ATTACHED_MDX_TAG);\n}\n__name(isMdxEntry, \"isMdxEntry\");\nfunction isStoryRender(r) {\n  return r.type === \"story\";\n}\n__name(isStoryRender, \"isStoryRender\");\nfunction isDocsRender(r) {\n  return r.type === \"docs\";\n}\n__name(isDocsRender, \"isDocsRender\");\nfunction isCsfDocsRender(r) {\n  return isDocsRender(r) && r.subtype === \"csf\";\n}\n__name(isCsfDocsRender, \"isCsfDocsRender\");\nvar _PreviewWithSelection = class _PreviewWithSelection extends Preview {\n  constructor(importFn, getProjectAnnotations, selectionStore, view) {\n    super(importFn, getProjectAnnotations, void 0, false);\n    this.importFn = importFn;\n    this.getProjectAnnotations = getProjectAnnotations;\n    this.selectionStore = selectionStore;\n    this.view = view;\n    this.initialize();\n  }\n  setupListeners() {\n    super.setupListeners();\n    globalWindow.onkeydown = this.onKeydown.bind(this);\n    this.channel.on(SET_CURRENT_STORY, this.onSetCurrentStory.bind(this));\n    this.channel.on(UPDATE_QUERY_PARAMS, this.onUpdateQueryParams.bind(this));\n    this.channel.on(PRELOAD_ENTRIES, this.onPreloadStories.bind(this));\n  }\n  async setInitialGlobals() {\n    if (!this.storyStoreValue) {\n      throw new CalledPreviewMethodBeforeInitializationError2({ methodName: \"setInitialGlobals\" });\n    }\n    const { globals } = this.selectionStore.selectionSpecifier || {};\n    if (globals) {\n      this.storyStoreValue.userGlobals.updateFromPersisted(globals);\n    }\n    this.emitGlobals();\n  }\n  // If initialization gets as far as the story index, this function runs.\n  async initializeWithStoryIndex(storyIndex) {\n    await super.initializeWithStoryIndex(storyIndex);\n    return this.selectSpecifiedStory();\n  }\n  // Use the selection specifier to choose a story, then render it\n  async selectSpecifiedStory() {\n    if (!this.storyStoreValue) {\n      throw new CalledPreviewMethodBeforeInitializationError2({\n        methodName: \"selectSpecifiedStory\"\n      });\n    }\n    if (this.selectionStore.selection) {\n      await this.renderSelection();\n      return;\n    }\n    if (!this.selectionStore.selectionSpecifier) {\n      this.renderMissingStory();\n      return;\n    }\n    const { storySpecifier, args } = this.selectionStore.selectionSpecifier;\n    const entry = this.storyStoreValue.storyIndex.entryFromSpecifier(storySpecifier);\n    if (!entry) {\n      if (storySpecifier === \"*\") {\n        this.renderStoryLoadingException(storySpecifier, new EmptyIndexError());\n      } else {\n        this.renderStoryLoadingException(\n          storySpecifier,\n          new NoStoryMatchError({ storySpecifier: storySpecifier.toString() })\n        );\n      }\n      return;\n    }\n    const { id: storyId, type: viewMode } = entry;\n    this.selectionStore.setSelection({ storyId, viewMode });\n    this.channel.emit(STORY_SPECIFIED, this.selectionStore.selection);\n    this.channel.emit(CURRENT_STORY_WAS_SET, this.selectionStore.selection);\n    await this.renderSelection({ persistedArgs: args });\n  }\n  // EVENT HANDLERS\n  // This happens when a config file gets reloaded\n  async onGetProjectAnnotationsChanged({\n    getProjectAnnotations\n  }) {\n    await super.onGetProjectAnnotationsChanged({ getProjectAnnotations });\n    if (this.selectionStore.selection) {\n      this.renderSelection();\n    }\n  }\n  // This happens when a glob gets HMR-ed\n  async onStoriesChanged({\n    importFn,\n    storyIndex\n  }) {\n    await super.onStoriesChanged({ importFn, storyIndex });\n    if (this.selectionStore.selection) {\n      await this.renderSelection();\n    } else {\n      await this.selectSpecifiedStory();\n    }\n  }\n  onKeydown(event) {\n    if (!this.storyRenders.find((r) => r.disableKeyListeners) && !focusInInput(event)) {\n      const { altKey, ctrlKey, metaKey, shiftKey, key, code, keyCode } = event;\n      this.channel.emit(PREVIEW_KEYDOWN, {\n        event: { altKey, ctrlKey, metaKey, shiftKey, key, code, keyCode }\n      });\n    }\n  }\n  async onSetCurrentStory(selection) {\n    this.selectionStore.setSelection({ viewMode: \"story\", ...selection });\n    await this.storeInitializationPromise;\n    this.channel.emit(CURRENT_STORY_WAS_SET, this.selectionStore.selection);\n    this.renderSelection();\n  }\n  onUpdateQueryParams(queryParams) {\n    this.selectionStore.setQueryParams(queryParams);\n  }\n  async onUpdateGlobals({ globals }) {\n    const currentStory = this.currentRender instanceof StoryRender && this.currentRender.story || void 0;\n    super.onUpdateGlobals({ globals, currentStory });\n    if (this.currentRender instanceof MdxDocsRender || this.currentRender instanceof CsfDocsRender) {\n      await this.currentRender.rerender?.();\n    }\n  }\n  async onUpdateArgs({ storyId, updatedArgs }) {\n    super.onUpdateArgs({ storyId, updatedArgs });\n  }\n  async onPreloadStories({ ids }) {\n    await this.storeInitializationPromise;\n    if (this.storyStoreValue) {\n      await Promise.allSettled(ids.map((id) => this.storyStoreValue?.loadEntry(id)));\n    }\n  }\n  // RENDERING\n  // We can either have:\n  // - a story selected in \"story\" viewMode,\n  //     in which case we render it to the root element, OR\n  // - a story selected in \"docs\" viewMode,\n  //     in which case we render the docsPage for that story\n  async renderSelection({ persistedArgs } = {}) {\n    const { renderToCanvas } = this;\n    if (!this.storyStoreValue || !renderToCanvas) {\n      throw new CalledPreviewMethodBeforeInitializationError2({ methodName: \"renderSelection\" });\n    }\n    const { selection } = this.selectionStore;\n    if (!selection) {\n      throw new Error(\"Cannot call renderSelection as no selection was made\");\n    }\n    const { storyId } = selection;\n    let entry;\n    try {\n      entry = await this.storyStoreValue.storyIdToEntry(storyId);\n    } catch (err) {\n      if (this.currentRender) {\n        await this.teardownRender(this.currentRender);\n      }\n      this.renderStoryLoadingException(storyId, err);\n      return;\n    }\n    const storyIdChanged = this.currentSelection?.storyId !== storyId;\n    const viewModeChanged = this.currentRender?.type !== entry.type;\n    if (entry.type === \"story\") {\n      this.view.showPreparingStory({ immediate: viewModeChanged });\n    } else {\n      this.view.showPreparingDocs({ immediate: viewModeChanged });\n    }\n    if (this.currentRender?.isPreparing()) {\n      await this.teardownRender(this.currentRender);\n    }\n    let render;\n    if (entry.type === \"story\") {\n      render = new StoryRender(\n        this.channel,\n        this.storyStoreValue,\n        renderToCanvas,\n        this.mainStoryCallbacks(storyId),\n        storyId,\n        \"story\"\n      );\n    } else if (isMdxEntry(entry)) {\n      render = new MdxDocsRender(\n        this.channel,\n        this.storyStoreValue,\n        entry,\n        this.mainStoryCallbacks(storyId)\n      );\n    } else {\n      render = new CsfDocsRender(\n        this.channel,\n        this.storyStoreValue,\n        entry,\n        this.mainStoryCallbacks(storyId)\n      );\n    }\n    const lastSelection = this.currentSelection;\n    this.currentSelection = selection;\n    const lastRender = this.currentRender;\n    this.currentRender = render;\n    try {\n      await render.prepare();\n    } catch (err) {\n      if (lastRender) {\n        await this.teardownRender(lastRender);\n      }\n      if (err !== PREPARE_ABORTED) {\n        this.renderStoryLoadingException(storyId, err);\n      }\n      return;\n    }\n    const implementationChanged = !storyIdChanged && lastRender && !render.isEqual(lastRender);\n    if (persistedArgs && isStoryRender(render)) {\n      invariant(!!render.story);\n      this.storyStoreValue.args.updateFromPersisted(render.story, persistedArgs);\n    }\n    if (lastRender && !lastRender.torndown && !storyIdChanged && !implementationChanged && !viewModeChanged) {\n      this.currentRender = lastRender;\n      this.channel.emit(STORY_UNCHANGED, storyId);\n      this.view.showMain();\n      return;\n    }\n    if (lastRender) {\n      await this.teardownRender(lastRender, { viewModeChanged });\n    }\n    if (lastSelection && (storyIdChanged || viewModeChanged)) {\n      this.channel.emit(STORY_CHANGED, storyId);\n    }\n    if (isStoryRender(render)) {\n      invariant(!!render.story);\n      const {\n        parameters,\n        initialArgs,\n        argTypes,\n        unmappedArgs,\n        initialGlobals,\n        userGlobals,\n        storyGlobals,\n        globals\n      } = this.storyStoreValue.getStoryContext(render.story);\n      this.channel.emit(STORY_PREPARED, {\n        id: storyId,\n        parameters,\n        initialArgs,\n        argTypes,\n        args: unmappedArgs\n      });\n      this.channel.emit(GLOBALS_UPDATED2, { userGlobals, storyGlobals, globals, initialGlobals });\n    } else {\n      let { parameters } = this.storyStoreValue.projectAnnotations;\n      const { initialGlobals, globals } = this.storyStoreValue.userGlobals;\n      this.channel.emit(GLOBALS_UPDATED2, {\n        globals,\n        initialGlobals,\n        storyGlobals: {},\n        userGlobals: globals\n      });\n      if (isCsfDocsRender(render) || render.entry.tags?.includes(ATTACHED_MDX_TAG)) {\n        if (!render.csfFiles) {\n          throw new MdxFileWithNoCsfReferencesError({ storyId });\n        }\n        ({ parameters } = this.storyStoreValue.preparedMetaFromCSFFile({\n          csfFile: render.csfFiles[0]\n        }));\n      }\n      this.channel.emit(DOCS_PREPARED, {\n        id: storyId,\n        parameters\n      });\n    }\n    if (isStoryRender(render)) {\n      invariant(!!render.story);\n      this.storyRenders.push(render);\n      this.currentRender.renderToElement(\n        this.view.prepareForStory(render.story)\n      );\n    } else {\n      this.currentRender.renderToElement(\n        this.view.prepareForDocs(),\n        // This argument is used for docs, which is currently only compatible with HTMLElements\n        this.renderStoryToElement.bind(this)\n      );\n    }\n  }\n  async teardownRender(render, { viewModeChanged = false } = {}) {\n    this.storyRenders = this.storyRenders.filter((r) => r !== render);\n    await render?.teardown?.({ viewModeChanged });\n  }\n  // UTILITIES\n  mainStoryCallbacks(storyId) {\n    return {\n      showStoryDuringRender: /* @__PURE__ */ __name(() => this.view.showStoryDuringRender(), \"showStoryDuringRender\"),\n      showMain: /* @__PURE__ */ __name(() => this.view.showMain(), \"showMain\"),\n      showError: /* @__PURE__ */ __name((err) => this.renderError(storyId, err), \"showError\"),\n      showException: /* @__PURE__ */ __name((err) => this.renderException(storyId, err), \"showException\")\n    };\n  }\n  renderPreviewEntryError(reason, err) {\n    super.renderPreviewEntryError(reason, err);\n    this.view.showErrorDisplay(err);\n  }\n  renderMissingStory() {\n    this.view.showNoPreview();\n    this.channel.emit(STORY_MISSING);\n  }\n  renderStoryLoadingException(storySpecifier, err) {\n    logger8.error(err);\n    this.view.showErrorDisplay(err);\n    this.channel.emit(STORY_MISSING, storySpecifier);\n  }\n  // renderException is used if we fail to render the story and it is uncaught by the app layer\n  renderException(storyId, error) {\n    const { name = \"Error\", message = String(error), stack } = error;\n    const renderId = this.currentRender?.renderId;\n    this.channel.emit(STORY_THREW_EXCEPTION, { name, message, stack });\n    this.channel.emit(STORY_RENDER_PHASE_CHANGED2, { newPhase: \"errored\", renderId, storyId });\n    this.view.showErrorDisplay(error);\n    logger8.error(`Error rendering story '${storyId}':`);\n    logger8.error(error);\n  }\n  // renderError is used by the various app layers to inform the user they have done something\n  // wrong -- for instance returned the wrong thing from a story\n  renderError(storyId, { title, description }) {\n    const renderId = this.currentRender?.renderId;\n    this.channel.emit(STORY_ERRORED, { title, description });\n    this.channel.emit(STORY_RENDER_PHASE_CHANGED2, { newPhase: \"errored\", renderId, storyId });\n    this.view.showErrorDisplay({ message: title, stack: description });\n    logger8.error(`Error rendering story ${title}: ${description}`);\n  }\n};\n__name(_PreviewWithSelection, \"PreviewWithSelection\");\nvar PreviewWithSelection = _PreviewWithSelection;\n\n// src/preview-api/modules/preview-web/UrlStore.ts\nvar import_picoquery2 = __toESM(require_main(), 1);\nimport { global as global6 } from \"@storybook/global\";\n\n// src/preview-api/modules/preview-web/parseArgsParam.ts\nimport { once as once3 } from \"storybook/internal/client-logger\";\nvar import_picoquery = __toESM(require_main(), 1);\nvar VALIDATION_REGEXP = /^[a-zA-Z0-9 _-]*$/;\nvar NUMBER_REGEXP = /^-?[0-9]+(\\.[0-9]+)?$/;\nvar HEX_REGEXP = /^#([a-f0-9]{3,4}|[a-f0-9]{6}|[a-f0-9]{8})$/i;\nvar COLOR_REGEXP = /^(rgba?|hsla?)\\(([0-9]{1,3}),\\s?([0-9]{1,3})%?,\\s?([0-9]{1,3})%?,?\\s?([0-9](\\.[0-9]{1,2})?)?\\)$/i;\nvar validateArgs = /* @__PURE__ */ __name((key = \"\", value) => {\n  if (key === null) {\n    return false;\n  }\n  if (key === \"\" || !VALIDATION_REGEXP.test(key)) {\n    return false;\n  }\n  if (value === null || value === void 0) {\n    return true;\n  }\n  if (value instanceof Date) {\n    return true;\n  }\n  if (typeof value === \"number\" || typeof value === \"boolean\") {\n    return true;\n  }\n  if (typeof value === \"string\") {\n    return VALIDATION_REGEXP.test(value) || NUMBER_REGEXP.test(value) || HEX_REGEXP.test(value) || COLOR_REGEXP.test(value);\n  }\n  if (Array.isArray(value)) {\n    return value.every((v) => validateArgs(key, v));\n  }\n  if (isPlainObject(value)) {\n    return Object.entries(value).every(([k, v]) => validateArgs(k, v));\n  }\n  return false;\n}, \"validateArgs\");\nvar QUERY_OPTIONS = {\n  delimiter: \";\",\n  // we're parsing a single query param\n  nesting: true,\n  arrayRepeat: true,\n  arrayRepeatSyntax: \"bracket\",\n  nestingSyntax: \"js\",\n  // objects are encoded using dot notation\n  valueDeserializer(str) {\n    if (str.startsWith(\"!\")) {\n      if (str === \"!undefined\") {\n        return void 0;\n      }\n      if (str === \"!null\") {\n        return null;\n      }\n      if (str === \"!true\") {\n        return true;\n      }\n      if (str === \"!false\") {\n        return false;\n      }\n      if (str.startsWith(\"!date(\") && str.endsWith(\")\")) {\n        return new Date(str.replaceAll(\" \", \"+\").slice(6, -1));\n      }\n      if (str.startsWith(\"!hex(\") && str.endsWith(\")\")) {\n        return `#${str.slice(5, -1)}`;\n      }\n      const color = str.slice(1).match(COLOR_REGEXP);\n      if (color) {\n        if (str.startsWith(\"!rgba\") || str.startsWith(\"!RGBA\")) {\n          return `${color[1]}(${color[2]}, ${color[3]}, ${color[4]}, ${color[5]})`;\n        }\n        if (str.startsWith(\"!hsla\") || str.startsWith(\"!HSLA\")) {\n          return `${color[1]}(${color[2]}, ${color[3]}%, ${color[4]}%, ${color[5]})`;\n        }\n        return str.startsWith(\"!rgb\") || str.startsWith(\"!RGB\") ? `${color[1]}(${color[2]}, ${color[3]}, ${color[4]})` : `${color[1]}(${color[2]}, ${color[3]}%, ${color[4]}%)`;\n      }\n    }\n    if (NUMBER_REGEXP.test(str)) {\n      return Number(str);\n    }\n    return str;\n  }\n};\nvar parseArgsParam = /* @__PURE__ */ __name((argsString) => {\n  const parts = argsString.split(\";\").map((part) => part.replace(\"=\", \"~\").replace(\":\", \"=\"));\n  return Object.entries((0, import_picoquery.parse)(parts.join(\";\"), QUERY_OPTIONS)).reduce((acc, [key, value]) => {\n    if (validateArgs(key, value)) {\n      return Object.assign(acc, { [key]: value });\n    }\n    once3.warn(dedent`\n      Omitted potentially unsafe URL args.\n\n      More info: https://storybook.js.org/docs/writing-stories/args#setting-args-through-the-url?ref=error\n    `);\n    return acc;\n  }, {});\n}, \"parseArgsParam\");\n\n// src/preview-api/modules/preview-web/UrlStore.ts\nvar { history, document: document2 } = global6;\nfunction pathToId(path) {\n  const match = (path || \"\").match(/^\\/story\\/(.+)/);\n  if (!match) {\n    throw new Error(`Invalid path '${path}',  must start with '/story/'`);\n  }\n  return match[1];\n}\n__name(pathToId, \"pathToId\");\nvar getQueryString = /* @__PURE__ */ __name(({\n  selection,\n  extraParams\n}) => {\n  const search = document2?.location.search.slice(1);\n  const { path, selectedKind, selectedStory, ...rest } = (0, import_picoquery2.parse)(search);\n  const queryStr = (0, import_picoquery2.stringify)({\n    ...rest,\n    ...extraParams,\n    ...selection && { id: selection.storyId, viewMode: selection.viewMode }\n  });\n  return `?${queryStr}`;\n}, \"getQueryString\");\nvar setPath = /* @__PURE__ */ __name((selection) => {\n  if (!selection) {\n    return;\n  }\n  const query = getQueryString({ selection });\n  const { hash = \"\" } = document2.location;\n  document2.title = selection.storyId;\n  history.replaceState({}, \"\", `${document2.location.pathname}${query}${hash}`);\n}, \"setPath\");\nvar isObject = /* @__PURE__ */ __name((val) => val != null && typeof val === \"object\" && Array.isArray(val) === false, \"isObject\");\nvar getFirstString = /* @__PURE__ */ __name((v) => {\n  if (v === void 0) {\n    return void 0;\n  }\n  if (typeof v === \"string\") {\n    return v;\n  }\n  if (Array.isArray(v)) {\n    return getFirstString(v[0]);\n  }\n  if (isObject(v)) {\n    return getFirstString(\n      Object.values(v).filter(Boolean)\n    );\n  }\n  return void 0;\n}, \"getFirstString\");\nvar getSelectionSpecifierFromPath = /* @__PURE__ */ __name(() => {\n  if (typeof document2 !== \"undefined\") {\n    const queryStr = document2.location.search.slice(1);\n    const query = (0, import_picoquery2.parse)(queryStr);\n    const args = typeof query.args === \"string\" ? parseArgsParam(query.args) : void 0;\n    const globals = typeof query.globals === \"string\" ? parseArgsParam(query.globals) : void 0;\n    let viewMode = getFirstString(query.viewMode);\n    if (typeof viewMode !== \"string\" || !viewMode.match(/docs|story/)) {\n      viewMode = \"story\";\n    }\n    const path = getFirstString(query.path);\n    const storyId = path ? pathToId(path) : getFirstString(query.id);\n    if (storyId) {\n      return { storySpecifier: storyId, args, globals, viewMode };\n    }\n  }\n  return null;\n}, \"getSelectionSpecifierFromPath\");\nvar _UrlStore = class _UrlStore {\n  constructor() {\n    this.selectionSpecifier = getSelectionSpecifierFromPath();\n  }\n  setSelection(selection) {\n    this.selection = selection;\n    setPath(this.selection);\n  }\n  setQueryParams(queryParams) {\n    const query = getQueryString({ extraParams: queryParams });\n    const { hash = \"\" } = document2.location;\n    history.replaceState({}, \"\", `${document2.location.pathname}${query}${hash}`);\n  }\n};\n__name(_UrlStore, \"UrlStore\");\nvar UrlStore = _UrlStore;\n\n// src/preview-api/modules/preview-web/WebView.ts\nvar import_ansi_to_html = __toESM(require_ansi_to_html(), 1);\nvar import_picoquery3 = __toESM(require_main(), 1);\nimport { logger as logger9 } from \"storybook/internal/client-logger\";\nimport { global as global7 } from \"@storybook/global\";\nvar { document: document3 } = global7;\nvar PREPARING_DELAY = 100;\nvar Mode = /* @__PURE__ */ ((Mode2) => {\n  Mode2[\"MAIN\"] = \"MAIN\";\n  Mode2[\"NOPREVIEW\"] = \"NOPREVIEW\";\n  Mode2[\"PREPARING_STORY\"] = \"PREPARING_STORY\";\n  Mode2[\"PREPARING_DOCS\"] = \"PREPARING_DOCS\";\n  Mode2[\"ERROR\"] = \"ERROR\";\n  return Mode2;\n})(Mode || {});\nvar classes = {\n  PREPARING_STORY: \"sb-show-preparing-story\",\n  PREPARING_DOCS: \"sb-show-preparing-docs\",\n  MAIN: \"sb-show-main\",\n  NOPREVIEW: \"sb-show-nopreview\",\n  ERROR: \"sb-show-errordisplay\"\n};\nvar layoutClassMap = {\n  centered: \"sb-main-centered\",\n  fullscreen: \"sb-main-fullscreen\",\n  padded: \"sb-main-padded\"\n};\nvar ansiConverter = new import_ansi_to_html.default({\n  escapeXML: true\n});\nvar _WebView = class _WebView {\n  constructor() {\n    this.testing = false;\n    if (typeof document3 !== \"undefined\") {\n      const { __SPECIAL_TEST_PARAMETER__ } = (0, import_picoquery3.parse)(document3.location.search.slice(1));\n      switch (__SPECIAL_TEST_PARAMETER__) {\n        case \"preparing-story\": {\n          this.showPreparingStory();\n          this.testing = true;\n          break;\n        }\n        case \"preparing-docs\": {\n          this.showPreparingDocs();\n          this.testing = true;\n          break;\n        }\n        default:\n      }\n    }\n  }\n  // Get ready to render a story, returning the element to render to\n  prepareForStory(story) {\n    this.showStory();\n    this.applyLayout(story.parameters.layout);\n    document3.documentElement.scrollTop = 0;\n    document3.documentElement.scrollLeft = 0;\n    return this.storyRoot();\n  }\n  storyRoot() {\n    return document3.getElementById(\"storybook-root\");\n  }\n  prepareForDocs() {\n    this.showMain();\n    this.showDocs();\n    this.applyLayout(\"fullscreen\");\n    document3.documentElement.scrollTop = 0;\n    document3.documentElement.scrollLeft = 0;\n    return this.docsRoot();\n  }\n  docsRoot() {\n    return document3.getElementById(\"storybook-docs\");\n  }\n  applyLayout(layout = \"padded\") {\n    if (layout === \"none\") {\n      document3.body.classList.remove(this.currentLayoutClass);\n      this.currentLayoutClass = null;\n      return;\n    }\n    this.checkIfLayoutExists(layout);\n    const layoutClass = layoutClassMap[layout];\n    document3.body.classList.remove(this.currentLayoutClass);\n    document3.body.classList.add(layoutClass);\n    this.currentLayoutClass = layoutClass;\n  }\n  checkIfLayoutExists(layout) {\n    if (!layoutClassMap[layout]) {\n      logger9.warn(\n        dedent`\n          The desired layout: ${layout} is not a valid option.\n          The possible options are: ${Object.keys(layoutClassMap).join(\", \")}, none.\n        `\n      );\n    }\n  }\n  showMode(mode) {\n    clearTimeout(this.preparingTimeout);\n    Object.keys(Mode).forEach((otherMode) => {\n      if (otherMode === mode) {\n        document3.body.classList.add(classes[otherMode]);\n      } else {\n        document3.body.classList.remove(classes[otherMode]);\n      }\n    });\n  }\n  showErrorDisplay({ message = \"\", stack = \"\" }) {\n    let header = message;\n    let detail = stack;\n    const parts = message.split(\"\\n\");\n    if (parts.length > 1) {\n      [header] = parts;\n      detail = parts.slice(1).join(\"\\n\").replace(/^\\n/, \"\");\n    }\n    document3.getElementById(\"error-message\").innerHTML = ansiConverter.toHtml(header);\n    document3.getElementById(\"error-stack\").innerHTML = ansiConverter.toHtml(detail);\n    this.showMode(\"ERROR\" /* ERROR */);\n  }\n  showNoPreview() {\n    if (this.testing) {\n      return;\n    }\n    this.showMode(\"NOPREVIEW\" /* NOPREVIEW */);\n    this.storyRoot()?.setAttribute(\"hidden\", \"true\");\n    this.docsRoot()?.setAttribute(\"hidden\", \"true\");\n  }\n  showPreparingStory({ immediate = false } = {}) {\n    clearTimeout(this.preparingTimeout);\n    if (immediate) {\n      this.showMode(\"PREPARING_STORY\" /* PREPARING_STORY */);\n    } else {\n      this.preparingTimeout = setTimeout(\n        () => this.showMode(\"PREPARING_STORY\" /* PREPARING_STORY */),\n        PREPARING_DELAY\n      );\n    }\n  }\n  showPreparingDocs({ immediate = false } = {}) {\n    clearTimeout(this.preparingTimeout);\n    if (immediate) {\n      this.showMode(\"PREPARING_DOCS\" /* PREPARING_DOCS */);\n    } else {\n      this.preparingTimeout = setTimeout(() => this.showMode(\"PREPARING_DOCS\" /* PREPARING_DOCS */), PREPARING_DELAY);\n    }\n  }\n  showMain() {\n    this.showMode(\"MAIN\" /* MAIN */);\n  }\n  showDocs() {\n    this.storyRoot().setAttribute(\"hidden\", \"true\");\n    this.docsRoot().removeAttribute(\"hidden\");\n  }\n  showStory() {\n    this.docsRoot().setAttribute(\"hidden\", \"true\");\n    this.storyRoot().removeAttribute(\"hidden\");\n  }\n  showStoryDuringRender() {\n    document3.body.classList.add(classes.MAIN);\n  }\n};\n__name(_WebView, \"WebView\");\nvar WebView = _WebView;\n\n// src/preview-api/modules/preview-web/PreviewWeb.tsx\nvar _PreviewWeb = class _PreviewWeb extends PreviewWithSelection {\n  constructor(importFn, getProjectAnnotations) {\n    super(importFn, getProjectAnnotations, new UrlStore(), new WebView());\n    this.importFn = importFn;\n    this.getProjectAnnotations = getProjectAnnotations;\n    global8.__STORYBOOK_PREVIEW__ = this;\n  }\n};\n__name(_PreviewWeb, \"PreviewWeb\");\nvar PreviewWeb = _PreviewWeb;\n\n// src/preview-api/modules/preview-web/simulate-pageload.ts\nimport { global as global9 } from \"@storybook/global\";\nvar { document: document4 } = global9;\nvar runScriptTypes = [\n  \"application/javascript\",\n  \"application/ecmascript\",\n  \"application/x-ecmascript\",\n  \"application/x-javascript\",\n  \"text/ecmascript\",\n  \"text/javascript\",\n  \"text/javascript1.0\",\n  \"text/javascript1.1\",\n  \"text/javascript1.2\",\n  \"text/javascript1.3\",\n  \"text/javascript1.4\",\n  \"text/javascript1.5\",\n  \"text/jscript\",\n  \"text/livescript\",\n  \"text/x-ecmascript\",\n  \"text/x-javascript\",\n  // Support modern javascript\n  \"module\"\n];\nvar SCRIPT = \"script\";\nvar SCRIPTS_ROOT_ID = \"scripts-root\";\nfunction simulateDOMContentLoaded() {\n  const DOMContentLoadedEvent = document4.createEvent(\"Event\");\n  DOMContentLoadedEvent.initEvent(\"DOMContentLoaded\", true, true);\n  document4.dispatchEvent(DOMContentLoadedEvent);\n}\n__name(simulateDOMContentLoaded, \"simulateDOMContentLoaded\");\nfunction insertScript($script, callback, $scriptRoot) {\n  const scriptEl = document4.createElement(\"script\");\n  scriptEl.type = $script.type === \"module\" ? \"module\" : \"text/javascript\";\n  if ($script.src) {\n    scriptEl.onload = callback;\n    scriptEl.onerror = callback;\n    scriptEl.src = $script.src;\n  } else {\n    scriptEl.textContent = $script.innerText;\n  }\n  if ($scriptRoot) {\n    $scriptRoot.appendChild(scriptEl);\n  } else {\n    document4.head.appendChild(scriptEl);\n  }\n  $script.parentNode.removeChild($script);\n  if (!$script.src) {\n    callback();\n  }\n}\n__name(insertScript, \"insertScript\");\nfunction insertScriptsSequentially(scriptsToExecute, callback, index = 0) {\n  scriptsToExecute[index](() => {\n    index++;\n    if (index === scriptsToExecute.length) {\n      callback();\n    } else {\n      insertScriptsSequentially(scriptsToExecute, callback, index);\n    }\n  });\n}\n__name(insertScriptsSequentially, \"insertScriptsSequentially\");\nfunction simulatePageLoad($container) {\n  let $scriptsRoot = document4.getElementById(SCRIPTS_ROOT_ID);\n  if (!$scriptsRoot) {\n    $scriptsRoot = document4.createElement(\"div\");\n    $scriptsRoot.id = SCRIPTS_ROOT_ID;\n    document4.body.appendChild($scriptsRoot);\n  } else {\n    $scriptsRoot.innerHTML = \"\";\n  }\n  const $scripts = Array.from($container.querySelectorAll(SCRIPT));\n  if ($scripts.length) {\n    const scriptsToExecute = [];\n    $scripts.forEach(($script) => {\n      const typeAttr = $script.getAttribute(\"type\");\n      if (!typeAttr || runScriptTypes.includes(typeAttr)) {\n        scriptsToExecute.push((callback) => insertScript($script, callback, $scriptsRoot));\n      }\n    });\n    if (scriptsToExecute.length) {\n      insertScriptsSequentially(scriptsToExecute, simulateDOMContentLoaded, void 0);\n    }\n  } else {\n    simulateDOMContentLoaded();\n  }\n}\n__name(simulatePageLoad, \"simulatePageLoad\");\n\n// src/preview-api/modules/preview-web/emitTransformCode.ts\nasync function emitTransformCode(source, context) {\n  const transform = context.parameters?.docs?.source?.transform;\n  const { id, unmappedArgs } = context;\n  const transformed = transform && source ? transform?.(source, context) : source;\n  const result = transformed ? await transformed : void 0;\n  addons.getChannel().emit(SNIPPET_RENDERED, {\n    id,\n    source: result,\n    args: unmappedArgs\n  });\n}\n__name(emitTransformCode, \"emitTransformCode\");\n\nexport {\n  mockChannel,\n  addons,\n  HooksContext,\n  applyHooks,\n  useMemo,\n  useCallback,\n  useRef,\n  useState,\n  useReducer,\n  useEffect,\n  useChannel,\n  useStoryContext,\n  useParameter,\n  useArgs,\n  useGlobals,\n  makeDecorator,\n  combineArgs,\n  normalizeArrays,\n  normalizeStory,\n  mountDestructured,\n  decorateStory,\n  sanitizeStoryContextUpdate,\n  defaultDecorateStory,\n  prepareStory,\n  prepareMeta,\n  filterArgTypes,\n  inferControls,\n  normalizeProjectAnnotations,\n  composeStepRunners,\n  composeConfigs,\n  ReporterAPI,\n  getCsfFactoryAnnotations,\n  setDefaultProjectAnnotations,\n  setProjectAnnotations,\n  composeStory,\n  composeStories,\n  createPlaywrightTest,\n  StoryStore,\n  userOrAutoTitleFromSpecifier,\n  userOrAutoTitle,\n  sortStoriesV7,\n  Preview,\n  DocsContext,\n  PreviewWithSelection,\n  UrlStore,\n  WebView,\n  PreviewWeb,\n  simulateDOMContentLoaded,\n  simulatePageLoad,\n  emitTransformCode\n};\n","import {\n  DEFAULT_BACKGROUNDS,\n  PARAM_KEY as PARAM_KEY2,\n  PARAM_KEY2 as PARAM_KEY3,\n  PARAM_KEY3 as PARAM_KEY4\n} from \"../_browser-chunks/chunk-CADGRH3P.js\";\nimport {\n  composeConfigs,\n  composeStory,\n  mountDestructured,\n  normalizeArrays,\n  normalizeProjectAnnotations\n} from \"../_browser-chunks/chunk-W4QKLQSC.js\";\nimport \"../_browser-chunks/chunk-Y3M7TW6K.js\";\nimport {\n  combineParameters\n} from \"../_browser-chunks/chunk-B4A3ADP3.js\";\nimport \"../_browser-chunks/chunk-ZNRFDIVA.js\";\nimport {\n  invariant\n} from \"../_browser-chunks/chunk-FUOHXXZT.js\";\nimport \"../_browser-chunks/chunk-AB7OOPUX.js\";\nimport \"../_browser-chunks/chunk-F4Q6SGTB.js\";\nimport \"../_browser-chunks/chunk-LYCSRYYR.js\";\nimport \"../_browser-chunks/chunk-UTNZYD2N.js\";\nimport \"../_browser-chunks/chunk-FSBVR7H5.js\";\nimport \"../_browser-chunks/chunk-NVV6MIOE.js\";\nimport {\n  dedent\n} from \"../_browser-chunks/chunk-OPCDBBL3.js\";\nimport {\n  HIGHLIGHT,\n  MAX_Z_INDEX,\n  MIN_TOUCH_AREA_SIZE,\n  REMOVE_HIGHLIGHT,\n  RESET_HIGHLIGHT,\n  SCROLL_INTO_VIEW\n} from \"../_browser-chunks/chunk-GTKOCWCT.js\";\nimport \"../_browser-chunks/chunk-ECQ75MKQ.js\";\nimport {\n  action\n} from \"../_browser-chunks/chunk-PB6FZ3WE.js\";\nimport \"../_browser-chunks/chunk-XW6KSYKF.js\";\nimport {\n  PARAM_KEY\n} from \"../_browser-chunks/chunk-HHW4FUMO.js\";\nimport {\n  __commonJS,\n  __export,\n  __name,\n  __toESM\n} from \"../_browser-chunks/chunk-MM7DTO55.js\";\n\n// ../node_modules/@ngard/tiny-isequal/index.js\nvar require_tiny_isequal = __commonJS({\n  \"../node_modules/@ngard/tiny-isequal/index.js\"(exports) {\n    Object.defineProperty(exports, \"__esModule\", { value: true }), exports.isEqual = /* @__PURE__ */ function() {\n      var e = Object.prototype.toString, r = Object.getPrototypeOf, t = Object.getOwnPropertySymbols ? function(e2) {\n        return Object.keys(e2).concat(Object.getOwnPropertySymbols(e2));\n      } : Object.keys;\n      return function(n, a) {\n        return (/* @__PURE__ */ __name(function n2(a2, c, u) {\n          var i, s, l, o = e.call(a2), f = e.call(c);\n          if (a2 === c) return true;\n          if (null == a2 || null == c) return false;\n          if (u.indexOf(a2) > -1 && u.indexOf(c) > -1) return true;\n          if (u.push(a2, c), o != f) return false;\n          if (i = t(a2), s = t(c), i.length != s.length || i.some(function(e2) {\n            return !n2(a2[e2], c[e2], u);\n          })) return false;\n          switch (o.slice(8, -1)) {\n            case \"Symbol\":\n              return a2.valueOf() == c.valueOf();\n            case \"Date\":\n            case \"Number\":\n              return +a2 == +c || +a2 != +a2 && +c != +c;\n            case \"RegExp\":\n            case \"Function\":\n            case \"String\":\n            case \"Boolean\":\n              return \"\" + a2 == \"\" + c;\n            case \"Set\":\n            case \"Map\":\n              i = a2.entries(), s = c.entries();\n              do {\n                if (!n2((l = i.next()).value, s.next().value, u)) return false;\n              } while (!l.done);\n              return true;\n            case \"ArrayBuffer\":\n              a2 = new Uint8Array(a2), c = new Uint8Array(c);\n            case \"DataView\":\n              a2 = new Uint8Array(a2.buffer), c = new Uint8Array(c.buffer);\n            case \"Float32Array\":\n            case \"Float64Array\":\n            case \"Int8Array\":\n            case \"Int16Array\":\n            case \"Int32Array\":\n            case \"Uint8Array\":\n            case \"Uint16Array\":\n            case \"Uint32Array\":\n            case \"Uint8ClampedArray\":\n            case \"Arguments\":\n            case \"Array\":\n              if (a2.length != c.length) return false;\n              for (l = 0; l < a2.length; l++) if ((l in a2 || l in c) && (l in a2 != l in c || !n2(a2[l], c[l], u))) return false;\n              return true;\n            case \"Object\":\n              return n2(r(a2), r(c), u);\n            default:\n              return false;\n          }\n        }, \"n\"))(n, a, []);\n      };\n    }();\n  }\n});\n\n// src/csf/toStartCaseStr.ts\nfunction toStartCaseStr(str) {\n  return str.replace(/_/g, \" \").replace(/-/g, \" \").replace(/\\./g, \" \").replace(/([^\\n])([A-Z])([a-z])/g, (str2, $1, $2, $3) => `${$1} ${$2}${$3}`).replace(/([a-z])([A-Z])/g, (str2, $1, $2) => `${$1} ${$2}`).replace(/([a-z])([0-9])/gi, (str2, $1, $2) => `${$1} ${$2}`).replace(/([0-9])([a-z])/gi, (str2, $1, $2) => `${$1} ${$2}`).replace(/(\\s|^)(\\w)/g, (str2, $1, $2) => `${$1}${$2.toUpperCase()}`).replace(/ +/g, \" \").trim();\n}\n__name(toStartCaseStr, \"toStartCaseStr\");\n\n// src/csf/includeConditionalArg.ts\nvar import_tiny_isequal = __toESM(require_tiny_isequal(), 1);\nvar count = /* @__PURE__ */ __name((vals) => vals.map((v) => typeof v !== \"undefined\").filter(Boolean).length, \"count\");\nvar testValue = /* @__PURE__ */ __name((cond, value) => {\n  const { exists, eq, neq, truthy } = cond;\n  if (count([exists, eq, neq, truthy]) > 1) {\n    throw new Error(`Invalid conditional test ${JSON.stringify({ exists, eq, neq })}`);\n  }\n  if (typeof eq !== \"undefined\") {\n    return (0, import_tiny_isequal.isEqual)(value, eq);\n  }\n  if (typeof neq !== \"undefined\") {\n    return !(0, import_tiny_isequal.isEqual)(value, neq);\n  }\n  if (typeof exists !== \"undefined\") {\n    const valueExists = typeof value !== \"undefined\";\n    return exists ? valueExists : !valueExists;\n  }\n  const shouldBeTruthy = typeof truthy === \"undefined\" ? true : truthy;\n  return shouldBeTruthy ? !!value : !value;\n}, \"testValue\");\nvar includeConditionalArg = /* @__PURE__ */ __name((argType, args, globals) => {\n  if (!argType.if) {\n    return true;\n  }\n  const { arg, global: global5 } = argType.if;\n  if (count([arg, global5]) !== 1) {\n    throw new Error(`Invalid conditional value ${JSON.stringify({ arg, global: global5 })}`);\n  }\n  const value = arg ? args[arg] : globals[global5];\n  return testValue(argType.if, value);\n}, \"includeConditionalArg\");\n\n// src/csf/csf-factories.ts\nimport { combineTags } from \"storybook/internal/csf\";\n\n// src/actions/preview.ts\nimport { definePreviewAddon } from \"storybook/internal/csf\";\n\n// src/actions/addArgs.ts\nvar addArgs_exports = {};\n__export(addArgs_exports, {\n  argsEnhancers: () => argsEnhancers\n});\n\n// src/actions/addArgsHelpers.ts\nvar isInInitialArgs = /* @__PURE__ */ __name((name, initialArgs) => typeof initialArgs[name] === \"undefined\" && !(name in initialArgs), \"isInInitialArgs\");\nvar inferActionsFromArgTypesRegex = /* @__PURE__ */ __name((context) => {\n  const {\n    initialArgs,\n    argTypes,\n    id,\n    parameters: { actions }\n  } = context;\n  if (!actions || actions.disable || !actions.argTypesRegex || !argTypes) {\n    return {};\n  }\n  const argTypesRegex = new RegExp(actions.argTypesRegex);\n  const argTypesMatchingRegex = Object.entries(argTypes).filter(\n    ([name]) => !!argTypesRegex.test(name)\n  );\n  return argTypesMatchingRegex.reduce((acc, [name, argType]) => {\n    if (isInInitialArgs(name, initialArgs)) {\n      acc[name] = action(name, { implicit: true, id });\n    }\n    return acc;\n  }, {});\n}, \"inferActionsFromArgTypesRegex\");\nvar addActionsFromArgTypes = /* @__PURE__ */ __name((context) => {\n  const {\n    initialArgs,\n    argTypes,\n    parameters: { actions }\n  } = context;\n  if (actions?.disable || !argTypes) {\n    return {};\n  }\n  const argTypesWithAction = Object.entries(argTypes).filter(([name, argType]) => !!argType.action);\n  return argTypesWithAction.reduce((acc, [name, argType]) => {\n    if (isInInitialArgs(name, initialArgs)) {\n      acc[name] = action(typeof argType.action === \"string\" ? argType.action : name);\n    }\n    return acc;\n  }, {});\n}, \"addActionsFromArgTypes\");\n\n// src/actions/addArgs.ts\nvar argsEnhancers = [\n  addActionsFromArgTypes,\n  inferActionsFromArgTypesRegex\n];\n\n// src/actions/loaders.ts\nvar loaders_exports = {};\n__export(loaders_exports, {\n  loaders: () => loaders\n});\nimport { onMockCall } from \"storybook/test\";\nvar subscribed = false;\nvar logActionsWhenMockCalled = /* @__PURE__ */ __name((context) => {\n  const { parameters: parameters2 } = context;\n  if (parameters2?.actions?.disable) {\n    return;\n  }\n  if (!subscribed) {\n    onMockCall((mock, args) => {\n      const name = mock.getMockName();\n      if (name === \"spy\") {\n        return;\n      }\n      if (name === \"vi.fn()\") {\n        return;\n      }\n      if (!/^next\\/.*::/.test(name) || [\n        \"next/router::useRouter()\",\n        \"next/navigation::useRouter()\",\n        \"next/navigation::redirect\",\n        \"next/cache::\",\n        \"next/headers::cookies().set\",\n        \"next/headers::cookies().delete\",\n        \"next/headers::headers().set\",\n        \"next/headers::headers().delete\"\n      ].some((prefix) => name.startsWith(prefix))) {\n        action(name)(args);\n      }\n    });\n    subscribed = true;\n  }\n}, \"logActionsWhenMockCalled\");\nvar loaders = [logActionsWhenMockCalled];\n\n// src/actions/preview.ts\nvar preview_default = /* @__PURE__ */ __name(() => definePreviewAddon({\n  ...addArgs_exports,\n  ...loaders_exports\n}), \"default\");\n\n// src/backgrounds/preview.ts\nimport { definePreviewAddon as definePreviewAddon2 } from \"storybook/internal/csf\";\n\n// src/backgrounds/decorator.ts\nimport { useEffect } from \"storybook/preview-api\";\n\n// src/backgrounds/utils.ts\nvar { document: document2 } = globalThis;\nvar isReduceMotionEnabled = /* @__PURE__ */ __name(() => {\n  if (!globalThis?.matchMedia) {\n    return false;\n  }\n  const prefersReduceMotion = globalThis.matchMedia(\"(prefers-reduced-motion: reduce)\");\n  return !!prefersReduceMotion?.matches;\n}, \"isReduceMotionEnabled\");\nvar clearStyles = /* @__PURE__ */ __name((selector) => {\n  const selectors = Array.isArray(selector) ? selector : [selector];\n  selectors.forEach(clearStyle);\n}, \"clearStyles\");\nvar clearStyle = /* @__PURE__ */ __name((selector) => {\n  if (!document2) {\n    return;\n  }\n  const element = document2.getElementById(selector);\n  if (element && element.parentElement) {\n    element.parentElement.removeChild(element);\n  }\n}, \"clearStyle\");\nvar addGridStyle = /* @__PURE__ */ __name((selector, css) => {\n  if (!document2) {\n    return;\n  }\n  const existingStyle = document2.getElementById(selector);\n  if (existingStyle) {\n    if (existingStyle.innerHTML !== css) {\n      existingStyle.innerHTML = css;\n    }\n  } else {\n    const style = document2.createElement(\"style\");\n    style.setAttribute(\"id\", selector);\n    style.innerHTML = css;\n    document2.head.appendChild(style);\n  }\n}, \"addGridStyle\");\nvar addBackgroundStyle = /* @__PURE__ */ __name((selector, css, storyId) => {\n  if (!document2) {\n    return;\n  }\n  const existingStyle = document2.getElementById(selector);\n  if (existingStyle) {\n    if (existingStyle.innerHTML !== css) {\n      existingStyle.innerHTML = css;\n    }\n  } else {\n    const style = document2.createElement(\"style\");\n    style.setAttribute(\"id\", selector);\n    style.innerHTML = css;\n    const gridStyleSelector = `addon-backgrounds-grid${storyId ? `-docs-${storyId}` : \"\"}`;\n    const existingGridStyle = document2.getElementById(gridStyleSelector);\n    if (existingGridStyle) {\n      existingGridStyle.parentElement?.insertBefore(style, existingGridStyle);\n    } else {\n      document2.head.appendChild(style);\n    }\n  }\n}, \"addBackgroundStyle\");\n\n// src/backgrounds/decorator.ts\nvar defaultGrid = {\n  cellSize: 100,\n  cellAmount: 10,\n  opacity: 0.8\n};\nvar BG_SELECTOR_BASE = `addon-backgrounds`;\nvar GRID_SELECTOR_BASE = \"addon-backgrounds-grid\";\nvar transitionStyle = isReduceMotionEnabled() ? \"\" : \"transition: background-color 0.3s;\";\nvar withBackgroundAndGrid = /* @__PURE__ */ __name((StoryFn, context) => {\n  const { globals = {}, parameters: parameters2 = {}, viewMode, id } = context;\n  const {\n    options = DEFAULT_BACKGROUNDS,\n    disable,\n    grid = defaultGrid\n  } = parameters2[PARAM_KEY2] || {};\n  const data = globals[PARAM_KEY2] || {};\n  const backgroundName = typeof data === \"string\" ? data : data?.value;\n  const item = backgroundName ? options[backgroundName] : void 0;\n  const value = typeof item === \"string\" ? item : item?.value || \"transparent\";\n  const showGrid = typeof data === \"string\" ? false : data.grid || false;\n  const shownBackground = !!item && !disable;\n  const backgroundSelector = viewMode === \"docs\" ? `#anchor--${id} .docs-story` : \".sb-show-main\";\n  const gridSelector = viewMode === \"docs\" ? `#anchor--${id} .docs-story` : \".sb-show-main\";\n  const isLayoutPadded = parameters2.layout === void 0 || parameters2.layout === \"padded\";\n  const defaultOffset = viewMode === \"docs\" ? 20 : isLayoutPadded ? 16 : 0;\n  const { cellAmount, cellSize, opacity, offsetX = defaultOffset, offsetY = defaultOffset } = grid;\n  const backgroundSelectorId = viewMode === \"docs\" ? `${BG_SELECTOR_BASE}-docs-${id}` : `${BG_SELECTOR_BASE}-color`;\n  const backgroundTarget = viewMode === \"docs\" ? id : null;\n  useEffect(() => {\n    const backgroundStyles = `\n    ${backgroundSelector} {\n      background: ${value} !important;\n      ${transitionStyle}\n      }`;\n    if (!shownBackground) {\n      clearStyles(backgroundSelectorId);\n      return;\n    }\n    addBackgroundStyle(backgroundSelectorId, backgroundStyles, backgroundTarget);\n  }, [backgroundSelector, backgroundSelectorId, backgroundTarget, shownBackground, value]);\n  const gridSelectorId = viewMode === \"docs\" ? `${GRID_SELECTOR_BASE}-docs-${id}` : `${GRID_SELECTOR_BASE}`;\n  useEffect(() => {\n    if (!showGrid) {\n      clearStyles(gridSelectorId);\n      return;\n    }\n    const gridSize = [\n      `${cellSize * cellAmount}px ${cellSize * cellAmount}px`,\n      `${cellSize * cellAmount}px ${cellSize * cellAmount}px`,\n      `${cellSize}px ${cellSize}px`,\n      `${cellSize}px ${cellSize}px`\n    ].join(\", \");\n    const gridStyles = `\n        ${gridSelector} {\n          background-size: ${gridSize} !important;\n          background-position: ${offsetX}px ${offsetY}px, ${offsetX}px ${offsetY}px, ${offsetX}px ${offsetY}px, ${offsetX}px ${offsetY}px !important;\n          background-blend-mode: difference !important;\n          background-image: linear-gradient(rgba(130, 130, 130, ${opacity}) 1px, transparent 1px),\n           linear-gradient(90deg, rgba(130, 130, 130, ${opacity}) 1px, transparent 1px),\n           linear-gradient(rgba(130, 130, 130, ${opacity / 2}) 1px, transparent 1px),\n           linear-gradient(90deg, rgba(130, 130, 130, ${opacity / 2}) 1px, transparent 1px) !important;\n        }\n      `;\n    addGridStyle(gridSelectorId, gridStyles);\n  }, [cellAmount, cellSize, gridSelector, gridSelectorId, showGrid, offsetX, offsetY, opacity]);\n  return StoryFn();\n}, \"withBackgroundAndGrid\");\n\n// src/backgrounds/preview.ts\nvar decorators = globalThis.FEATURES?.backgrounds ? [withBackgroundAndGrid] : [];\nvar parameters = {\n  [PARAM_KEY2]: {\n    grid: {\n      cellSize: 20,\n      opacity: 0.5,\n      cellAmount: 5\n    },\n    disable: false\n  }\n};\nvar initialGlobals = {\n  [PARAM_KEY2]: { value: void 0, grid: false }\n};\nvar preview_default2 = /* @__PURE__ */ __name(() => definePreviewAddon2({\n  decorators,\n  parameters,\n  initialGlobals\n}), \"default\");\n\n// src/component-testing/preview.ts\nimport { definePreviewAddon as definePreviewAddon3 } from \"storybook/internal/csf\";\nimport { instrument } from \"storybook/internal/instrumenter\";\nvar { step } = instrument(\n  {\n    // It seems like the label is unused, but the instrumenter has access to it\n    // The context will be bounded later in StoryRender, so that the user can write just:\n    // await step(\"label\", (context) => {\n    //   // labeled step\n    // });\n    step: /* @__PURE__ */ __name(async (label, play, context) => play(context), \"step\")\n  },\n  { intercept: true }\n);\nvar preview_default3 = /* @__PURE__ */ __name(() => definePreviewAddon3({\n  parameters: {\n    throwPlayFunctionExceptions: false\n  },\n  runStep: step\n}), \"default\");\n\n// src/highlight/preview.ts\nimport { definePreviewAddon as definePreviewAddon4 } from \"storybook/internal/csf\";\nimport { addons } from \"storybook/preview-api\";\n\n// src/highlight/useHighlights.ts\nimport { STORY_RENDER_PHASE_CHANGED } from \"storybook/internal/core-events\";\n\n// src/highlight/icons.ts\nvar iconPaths = {\n  chevronLeft: [\n    \"M9.10355 10.1464C9.29882 10.3417 9.29882 10.6583 9.10355 10.8536C8.90829 11.0488 8.59171 11.0488 8.39645 10.8536L4.89645 7.35355C4.70118 7.15829 4.70118 6.84171 4.89645 6.64645L8.39645 3.14645C8.59171 2.95118 8.90829 2.95118 9.10355 3.14645C9.29882 3.34171 9.29882 3.65829 9.10355 3.85355L5.95711 7L9.10355 10.1464Z\"\n  ],\n  chevronRight: [\n    \"M4.89645 10.1464C4.70118 10.3417 4.70118 10.6583 4.89645 10.8536C5.09171 11.0488 5.40829 11.0488 5.60355 10.8536L9.10355 7.35355C9.29882 7.15829 9.29882 6.84171 9.10355 6.64645L5.60355 3.14645C5.40829 2.95118 5.09171 2.95118 4.89645 3.14645C4.70118 3.34171 4.70118 3.65829 4.89645 3.85355L8.04289 7L4.89645 10.1464Z\"\n  ],\n  info: [\n    \"M7 5.5a.5.5 0 01.5.5v4a.5.5 0 01-1 0V6a.5.5 0 01.5-.5zM7 4.5A.75.75 0 107 3a.75.75 0 000 1.5z\",\n    \"M7 14A7 7 0 107 0a7 7 0 000 14zm0-1A6 6 0 107 1a6 6 0 000 12z\"\n  ],\n  shareAlt: [\n    \"M2 1.004a1 1 0 00-1 1v10a1 1 0 001 1h10a1 1 0 001-1v-4.5a.5.5 0 00-1 0v4.5H2v-10h4.5a.5.5 0 000-1H2z\",\n    \"M7.354 7.357L12 2.711v1.793a.5.5 0 001 0v-3a.5.5 0 00-.5-.5h-3a.5.5 0 100 1h1.793L6.646 6.65a.5.5 0 10.708.707z\"\n  ]\n};\n\n// src/highlight/utils.ts\nvar svgElements = \"svg,path,rect,circle,line,polyline,polygon,ellipse,text\".split(\",\");\nvar createElement = /* @__PURE__ */ __name((type, props = {}, children) => {\n  const element = svgElements.includes(type) ? document.createElementNS(\"http://www.w3.org/2000/svg\", type) : document.createElement(type);\n  Object.entries(props).forEach(([key, val]) => {\n    if (/[A-Z]/.test(key)) {\n      if (key === \"onClick\") {\n        element.addEventListener(\"click\", val);\n        element.addEventListener(\"keydown\", (e) => {\n          if (e.key === \"Enter\" || e.key === \" \") {\n            e.preventDefault();\n            val();\n          }\n        });\n      }\n      if (key === \"onMouseEnter\") {\n        element.addEventListener(\"mouseenter\", val);\n      }\n      if (key === \"onMouseLeave\") {\n        element.addEventListener(\"mouseleave\", val);\n      }\n    } else {\n      element.setAttribute(key, val);\n    }\n  });\n  children?.forEach((child) => {\n    if (child === null || child === void 0 || child === false) {\n      return;\n    }\n    try {\n      element.appendChild(child);\n    } catch (e) {\n      element.appendChild(document.createTextNode(String(child)));\n    }\n  });\n  return element;\n}, \"createElement\");\nvar createIcon = /* @__PURE__ */ __name((name) => iconPaths[name] && createElement(\n  \"svg\",\n  { width: \"14\", height: \"14\", viewBox: \"0 0 14 14\", xmlns: \"http://www.w3.org/2000/svg\" },\n  iconPaths[name].map(\n    (d) => createElement(\"path\", {\n      fill: \"currentColor\",\n      \"fill-rule\": \"evenodd\",\n      \"clip-rule\": \"evenodd\",\n      d\n    })\n  )\n), \"createIcon\");\nvar normalizeOptions = /* @__PURE__ */ __name((options) => {\n  if (\"elements\" in options) {\n    const { elements, color, style } = options;\n    return {\n      id: void 0,\n      priority: 0,\n      selectors: elements,\n      styles: {\n        outline: `2px ${style} ${color}`,\n        outlineOffset: \"2px\",\n        boxShadow: \"0 0 0 6px rgba(255,255,255,0.6)\"\n      },\n      menu: void 0\n    };\n  }\n  const { menu, ...rest } = options;\n  return {\n    id: void 0,\n    priority: 0,\n    styles: {\n      outline: \"2px dashed #029cfd\"\n    },\n    ...rest,\n    menu: Array.isArray(menu) ? menu.every(Array.isArray) ? menu : [menu] : void 0\n  };\n}, \"normalizeOptions\");\nvar isFunction = /* @__PURE__ */ __name((obj) => obj instanceof Function, \"isFunction\");\nvar state = /* @__PURE__ */ new Map();\nvar listeners = /* @__PURE__ */ new Map();\nvar teardowns = /* @__PURE__ */ new Map();\nvar useStore = /* @__PURE__ */ __name((initialValue) => {\n  const key = Symbol();\n  listeners.set(key, []);\n  state.set(key, initialValue);\n  const get = /* @__PURE__ */ __name(() => state.get(key), \"get\");\n  const set = /* @__PURE__ */ __name((update) => {\n    const current = state.get(key);\n    const next = isFunction(update) ? update(current) : update;\n    if (next !== current) {\n      state.set(key, next);\n      listeners.get(key)?.forEach((listener) => {\n        teardowns.get(listener)?.();\n        teardowns.set(listener, listener(next));\n      });\n    }\n  }, \"set\");\n  const subscribe = /* @__PURE__ */ __name((listener) => {\n    listeners.get(key)?.push(listener);\n    return () => {\n      const list = listeners.get(key);\n      if (list) {\n        listeners.set(\n          key,\n          list.filter((l) => l !== listener)\n        );\n      }\n    };\n  }, \"subscribe\");\n  const teardown = /* @__PURE__ */ __name(() => {\n    listeners.get(key)?.forEach((listener) => {\n      teardowns.get(listener)?.();\n      teardowns.delete(listener);\n    });\n    listeners.delete(key);\n    state.delete(key);\n  }, \"teardown\");\n  return { get, set, subscribe, teardown };\n}, \"useStore\");\nvar mapElements = /* @__PURE__ */ __name((highlights) => {\n  const root = document.getElementById(\"storybook-root\");\n  const map = /* @__PURE__ */ new Map();\n  for (const highlight of highlights) {\n    const { priority = 0 } = highlight;\n    for (const selector of highlight.selectors) {\n      const elements = [\n        ...document.querySelectorAll(\n          // Elements matching the selector, excluding storybook elements and their descendants.\n          // Necessary to find portaled elements (e.g. children of `body`).\n          `:is(${selector}):not([id^=\"storybook-\"], [id^=\"storybook-\"] *, [class^=\"sb-\"], [class^=\"sb-\"] *)`\n        ),\n        // Elements matching the selector inside the storybook root, as these were excluded above.\n        ...root?.querySelectorAll(selector) || []\n      ];\n      for (const element of elements) {\n        const existing = map.get(element);\n        if (!existing || existing.priority <= priority) {\n          map.set(element, {\n            ...highlight,\n            priority,\n            selectors: Array.from(new Set((existing?.selectors || []).concat(selector)))\n          });\n        }\n      }\n    }\n  }\n  return map;\n}, \"mapElements\");\nvar mapBoxes = /* @__PURE__ */ __name((elements) => Array.from(elements.entries()).map(([element, { selectors, styles, hoverStyles, focusStyles, menu }]) => {\n  const { top, left, width, height } = element.getBoundingClientRect();\n  const { position } = getComputedStyle(element);\n  return {\n    element,\n    selectors,\n    styles,\n    hoverStyles,\n    focusStyles,\n    menu,\n    top: position === \"fixed\" ? top : top + window.scrollY,\n    left: position === \"fixed\" ? left : left + window.scrollX,\n    width,\n    height\n  };\n}).sort((a, b) => b.width * b.height - a.width * a.height), \"mapBoxes\");\nvar isOverMenu = /* @__PURE__ */ __name((menuElement, coordinates) => {\n  const menu = menuElement.getBoundingClientRect();\n  const { x, y } = coordinates;\n  return menu?.top && menu?.left && x >= menu.left && x <= menu.left + menu.width && y >= menu.top && y <= menu.top + menu.height;\n}, \"isOverMenu\");\nvar isTargeted = /* @__PURE__ */ __name((box, boxElement, coordinates) => {\n  if (!boxElement || !coordinates) {\n    return false;\n  }\n  let { left, top, width, height } = box;\n  if (height < MIN_TOUCH_AREA_SIZE) {\n    top = top - Math.round((MIN_TOUCH_AREA_SIZE - height) / 2);\n    height = MIN_TOUCH_AREA_SIZE;\n  }\n  if (width < MIN_TOUCH_AREA_SIZE) {\n    left = left - Math.round((MIN_TOUCH_AREA_SIZE - width) / 2);\n    width = MIN_TOUCH_AREA_SIZE;\n  }\n  if (boxElement.style.position === \"fixed\") {\n    left += window.scrollX;\n    top += window.scrollY;\n  }\n  const { x, y } = coordinates;\n  return x >= left && x <= left + width && y >= top && y <= top + height;\n}, \"isTargeted\");\nvar keepInViewport = /* @__PURE__ */ __name((element, targetCoordinates, options = {}) => {\n  const { x, y } = targetCoordinates;\n  const { margin = 5, topOffset = 0, centered = false } = options;\n  const { scrollX, scrollY, innerHeight: windowHeight, innerWidth: windowWidth } = window;\n  const top = Math.min(\n    element.style.position === \"fixed\" ? y - scrollY : y,\n    windowHeight - element.clientHeight - margin - topOffset + scrollY\n  );\n  const leftOffset = centered ? element.clientWidth / 2 : 0;\n  const left = element.style.position === \"fixed\" ? Math.max(Math.min(x - scrollX, windowWidth - leftOffset - margin), leftOffset + margin) : Math.max(\n    Math.min(x, windowWidth - leftOffset - margin + scrollX),\n    leftOffset + margin + scrollX\n  );\n  Object.assign(element.style, {\n    ...left !== x && { left: `${left}px` },\n    ...top !== y && { top: `${top}px` }\n  });\n}, \"keepInViewport\");\nvar showPopover = /* @__PURE__ */ __name((element) => {\n  if (window.HTMLElement.prototype.hasOwnProperty(\"showPopover\")) {\n    element.showPopover();\n  }\n}, \"showPopover\");\nvar hidePopover = /* @__PURE__ */ __name((element) => {\n  if (window.HTMLElement.prototype.hasOwnProperty(\"showPopover\")) {\n    element.hidePopover();\n  }\n}, \"hidePopover\");\nvar getEventDetails = /* @__PURE__ */ __name((target) => ({\n  top: target.top,\n  left: target.left,\n  width: target.width,\n  height: target.height,\n  selectors: target.selectors,\n  element: {\n    attributes: Object.fromEntries(\n      Array.from(target.element.attributes).map((attr) => [attr.name, attr.value])\n    ),\n    localName: target.element.localName,\n    tagName: target.element.tagName,\n    outerHTML: target.element.outerHTML\n  }\n}), \"getEventDetails\");\n\n// src/highlight/useHighlights.ts\nvar menuId = \"storybook-highlights-menu\";\nvar rootId = \"storybook-highlights-root\";\nvar storybookRootId = \"storybook-root\";\nvar useHighlights = /* @__PURE__ */ __name((channel) => {\n  if (globalThis.__STORYBOOK_HIGHLIGHT_INITIALIZED) {\n    return;\n  }\n  globalThis.__STORYBOOK_HIGHLIGHT_INITIALIZED = true;\n  const { document: document3 } = globalThis;\n  const highlights = useStore([]);\n  const elements = useStore(/* @__PURE__ */ new Map());\n  const boxes = useStore([]);\n  const clickCoords = useStore();\n  const hoverCoords = useStore();\n  const targets = useStore([]);\n  const hovered = useStore([]);\n  const focused = useStore();\n  const selected = useStore();\n  let root = document3.getElementById(rootId);\n  highlights.subscribe(() => {\n    if (!root) {\n      root = createElement(\"div\", { id: rootId });\n      document3.body.appendChild(root);\n    }\n  });\n  highlights.subscribe((value) => {\n    const storybookRoot = document3.getElementById(storybookRootId);\n    if (!storybookRoot) {\n      return;\n    }\n    elements.set(mapElements(value));\n    const observer = new MutationObserver(() => elements.set(mapElements(value)));\n    observer.observe(storybookRoot, { subtree: true, childList: true });\n    return () => {\n      observer.disconnect();\n    };\n  });\n  elements.subscribe((value) => {\n    const updateBoxes = /* @__PURE__ */ __name(() => requestAnimationFrame(() => boxes.set(mapBoxes(value))), \"updateBoxes\");\n    const observer = new ResizeObserver(updateBoxes);\n    observer.observe(document3.body);\n    Array.from(value.keys()).forEach((element) => observer.observe(element));\n    const scrollers = Array.from(document3.body.querySelectorAll(\"*\")).filter((el) => {\n      const { overflow, overflowX, overflowY } = window.getComputedStyle(el);\n      return [\"auto\", \"scroll\"].some((o) => [overflow, overflowX, overflowY].includes(o));\n    });\n    scrollers.forEach((element) => element.addEventListener(\"scroll\", updateBoxes));\n    return () => {\n      observer.disconnect();\n      scrollers.forEach((element) => element.removeEventListener(\"scroll\", updateBoxes));\n    };\n  });\n  elements.subscribe((value) => {\n    const sticky = Array.from(value.keys()).filter(({ style }) => style.position === \"sticky\");\n    const updateBoxes = /* @__PURE__ */ __name(() => requestAnimationFrame(() => {\n      boxes.set(\n        (current) => current.map((box) => {\n          if (sticky.includes(box.element)) {\n            const { top, left } = box.element.getBoundingClientRect();\n            return { ...box, top: top + window.scrollY, left: left + window.scrollX };\n          }\n          return box;\n        })\n      );\n    }), \"updateBoxes\");\n    document3.addEventListener(\"scroll\", updateBoxes);\n    return () => document3.removeEventListener(\"scroll\", updateBoxes);\n  });\n  elements.subscribe((value) => {\n    targets.set((t) => t.filter(({ element }) => value.has(element)));\n  });\n  targets.subscribe((value) => {\n    if (value.length) {\n      selected.set((s) => value.some((t) => t.element === s?.element) ? s : void 0);\n      focused.set((s) => value.some((t) => t.element === s?.element) ? s : void 0);\n    } else {\n      selected.set(void 0);\n      focused.set(void 0);\n      clickCoords.set(void 0);\n    }\n  });\n  const styleElementByHighlight = new Map(/* @__PURE__ */ new Map());\n  highlights.subscribe((value) => {\n    value.forEach(({ keyframes }) => {\n      if (keyframes) {\n        let style = styleElementByHighlight.get(keyframes);\n        if (!style) {\n          style = document3.createElement(\"style\");\n          style.setAttribute(\"data-highlight\", \"keyframes\");\n          styleElementByHighlight.set(keyframes, style);\n          document3.head.appendChild(style);\n        }\n        style.innerHTML = keyframes;\n      }\n    });\n    styleElementByHighlight.forEach((style, keyframes) => {\n      if (!value.some((v) => v.keyframes === keyframes)) {\n        style.remove();\n        styleElementByHighlight.delete(keyframes);\n      }\n    });\n  });\n  const boxElementByTargetElement = new Map(/* @__PURE__ */ new Map());\n  boxes.subscribe((value) => {\n    value.forEach((box) => {\n      let boxElement = boxElementByTargetElement.get(box.element);\n      if (root && !boxElement) {\n        const props = {\n          popover: \"manual\",\n          \"data-highlight-dimensions\": `w${box.width.toFixed(0)}h${box.height.toFixed(0)}`,\n          \"data-highlight-coordinates\": `x${box.left.toFixed(0)}y${box.top.toFixed(0)}`\n        };\n        boxElement = root.appendChild(\n          createElement(\"div\", props, [createElement(\"div\")])\n        );\n        boxElementByTargetElement.set(box.element, boxElement);\n      }\n    });\n    boxElementByTargetElement.forEach((box, element) => {\n      if (!value.some(({ element: e }) => e === element)) {\n        box.remove();\n        boxElementByTargetElement.delete(element);\n      }\n    });\n  });\n  boxes.subscribe((value) => {\n    const targetable = value.filter((box) => box.menu);\n    if (!targetable.length) {\n      return;\n    }\n    const onClick = /* @__PURE__ */ __name((event) => {\n      requestAnimationFrame(() => {\n        const menu = document3.getElementById(menuId);\n        const coords = { x: event.pageX, y: event.pageY };\n        if (menu && !isOverMenu(menu, coords)) {\n          const results = targetable.filter((box) => {\n            const boxElement = boxElementByTargetElement.get(box.element);\n            return isTargeted(box, boxElement, coords);\n          });\n          clickCoords.set(results.length ? coords : void 0);\n          targets.set(results);\n        }\n      });\n    }, \"onClick\");\n    document3.addEventListener(\"click\", onClick);\n    return () => document3.removeEventListener(\"click\", onClick);\n  });\n  const updateHovered = /* @__PURE__ */ __name(() => {\n    const menu = document3.getElementById(menuId);\n    const coords = hoverCoords.get();\n    if (!coords || menu && isOverMenu(menu, coords)) {\n      return;\n    }\n    hovered.set((current) => {\n      const update = boxes.get().filter((box) => {\n        const boxElement = boxElementByTargetElement.get(box.element);\n        return isTargeted(box, boxElement, coords);\n      });\n      const existing = current.filter((box) => update.includes(box));\n      const additions = update.filter((box) => !current.includes(box));\n      const hasRemovals = current.length - existing.length;\n      return additions.length || hasRemovals ? [...existing, ...additions] : current;\n    });\n  }, \"updateHovered\");\n  hoverCoords.subscribe(updateHovered);\n  boxes.subscribe(updateHovered);\n  const updateBoxStyles = /* @__PURE__ */ __name(() => {\n    const selectedElement = selected.get();\n    const targetElements = selectedElement ? [selectedElement] : targets.get();\n    const focusedElement = targetElements.length === 1 ? targetElements[0] : focused.get();\n    const isMenuOpen = clickCoords.get() !== void 0;\n    boxes.get().forEach((box) => {\n      const boxElement = boxElementByTargetElement.get(box.element);\n      if (boxElement) {\n        const isFocused = focusedElement === box;\n        const isHovered = isMenuOpen ? focusedElement ? isFocused : targetElements.includes(box) : hovered.get()?.includes(box);\n        Object.assign(boxElement.style, {\n          animation: \"none\",\n          background: \"transparent\",\n          border: \"none\",\n          boxSizing: \"border-box\",\n          outline: \"none\",\n          outlineOffset: \"0px\",\n          ...box.styles,\n          ...isHovered ? box.hoverStyles : {},\n          ...isFocused ? box.focusStyles : {},\n          position: getComputedStyle(box.element).position === \"fixed\" ? \"fixed\" : \"absolute\",\n          zIndex: MAX_Z_INDEX - 10,\n          top: `${box.top}px`,\n          left: `${box.left}px`,\n          width: `${box.width}px`,\n          height: `${box.height}px`,\n          margin: 0,\n          padding: 0,\n          cursor: box.menu && isHovered ? \"pointer\" : \"default\",\n          pointerEvents: box.menu ? \"auto\" : \"none\",\n          display: \"flex\",\n          alignItems: \"center\",\n          justifyContent: \"center\",\n          overflow: \"visible\"\n        });\n        Object.assign(boxElement.children[0].style, {\n          width: \"100%\",\n          height: \"100%\",\n          minHeight: `${MIN_TOUCH_AREA_SIZE}px`,\n          minWidth: `${MIN_TOUCH_AREA_SIZE}px`,\n          boxSizing: \"content-box\",\n          padding: boxElement.style.outlineWidth || \"0px\"\n        });\n        showPopover(boxElement);\n      }\n    });\n  }, \"updateBoxStyles\");\n  boxes.subscribe(updateBoxStyles);\n  targets.subscribe(updateBoxStyles);\n  hovered.subscribe(updateBoxStyles);\n  focused.subscribe(updateBoxStyles);\n  selected.subscribe(updateBoxStyles);\n  const renderMenu = /* @__PURE__ */ __name(() => {\n    if (!root) {\n      return;\n    }\n    let menu = document3.getElementById(menuId);\n    if (menu) {\n      menu.innerHTML = \"\";\n    } else {\n      const props = { id: menuId, popover: \"manual\" };\n      menu = root.appendChild(createElement(\"div\", props));\n      root.appendChild(\n        createElement(\"style\", {}, [\n          `\n            #${menuId} {\n              position: absolute;\n              z-index: ${MAX_Z_INDEX};\n              width: 300px;\n              padding: 0px;\n              margin: 15px 0 0 0;\n              transform: translateX(-50%);\n              font-family: \"Nunito Sans\", -apple-system, \".SFNSText-Regular\", \"San Francisco\", BlinkMacSystemFont, \"Segoe UI\", \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n              font-size: 12px;\n              background: white;\n              border: none;\n              border-radius: 6px;\n              box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.05), 0 5px 15px 0 rgba(0, 0, 0, 0.1);\n              color: #2E3438;\n            }\n            #${menuId} ul {\n              list-style: none;\n              margin: 0;\n              padding: 0;\n            }\n            #${menuId} > ul {\n              max-height: 300px;\n              overflow-y: auto;\n              padding: 4px 0;\n            }\n            #${menuId} li {\n              padding: 0 4px;\n              margin: 0;\n            }\n            #${menuId} li > :not(ul) {\n              display: flex;\n              padding: 8px;\n              margin: 0;\n              align-items: center;\n              gap: 8px;\n              border-radius: 4px;\n            }\n            #${menuId} button {\n              width: 100%;\n              border: 0;\n              background: transparent;\n              color: inherit;\n              text-align: left;\n              font-family: inherit;\n              font-size: inherit;\n            }\n            #${menuId} button:focus-visible {\n              outline-color: #029CFD;\n            }\n            #${menuId} button:hover {\n              background: rgba(2, 156, 253, 0.07);\n              color: #029CFD;\n              cursor: pointer;\n            }\n            #${menuId} li code {\n              white-space: nowrap;\n              overflow: hidden;\n              text-overflow: ellipsis;\n              line-height: 16px;\n              font-size: 11px;\n            }\n            #${menuId} li svg {\n              flex-shrink: 0;\n              margin: 1px;\n              color: #73828C;\n            }\n            #${menuId} li > button:hover svg, #${menuId} li > button:focus-visible svg {\n              color: #029CFD;\n            }\n            #${menuId} .element-list li svg {\n              display: none;\n            }\n            #${menuId} li.selectable svg, #${menuId} li.selected svg {\n              display: block;\n            }\n            #${menuId} .menu-list {\n              border-top: 1px solid rgba(38, 85, 115, 0.15);\n            }\n            #${menuId} .menu-list > li:not(:last-child) {\n              padding-bottom: 4px;\n              margin-bottom: 4px;\n              border-bottom: 1px solid rgba(38, 85, 115, 0.15);\n            }\n            #${menuId} .menu-items, #${menuId} .menu-items li {\n              padding: 0;\n            }\n            #${menuId} .menu-item {\n              display: flex;\n            }\n            #${menuId} .menu-item-content {\n              display: flex;\n              flex-direction: column;\n              flex-grow: 1;\n            }\n          `\n        ])\n      );\n    }\n    const selectedElement = selected.get();\n    const elementList = selectedElement ? [selectedElement] : targets.get();\n    if (elementList.length) {\n      menu.style.position = getComputedStyle(elementList[0].element).position === \"fixed\" ? \"fixed\" : \"absolute\";\n      menu.appendChild(\n        createElement(\n          \"ul\",\n          { class: \"element-list\" },\n          elementList.map((target) => {\n            const selectable = elementList.length > 1 && !!target.menu?.some(\n              (group) => group.some(\n                (item) => !item.selectors || item.selectors.some((s) => target.selectors.includes(s))\n              )\n            );\n            const props = selectable ? {\n              class: \"selectable\",\n              onClick: /* @__PURE__ */ __name(() => selected.set(target), \"onClick\"),\n              onMouseEnter: /* @__PURE__ */ __name(() => focused.set(target), \"onMouseEnter\"),\n              onMouseLeave: /* @__PURE__ */ __name(() => focused.set(void 0), \"onMouseLeave\")\n            } : selectedElement ? { class: \"selected\", onClick: /* @__PURE__ */ __name(() => selected.set(void 0), \"onClick\") } : {};\n            const asButton = selectable || selectedElement;\n            return createElement(\"li\", props, [\n              createElement(asButton ? \"button\" : \"div\", asButton ? { type: \"button\" } : {}, [\n                selectedElement ? createIcon(\"chevronLeft\") : null,\n                createElement(\"code\", {}, [target.element.outerHTML]),\n                selectable ? createIcon(\"chevronRight\") : null\n              ])\n            ]);\n          })\n        )\n      );\n    }\n    if (selected.get() || targets.get().length === 1) {\n      const target = selected.get() || targets.get()[0];\n      const menuGroups = target.menu?.filter(\n        (group) => group.some(\n          (item) => !item.selectors || item.selectors.some((s) => target.selectors.includes(s))\n        )\n      );\n      if (menuGroups?.length) {\n        menu.appendChild(\n          createElement(\n            \"ul\",\n            { class: \"menu-list\" },\n            menuGroups.map(\n              (menuItems) => createElement(\"li\", {}, [\n                createElement(\n                  \"ul\",\n                  { class: \"menu-items\" },\n                  menuItems.map(\n                    ({ id, title, description, iconLeft, iconRight, clickEvent: event }) => {\n                      const onClick = event && (() => channel.emit(event, id, getEventDetails(target)));\n                      return createElement(\"li\", {}, [\n                        createElement(\n                          onClick ? \"button\" : \"div\",\n                          onClick ? { class: \"menu-item\", type: \"button\", onClick } : { class: \"menu-item\" },\n                          [\n                            iconLeft ? createIcon(iconLeft) : null,\n                            createElement(\"div\", { class: \"menu-item-content\" }, [\n                              createElement(description ? \"strong\" : \"span\", {}, [title]),\n                              description && createElement(\"span\", {}, [description])\n                            ]),\n                            iconRight ? createIcon(iconRight) : null\n                          ]\n                        )\n                      ]);\n                    }\n                  )\n                )\n              ])\n            )\n          )\n        );\n      }\n    }\n    const coords = clickCoords.get();\n    if (coords) {\n      Object.assign(menu.style, {\n        display: \"block\",\n        left: `${menu.style.position === \"fixed\" ? coords.x - window.scrollX : coords.x}px`,\n        top: `${menu.style.position === \"fixed\" ? coords.y - window.scrollY : coords.y}px`\n      });\n      showPopover(menu);\n      requestAnimationFrame(() => keepInViewport(menu, coords, { topOffset: 15, centered: true }));\n    } else {\n      hidePopover(menu);\n      Object.assign(menu.style, { display: \"none\" });\n    }\n  }, \"renderMenu\");\n  targets.subscribe(renderMenu);\n  selected.subscribe(renderMenu);\n  const addHighlight = /* @__PURE__ */ __name((highlight) => {\n    const info = normalizeOptions(highlight);\n    highlights.set((value) => {\n      const others = info.id ? value.filter((h) => h.id !== info.id) : value;\n      return info.selectors?.length ? [...others, info] : others;\n    });\n  }, \"addHighlight\");\n  const removeHighlight = /* @__PURE__ */ __name((id) => {\n    if (id) {\n      highlights.set((value) => value.filter((h) => h.id !== id));\n    }\n  }, \"removeHighlight\");\n  const resetState = /* @__PURE__ */ __name(() => {\n    highlights.set([]);\n    elements.set(/* @__PURE__ */ new Map());\n    boxes.set([]);\n    clickCoords.set(void 0);\n    hoverCoords.set(void 0);\n    targets.set([]);\n    hovered.set([]);\n    focused.set(void 0);\n    selected.set(void 0);\n  }, \"resetState\");\n  let removeTimeout;\n  const scrollIntoView = /* @__PURE__ */ __name((target, options) => {\n    const id = \"scrollIntoView-highlight\";\n    clearTimeout(removeTimeout);\n    removeHighlight(id);\n    const element = document3.querySelector(target);\n    if (!element) {\n      console.warn(`Cannot scroll into view: ${target} not found`);\n      return;\n    }\n    element.scrollIntoView({ behavior: \"smooth\", block: \"center\", ...options });\n    const keyframeName = `kf-${Math.random().toString(36).substring(2, 15)}`;\n    highlights.set((value) => [\n      ...value,\n      {\n        id,\n        priority: 1e3,\n        selectors: [target],\n        styles: {\n          outline: \"2px solid #1EA7FD\",\n          outlineOffset: \"-1px\",\n          animation: `${keyframeName} 3s linear forwards`\n        },\n        keyframes: `@keyframes ${keyframeName} {\n          0% { outline: 2px solid #1EA7FD; }\n          20% { outline: 2px solid #1EA7FD00; }\n          40% { outline: 2px solid #1EA7FD; }\n          60% { outline: 2px solid #1EA7FD00; }\n          80% { outline: 2px solid #1EA7FD; }\n          100% { outline: 2px solid #1EA7FD00; }\n        }`\n      }\n    ]);\n    removeTimeout = setTimeout(() => removeHighlight(id), 3500);\n  }, \"scrollIntoView\");\n  const onMouseMove = /* @__PURE__ */ __name((event) => {\n    requestAnimationFrame(() => hoverCoords.set({ x: event.pageX, y: event.pageY }));\n  }, \"onMouseMove\");\n  document3.body.addEventListener(\"mousemove\", onMouseMove);\n  channel.on(HIGHLIGHT, addHighlight);\n  channel.on(REMOVE_HIGHLIGHT, removeHighlight);\n  channel.on(RESET_HIGHLIGHT, resetState);\n  channel.on(SCROLL_INTO_VIEW, scrollIntoView);\n  channel.on(STORY_RENDER_PHASE_CHANGED, ({ newPhase }) => {\n    if (newPhase === \"loading\") {\n      resetState();\n    }\n  });\n}, \"useHighlights\");\n\n// src/highlight/preview.ts\nif (globalThis?.FEATURES?.highlight && addons?.ready) {\n  addons.ready().then(useHighlights);\n}\nvar preview_default4 = /* @__PURE__ */ __name(() => definePreviewAddon4({}), \"default\");\n\n// src/measure/preview.ts\nimport { definePreviewAddon as definePreviewAddon5 } from \"storybook/internal/csf\";\n\n// src/measure/withMeasure.ts\nimport { useEffect as useEffect2 } from \"storybook/preview-api\";\n\n// src/measure/box-model/canvas.ts\nimport { global } from \"@storybook/global\";\nfunction getDocumentWidthAndHeight() {\n  const container = global.document.documentElement;\n  const height = Math.max(container.scrollHeight, container.offsetHeight);\n  const width = Math.max(container.scrollWidth, container.offsetWidth);\n  return { width, height };\n}\n__name(getDocumentWidthAndHeight, \"getDocumentWidthAndHeight\");\nfunction createCanvas() {\n  const canvas = global.document.createElement(\"canvas\");\n  canvas.id = \"storybook-addon-measure\";\n  const context = canvas.getContext(\"2d\");\n  invariant(context != null);\n  const { width, height } = getDocumentWidthAndHeight();\n  setCanvasWidthAndHeight(canvas, context, { width, height });\n  canvas.style.position = \"absolute\";\n  canvas.style.left = \"0\";\n  canvas.style.top = \"0\";\n  canvas.style.zIndex = \"2147483647\";\n  canvas.style.pointerEvents = \"none\";\n  global.document.body.appendChild(canvas);\n  return { canvas, context, width, height };\n}\n__name(createCanvas, \"createCanvas\");\nfunction setCanvasWidthAndHeight(canvas, context, { width, height }) {\n  canvas.style.width = `${width}px`;\n  canvas.style.height = `${height}px`;\n  const scale = global.window.devicePixelRatio;\n  canvas.width = Math.floor(width * scale);\n  canvas.height = Math.floor(height * scale);\n  context.scale(scale, scale);\n}\n__name(setCanvasWidthAndHeight, \"setCanvasWidthAndHeight\");\nvar state2 = {};\nfunction init() {\n  if (!state2.canvas) {\n    state2 = createCanvas();\n  }\n}\n__name(init, \"init\");\nfunction clear() {\n  if (state2.context) {\n    state2.context.clearRect(0, 0, state2.width ?? 0, state2.height ?? 0);\n  }\n}\n__name(clear, \"clear\");\nfunction draw(callback) {\n  clear();\n  callback(state2.context);\n}\n__name(draw, \"draw\");\nfunction rescale() {\n  invariant(state2.canvas, \"Canvas should exist in the state.\");\n  invariant(state2.context, \"Context should exist in the state.\");\n  setCanvasWidthAndHeight(state2.canvas, state2.context, { width: 0, height: 0 });\n  const { width, height } = getDocumentWidthAndHeight();\n  setCanvasWidthAndHeight(state2.canvas, state2.context, { width, height });\n  state2.width = width;\n  state2.height = height;\n}\n__name(rescale, \"rescale\");\nfunction destroy() {\n  if (state2.canvas) {\n    clear();\n    state2.canvas.parentNode?.removeChild(state2.canvas);\n    state2 = {};\n  }\n}\n__name(destroy, \"destroy\");\n\n// src/measure/box-model/visualizer.ts\nimport { global as global2 } from \"@storybook/global\";\n\n// src/measure/box-model/labels.ts\nvar colors = {\n  margin: \"#f6b26b\",\n  border: \"#ffe599\",\n  padding: \"#93c47d\",\n  content: \"#6fa8dc\",\n  text: \"#232020\"\n};\nvar labelPadding = 6;\nfunction roundedRect(context, { x, y, w, h, r }) {\n  x = x - w / 2;\n  y = y - h / 2;\n  if (w < 2 * r) {\n    r = w / 2;\n  }\n  if (h < 2 * r) {\n    r = h / 2;\n  }\n  context.beginPath();\n  context.moveTo(x + r, y);\n  context.arcTo(x + w, y, x + w, y + h, r);\n  context.arcTo(x + w, y + h, x, y + h, r);\n  context.arcTo(x, y + h, x, y, r);\n  context.arcTo(x, y, x + w, y, r);\n  context.closePath();\n}\n__name(roundedRect, \"roundedRect\");\nfunction positionCoordinate(position, { padding, border, width, height, top, left }) {\n  const contentWidth = width - border.left - border.right - padding.left - padding.right;\n  const contentHeight = height - padding.top - padding.bottom - border.top - border.bottom;\n  let x = left + border.left + padding.left;\n  let y = top + border.top + padding.top;\n  if (position === \"top\") {\n    x += contentWidth / 2;\n  } else if (position === \"right\") {\n    x += contentWidth;\n    y += contentHeight / 2;\n  } else if (position === \"bottom\") {\n    x += contentWidth / 2;\n    y += contentHeight;\n  } else if (position === \"left\") {\n    y += contentHeight / 2;\n  } else if (position === \"center\") {\n    x += contentWidth / 2;\n    y += contentHeight / 2;\n  }\n  return { x, y };\n}\n__name(positionCoordinate, \"positionCoordinate\");\nfunction offset(type, position, { margin, border, padding }, labelPaddingSize, external) {\n  let shift = /* @__PURE__ */ __name((dir) => 0, \"shift\");\n  let offsetX = 0;\n  let offsetY = 0;\n  const locationMultiplier = external ? 1 : 0.5;\n  const labelPaddingShift = external ? labelPaddingSize * 2 : 0;\n  if (type === \"padding\") {\n    shift = /* @__PURE__ */ __name((dir) => padding[dir] * locationMultiplier + labelPaddingShift, \"shift\");\n  } else if (type === \"border\") {\n    shift = /* @__PURE__ */ __name((dir) => padding[dir] + border[dir] * locationMultiplier + labelPaddingShift, \"shift\");\n  } else if (type === \"margin\") {\n    shift = /* @__PURE__ */ __name((dir) => padding[dir] + border[dir] + margin[dir] * locationMultiplier + labelPaddingShift, \"shift\");\n  }\n  if (position === \"top\") {\n    offsetY = -shift(\"top\");\n  } else if (position === \"right\") {\n    offsetX = shift(\"right\");\n  } else if (position === \"bottom\") {\n    offsetY = shift(\"bottom\");\n  } else if (position === \"left\") {\n    offsetX = -shift(\"left\");\n  }\n  return { offsetX, offsetY };\n}\n__name(offset, \"offset\");\nfunction collide(a, b) {\n  return Math.abs(a.x - b.x) < Math.abs(a.w + b.w) / 2 && Math.abs(a.y - b.y) < Math.abs(a.h + b.h) / 2;\n}\n__name(collide, \"collide\");\nfunction overlapAdjustment(position, currentRect, prevRect) {\n  if (position === \"top\") {\n    currentRect.y = prevRect.y - prevRect.h - labelPadding;\n  } else if (position === \"right\") {\n    currentRect.x = prevRect.x + prevRect.w / 2 + labelPadding + currentRect.w / 2;\n  } else if (position === \"bottom\") {\n    currentRect.y = prevRect.y + prevRect.h + labelPadding;\n  } else if (position === \"left\") {\n    currentRect.x = prevRect.x - prevRect.w / 2 - labelPadding - currentRect.w / 2;\n  }\n  return { x: currentRect.x, y: currentRect.y };\n}\n__name(overlapAdjustment, \"overlapAdjustment\");\nfunction textWithRect(context, type, { x, y, w, h }, text) {\n  roundedRect(context, { x, y, w, h, r: 3 });\n  context.fillStyle = `${colors[type]}dd`;\n  context.fill();\n  context.strokeStyle = colors[type];\n  context.stroke();\n  context.fillStyle = colors.text;\n  context.fillText(text, x, y);\n  roundedRect(context, { x, y, w, h, r: 3 });\n  context.fillStyle = `${colors[type]}dd`;\n  context.fill();\n  context.strokeStyle = colors[type];\n  context.stroke();\n  context.fillStyle = colors.text;\n  context.fillText(text, x, y);\n  return { x, y, w, h };\n}\n__name(textWithRect, \"textWithRect\");\nfunction configureText(context, text) {\n  context.font = \"600 12px monospace\";\n  context.textBaseline = \"middle\";\n  context.textAlign = \"center\";\n  const metrics = context.measureText(text);\n  const actualHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;\n  const w = metrics.width + labelPadding * 2;\n  const h = actualHeight + labelPadding * 2;\n  return { w, h };\n}\n__name(configureText, \"configureText\");\nfunction drawLabel(context, measurements, { type, position = \"center\", text }, prevRect, external = false) {\n  let { x, y } = positionCoordinate(position, measurements);\n  const { offsetX, offsetY } = offset(type, position, measurements, labelPadding + 1, external);\n  x += offsetX;\n  y += offsetY;\n  const { w, h } = configureText(context, text);\n  if (prevRect && collide({ x, y, w, h }, prevRect)) {\n    const adjusted = overlapAdjustment(position, { x, y, w, h }, prevRect);\n    x = adjusted.x;\n    y = adjusted.y;\n  }\n  return textWithRect(context, type, { x, y, w, h }, text);\n}\n__name(drawLabel, \"drawLabel\");\nfunction floatingOffset(alignment, { w, h }) {\n  const deltaW = w * 0.5 + labelPadding;\n  const deltaH = h * 0.5 + labelPadding;\n  return {\n    offsetX: (alignment.x === \"left\" ? -1 : 1) * deltaW,\n    offsetY: (alignment.y === \"top\" ? -1 : 1) * deltaH\n  };\n}\n__name(floatingOffset, \"floatingOffset\");\nfunction drawFloatingLabel(context, measurements, { type, text }) {\n  const { floatingAlignment: floatingAlignment2, extremities } = measurements;\n  let x = extremities[floatingAlignment2.x];\n  let y = extremities[floatingAlignment2.y];\n  const { w, h } = configureText(context, text);\n  const { offsetX, offsetY } = floatingOffset(floatingAlignment2, {\n    w,\n    h\n  });\n  x += offsetX;\n  y += offsetY;\n  return textWithRect(context, type, { x, y, w, h }, text);\n}\n__name(drawFloatingLabel, \"drawFloatingLabel\");\nfunction drawStack(context, measurements, stack, external) {\n  const rects = [];\n  stack.forEach((l, idx) => {\n    const rect = external && l.position === \"center\" ? drawFloatingLabel(context, measurements, l) : drawLabel(context, measurements, l, rects[idx - 1], external);\n    rects[idx] = rect;\n  });\n}\n__name(drawStack, \"drawStack\");\nfunction labelStacks(context, measurements, labels, externalLabels) {\n  const stacks = labels.reduce((acc, l) => {\n    if (!Object.prototype.hasOwnProperty.call(acc, l.position)) {\n      acc[l.position] = [];\n    }\n    acc[l.position]?.push(l);\n    return acc;\n  }, {});\n  if (stacks.top) {\n    drawStack(context, measurements, stacks.top, externalLabels);\n  }\n  if (stacks.right) {\n    drawStack(context, measurements, stacks.right, externalLabels);\n  }\n  if (stacks.bottom) {\n    drawStack(context, measurements, stacks.bottom, externalLabels);\n  }\n  if (stacks.left) {\n    drawStack(context, measurements, stacks.left, externalLabels);\n  }\n  if (stacks.center) {\n    drawStack(context, measurements, stacks.center, externalLabels);\n  }\n}\n__name(labelStacks, \"labelStacks\");\n\n// src/measure/box-model/visualizer.ts\nvar colors2 = {\n  margin: \"#f6b26ba8\",\n  border: \"#ffe599a8\",\n  padding: \"#93c47d8c\",\n  content: \"#6fa8dca8\"\n};\nvar SMALL_NODE_SIZE = 30;\nfunction pxToNumber(px) {\n  return parseInt(px.replace(\"px\", \"\"), 10);\n}\n__name(pxToNumber, \"pxToNumber\");\nfunction round(value) {\n  return Number.isInteger(value) ? value : value.toFixed(2);\n}\n__name(round, \"round\");\nfunction filterZeroValues(labels) {\n  return labels.filter((l) => l.text !== 0 && l.text !== \"0\");\n}\n__name(filterZeroValues, \"filterZeroValues\");\nfunction floatingAlignment(extremities) {\n  const windowExtremities = {\n    top: global2.window.scrollY,\n    bottom: global2.window.scrollY + global2.window.innerHeight,\n    left: global2.window.scrollX,\n    right: global2.window.scrollX + global2.window.innerWidth\n  };\n  const distances = {\n    top: Math.abs(windowExtremities.top - extremities.top),\n    bottom: Math.abs(windowExtremities.bottom - extremities.bottom),\n    left: Math.abs(windowExtremities.left - extremities.left),\n    right: Math.abs(windowExtremities.right - extremities.right)\n  };\n  return {\n    x: distances.left > distances.right ? \"left\" : \"right\",\n    y: distances.top > distances.bottom ? \"top\" : \"bottom\"\n  };\n}\n__name(floatingAlignment, \"floatingAlignment\");\nfunction measureElement(element) {\n  const style = global2.getComputedStyle(element);\n  let { top, left, right, bottom, width, height } = element.getBoundingClientRect();\n  const {\n    marginTop,\n    marginBottom,\n    marginLeft,\n    marginRight,\n    paddingTop,\n    paddingBottom,\n    paddingLeft,\n    paddingRight,\n    borderBottomWidth,\n    borderTopWidth,\n    borderLeftWidth,\n    borderRightWidth\n  } = style;\n  top = top + global2.window.scrollY;\n  left = left + global2.window.scrollX;\n  bottom = bottom + global2.window.scrollY;\n  right = right + global2.window.scrollX;\n  const margin = {\n    top: pxToNumber(marginTop),\n    bottom: pxToNumber(marginBottom),\n    left: pxToNumber(marginLeft),\n    right: pxToNumber(marginRight)\n  };\n  const padding = {\n    top: pxToNumber(paddingTop),\n    bottom: pxToNumber(paddingBottom),\n    left: pxToNumber(paddingLeft),\n    right: pxToNumber(paddingRight)\n  };\n  const border = {\n    top: pxToNumber(borderTopWidth),\n    bottom: pxToNumber(borderBottomWidth),\n    left: pxToNumber(borderLeftWidth),\n    right: pxToNumber(borderRightWidth)\n  };\n  const extremities = {\n    top: top - margin.top,\n    bottom: bottom + margin.bottom,\n    left: left - margin.left,\n    right: right + margin.right\n  };\n  return {\n    margin,\n    padding,\n    border,\n    top,\n    left,\n    bottom,\n    right,\n    width,\n    height,\n    extremities,\n    floatingAlignment: floatingAlignment(extremities)\n  };\n}\n__name(measureElement, \"measureElement\");\nfunction drawMargin(context, { margin, width, height, top, left, bottom, right }) {\n  const marginHeight = height + margin.bottom + margin.top;\n  context.fillStyle = colors2.margin;\n  context.fillRect(left, top - margin.top, width, margin.top);\n  context.fillRect(right, top - margin.top, margin.right, marginHeight);\n  context.fillRect(left, bottom, width, margin.bottom);\n  context.fillRect(left - margin.left, top - margin.top, margin.left, marginHeight);\n  const marginLabels = [\n    {\n      type: \"margin\",\n      text: round(margin.top),\n      position: \"top\"\n    },\n    {\n      type: \"margin\",\n      text: round(margin.right),\n      position: \"right\"\n    },\n    {\n      type: \"margin\",\n      text: round(margin.bottom),\n      position: \"bottom\"\n    },\n    {\n      type: \"margin\",\n      text: round(margin.left),\n      position: \"left\"\n    }\n  ];\n  return filterZeroValues(marginLabels);\n}\n__name(drawMargin, \"drawMargin\");\nfunction drawPadding(context, { padding, border, width, height, top, left, bottom, right }) {\n  const paddingWidth = width - border.left - border.right;\n  const paddingHeight = height - padding.top - padding.bottom - border.top - border.bottom;\n  context.fillStyle = colors2.padding;\n  context.fillRect(left + border.left, top + border.top, paddingWidth, padding.top);\n  context.fillRect(\n    right - padding.right - border.right,\n    top + padding.top + border.top,\n    padding.right,\n    paddingHeight\n  );\n  context.fillRect(\n    left + border.left,\n    bottom - padding.bottom - border.bottom,\n    paddingWidth,\n    padding.bottom\n  );\n  context.fillRect(left + border.left, top + padding.top + border.top, padding.left, paddingHeight);\n  const paddingLabels = [\n    {\n      type: \"padding\",\n      text: padding.top,\n      position: \"top\"\n    },\n    {\n      type: \"padding\",\n      text: padding.right,\n      position: \"right\"\n    },\n    {\n      type: \"padding\",\n      text: padding.bottom,\n      position: \"bottom\"\n    },\n    {\n      type: \"padding\",\n      text: padding.left,\n      position: \"left\"\n    }\n  ];\n  return filterZeroValues(paddingLabels);\n}\n__name(drawPadding, \"drawPadding\");\nfunction drawBorder(context, { border, width, height, top, left, bottom, right }) {\n  const borderHeight = height - border.top - border.bottom;\n  context.fillStyle = colors2.border;\n  context.fillRect(left, top, width, border.top);\n  context.fillRect(left, bottom - border.bottom, width, border.bottom);\n  context.fillRect(left, top + border.top, border.left, borderHeight);\n  context.fillRect(right - border.right, top + border.top, border.right, borderHeight);\n  const borderLabels = [\n    {\n      type: \"border\",\n      text: border.top,\n      position: \"top\"\n    },\n    {\n      type: \"border\",\n      text: border.right,\n      position: \"right\"\n    },\n    {\n      type: \"border\",\n      text: border.bottom,\n      position: \"bottom\"\n    },\n    {\n      type: \"border\",\n      text: border.left,\n      position: \"left\"\n    }\n  ];\n  return filterZeroValues(borderLabels);\n}\n__name(drawBorder, \"drawBorder\");\nfunction drawContent(context, { padding, border, width, height, top, left }) {\n  const contentWidth = width - border.left - border.right - padding.left - padding.right;\n  const contentHeight = height - padding.top - padding.bottom - border.top - border.bottom;\n  context.fillStyle = colors2.content;\n  context.fillRect(\n    left + border.left + padding.left,\n    top + border.top + padding.top,\n    contentWidth,\n    contentHeight\n  );\n  return [\n    {\n      type: \"content\",\n      position: \"center\",\n      text: `${round(contentWidth)} x ${round(contentHeight)}`\n    }\n  ];\n}\n__name(drawContent, \"drawContent\");\nfunction drawBoxModel(element) {\n  return (context) => {\n    if (element && context) {\n      const measurements = measureElement(element);\n      const marginLabels = drawMargin(context, measurements);\n      const paddingLabels = drawPadding(context, measurements);\n      const borderLabels = drawBorder(context, measurements);\n      const contentLabels = drawContent(context, measurements);\n      const externalLabels = measurements.width <= SMALL_NODE_SIZE * 3 || measurements.height <= SMALL_NODE_SIZE;\n      labelStacks(\n        context,\n        measurements,\n        [...contentLabels, ...paddingLabels, ...borderLabels, ...marginLabels],\n        externalLabels\n      );\n    }\n  };\n}\n__name(drawBoxModel, \"drawBoxModel\");\nfunction drawSelectedElement(element) {\n  draw(drawBoxModel(element));\n}\n__name(drawSelectedElement, \"drawSelectedElement\");\n\n// src/measure/util.ts\nimport { global as global3 } from \"@storybook/global\";\nvar deepElementFromPoint = /* @__PURE__ */ __name((x, y) => {\n  const element = global3.document.elementFromPoint(x, y);\n  const crawlShadows = /* @__PURE__ */ __name((node) => {\n    if (node && node.shadowRoot) {\n      const nestedElement = node.shadowRoot.elementFromPoint(x, y);\n      if (node.isEqualNode(nestedElement)) {\n        return node;\n      }\n      if (nestedElement.shadowRoot) {\n        return crawlShadows(nestedElement);\n      }\n      return nestedElement;\n    }\n    return node;\n  }, \"crawlShadows\");\n  const shadowElement = crawlShadows(element);\n  return shadowElement || element;\n}, \"deepElementFromPoint\");\n\n// src/measure/withMeasure.ts\nvar nodeAtPointerRef;\nvar pointer = { x: 0, y: 0 };\nfunction findAndDrawElement(x, y) {\n  nodeAtPointerRef = deepElementFromPoint(x, y);\n  drawSelectedElement(nodeAtPointerRef);\n}\n__name(findAndDrawElement, \"findAndDrawElement\");\nvar withMeasure = /* @__PURE__ */ __name((StoryFn, context) => {\n  const { measureEnabled } = context.globals || {};\n  useEffect2(() => {\n    if (typeof globalThis.document === \"undefined\") {\n      return;\n    }\n    const onPointerMove = /* @__PURE__ */ __name((event) => {\n      window.requestAnimationFrame(() => {\n        event.stopPropagation();\n        pointer.x = event.clientX;\n        pointer.y = event.clientY;\n      });\n    }, \"onPointerMove\");\n    globalThis.document.addEventListener(\"pointermove\", onPointerMove);\n    return () => {\n      globalThis.document.removeEventListener(\"pointermove\", onPointerMove);\n    };\n  }, []);\n  useEffect2(() => {\n    const onPointerOver = /* @__PURE__ */ __name((event) => {\n      window.requestAnimationFrame(() => {\n        event.stopPropagation();\n        findAndDrawElement(event.clientX, event.clientY);\n      });\n    }, \"onPointerOver\");\n    const onResize = /* @__PURE__ */ __name(() => {\n      window.requestAnimationFrame(() => {\n        rescale();\n      });\n    }, \"onResize\");\n    if (context.viewMode === \"story\" && measureEnabled) {\n      globalThis.document.addEventListener(\"pointerover\", onPointerOver);\n      init();\n      globalThis.window.addEventListener(\"resize\", onResize);\n      findAndDrawElement(pointer.x, pointer.y);\n    }\n    return () => {\n      globalThis.window.removeEventListener(\"resize\", onResize);\n      destroy();\n    };\n  }, [measureEnabled, context.viewMode]);\n  return StoryFn();\n}, \"withMeasure\");\n\n// src/measure/preview.ts\nvar decorators2 = globalThis.FEATURES?.measure ? [withMeasure] : [];\nvar initialGlobals2 = {\n  [PARAM_KEY3]: false\n};\nvar preview_default5 = /* @__PURE__ */ __name(() => definePreviewAddon5({\n  decorators: decorators2,\n  initialGlobals: initialGlobals2\n}), \"default\");\n\n// src/outline/preview.ts\nimport { definePreviewAddon as definePreviewAddon6 } from \"storybook/internal/csf\";\n\n// src/outline/withOutline.ts\nimport { useEffect as useEffect3, useMemo } from \"storybook/preview-api\";\n\n// src/outline/helpers.ts\nimport { global as global4 } from \"@storybook/global\";\nvar clearStyles2 = /* @__PURE__ */ __name((selector) => {\n  const selectors = Array.isArray(selector) ? selector : [selector];\n  selectors.forEach(clearStyle2);\n}, \"clearStyles\");\nvar clearStyle2 = /* @__PURE__ */ __name((input) => {\n  const selector = typeof input === \"string\" ? input : input.join(\"\");\n  const element = global4.document.getElementById(selector);\n  if (element && element.parentElement) {\n    element.parentElement.removeChild(element);\n  }\n}, \"clearStyle\");\nvar addOutlineStyles = /* @__PURE__ */ __name((selector, css) => {\n  const existingStyle = global4.document.getElementById(selector);\n  if (existingStyle) {\n    if (existingStyle.innerHTML !== css) {\n      existingStyle.innerHTML = css;\n    }\n  } else {\n    const style = global4.document.createElement(\"style\");\n    style.setAttribute(\"id\", selector);\n    style.innerHTML = css;\n    global4.document.head.appendChild(style);\n  }\n}, \"addOutlineStyles\");\n\n// src/outline/outlineCSS.ts\nfunction outlineCSS(selector) {\n  return dedent`\n    ${selector} body {\n      outline: 1px solid #2980b9 !important;\n    }\n\n    ${selector} article {\n      outline: 1px solid #3498db !important;\n    }\n\n    ${selector} nav {\n      outline: 1px solid #0088c3 !important;\n    }\n\n    ${selector} aside {\n      outline: 1px solid #33a0ce !important;\n    }\n\n    ${selector} section {\n      outline: 1px solid #66b8da !important;\n    }\n\n    ${selector} header {\n      outline: 1px solid #99cfe7 !important;\n    }\n\n    ${selector} footer {\n      outline: 1px solid #cce7f3 !important;\n    }\n\n    ${selector} h1 {\n      outline: 1px solid #162544 !important;\n    }\n\n    ${selector} h2 {\n      outline: 1px solid #314e6e !important;\n    }\n\n    ${selector} h3 {\n      outline: 1px solid #3e5e85 !important;\n    }\n\n    ${selector} h4 {\n      outline: 1px solid #449baf !important;\n    }\n\n    ${selector} h5 {\n      outline: 1px solid #c7d1cb !important;\n    }\n\n    ${selector} h6 {\n      outline: 1px solid #4371d0 !important;\n    }\n\n    ${selector} main {\n      outline: 1px solid #2f4f90 !important;\n    }\n\n    ${selector} address {\n      outline: 1px solid #1a2c51 !important;\n    }\n\n    ${selector} div {\n      outline: 1px solid #036cdb !important;\n    }\n\n    ${selector} p {\n      outline: 1px solid #ac050b !important;\n    }\n\n    ${selector} hr {\n      outline: 1px solid #ff063f !important;\n    }\n\n    ${selector} pre {\n      outline: 1px solid #850440 !important;\n    }\n\n    ${selector} blockquote {\n      outline: 1px solid #f1b8e7 !important;\n    }\n\n    ${selector} ol {\n      outline: 1px solid #ff050c !important;\n    }\n\n    ${selector} ul {\n      outline: 1px solid #d90416 !important;\n    }\n\n    ${selector} li {\n      outline: 1px solid #d90416 !important;\n    }\n\n    ${selector} dl {\n      outline: 1px solid #fd3427 !important;\n    }\n\n    ${selector} dt {\n      outline: 1px solid #ff0043 !important;\n    }\n\n    ${selector} dd {\n      outline: 1px solid #e80174 !important;\n    }\n\n    ${selector} figure {\n      outline: 1px solid #ff00bb !important;\n    }\n\n    ${selector} figcaption {\n      outline: 1px solid #bf0032 !important;\n    }\n\n    ${selector} table {\n      outline: 1px solid #00cc99 !important;\n    }\n\n    ${selector} caption {\n      outline: 1px solid #37ffc4 !important;\n    }\n\n    ${selector} thead {\n      outline: 1px solid #98daca !important;\n    }\n\n    ${selector} tbody {\n      outline: 1px solid #64a7a0 !important;\n    }\n\n    ${selector} tfoot {\n      outline: 1px solid #22746b !important;\n    }\n\n    ${selector} tr {\n      outline: 1px solid #86c0b2 !important;\n    }\n\n    ${selector} th {\n      outline: 1px solid #a1e7d6 !important;\n    }\n\n    ${selector} td {\n      outline: 1px solid #3f5a54 !important;\n    }\n\n    ${selector} col {\n      outline: 1px solid #6c9a8f !important;\n    }\n\n    ${selector} colgroup {\n      outline: 1px solid #6c9a9d !important;\n    }\n\n    ${selector} button {\n      outline: 1px solid #da8301 !important;\n    }\n\n    ${selector} datalist {\n      outline: 1px solid #c06000 !important;\n    }\n\n    ${selector} fieldset {\n      outline: 1px solid #d95100 !important;\n    }\n\n    ${selector} form {\n      outline: 1px solid #d23600 !important;\n    }\n\n    ${selector} input {\n      outline: 1px solid #fca600 !important;\n    }\n\n    ${selector} keygen {\n      outline: 1px solid #b31e00 !important;\n    }\n\n    ${selector} label {\n      outline: 1px solid #ee8900 !important;\n    }\n\n    ${selector} legend {\n      outline: 1px solid #de6d00 !important;\n    }\n\n    ${selector} meter {\n      outline: 1px solid #e8630c !important;\n    }\n\n    ${selector} optgroup {\n      outline: 1px solid #b33600 !important;\n    }\n\n    ${selector} option {\n      outline: 1px solid #ff8a00 !important;\n    }\n\n    ${selector} output {\n      outline: 1px solid #ff9619 !important;\n    }\n\n    ${selector} progress {\n      outline: 1px solid #e57c00 !important;\n    }\n\n    ${selector} select {\n      outline: 1px solid #e26e0f !important;\n    }\n\n    ${selector} textarea {\n      outline: 1px solid #cc5400 !important;\n    }\n\n    ${selector} details {\n      outline: 1px solid #33848f !important;\n    }\n\n    ${selector} summary {\n      outline: 1px solid #60a1a6 !important;\n    }\n\n    ${selector} command {\n      outline: 1px solid #438da1 !important;\n    }\n\n    ${selector} menu {\n      outline: 1px solid #449da6 !important;\n    }\n\n    ${selector} del {\n      outline: 1px solid #bf0000 !important;\n    }\n\n    ${selector} ins {\n      outline: 1px solid #400000 !important;\n    }\n\n    ${selector} img {\n      outline: 1px solid #22746b !important;\n    }\n\n    ${selector} iframe {\n      outline: 1px solid #64a7a0 !important;\n    }\n\n    ${selector} embed {\n      outline: 1px solid #98daca !important;\n    }\n\n    ${selector} object {\n      outline: 1px solid #00cc99 !important;\n    }\n\n    ${selector} param {\n      outline: 1px solid #37ffc4 !important;\n    }\n\n    ${selector} video {\n      outline: 1px solid #6ee866 !important;\n    }\n\n    ${selector} audio {\n      outline: 1px solid #027353 !important;\n    }\n\n    ${selector} source {\n      outline: 1px solid #012426 !important;\n    }\n\n    ${selector} canvas {\n      outline: 1px solid #a2f570 !important;\n    }\n\n    ${selector} track {\n      outline: 1px solid #59a600 !important;\n    }\n\n    ${selector} map {\n      outline: 1px solid #7be500 !important;\n    }\n\n    ${selector} area {\n      outline: 1px solid #305900 !important;\n    }\n\n    ${selector} a {\n      outline: 1px solid #ff62ab !important;\n    }\n\n    ${selector} em {\n      outline: 1px solid #800b41 !important;\n    }\n\n    ${selector} strong {\n      outline: 1px solid #ff1583 !important;\n    }\n\n    ${selector} i {\n      outline: 1px solid #803156 !important;\n    }\n\n    ${selector} b {\n      outline: 1px solid #cc1169 !important;\n    }\n\n    ${selector} u {\n      outline: 1px solid #ff0430 !important;\n    }\n\n    ${selector} s {\n      outline: 1px solid #f805e3 !important;\n    }\n\n    ${selector} small {\n      outline: 1px solid #d107b2 !important;\n    }\n\n    ${selector} abbr {\n      outline: 1px solid #4a0263 !important;\n    }\n\n    ${selector} q {\n      outline: 1px solid #240018 !important;\n    }\n\n    ${selector} cite {\n      outline: 1px solid #64003c !important;\n    }\n\n    ${selector} dfn {\n      outline: 1px solid #b4005a !important;\n    }\n\n    ${selector} sub {\n      outline: 1px solid #dba0c8 !important;\n    }\n\n    ${selector} sup {\n      outline: 1px solid #cc0256 !important;\n    }\n\n    ${selector} time {\n      outline: 1px solid #d6606d !important;\n    }\n\n    ${selector} code {\n      outline: 1px solid #e04251 !important;\n    }\n\n    ${selector} kbd {\n      outline: 1px solid #5e001f !important;\n    }\n\n    ${selector} samp {\n      outline: 1px solid #9c0033 !important;\n    }\n\n    ${selector} var {\n      outline: 1px solid #d90047 !important;\n    }\n\n    ${selector} mark {\n      outline: 1px solid #ff0053 !important;\n    }\n\n    ${selector} bdi {\n      outline: 1px solid #bf3668 !important;\n    }\n\n    ${selector} bdo {\n      outline: 1px solid #6f1400 !important;\n    }\n\n    ${selector} ruby {\n      outline: 1px solid #ff7b93 !important;\n    }\n\n    ${selector} rt {\n      outline: 1px solid #ff2f54 !important;\n    }\n\n    ${selector} rp {\n      outline: 1px solid #803e49 !important;\n    }\n\n    ${selector} span {\n      outline: 1px solid #cc2643 !important;\n    }\n\n    ${selector} br {\n      outline: 1px solid #db687d !important;\n    }\n\n    ${selector} wbr {\n      outline: 1px solid #db175b !important;\n    }`;\n}\n__name(outlineCSS, \"outlineCSS\");\n\n// src/outline/withOutline.ts\nvar withOutline = /* @__PURE__ */ __name((StoryFn, context) => {\n  const globals = context.globals || {};\n  const isActive = [true, \"true\"].includes(globals[PARAM_KEY4]);\n  const isInDocs = context.viewMode === \"docs\";\n  const outlineStyles = useMemo(() => {\n    const selector = isInDocs ? `[data-story-block=\"true\"]` : \".sb-show-main\";\n    return outlineCSS(selector);\n  }, [context]);\n  useEffect3(() => {\n    const selectorId = isInDocs ? `addon-outline-docs-${context.id}` : `addon-outline`;\n    if (!isActive) {\n      clearStyles2(selectorId);\n    } else {\n      addOutlineStyles(selectorId, outlineStyles);\n    }\n    return () => {\n      clearStyles2(selectorId);\n    };\n  }, [isActive, outlineStyles, context]);\n  return StoryFn();\n}, \"withOutline\");\n\n// src/outline/preview.ts\nvar decorators3 = globalThis.FEATURES?.outline ? [withOutline] : [];\nvar initialGlobals3 = {\n  [PARAM_KEY4]: false\n};\nvar preview_default6 = /* @__PURE__ */ __name(() => definePreviewAddon6({ decorators: decorators3, initialGlobals: initialGlobals3 }), \"default\");\n\n// src/test/preview.ts\nimport { definePreviewAddon as definePreviewAddon7 } from \"storybook/internal/csf\";\nimport { instrument as instrument2 } from \"storybook/internal/instrumenter\";\nimport {\n  clearAllMocks,\n  fn,\n  isMockFunction,\n  resetAllMocks,\n  restoreAllMocks,\n  uninstrumentedUserEvent,\n  within\n} from \"storybook/test\";\nvar resetAllMocksLoader = /* @__PURE__ */ __name(({ parameters: parameters2 }) => {\n  if (parameters2?.test?.mockReset === true) {\n    resetAllMocks();\n  } else if (parameters2?.test?.clearMocks === true) {\n    clearAllMocks();\n  } else if (parameters2?.test?.restoreMocks !== false) {\n    restoreAllMocks();\n  }\n}, \"resetAllMocksLoader\");\nvar traverseArgs = /* @__PURE__ */ __name((value, depth = 0, key) => {\n  if (depth > 5) {\n    return value;\n  }\n  if (value == null) {\n    return value;\n  }\n  if (isMockFunction(value)) {\n    if (key) {\n      value.mockName(key);\n    }\n    return value;\n  }\n  if (typeof value === \"function\" && \"isAction\" in value && value.isAction && !(\"implicit\" in value && value.implicit)) {\n    const mock = fn(value);\n    if (key) {\n      mock.mockName(key);\n    }\n    return mock;\n  }\n  if (Array.isArray(value)) {\n    depth++;\n    for (let i = 0; i < value.length; i++) {\n      if (Object.getOwnPropertyDescriptor(value, i)?.writable) {\n        value[i] = traverseArgs(value[i], depth);\n      }\n    }\n    return value;\n  }\n  if (typeof value === \"object\" && value.constructor === Object) {\n    depth++;\n    for (const [k, v] of Object.entries(value)) {\n      if (Object.getOwnPropertyDescriptor(value, k)?.writable) {\n        value[k] = traverseArgs(v, depth, k);\n      }\n    }\n    return value;\n  }\n  return value;\n}, \"traverseArgs\");\nvar nameSpiesAndWrapActionsInSpies = /* @__PURE__ */ __name(({ initialArgs }) => {\n  traverseArgs(initialArgs);\n}, \"nameSpiesAndWrapActionsInSpies\");\nvar patchedFocus = false;\nvar enhanceContext = /* @__PURE__ */ __name(async (context) => {\n  if (globalThis.HTMLElement && context.canvasElement instanceof globalThis.HTMLElement) {\n    context.canvas = within(context.canvasElement);\n  }\n  const clipboard = globalThis.window?.navigator?.clipboard;\n  if (clipboard) {\n    context.userEvent = instrument2(\n      { userEvent: uninstrumentedUserEvent.setup() },\n      {\n        intercept: true,\n        getKeys: /* @__PURE__ */ __name((obj) => Object.keys(obj).filter((key) => key !== \"eventWrapper\"), \"getKeys\")\n      }\n    ).userEvent;\n    Object.defineProperty(globalThis.window.navigator, \"clipboard\", {\n      get: /* @__PURE__ */ __name(() => clipboard, \"get\"),\n      configurable: true\n    });\n    let currentFocus = HTMLElement.prototype.focus;\n    if (!patchedFocus) {\n      Object.defineProperties(HTMLElement.prototype, {\n        focus: {\n          configurable: true,\n          set: /* @__PURE__ */ __name((newFocus) => {\n            currentFocus = newFocus;\n            patchedFocus = true;\n          }, \"set\"),\n          get: /* @__PURE__ */ __name(() => {\n            return currentFocus;\n          }, \"get\")\n        }\n      });\n    }\n  }\n}, \"enhanceContext\");\nvar preview_default7 = /* @__PURE__ */ __name(() => definePreviewAddon7({\n  loaders: [resetAllMocksLoader, nameSpiesAndWrapActionsInSpies, enhanceContext]\n}), \"default\");\n\n// src/viewport/preview.ts\nimport { definePreviewAddon as definePreviewAddon8 } from \"storybook/internal/csf\";\nvar initialGlobals4 = {\n  [PARAM_KEY]: { value: void 0, isRotated: false }\n};\nvar preview_default8 = /* @__PURE__ */ __name(() => definePreviewAddon8({\n  initialGlobals: initialGlobals4\n}), \"default\");\n\n// src/csf/core-annotations.ts\nfunction getCoreAnnotations() {\n  return [\n    // @ts-expect-error CJS fallback\n    (preview_default5.default ?? preview_default5)(),\n    // @ts-expect-error CJS fallback\n    (preview_default2.default ?? preview_default2)(),\n    // @ts-expect-error CJS fallback\n    (preview_default4.default ?? preview_default4)(),\n    // @ts-expect-error CJS fallback\n    (preview_default6.default ?? preview_default6)(),\n    // @ts-expect-error CJS fallback\n    (preview_default8.default ?? preview_default8)(),\n    // @ts-expect-error CJS fallback\n    (preview_default.default ?? preview_default)(),\n    // @ts-expect-error CJS fallback\n    (preview_default3.default ?? preview_default3)(),\n    // @ts-expect-error CJS fallback\n    (preview_default7.default ?? preview_default7)()\n  ];\n}\n__name(getCoreAnnotations, \"getCoreAnnotations\");\n\n// src/csf/csf-factories.ts\nfunction definePreview(input) {\n  let composed;\n  const preview = {\n    _tag: \"Preview\",\n    input,\n    get composed() {\n      if (composed) {\n        return composed;\n      }\n      const { addons: addons2, ...rest } = input;\n      composed = normalizeProjectAnnotations(\n        composeConfigs([...getCoreAnnotations(), ...addons2 ?? [], rest])\n      );\n      return composed;\n    },\n    meta(meta) {\n      return defineMeta(meta, this);\n    }\n  };\n  globalThis.globalProjectAnnotations = preview.composed;\n  return preview;\n}\n__name(definePreview, \"definePreview\");\nfunction definePreviewAddon9(preview) {\n  return preview;\n}\n__name(definePreviewAddon9, \"definePreviewAddon\");\nfunction isPreview(input) {\n  return input != null && typeof input === \"object\" && \"_tag\" in input && input?._tag === \"Preview\";\n}\n__name(isPreview, \"isPreview\");\nfunction isMeta(input) {\n  return input != null && typeof input === \"object\" && \"_tag\" in input && input?._tag === \"Meta\";\n}\n__name(isMeta, \"isMeta\");\nfunction defineMeta(input, preview) {\n  return {\n    _tag: \"Meta\",\n    input,\n    preview,\n    // @ts-expect-error hard\n    story(story = {}) {\n      return defineStory(typeof story === \"function\" ? { render: story } : story, this);\n    }\n  };\n}\n__name(defineMeta, \"defineMeta\");\nfunction isStory(input) {\n  return input != null && typeof input === \"object\" && \"_tag\" in input && input?._tag === \"Story\";\n}\n__name(isStory, \"isStory\");\nfunction defineStory(input, meta) {\n  let composed;\n  const compose = /* @__PURE__ */ __name(() => {\n    if (!composed) {\n      composed = composeStory(\n        input,\n        meta.input,\n        void 0,\n        meta.preview.composed\n      );\n    }\n    return composed;\n  }, \"compose\");\n  const __children = [];\n  return {\n    _tag: \"Story\",\n    input,\n    meta,\n    // @ts-expect-error this is a private property used only once in renderers/react/src/preview\n    __compose: compose,\n    __children,\n    get composed() {\n      const composed2 = compose();\n      const { args, argTypes, parameters: parameters2, id, tags, globals, storyName: name } = composed2;\n      return { args, argTypes, parameters: parameters2, id, tags, name, globals };\n    },\n    get play() {\n      return input.play ?? meta.input?.play ?? (async () => {\n      });\n    },\n    async run(context) {\n      await compose().run(context);\n    },\n    test(name, overridesOrTestFn, testFn) {\n      const annotations = typeof overridesOrTestFn !== \"function\" ? overridesOrTestFn : {};\n      const testFunction = typeof overridesOrTestFn !== \"function\" ? testFn : overridesOrTestFn;\n      const play = mountDestructured(this.play) || mountDestructured(testFunction) ? async ({ context }) => {\n        await this.play?.(context);\n        await testFunction(context);\n      } : async (context) => {\n        await this.play?.(context);\n        await testFunction(context);\n      };\n      const test = this.extend({\n        ...annotations,\n        name,\n        tags: [\"test-fn\", \"!autodocs\", ...annotations.tags ?? []],\n        play\n      });\n      __children.push(test);\n      return test;\n    },\n    extend(input2) {\n      return defineStory(\n        {\n          ...this.input,\n          ...input2,\n          args: { ...this.input.args || {}, ...input2.args },\n          argTypes: combineParameters(this.input.argTypes, input2.argTypes),\n          afterEach: [\n            ...normalizeArrays(this.input?.afterEach ?? []),\n            ...normalizeArrays(input2.afterEach ?? [])\n          ],\n          beforeEach: [\n            ...normalizeArrays(this.input?.beforeEach ?? []),\n            ...normalizeArrays(input2.beforeEach ?? [])\n          ],\n          decorators: [\n            ...normalizeArrays(this.input?.decorators ?? []),\n            ...normalizeArrays(input2.decorators ?? [])\n          ],\n          globals: { ...this.input.globals, ...input2.globals },\n          loaders: [\n            ...normalizeArrays(this.input?.loaders ?? []),\n            ...normalizeArrays(input2.loaders ?? [])\n          ],\n          parameters: combineParameters(this.input.parameters, input2.parameters),\n          tags: combineTags(...this.input.tags ?? [], ...input2.tags ?? [])\n        },\n        this.meta\n      );\n    }\n  };\n}\n__name(defineStory, \"defineStory\");\nfunction getStoryChildren(story) {\n  if (\"__children\" in story) {\n    return story.__children;\n  }\n  return [];\n}\n__name(getStoryChildren, \"getStoryChildren\");\n\n// src/csf/index.ts\nvar sanitize = /* @__PURE__ */ __name((string) => {\n  return string.toLowerCase().replace(/[ '`~!@#$%^&*()_|+\\-=?;:'\",.<>\\{\\}\\[\\]\\\\\\/]/gi, \"-\").replace(/-+/g, \"-\").replace(/^-+/, \"\").replace(/-+$/, \"\");\n}, \"sanitize\");\nvar sanitizeSafe = /* @__PURE__ */ __name((string, part) => {\n  const sanitized = sanitize(string);\n  if (sanitized === \"\") {\n    throw new Error(`Invalid ${part} '${string}', must include alphanumeric characters`);\n  }\n  return sanitized;\n}, \"sanitizeSafe\");\nvar toId = /* @__PURE__ */ __name((kind, name) => `${sanitizeSafe(kind, \"kind\")}${name ? `--${sanitizeSafe(name, \"name\")}` : \"\"}`, \"toId\");\nvar toTestId = /* @__PURE__ */ __name((parentId, testName) => `${parentId}:${sanitizeSafe(testName, \"test\")}`, \"toTestId\");\nvar storyNameFromExport = /* @__PURE__ */ __name((key) => toStartCaseStr(key), \"storyNameFromExport\");\nfunction matches(storyKey, arrayOrRegex) {\n  if (Array.isArray(arrayOrRegex)) {\n    return arrayOrRegex.includes(storyKey);\n  }\n  return storyKey.match(arrayOrRegex);\n}\n__name(matches, \"matches\");\nfunction isExportStory(key, { includeStories, excludeStories }) {\n  return (\n    // https://babeljs.io/docs/en/babel-plugin-transform-modules-commonjs\n    key !== \"__esModule\" && (!includeStories || matches(key, includeStories)) && (!excludeStories || !matches(key, excludeStories))\n  );\n}\n__name(isExportStory, \"isExportStory\");\nvar parseKind = /* @__PURE__ */ __name((kind, { rootSeparator, groupSeparator }) => {\n  const [root, remainder] = kind.split(rootSeparator, 2);\n  const groups = (remainder || kind).split(groupSeparator).filter((i) => !!i);\n  return {\n    root: remainder ? root : null,\n    groups\n  };\n}, \"parseKind\");\nvar combineTags2 = /* @__PURE__ */ __name((...tags) => {\n  const result = tags.reduce((acc, tag) => {\n    if (tag.startsWith(\"!\")) {\n      acc.delete(tag.slice(1));\n    } else {\n      acc.add(tag);\n    }\n    return acc;\n  }, /* @__PURE__ */ new Set());\n  return Array.from(result);\n}, \"combineTags\");\nexport {\n  combineTags2 as combineTags,\n  definePreview,\n  definePreviewAddon9 as definePreviewAddon,\n  getCoreAnnotations,\n  getStoryChildren,\n  includeConditionalArg,\n  isExportStory,\n  isMeta,\n  isPreview,\n  isStory,\n  parseKind,\n  sanitize,\n  storyNameFromExport,\n  toId,\n  toTestId\n};\n"],"names":[],"sourceRoot":""}