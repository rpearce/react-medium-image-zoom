{"version":3,"file":"846.925873ef.iframe.bundle.js","mappings":";;AA4+CA;AACA;AACA;AACA","sources":["webpack://react-medium-image-zoom/./node_modules/.pnpm/storybook@10.1.4_@testing-library+dom@10.4.0_prettier@2.8.8_react-dom@19.2.1_react@19.2.1__react@19.2.1/node_modules/storybook/dist/_browser-chunks/WithTooltip-IO6J4KBT.js"],"sourcesContent":["import {\n  _objectWithoutPropertiesLoose\n} from \"./chunk-45UGUKRX.js\";\nimport {\n  _extends\n} from \"./chunk-CHUV5WSW.js\";\nimport {\n  require_memoizerific\n} from \"./chunk-WJYERY3R.js\";\nimport {\n  __commonJS,\n  __toESM\n} from \"./chunk-A242L54C.js\";\n\n// ../node_modules/react-fast-compare/index.js\nvar require_react_fast_compare = __commonJS({\n  \"../node_modules/react-fast-compare/index.js\"(exports, module) {\n    var hasElementType = typeof Element < \"u\", hasMap = typeof Map == \"function\", hasSet = typeof Set == \"function\", hasArrayBuffer = typeof ArrayBuffer == \"function\" && !!ArrayBuffer.isView;\n    function equal(a, b) {\n      if (a === b) return !0;\n      if (a && b && typeof a == \"object\" && typeof b == \"object\") {\n        if (a.constructor !== b.constructor) return !1;\n        var length, i, keys;\n        if (Array.isArray(a)) {\n          if (length = a.length, length != b.length) return !1;\n          for (i = length; i-- !== 0; )\n            if (!equal(a[i], b[i])) return !1;\n          return !0;\n        }\n        var it;\n        if (hasMap && a instanceof Map && b instanceof Map) {\n          if (a.size !== b.size) return !1;\n          for (it = a.entries(); !(i = it.next()).done; )\n            if (!b.has(i.value[0])) return !1;\n          for (it = a.entries(); !(i = it.next()).done; )\n            if (!equal(i.value[1], b.get(i.value[0]))) return !1;\n          return !0;\n        }\n        if (hasSet && a instanceof Set && b instanceof Set) {\n          if (a.size !== b.size) return !1;\n          for (it = a.entries(); !(i = it.next()).done; )\n            if (!b.has(i.value[0])) return !1;\n          return !0;\n        }\n        if (hasArrayBuffer && ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {\n          if (length = a.length, length != b.length) return !1;\n          for (i = length; i-- !== 0; )\n            if (a[i] !== b[i]) return !1;\n          return !0;\n        }\n        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n        if (a.valueOf !== Object.prototype.valueOf && typeof a.valueOf == \"function\" && typeof b.valueOf == \"function\") return a.valueOf() === b.valueOf();\n        if (a.toString !== Object.prototype.toString && typeof a.toString == \"function\" && typeof b.toString == \"function\") return a.toString() === b.toString();\n        if (keys = Object.keys(a), length = keys.length, length !== Object.keys(b).length) return !1;\n        for (i = length; i-- !== 0; )\n          if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return !1;\n        if (hasElementType && a instanceof Element) return !1;\n        for (i = length; i-- !== 0; )\n          if (!((keys[i] === \"_owner\" || keys[i] === \"__v\" || keys[i] === \"__o\") && a.$$typeof) && !equal(a[keys[i]], b[keys[i]]))\n            return !1;\n        return !0;\n      }\n      return a !== a && b !== b;\n    }\n    module.exports = function(a, b) {\n      try {\n        return equal(a, b);\n      } catch (error) {\n        if ((error.message || \"\").match(/stack|recursion/i))\n          return console.warn(\"react-fast-compare cannot handle circular refs\"), !1;\n        throw error;\n      }\n    };\n  }\n});\n\n// ../node_modules/warning/warning.js\nvar require_warning = __commonJS({\n  \"../node_modules/warning/warning.js\"(exports, module) {\n    \"use strict\";\n    var __DEV__ = process.env.NODE_ENV !== \"production\", warning2 = function() {\n    };\n    __DEV__ && (printWarning = function(format, args) {\n      var len = arguments.length;\n      args = new Array(len > 1 ? len - 1 : 0);\n      for (var key = 1; key < len; key++)\n        args[key - 1] = arguments[key];\n      var argIndex = 0, message = \"Warning: \" + format.replace(/%s/g, function() {\n        return args[argIndex++];\n      });\n      typeof console < \"u\" && console.error(message);\n      try {\n        throw new Error(message);\n      } catch {\n      }\n    }, warning2 = function(condition, format, args) {\n      var len = arguments.length;\n      args = new Array(len > 2 ? len - 2 : 0);\n      for (var key = 2; key < len; key++)\n        args[key - 2] = arguments[key];\n      if (format === void 0)\n        throw new Error(\n          \"`warning(condition, format, ...args)` requires a warning message argument\"\n        );\n      condition || printWarning.apply(null, [format].concat(args));\n    });\n    var printWarning;\n    module.exports = warning2;\n  }\n});\n\n// src/components/components/tooltip/WithTooltip.tsx\nvar import_memoizerific = __toESM(require_memoizerific(), 1);\nimport React7, { useCallback as useCallback4, useEffect as useEffect6, useState as useState5 } from \"react\";\nimport ReactDOM2 from \"react-dom\";\nimport { deprecate } from \"storybook/internal/client-logger\";\nimport { global } from \"@storybook/global\";\n\n// ../node_modules/react-popper-tooltip/dist/esm/react-popper-tooltip.js\nimport * as React6 from \"react\";\n\n// ../node_modules/react-popper/lib/esm/Popper.js\nimport * as React4 from \"react\";\n\n// ../node_modules/react-popper/lib/esm/Manager.js\nimport * as React from \"react\";\nvar ManagerReferenceNodeContext = React.createContext(), ManagerReferenceNodeSetterContext = React.createContext();\n\n// ../node_modules/react-popper/lib/esm/utils.js\nimport * as React2 from \"react\";\nvar fromEntries = function(entries) {\n  return entries.reduce(function(acc, _ref) {\n    var key = _ref[0], value = _ref[1];\n    return acc[key] = value, acc;\n  }, {});\n}, useIsomorphicLayoutEffect = typeof window < \"u\" && window.document && window.document.createElement ? React2.useLayoutEffect : React2.useEffect;\n\n// ../node_modules/react-popper/lib/esm/usePopper.js\nimport * as React3 from \"react\";\nimport * as ReactDOM from \"react-dom\";\n\n// ../node_modules/@popperjs/core/lib/enums.js\nvar top = \"top\", bottom = \"bottom\", right = \"right\", left = \"left\", auto = \"auto\", basePlacements = [top, bottom, right, left], start = \"start\", end = \"end\", clippingParents = \"clippingParents\", viewport = \"viewport\", popper = \"popper\", reference = \"reference\", variationPlacements = basePlacements.reduce(function(acc, placement) {\n  return acc.concat([placement + \"-\" + start, placement + \"-\" + end]);\n}, []), placements = [].concat(basePlacements, [auto]).reduce(function(acc, placement) {\n  return acc.concat([placement, placement + \"-\" + start, placement + \"-\" + end]);\n}, []), beforeRead = \"beforeRead\", read = \"read\", afterRead = \"afterRead\", beforeMain = \"beforeMain\", main = \"main\", afterMain = \"afterMain\", beforeWrite = \"beforeWrite\", write = \"write\", afterWrite = \"afterWrite\", modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];\n\n// ../node_modules/@popperjs/core/lib/dom-utils/getNodeName.js\nfunction getNodeName(element) {\n  return element ? (element.nodeName || \"\").toLowerCase() : null;\n}\n\n// ../node_modules/@popperjs/core/lib/dom-utils/getWindow.js\nfunction getWindow(node) {\n  if (node == null)\n    return window;\n  if (node.toString() !== \"[object Window]\") {\n    var ownerDocument = node.ownerDocument;\n    return ownerDocument && ownerDocument.defaultView || window;\n  }\n  return node;\n}\n\n// ../node_modules/@popperjs/core/lib/dom-utils/instanceOf.js\nfunction isElement(node) {\n  var OwnElement = getWindow(node).Element;\n  return node instanceof OwnElement || node instanceof Element;\n}\nfunction isHTMLElement(node) {\n  var OwnElement = getWindow(node).HTMLElement;\n  return node instanceof OwnElement || node instanceof HTMLElement;\n}\nfunction isShadowRoot(node) {\n  if (typeof ShadowRoot > \"u\")\n    return !1;\n  var OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\n\n// ../node_modules/@popperjs/core/lib/modifiers/applyStyles.js\nfunction applyStyles(_ref) {\n  var state = _ref.state;\n  Object.keys(state.elements).forEach(function(name) {\n    var style = state.styles[name] || {}, attributes = state.attributes[name] || {}, element = state.elements[name];\n    !isHTMLElement(element) || !getNodeName(element) || (Object.assign(element.style, style), Object.keys(attributes).forEach(function(name2) {\n      var value = attributes[name2];\n      value === !1 ? element.removeAttribute(name2) : element.setAttribute(name2, value === !0 ? \"\" : value);\n    }));\n  });\n}\nfunction effect(_ref2) {\n  var state = _ref2.state, initialStyles = {\n    popper: {\n      position: state.options.strategy,\n      left: \"0\",\n      top: \"0\",\n      margin: \"0\"\n    },\n    arrow: {\n      position: \"absolute\"\n    },\n    reference: {}\n  };\n  return Object.assign(state.elements.popper.style, initialStyles.popper), state.styles = initialStyles, state.elements.arrow && Object.assign(state.elements.arrow.style, initialStyles.arrow), function() {\n    Object.keys(state.elements).forEach(function(name) {\n      var element = state.elements[name], attributes = state.attributes[name] || {}, styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]), style = styleProperties.reduce(function(style2, property) {\n        return style2[property] = \"\", style2;\n      }, {});\n      !isHTMLElement(element) || !getNodeName(element) || (Object.assign(element.style, style), Object.keys(attributes).forEach(function(attribute) {\n        element.removeAttribute(attribute);\n      }));\n    });\n  };\n}\nvar applyStyles_default = {\n  name: \"applyStyles\",\n  enabled: !0,\n  phase: \"write\",\n  fn: applyStyles,\n  effect,\n  requires: [\"computeStyles\"]\n};\n\n// ../node_modules/@popperjs/core/lib/utils/getBasePlacement.js\nfunction getBasePlacement(placement) {\n  return placement.split(\"-\")[0];\n}\n\n// ../node_modules/@popperjs/core/lib/utils/math.js\nvar max = Math.max, min = Math.min, round = Math.round;\n\n// ../node_modules/@popperjs/core/lib/utils/userAgent.js\nfunction getUAString() {\n  var uaData = navigator.userAgentData;\n  return uaData != null && uaData.brands && Array.isArray(uaData.brands) ? uaData.brands.map(function(item) {\n    return item.brand + \"/\" + item.version;\n  }).join(\" \") : navigator.userAgent;\n}\n\n// ../node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js\nfunction isLayoutViewport() {\n  return !/^((?!chrome|android).)*safari/i.test(getUAString());\n}\n\n// ../node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy) {\n  includeScale === void 0 && (includeScale = !1), isFixedStrategy === void 0 && (isFixedStrategy = !1);\n  var clientRect = element.getBoundingClientRect(), scaleX = 1, scaleY = 1;\n  includeScale && isHTMLElement(element) && (scaleX = element.offsetWidth > 0 && round(clientRect.width) / element.offsetWidth || 1, scaleY = element.offsetHeight > 0 && round(clientRect.height) / element.offsetHeight || 1);\n  var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport, addVisualOffsets = !isLayoutViewport() && isFixedStrategy, x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX, y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY, width = clientRect.width / scaleX, height = clientRect.height / scaleY;\n  return {\n    width,\n    height,\n    top: y,\n    right: x + width,\n    bottom: y + height,\n    left: x,\n    x,\n    y\n  };\n}\n\n// ../node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js\nfunction getLayoutRect(element) {\n  var clientRect = getBoundingClientRect(element), width = element.offsetWidth, height = element.offsetHeight;\n  return Math.abs(clientRect.width - width) <= 1 && (width = clientRect.width), Math.abs(clientRect.height - height) <= 1 && (height = clientRect.height), {\n    x: element.offsetLeft,\n    y: element.offsetTop,\n    width,\n    height\n  };\n}\n\n// ../node_modules/@popperjs/core/lib/dom-utils/contains.js\nfunction contains(parent, child) {\n  var rootNode = child.getRootNode && child.getRootNode();\n  if (parent.contains(child))\n    return !0;\n  if (rootNode && isShadowRoot(rootNode)) {\n    var next = child;\n    do {\n      if (next && parent.isSameNode(next))\n        return !0;\n      next = next.parentNode || next.host;\n    } while (next);\n  }\n  return !1;\n}\n\n// ../node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\n\n// ../node_modules/@popperjs/core/lib/dom-utils/isTableElement.js\nfunction isTableElement(element) {\n  return [\"table\", \"td\", \"th\"].indexOf(getNodeName(element)) >= 0;\n}\n\n// ../node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js\nfunction getDocumentElement(element) {\n  return ((isElement(element) ? element.ownerDocument : (\n    // $FlowFixMe[prop-missing]\n    element.document\n  )) || window.document).documentElement;\n}\n\n// ../node_modules/@popperjs/core/lib/dom-utils/getParentNode.js\nfunction getParentNode(element) {\n  return getNodeName(element) === \"html\" ? element : (\n    // this is a quicker (but less type safe) way to save quite some bytes from the bundle\n    // $FlowFixMe[incompatible-return]\n    // $FlowFixMe[prop-missing]\n    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    element.parentNode || // DOM Element detected\n    (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected\n    // $FlowFixMe[incompatible-call]: HTMLElement is a Node\n    getDocumentElement(element)\n  );\n}\n\n// ../node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js\nfunction getTrueOffsetParent(element) {\n  return !isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837\n  getComputedStyle(element).position === \"fixed\" ? null : element.offsetParent;\n}\nfunction getContainingBlock(element) {\n  var isFirefox = /firefox/i.test(getUAString()), isIE = /Trident/i.test(getUAString());\n  if (isIE && isHTMLElement(element)) {\n    var elementCss = getComputedStyle(element);\n    if (elementCss.position === \"fixed\")\n      return null;\n  }\n  var currentNode = getParentNode(element);\n  for (isShadowRoot(currentNode) && (currentNode = currentNode.host); isHTMLElement(currentNode) && [\"html\", \"body\"].indexOf(getNodeName(currentNode)) < 0; ) {\n    var css = getComputedStyle(currentNode);\n    if (css.transform !== \"none\" || css.perspective !== \"none\" || css.contain === \"paint\" || [\"transform\", \"perspective\"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === \"filter\" || isFirefox && css.filter && css.filter !== \"none\")\n      return currentNode;\n    currentNode = currentNode.parentNode;\n  }\n  return null;\n}\nfunction getOffsetParent(element) {\n  for (var window2 = getWindow(element), offsetParent = getTrueOffsetParent(element); offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === \"static\"; )\n    offsetParent = getTrueOffsetParent(offsetParent);\n  return offsetParent && (getNodeName(offsetParent) === \"html\" || getNodeName(offsetParent) === \"body\" && getComputedStyle(offsetParent).position === \"static\") ? window2 : offsetParent || getContainingBlock(element) || window2;\n}\n\n// ../node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js\nfunction getMainAxisFromPlacement(placement) {\n  return [\"top\", \"bottom\"].indexOf(placement) >= 0 ? \"x\" : \"y\";\n}\n\n// ../node_modules/@popperjs/core/lib/utils/within.js\nfunction within(min2, value, max2) {\n  return max(min2, min(value, max2));\n}\nfunction withinMaxClamp(min2, value, max2) {\n  var v = within(min2, value, max2);\n  return v > max2 ? max2 : v;\n}\n\n// ../node_modules/@popperjs/core/lib/utils/getFreshSideObject.js\nfunction getFreshSideObject() {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  };\n}\n\n// ../node_modules/@popperjs/core/lib/utils/mergePaddingObject.js\nfunction mergePaddingObject(paddingObject) {\n  return Object.assign({}, getFreshSideObject(), paddingObject);\n}\n\n// ../node_modules/@popperjs/core/lib/utils/expandToHashMap.js\nfunction expandToHashMap(value, keys) {\n  return keys.reduce(function(hashMap, key) {\n    return hashMap[key] = value, hashMap;\n  }, {});\n}\n\n// ../node_modules/@popperjs/core/lib/modifiers/arrow.js\nvar toPaddingObject = function(padding, state) {\n  return padding = typeof padding == \"function\" ? padding(Object.assign({}, state.rects, {\n    placement: state.placement\n  })) : padding, mergePaddingObject(typeof padding != \"number\" ? padding : expandToHashMap(padding, basePlacements));\n};\nfunction arrow(_ref) {\n  var _state$modifiersData$, state = _ref.state, name = _ref.name, options = _ref.options, arrowElement = state.elements.arrow, popperOffsets2 = state.modifiersData.popperOffsets, basePlacement = getBasePlacement(state.placement), axis = getMainAxisFromPlacement(basePlacement), isVertical = [left, right].indexOf(basePlacement) >= 0, len = isVertical ? \"height\" : \"width\";\n  if (!(!arrowElement || !popperOffsets2)) {\n    var paddingObject = toPaddingObject(options.padding, state), arrowRect = getLayoutRect(arrowElement), minProp = axis === \"y\" ? top : left, maxProp = axis === \"y\" ? bottom : right, endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len], startDiff = popperOffsets2[axis] - state.rects.reference[axis], arrowOffsetParent = getOffsetParent(arrowElement), clientSize = arrowOffsetParent ? axis === \"y\" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0, centerToReference = endDiff / 2 - startDiff / 2, min2 = paddingObject[minProp], max2 = clientSize - arrowRect[len] - paddingObject[maxProp], center = clientSize / 2 - arrowRect[len] / 2 + centerToReference, offset2 = within(min2, center, max2), axisProp = axis;\n    state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);\n  }\n}\nfunction effect2(_ref2) {\n  var state = _ref2.state, options = _ref2.options, _options$element = options.element, arrowElement = _options$element === void 0 ? \"[data-popper-arrow]\" : _options$element;\n  arrowElement != null && (typeof arrowElement == \"string\" && (arrowElement = state.elements.popper.querySelector(arrowElement), !arrowElement) || contains(state.elements.popper, arrowElement) && (state.elements.arrow = arrowElement));\n}\nvar arrow_default = {\n  name: \"arrow\",\n  enabled: !0,\n  phase: \"main\",\n  fn: arrow,\n  effect: effect2,\n  requires: [\"popperOffsets\"],\n  requiresIfExists: [\"preventOverflow\"]\n};\n\n// ../node_modules/@popperjs/core/lib/utils/getVariation.js\nfunction getVariation(placement) {\n  return placement.split(\"-\")[1];\n}\n\n// ../node_modules/@popperjs/core/lib/modifiers/computeStyles.js\nvar unsetSides = {\n  top: \"auto\",\n  right: \"auto\",\n  bottom: \"auto\",\n  left: \"auto\"\n};\nfunction roundOffsetsByDPR(_ref, win) {\n  var x = _ref.x, y = _ref.y, dpr = win.devicePixelRatio || 1;\n  return {\n    x: round(x * dpr) / dpr || 0,\n    y: round(y * dpr) / dpr || 0\n  };\n}\nfunction mapToStyles(_ref2) {\n  var _Object$assign2, popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed, _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y, _ref3 = typeof roundOffsets == \"function\" ? roundOffsets({\n    x,\n    y\n  }) : {\n    x,\n    y\n  };\n  x = _ref3.x, y = _ref3.y;\n  var hasX = offsets.hasOwnProperty(\"x\"), hasY = offsets.hasOwnProperty(\"y\"), sideX = left, sideY = top, win = window;\n  if (adaptive) {\n    var offsetParent = getOffsetParent(popper2), heightProp = \"clientHeight\", widthProp = \"clientWidth\";\n    if (offsetParent === getWindow(popper2) && (offsetParent = getDocumentElement(popper2), getComputedStyle(offsetParent).position !== \"static\" && position === \"absolute\" && (heightProp = \"scrollHeight\", widthProp = \"scrollWidth\")), offsetParent = offsetParent, placement === top || (placement === left || placement === right) && variation === end) {\n      sideY = bottom;\n      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (\n        // $FlowFixMe[prop-missing]\n        offsetParent[heightProp]\n      );\n      y -= offsetY - popperRect.height, y *= gpuAcceleration ? 1 : -1;\n    }\n    if (placement === left || (placement === top || placement === bottom) && variation === end) {\n      sideX = right;\n      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (\n        // $FlowFixMe[prop-missing]\n        offsetParent[widthProp]\n      );\n      x -= offsetX - popperRect.width, x *= gpuAcceleration ? 1 : -1;\n    }\n  }\n  var commonStyles = Object.assign({\n    position\n  }, adaptive && unsetSides), _ref4 = roundOffsets === !0 ? roundOffsetsByDPR({\n    x,\n    y\n  }, getWindow(popper2)) : {\n    x,\n    y\n  };\n  if (x = _ref4.x, y = _ref4.y, gpuAcceleration) {\n    var _Object$assign;\n    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? \"0\" : \"\", _Object$assign[sideX] = hasX ? \"0\" : \"\", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? \"translate(\" + x + \"px, \" + y + \"px)\" : \"translate3d(\" + x + \"px, \" + y + \"px, 0)\", _Object$assign));\n  }\n  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + \"px\" : \"\", _Object$assign2[sideX] = hasX ? x + \"px\" : \"\", _Object$assign2.transform = \"\", _Object$assign2));\n}\nfunction computeStyles(_ref5) {\n  var state = _ref5.state, options = _ref5.options, _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? !0 : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? !0 : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? !0 : _options$roundOffsets, commonStyles = {\n    placement: getBasePlacement(state.placement),\n    variation: getVariation(state.placement),\n    popper: state.elements.popper,\n    popperRect: state.rects.popper,\n    gpuAcceleration,\n    isFixed: state.options.strategy === \"fixed\"\n  };\n  state.modifiersData.popperOffsets != null && (state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {\n    offsets: state.modifiersData.popperOffsets,\n    position: state.options.strategy,\n    adaptive,\n    roundOffsets\n  })))), state.modifiersData.arrow != null && (state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {\n    offsets: state.modifiersData.arrow,\n    position: \"absolute\",\n    adaptive: !1,\n    roundOffsets\n  })))), state.attributes.popper = Object.assign({}, state.attributes.popper, {\n    \"data-popper-placement\": state.placement\n  });\n}\nvar computeStyles_default = {\n  name: \"computeStyles\",\n  enabled: !0,\n  phase: \"beforeWrite\",\n  fn: computeStyles,\n  data: {}\n};\n\n// ../node_modules/@popperjs/core/lib/modifiers/eventListeners.js\nvar passive = {\n  passive: !0\n};\nfunction effect3(_ref) {\n  var state = _ref.state, instance = _ref.instance, options = _ref.options, _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? !0 : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? !0 : _options$resize, window2 = getWindow(state.elements.popper), scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);\n  return scroll && scrollParents.forEach(function(scrollParent) {\n    scrollParent.addEventListener(\"scroll\", instance.update, passive);\n  }), resize && window2.addEventListener(\"resize\", instance.update, passive), function() {\n    scroll && scrollParents.forEach(function(scrollParent) {\n      scrollParent.removeEventListener(\"scroll\", instance.update, passive);\n    }), resize && window2.removeEventListener(\"resize\", instance.update, passive);\n  };\n}\nvar eventListeners_default = {\n  name: \"eventListeners\",\n  enabled: !0,\n  phase: \"write\",\n  fn: function() {\n  },\n  effect: effect3,\n  data: {}\n};\n\n// ../node_modules/@popperjs/core/lib/utils/getOppositePlacement.js\nvar hash = {\n  left: \"right\",\n  right: \"left\",\n  bottom: \"top\",\n  top: \"bottom\"\n};\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, function(matched) {\n    return hash[matched];\n  });\n}\n\n// ../node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js\nvar hash2 = {\n  start: \"end\",\n  end: \"start\"\n};\nfunction getOppositeVariationPlacement(placement) {\n  return placement.replace(/start|end/g, function(matched) {\n    return hash2[matched];\n  });\n}\n\n// ../node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js\nfunction getWindowScroll(node) {\n  var win = getWindow(node), scrollLeft = win.pageXOffset, scrollTop = win.pageYOffset;\n  return {\n    scrollLeft,\n    scrollTop\n  };\n}\n\n// ../node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js\nfunction getWindowScrollBarX(element) {\n  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;\n}\n\n// ../node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js\nfunction getViewportRect(element, strategy) {\n  var win = getWindow(element), html = getDocumentElement(element), visualViewport = win.visualViewport, width = html.clientWidth, height = html.clientHeight, x = 0, y = 0;\n  if (visualViewport) {\n    width = visualViewport.width, height = visualViewport.height;\n    var layoutViewport = isLayoutViewport();\n    (layoutViewport || !layoutViewport && strategy === \"fixed\") && (x = visualViewport.offsetLeft, y = visualViewport.offsetTop);\n  }\n  return {\n    width,\n    height,\n    x: x + getWindowScrollBarX(element),\n    y\n  };\n}\n\n// ../node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js\nfunction getDocumentRect(element) {\n  var _element$ownerDocumen, html = getDocumentElement(element), winScroll = getWindowScroll(element), body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body, width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0), height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0), x = -winScroll.scrollLeft + getWindowScrollBarX(element), y = -winScroll.scrollTop;\n  return getComputedStyle(body || html).direction === \"rtl\" && (x += max(html.clientWidth, body ? body.clientWidth : 0) - width), {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// ../node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js\nfunction isScrollParent(element) {\n  var _getComputedStyle = getComputedStyle(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;\n  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n}\n\n// ../node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js\nfunction getScrollParent(node) {\n  return [\"html\", \"body\", \"#document\"].indexOf(getNodeName(node)) >= 0 ? node.ownerDocument.body : isHTMLElement(node) && isScrollParent(node) ? node : getScrollParent(getParentNode(node));\n}\n\n// ../node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js\nfunction listScrollParents(element, list) {\n  var _element$ownerDocumen;\n  list === void 0 && (list = []);\n  var scrollParent = getScrollParent(element), isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body), win = getWindow(scrollParent), target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent, updatedList = list.concat(target);\n  return isBody ? updatedList : (\n    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here\n    updatedList.concat(listScrollParents(getParentNode(target)))\n  );\n}\n\n// ../node_modules/@popperjs/core/lib/utils/rectToClientRect.js\nfunction rectToClientRect(rect) {\n  return Object.assign({}, rect, {\n    left: rect.x,\n    top: rect.y,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  });\n}\n\n// ../node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js\nfunction getInnerBoundingClientRect(element, strategy) {\n  var rect = getBoundingClientRect(element, !1, strategy === \"fixed\");\n  return rect.top = rect.top + element.clientTop, rect.left = rect.left + element.clientLeft, rect.bottom = rect.top + element.clientHeight, rect.right = rect.left + element.clientWidth, rect.width = element.clientWidth, rect.height = element.clientHeight, rect.x = rect.left, rect.y = rect.top, rect;\n}\nfunction getClientRectFromMixedType(element, clippingParent, strategy) {\n  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));\n}\nfunction getClippingParents(element) {\n  var clippingParents2 = listScrollParents(getParentNode(element)), canEscapeClipping = [\"absolute\", \"fixed\"].indexOf(getComputedStyle(element).position) >= 0, clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n  return isElement(clipperElement) ? clippingParents2.filter(function(clippingParent) {\n    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== \"body\";\n  }) : [];\n}\nfunction getClippingRect(element, boundary, rootBoundary, strategy) {\n  var mainClippingParents = boundary === \"clippingParents\" ? getClippingParents(element) : [].concat(boundary), clippingParents2 = [].concat(mainClippingParents, [rootBoundary]), firstClippingParent = clippingParents2[0], clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {\n    var rect = getClientRectFromMixedType(element, clippingParent, strategy);\n    return accRect.top = max(rect.top, accRect.top), accRect.right = min(rect.right, accRect.right), accRect.bottom = min(rect.bottom, accRect.bottom), accRect.left = max(rect.left, accRect.left), accRect;\n  }, getClientRectFromMixedType(element, firstClippingParent, strategy));\n  return clippingRect.width = clippingRect.right - clippingRect.left, clippingRect.height = clippingRect.bottom - clippingRect.top, clippingRect.x = clippingRect.left, clippingRect.y = clippingRect.top, clippingRect;\n}\n\n// ../node_modules/@popperjs/core/lib/utils/computeOffsets.js\nfunction computeOffsets(_ref) {\n  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement, basePlacement = placement ? getBasePlacement(placement) : null, variation = placement ? getVariation(placement) : null, commonX = reference2.x + reference2.width / 2 - element.width / 2, commonY = reference2.y + reference2.height / 2 - element.height / 2, offsets;\n  switch (basePlacement) {\n    case top:\n      offsets = {\n        x: commonX,\n        y: reference2.y - element.height\n      };\n      break;\n    case bottom:\n      offsets = {\n        x: commonX,\n        y: reference2.y + reference2.height\n      };\n      break;\n    case right:\n      offsets = {\n        x: reference2.x + reference2.width,\n        y: commonY\n      };\n      break;\n    case left:\n      offsets = {\n        x: reference2.x - element.width,\n        y: commonY\n      };\n      break;\n    default:\n      offsets = {\n        x: reference2.x,\n        y: reference2.y\n      };\n  }\n  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;\n  if (mainAxis != null) {\n    var len = mainAxis === \"y\" ? \"height\" : \"width\";\n    switch (variation) {\n      case start:\n        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);\n        break;\n      case end:\n        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);\n        break;\n      default:\n    }\n  }\n  return offsets;\n}\n\n// ../node_modules/@popperjs/core/lib/utils/detectOverflow.js\nfunction detectOverflow(state, options) {\n  options === void 0 && (options = {});\n  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? !1 : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding, paddingObject = mergePaddingObject(typeof padding != \"number\" ? padding : expandToHashMap(padding, basePlacements)), altContext = elementContext === popper ? reference : popper, popperRect = state.rects.popper, element = state.elements[altBoundary ? altContext : elementContext], clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy), referenceClientRect = getBoundingClientRect(state.elements.reference), popperOffsets2 = computeOffsets({\n    reference: referenceClientRect,\n    element: popperRect,\n    strategy: \"absolute\",\n    placement\n  }), popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2)), elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect, overflowOffsets = {\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n    right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n  }, offsetData = state.modifiersData.offset;\n  if (elementContext === popper && offsetData) {\n    var offset2 = offsetData[placement];\n    Object.keys(overflowOffsets).forEach(function(key) {\n      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1, axis = [top, bottom].indexOf(key) >= 0 ? \"y\" : \"x\";\n      overflowOffsets[key] += offset2[axis] * multiply;\n    });\n  }\n  return overflowOffsets;\n}\n\n// ../node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js\nfunction computeAutoPlacement(state, options) {\n  options === void 0 && (options = {});\n  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP, variation = getVariation(placement), placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {\n    return getVariation(placement2) === variation;\n  }) : basePlacements, allowedPlacements = placements2.filter(function(placement2) {\n    return allowedAutoPlacements.indexOf(placement2) >= 0;\n  });\n  allowedPlacements.length === 0 && (allowedPlacements = placements2);\n  var overflows = allowedPlacements.reduce(function(acc, placement2) {\n    return acc[placement2] = detectOverflow(state, {\n      placement: placement2,\n      boundary,\n      rootBoundary,\n      padding\n    })[getBasePlacement(placement2)], acc;\n  }, {});\n  return Object.keys(overflows).sort(function(a, b) {\n    return overflows[a] - overflows[b];\n  });\n}\n\n// ../node_modules/@popperjs/core/lib/modifiers/flip.js\nfunction getExpandedFallbackPlacements(placement) {\n  if (getBasePlacement(placement) === auto)\n    return [];\n  var oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];\n}\nfunction flip(_ref) {\n  var state = _ref.state, options = _ref.options, name = _ref.name;\n  if (!state.modifiersData[name]._skip) {\n    for (var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? !0 : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? !0 : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? !0 : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements, preferredPlacement = state.options.placement, basePlacement = getBasePlacement(preferredPlacement), isBasePlacement = basePlacement === preferredPlacement, fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement)), placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {\n      return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {\n        placement: placement2,\n        boundary,\n        rootBoundary,\n        padding,\n        flipVariations,\n        allowedAutoPlacements\n      }) : placement2);\n    }, []), referenceRect = state.rects.reference, popperRect = state.rects.popper, checksMap = /* @__PURE__ */ new Map(), makeFallbackChecks = !0, firstFittingPlacement = placements2[0], i = 0; i < placements2.length; i++) {\n      var placement = placements2[i], _basePlacement = getBasePlacement(placement), isStartVariation = getVariation(placement) === start, isVertical = [top, bottom].indexOf(_basePlacement) >= 0, len = isVertical ? \"width\" : \"height\", overflow = detectOverflow(state, {\n        placement,\n        boundary,\n        rootBoundary,\n        altBoundary,\n        padding\n      }), mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;\n      referenceRect[len] > popperRect[len] && (mainVariationSide = getOppositePlacement(mainVariationSide));\n      var altVariationSide = getOppositePlacement(mainVariationSide), checks = [];\n      if (checkMainAxis && checks.push(overflow[_basePlacement] <= 0), checkAltAxis && checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0), checks.every(function(check) {\n        return check;\n      })) {\n        firstFittingPlacement = placement, makeFallbackChecks = !1;\n        break;\n      }\n      checksMap.set(placement, checks);\n    }\n    if (makeFallbackChecks)\n      for (var numberOfChecks = flipVariations ? 3 : 1, _loop = function(_i2) {\n        var fittingPlacement = placements2.find(function(placement2) {\n          var checks2 = checksMap.get(placement2);\n          if (checks2)\n            return checks2.slice(0, _i2).every(function(check) {\n              return check;\n            });\n        });\n        if (fittingPlacement)\n          return firstFittingPlacement = fittingPlacement, \"break\";\n      }, _i = numberOfChecks; _i > 0; _i--) {\n        var _ret = _loop(_i);\n        if (_ret === \"break\") break;\n      }\n    state.placement !== firstFittingPlacement && (state.modifiersData[name]._skip = !0, state.placement = firstFittingPlacement, state.reset = !0);\n  }\n}\nvar flip_default = {\n  name: \"flip\",\n  enabled: !0,\n  phase: \"main\",\n  fn: flip,\n  requiresIfExists: [\"offset\"],\n  data: {\n    _skip: !1\n  }\n};\n\n// ../node_modules/@popperjs/core/lib/modifiers/hide.js\nfunction getSideOffsets(overflow, rect, preventedOffsets) {\n  return preventedOffsets === void 0 && (preventedOffsets = {\n    x: 0,\n    y: 0\n  }), {\n    top: overflow.top - rect.height - preventedOffsets.y,\n    right: overflow.right - rect.width + preventedOffsets.x,\n    bottom: overflow.bottom - rect.height + preventedOffsets.y,\n    left: overflow.left - rect.width - preventedOffsets.x\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return [top, right, bottom, left].some(function(side) {\n    return overflow[side] >= 0;\n  });\n}\nfunction hide(_ref) {\n  var state = _ref.state, name = _ref.name, referenceRect = state.rects.reference, popperRect = state.rects.popper, preventedOffsets = state.modifiersData.preventOverflow, referenceOverflow = detectOverflow(state, {\n    elementContext: \"reference\"\n  }), popperAltOverflow = detectOverflow(state, {\n    altBoundary: !0\n  }), referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect), popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets), isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets), hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);\n  state.modifiersData[name] = {\n    referenceClippingOffsets,\n    popperEscapeOffsets,\n    isReferenceHidden,\n    hasPopperEscaped\n  }, state.attributes.popper = Object.assign({}, state.attributes.popper, {\n    \"data-popper-reference-hidden\": isReferenceHidden,\n    \"data-popper-escaped\": hasPopperEscaped\n  });\n}\nvar hide_default = {\n  name: \"hide\",\n  enabled: !0,\n  phase: \"main\",\n  requiresIfExists: [\"preventOverflow\"],\n  fn: hide\n};\n\n// ../node_modules/@popperjs/core/lib/modifiers/offset.js\nfunction distanceAndSkiddingToXY(placement, rects, offset2) {\n  var basePlacement = getBasePlacement(placement), invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1, _ref = typeof offset2 == \"function\" ? offset2(Object.assign({}, rects, {\n    placement\n  })) : offset2, skidding = _ref[0], distance = _ref[1];\n  return skidding = skidding || 0, distance = (distance || 0) * invertDistance, [left, right].indexOf(basePlacement) >= 0 ? {\n    x: distance,\n    y: skidding\n  } : {\n    x: skidding,\n    y: distance\n  };\n}\nfunction offset(_ref2) {\n  var state = _ref2.state, options = _ref2.options, name = _ref2.name, _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset, data = placements.reduce(function(acc, placement) {\n    return acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2), acc;\n  }, {}), _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;\n  state.modifiersData.popperOffsets != null && (state.modifiersData.popperOffsets.x += x, state.modifiersData.popperOffsets.y += y), state.modifiersData[name] = data;\n}\nvar offset_default = {\n  name: \"offset\",\n  enabled: !0,\n  phase: \"main\",\n  requires: [\"popperOffsets\"],\n  fn: offset\n};\n\n// ../node_modules/@popperjs/core/lib/modifiers/popperOffsets.js\nfunction popperOffsets(_ref) {\n  var state = _ref.state, name = _ref.name;\n  state.modifiersData[name] = computeOffsets({\n    reference: state.rects.reference,\n    element: state.rects.popper,\n    strategy: \"absolute\",\n    placement: state.placement\n  });\n}\nvar popperOffsets_default = {\n  name: \"popperOffsets\",\n  enabled: !0,\n  phase: \"read\",\n  fn: popperOffsets,\n  data: {}\n};\n\n// ../node_modules/@popperjs/core/lib/utils/getAltAxis.js\nfunction getAltAxis(axis) {\n  return axis === \"x\" ? \"y\" : \"x\";\n}\n\n// ../node_modules/@popperjs/core/lib/modifiers/preventOverflow.js\nfunction preventOverflow(_ref) {\n  var state = _ref.state, options = _ref.options, name = _ref.name, _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? !0 : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? !1 : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? !0 : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset, overflow = detectOverflow(state, {\n    boundary,\n    rootBoundary,\n    padding,\n    altBoundary\n  }), basePlacement = getBasePlacement(state.placement), variation = getVariation(state.placement), isBasePlacement = !variation, mainAxis = getMainAxisFromPlacement(basePlacement), altAxis = getAltAxis(mainAxis), popperOffsets2 = state.modifiersData.popperOffsets, referenceRect = state.rects.reference, popperRect = state.rects.popper, tetherOffsetValue = typeof tetherOffset == \"function\" ? tetherOffset(Object.assign({}, state.rects, {\n    placement: state.placement\n  })) : tetherOffset, normalizedTetherOffsetValue = typeof tetherOffsetValue == \"number\" ? {\n    mainAxis: tetherOffsetValue,\n    altAxis: tetherOffsetValue\n  } : Object.assign({\n    mainAxis: 0,\n    altAxis: 0\n  }, tetherOffsetValue), offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null, data = {\n    x: 0,\n    y: 0\n  };\n  if (popperOffsets2) {\n    if (checkMainAxis) {\n      var _offsetModifierState$, mainSide = mainAxis === \"y\" ? top : left, altSide = mainAxis === \"y\" ? bottom : right, len = mainAxis === \"y\" ? \"height\" : \"width\", offset2 = popperOffsets2[mainAxis], min2 = offset2 + overflow[mainSide], max2 = offset2 - overflow[altSide], additive = tether ? -popperRect[len] / 2 : 0, minLen = variation === start ? referenceRect[len] : popperRect[len], maxLen = variation === start ? -popperRect[len] : -referenceRect[len], arrowElement = state.elements.arrow, arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {\n        width: 0,\n        height: 0\n      }, arrowPaddingObject = state.modifiersData[\"arrow#persistent\"] ? state.modifiersData[\"arrow#persistent\"].padding : getFreshSideObject(), arrowPaddingMin = arrowPaddingObject[mainSide], arrowPaddingMax = arrowPaddingObject[altSide], arrowLen = within(0, referenceRect[len], arrowRect[len]), minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis, maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis, arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow), clientOffset = arrowOffsetParent ? mainAxis === \"y\" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0, offsetModifierValue = (_offsetModifierState$ = offsetModifierState?.[mainAxis]) != null ? _offsetModifierState$ : 0, tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset, tetherMax = offset2 + maxOffset - offsetModifierValue, preventedOffset = within(tether ? min(min2, tetherMin) : min2, offset2, tether ? max(max2, tetherMax) : max2);\n      popperOffsets2[mainAxis] = preventedOffset, data[mainAxis] = preventedOffset - offset2;\n    }\n    if (checkAltAxis) {\n      var _offsetModifierState$2, _mainSide = mainAxis === \"x\" ? top : left, _altSide = mainAxis === \"x\" ? bottom : right, _offset = popperOffsets2[altAxis], _len = altAxis === \"y\" ? \"height\" : \"width\", _min = _offset + overflow[_mainSide], _max = _offset - overflow[_altSide], isOriginSide = [top, left].indexOf(basePlacement) !== -1, _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState?.[altAxis]) != null ? _offsetModifierState$2 : 0, _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis, _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max, _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);\n      popperOffsets2[altAxis] = _preventedOffset, data[altAxis] = _preventedOffset - _offset;\n    }\n    state.modifiersData[name] = data;\n  }\n}\nvar preventOverflow_default = {\n  name: \"preventOverflow\",\n  enabled: !0,\n  phase: \"main\",\n  fn: preventOverflow,\n  requiresIfExists: [\"offset\"]\n};\n\n// ../node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js\nfunction getHTMLElementScroll(element) {\n  return {\n    scrollLeft: element.scrollLeft,\n    scrollTop: element.scrollTop\n  };\n}\n\n// ../node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js\nfunction getNodeScroll(node) {\n  return node === getWindow(node) || !isHTMLElement(node) ? getWindowScroll(node) : getHTMLElementScroll(node);\n}\n\n// ../node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js\nfunction isElementScaled(element) {\n  var rect = element.getBoundingClientRect(), scaleX = round(rect.width) / element.offsetWidth || 1, scaleY = round(rect.height) / element.offsetHeight || 1;\n  return scaleX !== 1 || scaleY !== 1;\n}\nfunction getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {\n  isFixed === void 0 && (isFixed = !1);\n  var isOffsetParentAnElement = isHTMLElement(offsetParent), offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent), documentElement = getDocumentElement(offsetParent), rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed), scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  }, offsets = {\n    x: 0,\n    y: 0\n  };\n  return (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) && ((getNodeName(offsetParent) !== \"body\" || // https://github.com/popperjs/popper-core/issues/1078\n  isScrollParent(documentElement)) && (scroll = getNodeScroll(offsetParent)), isHTMLElement(offsetParent) ? (offsets = getBoundingClientRect(offsetParent, !0), offsets.x += offsetParent.clientLeft, offsets.y += offsetParent.clientTop) : documentElement && (offsets.x = getWindowScrollBarX(documentElement))), {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\n// ../node_modules/@popperjs/core/lib/utils/orderModifiers.js\nfunction order(modifiers) {\n  var map = /* @__PURE__ */ new Map(), visited = /* @__PURE__ */ new Set(), result = [];\n  modifiers.forEach(function(modifier) {\n    map.set(modifier.name, modifier);\n  });\n  function sort(modifier) {\n    visited.add(modifier.name);\n    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);\n    requires.forEach(function(dep) {\n      if (!visited.has(dep)) {\n        var depModifier = map.get(dep);\n        depModifier && sort(depModifier);\n      }\n    }), result.push(modifier);\n  }\n  return modifiers.forEach(function(modifier) {\n    visited.has(modifier.name) || sort(modifier);\n  }), result;\n}\nfunction orderModifiers(modifiers) {\n  var orderedModifiers = order(modifiers);\n  return modifierPhases.reduce(function(acc, phase) {\n    return acc.concat(orderedModifiers.filter(function(modifier) {\n      return modifier.phase === phase;\n    }));\n  }, []);\n}\n\n// ../node_modules/@popperjs/core/lib/utils/debounce.js\nfunction debounce(fn2) {\n  var pending;\n  return function() {\n    return pending || (pending = new Promise(function(resolve) {\n      Promise.resolve().then(function() {\n        pending = void 0, resolve(fn2());\n      });\n    })), pending;\n  };\n}\n\n// ../node_modules/@popperjs/core/lib/utils/mergeByName.js\nfunction mergeByName(modifiers) {\n  var merged = modifiers.reduce(function(merged2, current) {\n    var existing = merged2[current.name];\n    return merged2[current.name] = existing ? Object.assign({}, existing, current, {\n      options: Object.assign({}, existing.options, current.options),\n      data: Object.assign({}, existing.data, current.data)\n    }) : current, merged2;\n  }, {});\n  return Object.keys(merged).map(function(key) {\n    return merged[key];\n  });\n}\n\n// ../node_modules/@popperjs/core/lib/createPopper.js\nvar DEFAULT_OPTIONS = {\n  placement: \"bottom\",\n  modifiers: [],\n  strategy: \"absolute\"\n};\nfunction areValidElements() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)\n    args[_key] = arguments[_key];\n  return !args.some(function(element) {\n    return !(element && typeof element.getBoundingClientRect == \"function\");\n  });\n}\nfunction popperGenerator(generatorOptions) {\n  generatorOptions === void 0 && (generatorOptions = {});\n  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers3 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;\n  return function(reference2, popper2, options) {\n    options === void 0 && (options = defaultOptions);\n    var state = {\n      placement: \"bottom\",\n      orderedModifiers: [],\n      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),\n      modifiersData: {},\n      elements: {\n        reference: reference2,\n        popper: popper2\n      },\n      attributes: {},\n      styles: {}\n    }, effectCleanupFns = [], isDestroyed = !1, instance = {\n      state,\n      setOptions: function(setOptionsAction) {\n        var options2 = typeof setOptionsAction == \"function\" ? setOptionsAction(state.options) : setOptionsAction;\n        cleanupModifierEffects(), state.options = Object.assign({}, defaultOptions, state.options, options2), state.scrollParents = {\n          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],\n          popper: listScrollParents(popper2)\n        };\n        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers3, state.options.modifiers)));\n        return state.orderedModifiers = orderedModifiers.filter(function(m) {\n          return m.enabled;\n        }), runModifierEffects(), instance.update();\n      },\n      // Sync update  it will always be executed, even if not necessary. This\n      // is useful for low frequency updates where sync behavior simplifies the\n      // logic.\n      // For high frequency updates (e.g. `resize` and `scroll` events), always\n      // prefer the async Popper#update method\n      forceUpdate: function() {\n        if (!isDestroyed) {\n          var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;\n          if (areValidElements(reference3, popper3)) {\n            state.rects = {\n              reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === \"fixed\"),\n              popper: getLayoutRect(popper3)\n            }, state.reset = !1, state.placement = state.options.placement, state.orderedModifiers.forEach(function(modifier) {\n              return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);\n            });\n            for (var index = 0; index < state.orderedModifiers.length; index++) {\n              if (state.reset === !0) {\n                state.reset = !1, index = -1;\n                continue;\n              }\n              var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;\n              typeof fn2 == \"function\" && (state = fn2({\n                state,\n                options: _options,\n                name,\n                instance\n              }) || state);\n            }\n          }\n        }\n      },\n      // Async and optimistically optimized update  it will not be executed if\n      // not necessary (debounced to run at most once-per-tick)\n      update: debounce(function() {\n        return new Promise(function(resolve) {\n          instance.forceUpdate(), resolve(state);\n        });\n      }),\n      destroy: function() {\n        cleanupModifierEffects(), isDestroyed = !0;\n      }\n    };\n    if (!areValidElements(reference2, popper2))\n      return instance;\n    instance.setOptions(options).then(function(state2) {\n      !isDestroyed && options.onFirstUpdate && options.onFirstUpdate(state2);\n    });\n    function runModifierEffects() {\n      state.orderedModifiers.forEach(function(_ref) {\n        var name = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect4 = _ref.effect;\n        if (typeof effect4 == \"function\") {\n          var cleanupFn = effect4({\n            state,\n            name,\n            instance,\n            options: options2\n          }), noopFn = function() {\n          };\n          effectCleanupFns.push(cleanupFn || noopFn);\n        }\n      });\n    }\n    function cleanupModifierEffects() {\n      effectCleanupFns.forEach(function(fn2) {\n        return fn2();\n      }), effectCleanupFns = [];\n    }\n    return instance;\n  };\n}\nvar createPopper = popperGenerator();\n\n// ../node_modules/@popperjs/core/lib/popper-lite.js\nvar defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default], createPopper2 = popperGenerator({\n  defaultModifiers\n});\n\n// ../node_modules/@popperjs/core/lib/popper.js\nvar defaultModifiers2 = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default], createPopper3 = popperGenerator({\n  defaultModifiers: defaultModifiers2\n});\n\n// ../node_modules/react-popper/lib/esm/usePopper.js\nvar import_react_fast_compare = __toESM(require_react_fast_compare());\nvar EMPTY_MODIFIERS = [], usePopper = function(referenceElement, popperElement, options) {\n  options === void 0 && (options = {});\n  var prevOptions = React3.useRef(null), optionsWithDefaults = {\n    onFirstUpdate: options.onFirstUpdate,\n    placement: options.placement || \"bottom\",\n    strategy: options.strategy || \"absolute\",\n    modifiers: options.modifiers || EMPTY_MODIFIERS\n  }, _React$useState = React3.useState({\n    styles: {\n      popper: {\n        position: optionsWithDefaults.strategy,\n        left: \"0\",\n        top: \"0\"\n      },\n      arrow: {\n        position: \"absolute\"\n      }\n    },\n    attributes: {}\n  }), state = _React$useState[0], setState = _React$useState[1], updateStateModifier = React3.useMemo(function() {\n    return {\n      name: \"updateState\",\n      enabled: !0,\n      phase: \"write\",\n      fn: function(_ref) {\n        var state2 = _ref.state, elements = Object.keys(state2.elements);\n        ReactDOM.flushSync(function() {\n          setState({\n            styles: fromEntries(elements.map(function(element) {\n              return [element, state2.styles[element] || {}];\n            })),\n            attributes: fromEntries(elements.map(function(element) {\n              return [element, state2.attributes[element]];\n            }))\n          });\n        });\n      },\n      requires: [\"computeStyles\"]\n    };\n  }, []), popperOptions = React3.useMemo(function() {\n    var newOptions = {\n      onFirstUpdate: optionsWithDefaults.onFirstUpdate,\n      placement: optionsWithDefaults.placement,\n      strategy: optionsWithDefaults.strategy,\n      modifiers: [].concat(optionsWithDefaults.modifiers, [updateStateModifier, {\n        name: \"applyStyles\",\n        enabled: !1\n      }])\n    };\n    return (0, import_react_fast_compare.default)(prevOptions.current, newOptions) ? prevOptions.current || newOptions : (prevOptions.current = newOptions, newOptions);\n  }, [optionsWithDefaults.onFirstUpdate, optionsWithDefaults.placement, optionsWithDefaults.strategy, optionsWithDefaults.modifiers, updateStateModifier]), popperInstanceRef = React3.useRef();\n  return useIsomorphicLayoutEffect(function() {\n    popperInstanceRef.current && popperInstanceRef.current.setOptions(popperOptions);\n  }, [popperOptions]), useIsomorphicLayoutEffect(function() {\n    if (!(referenceElement == null || popperElement == null)) {\n      var createPopper4 = options.createPopper || createPopper3, popperInstance = createPopper4(referenceElement, popperElement, popperOptions);\n      return popperInstanceRef.current = popperInstance, function() {\n        popperInstance.destroy(), popperInstanceRef.current = null;\n      };\n    }\n  }, [referenceElement, popperElement, options.createPopper]), {\n    state: popperInstanceRef.current ? popperInstanceRef.current.state : null,\n    styles: state.styles,\n    attributes: state.attributes,\n    update: popperInstanceRef.current ? popperInstanceRef.current.update : null,\n    forceUpdate: popperInstanceRef.current ? popperInstanceRef.current.forceUpdate : null\n  };\n};\n\n// ../node_modules/react-popper/lib/esm/Reference.js\nvar import_warning = __toESM(require_warning());\nimport * as React5 from \"react\";\n\n// ../node_modules/react-popper-tooltip/dist/esm/react-popper-tooltip.js\nfunction useGetLatest(val) {\n  var ref = React6.useRef(val);\n  return ref.current = val, React6.useCallback(function() {\n    return ref.current;\n  }, []);\n}\nvar noop = function() {\n};\nfunction useControlledState(_ref) {\n  var initial = _ref.initial, value = _ref.value, _ref$onChange = _ref.onChange, onChange = _ref$onChange === void 0 ? noop : _ref$onChange;\n  if (initial === void 0 && value === void 0)\n    throw new TypeError('Either \"value\" or \"initial\" variable must be set. Now both are undefined');\n  var _React$useState = React6.useState(initial), state = _React$useState[0], setState = _React$useState[1], getLatest = useGetLatest(state), set = React6.useCallback(function(updater) {\n    var state2 = getLatest(), updatedState = typeof updater == \"function\" ? updater(state2) : updater;\n    typeof updatedState.persist == \"function\" && updatedState.persist(), setState(updatedState), typeof onChange == \"function\" && onChange(updatedState);\n  }, [getLatest, onChange]), isControlled = value !== void 0;\n  return [isControlled ? value : state, isControlled ? onChange : set];\n}\nfunction generateBoundingClientRect(x, y) {\n  return x === void 0 && (x = 0), y === void 0 && (y = 0), function() {\n    return {\n      width: 0,\n      height: 0,\n      top: y,\n      right: x,\n      bottom: y,\n      left: x,\n      x: 0,\n      y: 0,\n      toJSON: function() {\n        return null;\n      }\n    };\n  };\n}\nvar _excluded = [\"styles\", \"attributes\"], virtualElement = {\n  getBoundingClientRect: generateBoundingClientRect()\n}, defaultConfig = {\n  closeOnOutsideClick: !0,\n  closeOnTriggerHidden: !1,\n  defaultVisible: !1,\n  delayHide: 0,\n  delayShow: 0,\n  followCursor: !1,\n  interactive: !1,\n  mutationObserverOptions: {\n    attributes: !0,\n    childList: !0,\n    subtree: !0\n  },\n  offset: [0, 6],\n  trigger: \"hover\"\n};\nfunction usePopperTooltip(config, popperOptions) {\n  var _popperProps$state, _popperProps$state$mo, _popperProps$state$mo2;\n  config === void 0 && (config = {}), popperOptions === void 0 && (popperOptions = {});\n  var finalConfig = Object.keys(defaultConfig).reduce(function(config2, key) {\n    var _extends2;\n    return _extends({}, config2, (_extends2 = {}, _extends2[key] = config2[key] !== void 0 ? config2[key] : defaultConfig[key], _extends2));\n  }, config), defaultModifiers3 = React6.useMemo(\n    function() {\n      return [{\n        name: \"offset\",\n        options: {\n          offset: finalConfig.offset\n        }\n      }];\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    Array.isArray(finalConfig.offset) ? finalConfig.offset : []\n  ), finalPopperOptions = _extends({}, popperOptions, {\n    placement: popperOptions.placement || finalConfig.placement,\n    modifiers: popperOptions.modifiers || defaultModifiers3\n  }), _React$useState = React6.useState(null), triggerRef = _React$useState[0], setTriggerRef = _React$useState[1], _React$useState2 = React6.useState(null), tooltipRef = _React$useState2[0], setTooltipRef = _React$useState2[1], _useControlledState = useControlledState({\n    initial: finalConfig.defaultVisible,\n    value: finalConfig.visible,\n    onChange: finalConfig.onVisibleChange\n  }), visible = _useControlledState[0], setVisible = _useControlledState[1], timer = React6.useRef();\n  React6.useEffect(function() {\n    return function() {\n      return clearTimeout(timer.current);\n    };\n  }, []);\n  var _usePopper = usePopper(finalConfig.followCursor ? virtualElement : triggerRef, tooltipRef, finalPopperOptions), styles = _usePopper.styles, attributes = _usePopper.attributes, popperProps = _objectWithoutPropertiesLoose(_usePopper, _excluded), update = popperProps.update, getLatest = useGetLatest({\n    visible,\n    triggerRef,\n    tooltipRef,\n    finalConfig\n  }), isTriggeredBy = React6.useCallback(\n    function(trigger) {\n      return Array.isArray(finalConfig.trigger) ? finalConfig.trigger.includes(trigger) : finalConfig.trigger === trigger;\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    Array.isArray(finalConfig.trigger) ? finalConfig.trigger : [finalConfig.trigger]\n  ), hideTooltip = React6.useCallback(function() {\n    clearTimeout(timer.current), timer.current = window.setTimeout(function() {\n      return setVisible(!1);\n    }, finalConfig.delayHide);\n  }, [finalConfig.delayHide, setVisible]), showTooltip = React6.useCallback(function() {\n    clearTimeout(timer.current), timer.current = window.setTimeout(function() {\n      return setVisible(!0);\n    }, finalConfig.delayShow);\n  }, [finalConfig.delayShow, setVisible]), toggleTooltip = React6.useCallback(function() {\n    getLatest().visible ? hideTooltip() : showTooltip();\n  }, [getLatest, hideTooltip, showTooltip]);\n  React6.useEffect(function() {\n    if (getLatest().finalConfig.closeOnOutsideClick) {\n      var handleClickOutside = function(event) {\n        var _event$composedPath, _getLatest = getLatest(), tooltipRef2 = _getLatest.tooltipRef, triggerRef2 = _getLatest.triggerRef, target = (event.composedPath == null || (_event$composedPath = event.composedPath()) == null ? void 0 : _event$composedPath[0]) || event.target;\n        target instanceof Node && tooltipRef2 != null && triggerRef2 != null && !tooltipRef2.contains(target) && !triggerRef2.contains(target) && hideTooltip();\n      };\n      return document.addEventListener(\"mousedown\", handleClickOutside), function() {\n        return document.removeEventListener(\"mousedown\", handleClickOutside);\n      };\n    }\n  }, [getLatest, hideTooltip]), React6.useEffect(function() {\n    if (!(triggerRef == null || !isTriggeredBy(\"click\")))\n      return triggerRef.addEventListener(\"click\", toggleTooltip), function() {\n        return triggerRef.removeEventListener(\"click\", toggleTooltip);\n      };\n  }, [triggerRef, isTriggeredBy, toggleTooltip]), React6.useEffect(function() {\n    if (!(triggerRef == null || !isTriggeredBy(\"double-click\")))\n      return triggerRef.addEventListener(\"dblclick\", toggleTooltip), function() {\n        return triggerRef.removeEventListener(\"dblclick\", toggleTooltip);\n      };\n  }, [triggerRef, isTriggeredBy, toggleTooltip]), React6.useEffect(function() {\n    if (!(triggerRef == null || !isTriggeredBy(\"right-click\"))) {\n      var preventDefaultAndToggle = function(event) {\n        event.preventDefault(), toggleTooltip();\n      };\n      return triggerRef.addEventListener(\"contextmenu\", preventDefaultAndToggle), function() {\n        return triggerRef.removeEventListener(\"contextmenu\", preventDefaultAndToggle);\n      };\n    }\n  }, [triggerRef, isTriggeredBy, toggleTooltip]), React6.useEffect(function() {\n    if (!(triggerRef == null || !isTriggeredBy(\"focus\")))\n      return triggerRef.addEventListener(\"focus\", showTooltip), triggerRef.addEventListener(\"blur\", hideTooltip), function() {\n        triggerRef.removeEventListener(\"focus\", showTooltip), triggerRef.removeEventListener(\"blur\", hideTooltip);\n      };\n  }, [triggerRef, isTriggeredBy, showTooltip, hideTooltip]), React6.useEffect(function() {\n    if (!(triggerRef == null || !isTriggeredBy(\"hover\")))\n      return triggerRef.addEventListener(\"mouseenter\", showTooltip), triggerRef.addEventListener(\"mouseleave\", hideTooltip), function() {\n        triggerRef.removeEventListener(\"mouseenter\", showTooltip), triggerRef.removeEventListener(\"mouseleave\", hideTooltip);\n      };\n  }, [triggerRef, isTriggeredBy, showTooltip, hideTooltip]), React6.useEffect(function() {\n    if (!(tooltipRef == null || !isTriggeredBy(\"hover\") || !getLatest().finalConfig.interactive))\n      return tooltipRef.addEventListener(\"mouseenter\", showTooltip), tooltipRef.addEventListener(\"mouseleave\", hideTooltip), function() {\n        tooltipRef.removeEventListener(\"mouseenter\", showTooltip), tooltipRef.removeEventListener(\"mouseleave\", hideTooltip);\n      };\n  }, [tooltipRef, isTriggeredBy, showTooltip, hideTooltip, getLatest]);\n  var isReferenceHidden = popperProps == null || (_popperProps$state = popperProps.state) == null || (_popperProps$state$mo = _popperProps$state.modifiersData) == null || (_popperProps$state$mo2 = _popperProps$state$mo.hide) == null ? void 0 : _popperProps$state$mo2.isReferenceHidden;\n  React6.useEffect(function() {\n    finalConfig.closeOnTriggerHidden && isReferenceHidden && hideTooltip();\n  }, [finalConfig.closeOnTriggerHidden, hideTooltip, isReferenceHidden]), React6.useEffect(function() {\n    if (!finalConfig.followCursor || triggerRef == null) return;\n    function setMousePosition(_ref) {\n      var clientX = _ref.clientX, clientY = _ref.clientY;\n      virtualElement.getBoundingClientRect = generateBoundingClientRect(clientX, clientY), update?.();\n    }\n    return triggerRef.addEventListener(\"mousemove\", setMousePosition), function() {\n      return triggerRef.removeEventListener(\"mousemove\", setMousePosition);\n    };\n  }, [finalConfig.followCursor, triggerRef, update]), React6.useEffect(function() {\n    if (!(tooltipRef == null || update == null || finalConfig.mutationObserverOptions == null)) {\n      var observer = new MutationObserver(update);\n      return observer.observe(tooltipRef, finalConfig.mutationObserverOptions), function() {\n        return observer.disconnect();\n      };\n    }\n  }, [finalConfig.mutationObserverOptions, tooltipRef, update]);\n  var getTooltipProps = function(args) {\n    return args === void 0 && (args = {}), _extends({}, args, {\n      style: _extends({}, args.style, styles.popper)\n    }, attributes.popper, {\n      \"data-popper-interactive\": finalConfig.interactive\n    });\n  }, getArrowProps = function(args) {\n    return args === void 0 && (args = {}), _extends({}, args, attributes.arrow, {\n      style: _extends({}, args.style, styles.arrow),\n      \"data-popper-arrow\": !0\n    });\n  };\n  return _extends({\n    getArrowProps,\n    getTooltipProps,\n    setTooltipRef,\n    setTriggerRef,\n    tooltipRef,\n    triggerRef,\n    visible\n  }, popperProps);\n}\n\n// src/components/components/tooltip/WithTooltip.tsx\nimport { lighten, styled } from \"storybook/theming\";\nvar { document: document2 } = global, match = (0, import_memoizerific.default)(1e3)(\n  (requests, actual, value, fallback = 0) => actual.split(\"-\")[0] === requests ? value : fallback\n), ArrowSpacing = 8, Arrow = styled.div(\n  {\n    position: \"absolute\",\n    borderStyle: \"solid\"\n  },\n  ({ placement }) => {\n    let x = 0, y = 0;\n    switch (!0) {\n      case (placement.startsWith(\"left\") || placement.startsWith(\"right\")): {\n        y = 8;\n        break;\n      }\n      case (placement.startsWith(\"top\") || placement.startsWith(\"bottom\")): {\n        x = 8;\n        break;\n      }\n      default:\n    }\n    return { transform: `translate3d(${x}px, ${y}px, 0px)` };\n  },\n  ({ theme, color, placement }) => ({\n    bottom: `${match(\"top\", placement, `${ArrowSpacing * -1}px`, \"auto\")}`,\n    top: `${match(\"bottom\", placement, `${ArrowSpacing * -1}px`, \"auto\")}`,\n    right: `${match(\"left\", placement, `${ArrowSpacing * -1}px`, \"auto\")}`,\n    left: `${match(\"right\", placement, `${ArrowSpacing * -1}px`, \"auto\")}`,\n    borderBottomWidth: `${match(\"top\", placement, \"0\", ArrowSpacing)}px`,\n    borderTopWidth: `${match(\"bottom\", placement, \"0\", ArrowSpacing)}px`,\n    borderRightWidth: `${match(\"left\", placement, \"0\", ArrowSpacing)}px`,\n    borderLeftWidth: `${match(\"right\", placement, \"0\", ArrowSpacing)}px`,\n    borderTopColor: match(\n      \"top\",\n      placement,\n      theme.color[color] || color || theme.base === \"light\" ? lighten(theme.background.app) : theme.background.app,\n      \"transparent\"\n    ),\n    borderBottomColor: match(\n      \"bottom\",\n      placement,\n      theme.color[color] || color || theme.base === \"light\" ? lighten(theme.background.app) : theme.background.app,\n      \"transparent\"\n    ),\n    borderLeftColor: match(\n      \"left\",\n      placement,\n      theme.color[color] || color || theme.base === \"light\" ? lighten(theme.background.app) : theme.background.app,\n      \"transparent\"\n    ),\n    borderRightColor: match(\n      \"right\",\n      placement,\n      theme.color[color] || color || theme.base === \"light\" ? lighten(theme.background.app) : theme.background.app,\n      \"transparent\"\n    )\n  })\n), Wrapper = styled.div(\n  ({ hidden }) => ({\n    display: hidden ? \"none\" : \"inline-block\",\n    zIndex: 2147483647,\n    colorScheme: \"light dark\"\n  }),\n  ({ theme, color, hasChrome }) => hasChrome ? {\n    background: color && theme.color[color] || color || theme.base === \"light\" ? lighten(theme.background.app) : theme.background.app,\n    filter: `\n            drop-shadow(0px 5px 5px rgba(0,0,0,0.05))\n            drop-shadow(0 1px 3px rgba(0,0,0,0.1))\n          `,\n    borderRadius: theme.appBorderRadius + 2,\n    fontSize: theme.typography.size.s1\n  } : {}\n), Tooltip = React7.forwardRef(\n  ({\n    placement = \"top\",\n    hasChrome = !0,\n    children,\n    arrowProps = {},\n    tooltipRef,\n    color,\n    withArrows,\n    ...props\n  }, ref) => React7.createElement(Wrapper, { \"data-testid\": \"tooltip\", hasChrome, ref, ...props, color }, hasChrome && withArrows && React7.createElement(Arrow, { placement, ...arrowProps, color }), children)\n);\nTooltip.displayName = \"Tooltip\";\nvar TargetContainer = styled.div`\n  display: inline-block;\n  cursor: ${(props) => props.trigger === \"hover\" || props.trigger?.includes(\"hover\") ? \"default\" : \"pointer\"};\n`, TargetSvgContainer = styled.g`\n  cursor: ${(props) => props.trigger === \"hover\" || props.trigger?.includes(\"hover\") ? \"default\" : \"pointer\"};\n`, WithTooltipPure = ({\n  svg = !1,\n  trigger = \"click\",\n  closeOnOutsideClick = !1,\n  placement = \"top\",\n  modifiers = [\n    {\n      name: \"preventOverflow\",\n      options: {\n        padding: 8\n      }\n    },\n    {\n      name: \"offset\",\n      options: {\n        offset: [8, 8]\n      }\n    },\n    {\n      name: \"arrow\",\n      options: {\n        padding: 8\n      }\n    }\n  ],\n  hasChrome = !0,\n  defaultVisible = !1,\n  withArrows,\n  offset: offset2,\n  tooltip,\n  children,\n  closeOnTriggerHidden,\n  mutationObserverOptions,\n  delayHide = trigger === \"hover\" ? 200 : 0,\n  visible,\n  interactive,\n  delayShow = trigger === \"hover\" ? 400 : 0,\n  strategy,\n  followCursor,\n  onVisibleChange,\n  portalContainer,\n  ...props\n}) => {\n  let Container = svg ? TargetSvgContainer : TargetContainer, {\n    getArrowProps,\n    getTooltipProps,\n    setTooltipRef,\n    setTriggerRef,\n    visible: isVisible,\n    state\n  } = usePopperTooltip(\n    {\n      trigger,\n      placement,\n      defaultVisible,\n      delayHide,\n      interactive,\n      closeOnOutsideClick,\n      closeOnTriggerHidden,\n      onVisibleChange,\n      delayShow,\n      followCursor,\n      mutationObserverOptions,\n      visible,\n      offset: offset2\n    },\n    {\n      modifiers,\n      strategy\n    }\n  ), portalTarget = (typeof portalContainer == \"string\" ? document2.querySelector(portalContainer) : portalContainer) || document2.body, tooltipComponent = isVisible ? React7.createElement(\n    Tooltip,\n    {\n      placement: state?.placement,\n      ref: setTooltipRef,\n      hasChrome,\n      arrowProps: getArrowProps(),\n      withArrows,\n      ...getTooltipProps()\n    },\n    typeof tooltip == \"function\" ? tooltip({ onHide: () => onVisibleChange(!1) }) : tooltip\n  ) : null;\n  return React7.createElement(React7.Fragment, null, React7.createElement(Container, { trigger, ref: setTriggerRef, ...props }, children), isVisible && ReactDOM2.createPortal(tooltipComponent, portalTarget));\n}, WithToolTipState = ({\n  startOpen = !1,\n  onVisibleChange: onChange,\n  ...rest\n}) => {\n  let [tooltipShown, setTooltipShown] = useState5(startOpen), onVisibilityChange = useCallback4(\n    (visibility) => {\n      onChange && onChange(visibility) === !1 || setTooltipShown(visibility);\n    },\n    [onChange]\n  );\n  return useEffect6(() => {\n    let hide2 = () => onVisibilityChange(!1), handleKeyDown = (e) => {\n      e.key === \"Escape\" && hide2();\n    };\n    document2.addEventListener(\"keydown\", handleKeyDown, !1);\n    let iframes = Array.from(document2.getElementsByTagName(\"iframe\")), unbinders = [];\n    return iframes.forEach((iframe) => {\n      let bind = () => {\n        try {\n          iframe.contentWindow.document && (iframe.contentWindow.document.addEventListener(\"click\", hide2), unbinders.push(() => {\n            try {\n              iframe.contentWindow.document.removeEventListener(\"click\", hide2);\n            } catch {\n            }\n          }));\n        } catch {\n        }\n      };\n      bind(), iframe.addEventListener(\"load\", bind), unbinders.push(() => {\n        iframe.removeEventListener(\"load\", bind);\n      });\n    }), () => {\n      document2.removeEventListener(\"keydown\", handleKeyDown), unbinders.forEach((unbind) => {\n        unbind();\n      });\n    };\n  }), React7.createElement(WithTooltipPure, { ...rest, visible: tooltipShown, onVisibleChange: onVisibilityChange });\n}, DeprecatedPure = (props) => (deprecate(\n  \"WithTooltipPure is deprecated and will be removed in Storybook 11. Please use WithTooltip instead.\"\n), React7.createElement(WithTooltipPure, { \"data-deprecated\": \"WithTooltipPure\", ...props })), DeprecatedState = (props) => (deprecate(\n  \"WithToolTipState is deprecated and will be removed in Storybook 11. Please use WithTooltip instead.\"\n), React7.createElement(WithToolTipState, { \"data-deprecated\": \"WithToolTipState\", ...props }));\nexport {\n  Tooltip,\n  DeprecatedState as WithToolTipState,\n  WithToolTipState as WithTooltip,\n  DeprecatedPure as WithTooltipPure\n};\n"],"names":[],"ignoreList":[],"sourceRoot":""}